[
  {
    "function_name": "xfs_attr3_leaf_moveents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "2243-2695",
    "snippet": "STATIC void\nxfs_attr3_leaf_moveents(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_attr_leafblock\t*leaf_s,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_s,\n\tint\t\t\t\tstart_s,\n\tstruct xfs_attr_leafblock\t*leaf_d,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_d,\n\tint\t\t\t\tstart_d,\n\tint\t\t\t\tcount)\n{\n\tstruct xfs_attr_leaf_entry\t*entry_s;\n\tstruct xfs_attr_leaf_entry\t*entry_d;\n\tint\t\t\t\tdesti;\n\tint\t\t\t\ttmp;\n\tint\t\t\t\ti;\n\n\t/*\n\t * Check for nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(ichdr_s->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       ichdr_s->magic == XFS_ATTR3_LEAF_MAGIC);\n\tASSERT(ichdr_s->magic == ichdr_d->magic);\n\tASSERT(ichdr_s->count > 0 && ichdr_s->count < args->geo->blksize / 8);\n\tASSERT(ichdr_s->firstused >= (ichdr_s->count * sizeof(*entry_s))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_s));\n\tASSERT(ichdr_d->count < args->geo->blksize / 8);\n\tASSERT(ichdr_d->firstused >= (ichdr_d->count * sizeof(*entry_d))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d));\n\n\tASSERT(start_s < ichdr_s->count);\n\tASSERT(start_d <= ichdr_d->count);\n\tASSERT(count <= ichdr_s->count);\n\n\n\t/*\n\t * Move the entries in the destination leaf up to make a hole?\n\t */\n\tif (start_d < ichdr_d->count) {\n\t\ttmp  = ichdr_d->count - start_d;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d + count];\n\t\tmemmove(entry_d, entry_s, tmp);\n\t}\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate attribute info packed and in sequence.\n\t */\n\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\tdesti = start_d;\n\tfor (i = 0; i < count; entry_s++, entry_d++, desti++, i++) {\n\t\tASSERT(be16_to_cpu(entry_s->nameidx) >= ichdr_s->firstused);\n\t\ttmp = xfs_attr_leaf_entsize(leaf_s, start_s + i);\n#ifdef GROT\n\t\t/*\n\t\t * Code to drop INCOMPLETE entries.  Difficult to use as we\n\t\t * may also need to change the insertion index.  Code turned\n\t\t * off for 6.2, should be revisited later.\n\t\t */\n\t\tif (entry_s->flags & XFS_ATTR_INCOMPLETE) { /* skip partials? */\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tentry_d--;\t/* to compensate for ++ in loop hdr */\n\t\t\tdesti--;\n\t\t\tif ((start_s + i) < offset)\n\t\t\t\tresult++;\t/* insertion index adjustment */\n\t\t} else {\n#endif /* GROT */\n\t\t\tichdr_d->firstused -= tmp;\n\t\t\t/* both on-disk, don't endian flip twice */\n\t\t\tentry_d->hashval = entry_s->hashval;\n\t\t\tentry_d->nameidx = cpu_to_be16(ichdr_d->firstused);\n\t\t\tentry_d->flags = entry_s->flags;\n\t\t\tASSERT(be16_to_cpu(entry_d->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemmove(xfs_attr3_leaf_name(leaf_d, desti),\n\t\t\t\txfs_attr3_leaf_name(leaf_s, start_s + i), tmp);\n\t\t\tASSERT(be16_to_cpu(entry_s->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_d->usedbytes += tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tichdr_d->count += 1;\n\t\t\ttmp = ichdr_d->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d);\n\t\t\tASSERT(ichdr_d->firstused >= tmp);\n#ifdef GROT\n\t\t}\n#endif /* GROT */\n\t}\n\n\t/*\n\t * Zero out the entries we just copied.\n\t */\n\tif (start_s == ichdr_s->count) {\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t} else {\n\t\t/*\n\t\t * Move the remaining entries down to fill the hole,\n\t\t * then zero the entries at the top.\n\t\t */\n\t\ttmp  = (ichdr_s->count - count) * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s + count];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tmemmove(entry_d, entry_s, tmp);\n\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[ichdr_s->count];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t}\n\n\t/*\n\t * Fill in the freemap information\n\t */\n\tichdr_d->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_d);\n\tichdr_d->freemap[0].base += ichdr_d->count * sizeof(xfs_attr_leaf_entry_t);\n\tichdr_d->freemap[0].size = ichdr_d->firstused - ichdr_d->freemap[0].base;\n\tichdr_d->freemap[1].base = 0;\n\tichdr_d->freemap[2].base = 0;\n\tichdr_d->freemap[1].size = 0;\n\tichdr_d->freemap[2].size = 0;\n\tichdr_s->holes = 1;\t/* leaf may not be compact */\n}\n\n/*\n * Pick up the last hashvalue from a leaf block.\n */\nxfs_dahash_t\nxfs_attr_leaf_lasthash(\n\tstruct xfs_buf\t*bp,\n\tint\t\t*count)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, bp->b_addr);\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif (count)\n\t\t*count = ichdr.count;\n\tif (!ichdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(entries[ichdr.count - 1].hashval);\n}\n\n/*\n * Calculate the number of bytes used to store the indicated attribute\n * (whether local or remote only calculate bytes in this block).\n */\nSTATIC int\nxfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index)\n{\n\tstruct xfs_attr_leaf_entry *entries;\n\txfs_attr_leaf_name_local_t *name_loc;\n\txfs_attr_leaf_name_remote_t *name_rmt;\n\tint size;\n\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (entries[index].flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_local(name_loc->namelen,\n\t\t\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_remote(name_rmt->namelen);\n\t}\n\treturn size;\n}\n\n/*\n * Calculate the number of bytes that would be required to store the new\n * attribute (whether local or remote only calculate bytes in this block).\n * This routine decides as a side effect whether the attribute will be\n * a \"local\" or a \"remote\" attribute.\n */\nint\nxfs_attr_leaf_newentsize(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tint\t\t\tsize;\n\n\tsize = xfs_attr_leaf_entsize_local(args->namelen, args->valuelen);\n\tif (size < xfs_attr_leaf_entsize_local_max(args->geo->blksize)) {\n\t\tif (local)\n\t\t\t*local = 1;\n\t\treturn size;\n\t}\n\tif (local)\n\t\t*local = 0;\n\treturn xfs_attr_leaf_entsize_remote(args->namelen);\n}\n\n\n/*========================================================================\n * Manage the INCOMPLETE flag in a leaf entry\n *========================================================================*/\n\n/*\n * Clear the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * Set the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_setflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n#endif\n\n\ttrace_xfs_attr_leaf_setflag(args);\n\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n#endif\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT((entry->flags & XFS_ATTR_INCOMPLETE) == 0);\n\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\tXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif ((entry->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * In a single transaction, clear the INCOMPLETE flag on the leaf entry\n * given by args->blkno/index and set the INCOMPLETE flag on the leaf\n * entry given by args->blkno2/index2.\n *\n * Note that they could be in different blocks, or in the same block.\n */\nint\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll(&args->trans, args->dp);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_roll",
          "args": [
            "&args->trans",
            "args->dp"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_roll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "995-1055",
          "snippet": "int\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp2",
            "XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt))"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf2",
            "name_rmt",
            "sizeof(*name_rmt)"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name_remote",
          "args": [
            "leaf2",
            "args->index2"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "796-800",
          "snippet": "static inline xfs_attr_leaf_name_remote_t *\nxfs_attr3_leaf_name_remote(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_remote_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_remote_t *\nxfs_attr3_leaf_name_remote(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_remote_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp2",
            "XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2))"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf2",
            "entry2",
            "sizeof(*entry2)"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp1",
            "XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt))"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf1",
            "name_rmt",
            "sizeof(*name_rmt)"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "args->rmtvaluelen"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "args->rmtblkno"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(entry1->flags & XFS_ATTR_LOCAL) == 0"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp1",
            "XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1))"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf1",
            "entry1",
            "sizeof(*entry1)"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(entry2->flags & XFS_ATTR_INCOMPLETE) == 0"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "entry1->flags & XFS_ATTR_INCOMPLETE"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "memcmp(name1, name2, namelen1) == 0"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name1",
            "name2",
            "namelen1"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "namelen1 == namelen2"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval)"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry2->hashval"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry1->hashval"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name_local",
          "args": [
            "leaf2",
            "args->index2"
          ],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "802-806",
          "snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->index2 >= 0"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->index2 < ichdr2.count"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&ichdr2",
            "leaf2"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->index >= 0"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->index < ichdr1.count"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf2"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_read",
          "args": [
            "args->trans",
            "args->dp",
            "args->blkno2",
            "-1",
            "&bp2"
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "256-271",
          "snippet": "int\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
            "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_flipflags",
          "args": [
            "args"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt))"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf",
            "name_rmt",
            "sizeof(*name_rmt)"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry))"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf",
            "entry",
            "sizeof(*entry)"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(entry->flags & XFS_ATTR_INCOMPLETE) == 0"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->index >= 0"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->index < ichdr.count"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_setflag",
          "args": [
            "args"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt))"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf",
            "name_rmt",
            "sizeof(*name_rmt)"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "args->rmtvaluelen"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "args->rmtblkno"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(entry->flags & XFS_ATTR_LOCAL) == 0"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry))"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf",
            "entry",
            "sizeof(*entry)"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "memcmp(name, args->name, namelen) == 0"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "args->name",
            "namelen"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "namelen == args->namelen"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be32_to_cpu(entry->hashval) == args->hashval"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->index >= 0"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->index < ichdr.count"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "entry->flags & XFS_ATTR_INCOMPLETE"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_clearflag",
          "args": [
            "args"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_entsize_remote",
          "args": [
            "args->namelen"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_leaf_entsize_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "813-817",
          "snippet": "static inline int xfs_attr_leaf_entsize_remote(int nlen)\n{\n\treturn ((uint)sizeof(xfs_attr_leaf_name_remote_t) - 1 + (nlen) + \\\n\t\tXFS_ATTR_LEAF_NAME_ALIGN - 1) & ~(XFS_ATTR_LEAF_NAME_ALIGN - 1);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ATTR_LEAF_NAME_ALIGN\t((uint)sizeof(xfs_dablk_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ATTR_LEAF_NAME_ALIGN\t((uint)sizeof(xfs_dablk_t))\n\nstatic inline int xfs_attr_leaf_entsize_remote(int nlen)\n{\n\treturn ((uint)sizeof(xfs_attr_leaf_name_remote_t) - 1 + (nlen) + \\\n\t\tXFS_ATTR_LEAF_NAME_ALIGN - 1) & ~(XFS_ATTR_LEAF_NAME_ALIGN - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_entsize_local_max",
          "args": [
            "args->geo->blksize"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_leaf_entsize_local_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "825-828",
          "snippet": "static inline int xfs_attr_leaf_entsize_local_max(int bsize)\n{\n\treturn (((bsize) >> 1) + ((bsize) >> 2));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_attr_leaf_entsize_local_max(int bsize)\n{\n\treturn (((bsize) >> 1) + ((bsize) >> 2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_entsize_local",
          "args": [
            "args->namelen",
            "args->valuelen"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_leaf_entsize_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "819-823",
          "snippet": "static inline int xfs_attr_leaf_entsize_local(int nlen, int vlen)\n{\n\treturn ((uint)sizeof(xfs_attr_leaf_name_local_t) - 1 + (nlen) + (vlen) +\n\t\tXFS_ATTR_LEAF_NAME_ALIGN - 1) & ~(XFS_ATTR_LEAF_NAME_ALIGN - 1);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ATTR_LEAF_NAME_ALIGN\t((uint)sizeof(xfs_dablk_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ATTR_LEAF_NAME_ALIGN\t((uint)sizeof(xfs_dablk_t))\n\nstatic inline int xfs_attr_leaf_entsize_local(int nlen, int vlen)\n{\n\treturn ((uint)sizeof(xfs_attr_leaf_name_local_t) - 1 + (nlen) + (vlen) +\n\t\tXFS_ATTR_LEAF_NAME_ALIGN - 1) & ~(XFS_ATTR_LEAF_NAME_ALIGN - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "name_loc->valuelen"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entries[ichdr.count - 1].hashval"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_size",
          "args": [
            "leaf_d"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "769-775",
          "snippet": "static inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "entry_s",
            "0",
            "tmp"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize)"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "entry_d",
            "entry_s",
            "tmp"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "entry_s",
            "0",
            "tmp"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize)"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr_d->firstused >= tmp"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xfs_attr3_leaf_name(leaf_s, start_s + i)",
            "0",
            "tmp"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(entry_s->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry_s->nameidx"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "xfs_attr3_leaf_name(leaf_d, desti)",
            "xfs_attr3_leaf_name(leaf_s, start_s + i)",
            "tmp"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(entry_d->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry_d->nameidx"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "ichdr_d->firstused"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xfs_attr3_leaf_name(leaf_s, start_s + i)",
            "0",
            "tmp"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(entry_s->nameidx) >= ichdr_s->firstused"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry_s->nameidx"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "entry_d",
            "entry_s",
            "tmp"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "count <= ichdr_s->count"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "start_d <= ichdr_d->count"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "start_s < ichdr_s->count"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr_d->firstused >= (ichdr_d->count * sizeof(*entry_d))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d)"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr_d->count < args->geo->blksize / 8"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr_s->firstused >= (ichdr_s->count * sizeof(*entry_s))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_s)"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr_s->count > 0 && ichdr_s->count < args->geo->blksize / 8"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr_s->magic == ichdr_d->magic"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr_s->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       ichdr_s->magic == XFS_ATTR3_LEAF_MAGIC"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nSTATIC void\nxfs_attr3_leaf_moveents(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_attr_leafblock\t*leaf_s,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_s,\n\tint\t\t\t\tstart_s,\n\tstruct xfs_attr_leafblock\t*leaf_d,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_d,\n\tint\t\t\t\tstart_d,\n\tint\t\t\t\tcount)\n{\n\tstruct xfs_attr_leaf_entry\t*entry_s;\n\tstruct xfs_attr_leaf_entry\t*entry_d;\n\tint\t\t\t\tdesti;\n\tint\t\t\t\ttmp;\n\tint\t\t\t\ti;\n\n\t/*\n\t * Check for nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(ichdr_s->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       ichdr_s->magic == XFS_ATTR3_LEAF_MAGIC);\n\tASSERT(ichdr_s->magic == ichdr_d->magic);\n\tASSERT(ichdr_s->count > 0 && ichdr_s->count < args->geo->blksize / 8);\n\tASSERT(ichdr_s->firstused >= (ichdr_s->count * sizeof(*entry_s))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_s));\n\tASSERT(ichdr_d->count < args->geo->blksize / 8);\n\tASSERT(ichdr_d->firstused >= (ichdr_d->count * sizeof(*entry_d))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d));\n\n\tASSERT(start_s < ichdr_s->count);\n\tASSERT(start_d <= ichdr_d->count);\n\tASSERT(count <= ichdr_s->count);\n\n\n\t/*\n\t * Move the entries in the destination leaf up to make a hole?\n\t */\n\tif (start_d < ichdr_d->count) {\n\t\ttmp  = ichdr_d->count - start_d;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d + count];\n\t\tmemmove(entry_d, entry_s, tmp);\n\t}\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate attribute info packed and in sequence.\n\t */\n\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\tdesti = start_d;\n\tfor (i = 0; i < count; entry_s++, entry_d++, desti++, i++) {\n\t\tASSERT(be16_to_cpu(entry_s->nameidx) >= ichdr_s->firstused);\n\t\ttmp = xfs_attr_leaf_entsize(leaf_s, start_s + i);\n#ifdef GROT\n\t\t/*\n\t\t * Code to drop INCOMPLETE entries.  Difficult to use as we\n\t\t * may also need to change the insertion index.  Code turned\n\t\t * off for 6.2, should be revisited later.\n\t\t */\n\t\tif (entry_s->flags & XFS_ATTR_INCOMPLETE) { /* skip partials? */\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tentry_d--;\t/* to compensate for ++ in loop hdr */\n\t\t\tdesti--;\n\t\t\tif ((start_s + i) < offset)\n\t\t\t\tresult++;\t/* insertion index adjustment */\n\t\t} else {\n#endif /* GROT */\n\t\t\tichdr_d->firstused -= tmp;\n\t\t\t/* both on-disk, don't endian flip twice */\n\t\t\tentry_d->hashval = entry_s->hashval;\n\t\t\tentry_d->nameidx = cpu_to_be16(ichdr_d->firstused);\n\t\t\tentry_d->flags = entry_s->flags;\n\t\t\tASSERT(be16_to_cpu(entry_d->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemmove(xfs_attr3_leaf_name(leaf_d, desti),\n\t\t\t\txfs_attr3_leaf_name(leaf_s, start_s + i), tmp);\n\t\t\tASSERT(be16_to_cpu(entry_s->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_d->usedbytes += tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tichdr_d->count += 1;\n\t\t\ttmp = ichdr_d->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d);\n\t\t\tASSERT(ichdr_d->firstused >= tmp);\n#ifdef GROT\n\t\t}\n#endif /* GROT */\n\t}\n\n\t/*\n\t * Zero out the entries we just copied.\n\t */\n\tif (start_s == ichdr_s->count) {\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t} else {\n\t\t/*\n\t\t * Move the remaining entries down to fill the hole,\n\t\t * then zero the entries at the top.\n\t\t */\n\t\ttmp  = (ichdr_s->count - count) * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s + count];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tmemmove(entry_d, entry_s, tmp);\n\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[ichdr_s->count];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t}\n\n\t/*\n\t * Fill in the freemap information\n\t */\n\tichdr_d->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_d);\n\tichdr_d->freemap[0].base += ichdr_d->count * sizeof(xfs_attr_leaf_entry_t);\n\tichdr_d->freemap[0].size = ichdr_d->firstused - ichdr_d->freemap[0].base;\n\tichdr_d->freemap[1].base = 0;\n\tichdr_d->freemap[2].base = 0;\n\tichdr_d->freemap[1].size = 0;\n\tichdr_d->freemap[2].size = 0;\n\tichdr_s->holes = 1;\t/* leaf may not be compact */\n}\n\n/*\n * Pick up the last hashvalue from a leaf block.\n */\nxfs_dahash_t\nxfs_attr_leaf_lasthash(\n\tstruct xfs_buf\t*bp,\n\tint\t\t*count)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, bp->b_addr);\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif (count)\n\t\t*count = ichdr.count;\n\tif (!ichdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(entries[ichdr.count - 1].hashval);\n}\n\n/*\n * Calculate the number of bytes used to store the indicated attribute\n * (whether local or remote only calculate bytes in this block).\n */\nSTATIC int\nxfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index)\n{\n\tstruct xfs_attr_leaf_entry *entries;\n\txfs_attr_leaf_name_local_t *name_loc;\n\txfs_attr_leaf_name_remote_t *name_rmt;\n\tint size;\n\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (entries[index].flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_local(name_loc->namelen,\n\t\t\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_remote(name_rmt->namelen);\n\t}\n\treturn size;\n}\n\n/*\n * Calculate the number of bytes that would be required to store the new\n * attribute (whether local or remote only calculate bytes in this block).\n * This routine decides as a side effect whether the attribute will be\n * a \"local\" or a \"remote\" attribute.\n */\nint\nxfs_attr_leaf_newentsize(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tint\t\t\tsize;\n\n\tsize = xfs_attr_leaf_entsize_local(args->namelen, args->valuelen);\n\tif (size < xfs_attr_leaf_entsize_local_max(args->geo->blksize)) {\n\t\tif (local)\n\t\t\t*local = 1;\n\t\treturn size;\n\t}\n\tif (local)\n\t\t*local = 0;\n\treturn xfs_attr_leaf_entsize_remote(args->namelen);\n}\n\n\n/*========================================================================\n * Manage the INCOMPLETE flag in a leaf entry\n *========================================================================*/\n\n/*\n * Clear the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * Set the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_setflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n#endif\n\n\ttrace_xfs_attr_leaf_setflag(args);\n\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n#endif\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT((entry->flags & XFS_ATTR_INCOMPLETE) == 0);\n\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\tXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif ((entry->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * In a single transaction, clear the INCOMPLETE flag on the leaf entry\n * given by args->blkno/index and set the INCOMPLETE flag on the leaf\n * entry given by args->blkno2/index2.\n *\n * Note that they could be in different blocks, or in the same block.\n */\nint\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll(&args->trans, args->dp);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_getvalue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "2180-2232",
    "snippet": "int\nxfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index < ichdr.count);\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       args->rmtvaluelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < args->rmtvaluelen) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = args->rmtvaluelen;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr3_rmt_blocks",
          "args": [
            "args->dp->i_mount",
            "args->rmtvaluelen"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_rmt_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "50-60",
          "snippet": "int\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "name_rmt->valueblk"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "name_rmt->valuelen"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "memcmp(args->name, name_rmt->name, args->namelen) == 0"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "args->name",
            "name_rmt->name",
            "args->namelen"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "name_rmt->namelen == args->namelen"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name_remote",
          "args": [
            "leaf",
            "args->index"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "796-800",
          "snippet": "static inline xfs_attr_leaf_name_remote_t *\nxfs_attr3_leaf_name_remote(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_remote_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_remote_t *\nxfs_attr3_leaf_name_remote(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_remote_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "args->value",
            "&name_loc->nameval[args->namelen]",
            "valuelen"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "name_loc->valuelen"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "memcmp(args->name, name_loc->nameval, args->namelen) == 0"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "args->name",
            "name_loc->nameval",
            "args->namelen"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "name_loc->namelen == args->namelen"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name_local",
          "args": [
            "leaf",
            "args->index"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "802-806",
          "snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->index < ichdr.count"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr.count < args->geo->blksize / 8"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&ichdr",
            "leaf"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index < ichdr.count);\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       args->rmtvaluelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < args->rmtvaluelen) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = args->rmtvaluelen;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_lookup_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "2070-2174",
    "snippet": "int\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr3_rmt_blocks",
          "args": [
            "args->dp->i_mount",
            "args->rmtvaluelen"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_rmt_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "50-60",
          "snippet": "int\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "name_rmt->valueblk"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "name_rmt->valuelen"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_namesp_match",
          "args": [
            "args->flags",
            "entry->flags"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_namesp_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "281-285",
          "snippet": "STATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "args->name",
            "name_rmt->name",
            "args->namelen"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name_remote",
          "args": [
            "leaf",
            "probe"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "796-800",
          "snippet": "static inline xfs_attr_leaf_name_remote_t *\nxfs_attr3_leaf_name_remote(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_remote_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_remote_t *\nxfs_attr3_leaf_name_remote(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_remote_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "args->name",
            "name_loc->nameval",
            "args->namelen"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name_local",
          "args": [
            "leaf",
            "probe"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "802-806",
          "snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "span <= 4 || be32_to_cpu(entry->hashval) == hashval"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "probe >= 0 && (!ichdr.count || probe < ichdr.count)"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr.count < args->geo->blksize / 8"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&ichdr",
            "leaf"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_lookup",
          "args": [
            "args"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_unbalance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "1944-2051",
    "snippet": "void\nxfs_attr3_leaf_unbalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_attr_leafblock *drop_leaf = drop_blk->bp->b_addr;\n\tstruct xfs_attr_leafblock *save_leaf = save_blk->bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr drophdr;\n\tstruct xfs_attr3_icleaf_hdr savehdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\n\ttrace_xfs_attr_leaf_unbalance(state->args);\n\n\tdrop_leaf = drop_blk->bp->b_addr;\n\tsave_leaf = save_blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&drophdr, drop_leaf);\n\txfs_attr3_leaf_hdr_from_disk(&savehdr, save_leaf);\n\tentry = xfs_attr3_leaf_entryp(drop_leaf);\n\n\t/*\n\t * Save last hashval from dying block for later Btree fixup.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(entry[drophdr.count - 1].hashval);\n\n\t/*\n\t * Check if we need a temp buffer, or can we do it in place.\n\t * Note that we don't check \"leaf\" for holes because we will\n\t * always be dropping it, toosmall() decided that for us already.\n\t */\n\tif (savehdr.holes == 0) {\n\t\t/*\n\t\t * dest leaf has no holes, so we add there.  May need\n\t\t * to make some room in the entry array.\n\t\t */\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr,\n\t\t\t\t\t\tsavehdr.count, drophdr.count);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Destination has holes, so we make a temporary copy\n\t\t * of the leaf and add them both to that.\n\t\t */\n\t\tstruct xfs_attr_leafblock *tmp_leaf;\n\t\tstruct xfs_attr3_icleaf_hdr tmphdr;\n\n\t\ttmp_leaf = kmem_zalloc(state->args->geo->blksize, KM_SLEEP);\n\n\t\t/*\n\t\t * Copy the header into the temp leaf so that all the stuff\n\t\t * not in the incore header is present and gets copied back in\n\t\t * once we've moved all the entries.\n\t\t */\n\t\tmemcpy(tmp_leaf, save_leaf, xfs_attr3_leaf_hdr_size(save_leaf));\n\n\t\tmemset(&tmphdr, 0, sizeof(tmphdr));\n\t\ttmphdr.magic = savehdr.magic;\n\t\ttmphdr.forw = savehdr.forw;\n\t\ttmphdr.back = savehdr.back;\n\t\ttmphdr.firstused = state->args->geo->blksize;\n\n\t\t/* write the header to the temp buffer to initialise it */\n\t\txfs_attr3_leaf_hdr_to_disk(tmp_leaf, &tmphdr);\n\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tsavehdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tsavehdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tdrophdr.count);\n\t\t}\n\t\tmemcpy(save_leaf, tmp_leaf, state->args->geo->blksize);\n\t\tsavehdr = tmphdr; /* struct copy */\n\t\tkmem_free(tmp_leaf);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(save_leaf, &savehdr);\n\txfs_trans_log_buf(state->args->trans, save_blk->bp, 0,\n\t\t\t\t\t   state->args->geo->blksize - 1);\n\n\t/*\n\t * Copy out last hashval in each block for B-tree code.\n\t */\n\tentry = xfs_attr3_leaf_entryp(save_leaf);\n\tsave_blk->hashval = be32_to_cpu(entry[savehdr.count - 1].hashval);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry[savehdr.count - 1].hashval"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "save_leaf"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "state->args->trans",
            "save_blk->bp",
            "0",
            "state->args->geo->blksize - 1"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_to_disk",
          "args": [
            "save_leaf",
            "&savehdr"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "130-171",
          "snippet": "void\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "tmp_leaf"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "save_leaf",
            "tmp_leaf",
            "state->args->geo->blksize"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_moveents",
          "args": [
            "state->args",
            "drop_leaf",
            "&drophdr",
            "0",
            "tmp_leaf",
            "&tmphdr",
            "tmphdr.count",
            "drophdr.count"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_moveents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "2243-2695",
          "snippet": "STATIC void\nxfs_attr3_leaf_moveents(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_attr_leafblock\t*leaf_s,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_s,\n\tint\t\t\t\tstart_s,\n\tstruct xfs_attr_leafblock\t*leaf_d,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_d,\n\tint\t\t\t\tstart_d,\n\tint\t\t\t\tcount)\n{\n\tstruct xfs_attr_leaf_entry\t*entry_s;\n\tstruct xfs_attr_leaf_entry\t*entry_d;\n\tint\t\t\t\tdesti;\n\tint\t\t\t\ttmp;\n\tint\t\t\t\ti;\n\n\t/*\n\t * Check for nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(ichdr_s->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       ichdr_s->magic == XFS_ATTR3_LEAF_MAGIC);\n\tASSERT(ichdr_s->magic == ichdr_d->magic);\n\tASSERT(ichdr_s->count > 0 && ichdr_s->count < args->geo->blksize / 8);\n\tASSERT(ichdr_s->firstused >= (ichdr_s->count * sizeof(*entry_s))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_s));\n\tASSERT(ichdr_d->count < args->geo->blksize / 8);\n\tASSERT(ichdr_d->firstused >= (ichdr_d->count * sizeof(*entry_d))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d));\n\n\tASSERT(start_s < ichdr_s->count);\n\tASSERT(start_d <= ichdr_d->count);\n\tASSERT(count <= ichdr_s->count);\n\n\n\t/*\n\t * Move the entries in the destination leaf up to make a hole?\n\t */\n\tif (start_d < ichdr_d->count) {\n\t\ttmp  = ichdr_d->count - start_d;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d + count];\n\t\tmemmove(entry_d, entry_s, tmp);\n\t}\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate attribute info packed and in sequence.\n\t */\n\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\tdesti = start_d;\n\tfor (i = 0; i < count; entry_s++, entry_d++, desti++, i++) {\n\t\tASSERT(be16_to_cpu(entry_s->nameidx) >= ichdr_s->firstused);\n\t\ttmp = xfs_attr_leaf_entsize(leaf_s, start_s + i);\n#ifdef GROT\n\t\t/*\n\t\t * Code to drop INCOMPLETE entries.  Difficult to use as we\n\t\t * may also need to change the insertion index.  Code turned\n\t\t * off for 6.2, should be revisited later.\n\t\t */\n\t\tif (entry_s->flags & XFS_ATTR_INCOMPLETE) { /* skip partials? */\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tentry_d--;\t/* to compensate for ++ in loop hdr */\n\t\t\tdesti--;\n\t\t\tif ((start_s + i) < offset)\n\t\t\t\tresult++;\t/* insertion index adjustment */\n\t\t} else {\n#endif /* GROT */\n\t\t\tichdr_d->firstused -= tmp;\n\t\t\t/* both on-disk, don't endian flip twice */\n\t\t\tentry_d->hashval = entry_s->hashval;\n\t\t\tentry_d->nameidx = cpu_to_be16(ichdr_d->firstused);\n\t\t\tentry_d->flags = entry_s->flags;\n\t\t\tASSERT(be16_to_cpu(entry_d->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemmove(xfs_attr3_leaf_name(leaf_d, desti),\n\t\t\t\txfs_attr3_leaf_name(leaf_s, start_s + i), tmp);\n\t\t\tASSERT(be16_to_cpu(entry_s->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_d->usedbytes += tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tichdr_d->count += 1;\n\t\t\ttmp = ichdr_d->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d);\n\t\t\tASSERT(ichdr_d->firstused >= tmp);\n#ifdef GROT\n\t\t}\n#endif /* GROT */\n\t}\n\n\t/*\n\t * Zero out the entries we just copied.\n\t */\n\tif (start_s == ichdr_s->count) {\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t} else {\n\t\t/*\n\t\t * Move the remaining entries down to fill the hole,\n\t\t * then zero the entries at the top.\n\t\t */\n\t\ttmp  = (ichdr_s->count - count) * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s + count];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tmemmove(entry_d, entry_s, tmp);\n\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[ichdr_s->count];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t}\n\n\t/*\n\t * Fill in the freemap information\n\t */\n\tichdr_d->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_d);\n\tichdr_d->freemap[0].base += ichdr_d->count * sizeof(xfs_attr_leaf_entry_t);\n\tichdr_d->freemap[0].size = ichdr_d->firstused - ichdr_d->freemap[0].base;\n\tichdr_d->freemap[1].base = 0;\n\tichdr_d->freemap[2].base = 0;\n\tichdr_d->freemap[1].size = 0;\n\tichdr_d->freemap[2].size = 0;\n\tichdr_s->holes = 1;\t/* leaf may not be compact */\n}\n\n/*\n * Pick up the last hashvalue from a leaf block.\n */\nxfs_dahash_t\nxfs_attr_leaf_lasthash(\n\tstruct xfs_buf\t*bp,\n\tint\t\t*count)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, bp->b_addr);\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif (count)\n\t\t*count = ichdr.count;\n\tif (!ichdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(entries[ichdr.count - 1].hashval);\n}\n\n/*\n * Calculate the number of bytes used to store the indicated attribute\n * (whether local or remote only calculate bytes in this block).\n */\nSTATIC int\nxfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index)\n{\n\tstruct xfs_attr_leaf_entry *entries;\n\txfs_attr_leaf_name_local_t *name_loc;\n\txfs_attr_leaf_name_remote_t *name_rmt;\n\tint size;\n\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (entries[index].flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_local(name_loc->namelen,\n\t\t\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_remote(name_rmt->namelen);\n\t}\n\treturn size;\n}\n\n/*\n * Calculate the number of bytes that would be required to store the new\n * attribute (whether local or remote only calculate bytes in this block).\n * This routine decides as a side effect whether the attribute will be\n * a \"local\" or a \"remote\" attribute.\n */\nint\nxfs_attr_leaf_newentsize(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tint\t\t\tsize;\n\n\tsize = xfs_attr_leaf_entsize_local(args->namelen, args->valuelen);\n\tif (size < xfs_attr_leaf_entsize_local_max(args->geo->blksize)) {\n\t\tif (local)\n\t\t\t*local = 1;\n\t\treturn size;\n\t}\n\tif (local)\n\t\t*local = 0;\n\treturn xfs_attr_leaf_entsize_remote(args->namelen);\n}\n\n\n/*========================================================================\n * Manage the INCOMPLETE flag in a leaf entry\n *========================================================================*/\n\n/*\n * Clear the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * Set the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_setflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n#endif\n\n\ttrace_xfs_attr_leaf_setflag(args);\n\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n#endif\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT((entry->flags & XFS_ATTR_INCOMPLETE) == 0);\n\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\tXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif ((entry->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * In a single transaction, clear the INCOMPLETE flag on the leaf entry\n * given by args->blkno/index and set the INCOMPLETE flag on the leaf\n * entry given by args->blkno2/index2.\n *\n * Note that they could be in different blocks, or in the same block.\n */\nint\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll(&args->trans, args->dp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nSTATIC void\nxfs_attr3_leaf_moveents(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_attr_leafblock\t*leaf_s,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_s,\n\tint\t\t\t\tstart_s,\n\tstruct xfs_attr_leafblock\t*leaf_d,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_d,\n\tint\t\t\t\tstart_d,\n\tint\t\t\t\tcount)\n{\n\tstruct xfs_attr_leaf_entry\t*entry_s;\n\tstruct xfs_attr_leaf_entry\t*entry_d;\n\tint\t\t\t\tdesti;\n\tint\t\t\t\ttmp;\n\tint\t\t\t\ti;\n\n\t/*\n\t * Check for nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(ichdr_s->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       ichdr_s->magic == XFS_ATTR3_LEAF_MAGIC);\n\tASSERT(ichdr_s->magic == ichdr_d->magic);\n\tASSERT(ichdr_s->count > 0 && ichdr_s->count < args->geo->blksize / 8);\n\tASSERT(ichdr_s->firstused >= (ichdr_s->count * sizeof(*entry_s))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_s));\n\tASSERT(ichdr_d->count < args->geo->blksize / 8);\n\tASSERT(ichdr_d->firstused >= (ichdr_d->count * sizeof(*entry_d))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d));\n\n\tASSERT(start_s < ichdr_s->count);\n\tASSERT(start_d <= ichdr_d->count);\n\tASSERT(count <= ichdr_s->count);\n\n\n\t/*\n\t * Move the entries in the destination leaf up to make a hole?\n\t */\n\tif (start_d < ichdr_d->count) {\n\t\ttmp  = ichdr_d->count - start_d;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d + count];\n\t\tmemmove(entry_d, entry_s, tmp);\n\t}\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate attribute info packed and in sequence.\n\t */\n\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\tdesti = start_d;\n\tfor (i = 0; i < count; entry_s++, entry_d++, desti++, i++) {\n\t\tASSERT(be16_to_cpu(entry_s->nameidx) >= ichdr_s->firstused);\n\t\ttmp = xfs_attr_leaf_entsize(leaf_s, start_s + i);\n#ifdef GROT\n\t\t/*\n\t\t * Code to drop INCOMPLETE entries.  Difficult to use as we\n\t\t * may also need to change the insertion index.  Code turned\n\t\t * off for 6.2, should be revisited later.\n\t\t */\n\t\tif (entry_s->flags & XFS_ATTR_INCOMPLETE) { /* skip partials? */\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tentry_d--;\t/* to compensate for ++ in loop hdr */\n\t\t\tdesti--;\n\t\t\tif ((start_s + i) < offset)\n\t\t\t\tresult++;\t/* insertion index adjustment */\n\t\t} else {\n#endif /* GROT */\n\t\t\tichdr_d->firstused -= tmp;\n\t\t\t/* both on-disk, don't endian flip twice */\n\t\t\tentry_d->hashval = entry_s->hashval;\n\t\t\tentry_d->nameidx = cpu_to_be16(ichdr_d->firstused);\n\t\t\tentry_d->flags = entry_s->flags;\n\t\t\tASSERT(be16_to_cpu(entry_d->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemmove(xfs_attr3_leaf_name(leaf_d, desti),\n\t\t\t\txfs_attr3_leaf_name(leaf_s, start_s + i), tmp);\n\t\t\tASSERT(be16_to_cpu(entry_s->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_d->usedbytes += tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tichdr_d->count += 1;\n\t\t\ttmp = ichdr_d->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d);\n\t\t\tASSERT(ichdr_d->firstused >= tmp);\n#ifdef GROT\n\t\t}\n#endif /* GROT */\n\t}\n\n\t/*\n\t * Zero out the entries we just copied.\n\t */\n\tif (start_s == ichdr_s->count) {\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t} else {\n\t\t/*\n\t\t * Move the remaining entries down to fill the hole,\n\t\t * then zero the entries at the top.\n\t\t */\n\t\ttmp  = (ichdr_s->count - count) * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s + count];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tmemmove(entry_d, entry_s, tmp);\n\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[ichdr_s->count];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t}\n\n\t/*\n\t * Fill in the freemap information\n\t */\n\tichdr_d->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_d);\n\tichdr_d->freemap[0].base += ichdr_d->count * sizeof(xfs_attr_leaf_entry_t);\n\tichdr_d->freemap[0].size = ichdr_d->firstused - ichdr_d->freemap[0].base;\n\tichdr_d->freemap[1].base = 0;\n\tichdr_d->freemap[2].base = 0;\n\tichdr_d->freemap[1].size = 0;\n\tichdr_d->freemap[2].size = 0;\n\tichdr_s->holes = 1;\t/* leaf may not be compact */\n}\n\n/*\n * Pick up the last hashvalue from a leaf block.\n */\nxfs_dahash_t\nxfs_attr_leaf_lasthash(\n\tstruct xfs_buf\t*bp,\n\tint\t\t*count)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, bp->b_addr);\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif (count)\n\t\t*count = ichdr.count;\n\tif (!ichdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(entries[ichdr.count - 1].hashval);\n}\n\n/*\n * Calculate the number of bytes used to store the indicated attribute\n * (whether local or remote only calculate bytes in this block).\n */\nSTATIC int\nxfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index)\n{\n\tstruct xfs_attr_leaf_entry *entries;\n\txfs_attr_leaf_name_local_t *name_loc;\n\txfs_attr_leaf_name_remote_t *name_rmt;\n\tint size;\n\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (entries[index].flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_local(name_loc->namelen,\n\t\t\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_remote(name_rmt->namelen);\n\t}\n\treturn size;\n}\n\n/*\n * Calculate the number of bytes that would be required to store the new\n * attribute (whether local or remote only calculate bytes in this block).\n * This routine decides as a side effect whether the attribute will be\n * a \"local\" or a \"remote\" attribute.\n */\nint\nxfs_attr_leaf_newentsize(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tint\t\t\tsize;\n\n\tsize = xfs_attr_leaf_entsize_local(args->namelen, args->valuelen);\n\tif (size < xfs_attr_leaf_entsize_local_max(args->geo->blksize)) {\n\t\tif (local)\n\t\t\t*local = 1;\n\t\treturn size;\n\t}\n\tif (local)\n\t\t*local = 0;\n\treturn xfs_attr_leaf_entsize_remote(args->namelen);\n}\n\n\n/*========================================================================\n * Manage the INCOMPLETE flag in a leaf entry\n *========================================================================*/\n\n/*\n * Clear the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * Set the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_setflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n#endif\n\n\ttrace_xfs_attr_leaf_setflag(args);\n\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n#endif\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT((entry->flags & XFS_ATTR_INCOMPLETE) == 0);\n\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\tXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif ((entry->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * In a single transaction, clear the INCOMPLETE flag on the leaf entry\n * given by args->blkno/index and set the INCOMPLETE flag on the leaf\n * entry given by args->blkno2/index2.\n *\n * Note that they could be in different blocks, or in the same block.\n */\nint\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll(&args->trans, args->dp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_order",
          "args": [
            "save_blk->bp",
            "&savehdr",
            "drop_blk->bp",
            "&drophdr"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1318-1338",
          "snippet": "static int\nxfs_attr3_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf1hdr,\n\tstruct xfs_buf\t*leaf2_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf2hdr)\n{\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\n\tentries1 = xfs_attr3_leaf_entryp(leaf1_bp->b_addr);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2_bp->b_addr);\n\tif (leaf1hdr->count > 0 && leaf2hdr->count > 0 &&\n\t    ((be32_to_cpu(entries2[0].hashval) <\n\t      be32_to_cpu(entries1[0].hashval)) ||\n\t     (be32_to_cpu(entries2[leaf2hdr->count - 1].hashval) <\n\t      be32_to_cpu(entries1[leaf1hdr->count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_attr3_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf1hdr,\n\tstruct xfs_buf\t*leaf2_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf2hdr)\n{\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\n\tentries1 = xfs_attr3_leaf_entryp(leaf1_bp->b_addr);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2_bp->b_addr);\n\tif (leaf1hdr->count > 0 && leaf2hdr->count > 0 &&\n\t    ((be32_to_cpu(entries2[0].hashval) <\n\t      be32_to_cpu(entries1[0].hashval)) ||\n\t     (be32_to_cpu(entries2[leaf2hdr->count - 1].hashval) <\n\t      be32_to_cpu(entries1[leaf1hdr->count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tmphdr",
            "0",
            "sizeof(tmphdr)"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp_leaf",
            "save_leaf",
            "xfs_attr3_leaf_hdr_size(save_leaf)"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_size",
          "args": [
            "save_leaf"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "769-775",
          "snippet": "static inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "state->args->geo->blksize",
            "KM_SLEEP"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry[drophdr.count - 1].hashval"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&savehdr",
            "save_leaf"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_unbalance",
          "args": [
            "state->args"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_unbalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_attr_leafblock *drop_leaf = drop_blk->bp->b_addr;\n\tstruct xfs_attr_leafblock *save_leaf = save_blk->bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr drophdr;\n\tstruct xfs_attr3_icleaf_hdr savehdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\n\ttrace_xfs_attr_leaf_unbalance(state->args);\n\n\tdrop_leaf = drop_blk->bp->b_addr;\n\tsave_leaf = save_blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&drophdr, drop_leaf);\n\txfs_attr3_leaf_hdr_from_disk(&savehdr, save_leaf);\n\tentry = xfs_attr3_leaf_entryp(drop_leaf);\n\n\t/*\n\t * Save last hashval from dying block for later Btree fixup.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(entry[drophdr.count - 1].hashval);\n\n\t/*\n\t * Check if we need a temp buffer, or can we do it in place.\n\t * Note that we don't check \"leaf\" for holes because we will\n\t * always be dropping it, toosmall() decided that for us already.\n\t */\n\tif (savehdr.holes == 0) {\n\t\t/*\n\t\t * dest leaf has no holes, so we add there.  May need\n\t\t * to make some room in the entry array.\n\t\t */\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr,\n\t\t\t\t\t\tsavehdr.count, drophdr.count);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Destination has holes, so we make a temporary copy\n\t\t * of the leaf and add them both to that.\n\t\t */\n\t\tstruct xfs_attr_leafblock *tmp_leaf;\n\t\tstruct xfs_attr3_icleaf_hdr tmphdr;\n\n\t\ttmp_leaf = kmem_zalloc(state->args->geo->blksize, KM_SLEEP);\n\n\t\t/*\n\t\t * Copy the header into the temp leaf so that all the stuff\n\t\t * not in the incore header is present and gets copied back in\n\t\t * once we've moved all the entries.\n\t\t */\n\t\tmemcpy(tmp_leaf, save_leaf, xfs_attr3_leaf_hdr_size(save_leaf));\n\n\t\tmemset(&tmphdr, 0, sizeof(tmphdr));\n\t\ttmphdr.magic = savehdr.magic;\n\t\ttmphdr.forw = savehdr.forw;\n\t\ttmphdr.back = savehdr.back;\n\t\ttmphdr.firstused = state->args->geo->blksize;\n\n\t\t/* write the header to the temp buffer to initialise it */\n\t\txfs_attr3_leaf_hdr_to_disk(tmp_leaf, &tmphdr);\n\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tsavehdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tsavehdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tdrophdr.count);\n\t\t}\n\t\tmemcpy(save_leaf, tmp_leaf, state->args->geo->blksize);\n\t\tsavehdr = tmphdr; /* struct copy */\n\t\tkmem_free(tmp_leaf);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(save_leaf, &savehdr);\n\txfs_trans_log_buf(state->args->trans, save_blk->bp, 0,\n\t\t\t\t\t   state->args->geo->blksize - 1);\n\n\t/*\n\t * Copy out last hashval in each block for B-tree code.\n\t */\n\tentry = xfs_attr3_leaf_entryp(save_leaf);\n\tsave_blk->hashval = be32_to_cpu(entry[savehdr.count - 1].hashval);\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "1789-1939",
    "snippet": "int\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t/*\n\t * Scan through free region table:\n\t *    check for adjacency of free'd entry with an existing one,\n\t *    find smallest free region in case we need to replace it,\n\t *    adjust any map that borders the entry table,\n\t */\n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t/*\n\t * Coalesce adjacent freemap regions,\n\t * or replace the smallest region.\n\t */\n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Replace smallest region (if it is smaller than free'd entry)\n\t\t */\n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t/*\n\t * Did we remove the first entry?\n\t */\n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t/*\n\t * Compress the remaining entries and zero out the removed stuff.\n\t */\n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t/*\n\t * If we removed the first entry, re-find the first used byte\n\t * in the name area.  Note that if the entry was the \"firstused\",\n\t * then we don't have a \"hole\" in our block resulting from\n\t * removing the name.\n\t */\n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tif (!ichdr.firstused)\n\t\t\tichdr.firstused = tmp - XFS_ATTR_LEAF_NAME_ALIGN;\n\t} else {\n\t\tichdr.holes = 1;\t/* mark as needing compaction */\n\t}\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t/*\n\t * Check if leaf is less than 50% full, caller may want to\n\t * \"join\" the leaf with a sibling if so.\n\t */\n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct; /* leaf is < 37% full */\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_size",
          "args": [
            "leaf"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "769-775",
          "snippet": "static inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf))"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf",
            "&leaf->hdr",
            "xfs_attr3_leaf_hdr_size(leaf)"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_to_disk",
          "args": [
            "leaf",
            "&ichdr"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "130-171",
          "snippet": "void\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(entry->nameidx) < args->geo->blksize"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(entry->nameidx) >= ichdr.firstused"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "entry",
            "0",
            "sizeof(xfs_attr_leaf_entry_t)"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t))"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf",
            "entry",
            "tmp + sizeof(xfs_attr_leaf_entry_t)"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "entry",
            "entry + 1",
            "tmp"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize)"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf",
            "xfs_attr3_leaf_name(leaf, args->index)",
            "entsize"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name",
          "args": [
            "leaf",
            "args->index"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "802-806",
          "snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xfs_attr3_leaf_name(leaf, args->index)",
            "0",
            "entsize"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr.freemap[i].size < args->geo->blksize"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr.freemap[i].base < args->geo->blksize"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_entsize",
          "args": [
            "leaf",
            "args->index"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_leaf_entsize_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "819-823",
          "snippet": "static inline int xfs_attr_leaf_entsize_local(int nlen, int vlen)\n{\n\treturn ((uint)sizeof(xfs_attr_leaf_name_local_t) - 1 + (nlen) + (vlen) +\n\t\tXFS_ATTR_LEAF_NAME_ALIGN - 1) & ~(XFS_ATTR_LEAF_NAME_ALIGN - 1);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ATTR_LEAF_NAME_ALIGN\t((uint)sizeof(xfs_dablk_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ATTR_LEAF_NAME_ALIGN\t((uint)sizeof(xfs_dablk_t))\n\nstatic inline int xfs_attr_leaf_entsize_local(int nlen, int vlen)\n{\n\treturn ((uint)sizeof(xfs_attr_leaf_name_local_t) - 1 + (nlen) + (vlen) +\n\t\tXFS_ATTR_LEAF_NAME_ALIGN - 1) & ~(XFS_ATTR_LEAF_NAME_ALIGN - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(entry->nameidx) < args->geo->blksize"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(entry->nameidx) >= ichdr.firstused"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf)"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->index >= 0 && args->index < ichdr.count"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr.count > 0 && ichdr.count < args->geo->blksize / 8"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&ichdr",
            "leaf"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_remove",
          "args": [
            "args"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t/*\n\t * Scan through free region table:\n\t *    check for adjacency of free'd entry with an existing one,\n\t *    find smallest free region in case we need to replace it,\n\t *    adjust any map that borders the entry table,\n\t */\n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t/*\n\t * Coalesce adjacent freemap regions,\n\t * or replace the smallest region.\n\t */\n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Replace smallest region (if it is smaller than free'd entry)\n\t\t */\n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t/*\n\t * Did we remove the first entry?\n\t */\n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t/*\n\t * Compress the remaining entries and zero out the removed stuff.\n\t */\n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t/*\n\t * If we removed the first entry, re-find the first used byte\n\t * in the name area.  Note that if the entry was the \"firstused\",\n\t * then we don't have a \"hole\" in our block resulting from\n\t * removing the name.\n\t */\n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tif (!ichdr.firstused)\n\t\t\tichdr.firstused = tmp - XFS_ATTR_LEAF_NAME_ALIGN;\n\t} else {\n\t\tichdr.holes = 1;\t/* mark as needing compaction */\n\t}\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t/*\n\t * Check if leaf is less than 50% full, caller may want to\n\t * \"join\" the leaf with a sibling if so.\n\t */\n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct; /* leaf is < 37% full */\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_toosmall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "1662-1781",
    "snippet": "int\nxfs_attr3_leaf_toosmall(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*action)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tbytes;\n\tint\t\t\tforward;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_toosmall(state->args);\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tleaf = blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tbytes = xfs_attr3_leaf_hdr_size(leaf) +\n\t\tichdr.count * sizeof(xfs_attr_leaf_entry_t) +\n\t\tichdr.usedbytes;\n\tif (bytes > (state->args->geo->blksize >> 1)) {\n\t\t*action = 0;\t/* blk over 50%, don't try to join */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (ichdr.count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (ichdr.forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (retval) {\n\t\t\t*action = 0;\n\t\t} else {\n\t\t\t*action = 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink an attribute list over time.\n\t */\n\t/* start with smaller blk num */\n\tforward = ichdr.forw < ichdr.back;\n\tfor (i = 0; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\t\tif (forward)\n\t\t\tblkno = ichdr.forw;\n\t\telse\n\t\t\tblkno = ichdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\terror = xfs_attr3_leaf_read(state->args->trans, state->args->dp,\n\t\t\t\t\tblkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_hdr_from_disk(&ichdr2, bp->b_addr);\n\n\t\tbytes = state->args->geo->blksize -\n\t\t\t(state->args->geo->blksize >> 2) -\n\t\t\tichdr.usedbytes - ichdr2.usedbytes -\n\t\t\t((ichdr.count + ichdr2.count) *\n\t\t\t\t\tsizeof(xfs_attr_leaf_entry_t)) -\n\t\t\txfs_attr3_leaf_hdr_size(leaf);\n\n\t\txfs_trans_brelse(state->args->trans, bp);\n\t\tif (bytes >= 0)\n\t\t\tbreak;\t/* fits with at least 25% to spare */\n\t}\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno) {\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t} else {\n\t\terror = xfs_da3_path_shift(state, &state->path, forward,\n\t\t\t\t\t\t 0, &retval);\n\t}\n\tif (error)\n\t\treturn error;\n\tif (retval) {\n\t\t*action = 0;\n\t} else {\n\t\t*action = 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da3_path_shift",
          "args": [
            "state",
            "&state->path",
            "forward",
            "0",
            "&retval"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_path_shift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1811-1932",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_path_shift(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path,\n\tint\t\t\tforward,\n\tint\t\t\trelease,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno = 0;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_path_shift(state->args);\n\n\t/*\n\t * Roll up the Btree looking for the first block where our\n\t * current index is not at the edge of the block.  Note that\n\t * we skip the bottom layer because we want the sibling block.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tASSERT(path != NULL);\n\tASSERT((path->active > 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tlevel = (path->active-1) - 1;\t/* skip bottom layer in path */\n\tfor (blk = &path->blk[level]; level >= 0; blk--, level--) {\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tif (forward && (blk->index < nodehdr.count - 1)) {\n\t\t\tblk->index++;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t} else if (!forward && (blk->index > 0)) {\n\t\t\tblk->index--;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (level < 0) {\n\t\t*result = -ENOENT;\t/* we're out of our tree */\n\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Roll down the edge of the subtree until we reach the\n\t * same depth we were at originally.\n\t */\n\tfor (blk++, level++; level < path->active; blk++, level++) {\n\t\t/*\n\t\t * Release the old block.\n\t\t * (if it's dirty, trans won't actually let go)\n\t\t */\n\t\tif (release)\n\t\t\txfs_trans_brelse(args->trans, blk->bp);\n\n\t\t/*\n\t\t * Read the next child block.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, dp, blkno, -1,\n\t\t\t\t\t&blk->bp, args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinfo = blk->bp->b_addr;\n\t\tASSERT(info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\n\t\t/*\n\t\t * Note: we flatten the magic number to a single type so we\n\t\t * don't have to compare against crc/non-crc types elsewhere.\n\t\t */\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\t\t\tnode = (xfs_da_intnode_t *)info;\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t\t\tif (forward)\n\t\t\t\tblk->index = 0;\n\t\t\telse\n\t\t\t\tblk->index = nodehdr.count - 1;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*result = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_path_shift(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path,\n\tint\t\t\tforward,\n\tint\t\t\trelease,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno = 0;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_path_shift(state->args);\n\n\t/*\n\t * Roll up the Btree looking for the first block where our\n\t * current index is not at the edge of the block.  Note that\n\t * we skip the bottom layer because we want the sibling block.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tASSERT(path != NULL);\n\tASSERT((path->active > 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tlevel = (path->active-1) - 1;\t/* skip bottom layer in path */\n\tfor (blk = &path->blk[level]; level >= 0; blk--, level--) {\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tif (forward && (blk->index < nodehdr.count - 1)) {\n\t\t\tblk->index++;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t} else if (!forward && (blk->index > 0)) {\n\t\t\tblk->index--;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (level < 0) {\n\t\t*result = -ENOENT;\t/* we're out of our tree */\n\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Roll down the edge of the subtree until we reach the\n\t * same depth we were at originally.\n\t */\n\tfor (blk++, level++; level < path->active; blk++, level++) {\n\t\t/*\n\t\t * Release the old block.\n\t\t * (if it's dirty, trans won't actually let go)\n\t\t */\n\t\tif (release)\n\t\t\txfs_trans_brelse(args->trans, blk->bp);\n\n\t\t/*\n\t\t * Read the next child block.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, dp, blkno, -1,\n\t\t\t\t\t&blk->bp, args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinfo = blk->bp->b_addr;\n\t\tASSERT(info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\n\t\t/*\n\t\t * Note: we flatten the magic number to a single type so we\n\t\t * don't have to compare against crc/non-crc types elsewhere.\n\t\t */\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\t\t\tnode = (xfs_da_intnode_t *)info;\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t\t\tif (forward)\n\t\t\t\tblk->index = 0;\n\t\t\telse\n\t\t\t\tblk->index = nodehdr.count - 1;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*result = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&state->altpath",
            "&state->path",
            "sizeof(state->path)"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "state->args->trans",
            "bp"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_size",
          "args": [
            "leaf"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "769-775",
          "snippet": "static inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&ichdr2",
            "bp->b_addr"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_read",
          "args": [
            "state->args->trans",
            "state->args->dp",
            "blkno",
            "-1",
            "&bp"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "256-271",
          "snippet": "int\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
            "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&state->altpath",
            "&state->path",
            "sizeof(state->path)"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_toosmall",
          "args": [
            "state->args"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_leaf_toosmall(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*action)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tbytes;\n\tint\t\t\tforward;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_toosmall(state->args);\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tleaf = blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tbytes = xfs_attr3_leaf_hdr_size(leaf) +\n\t\tichdr.count * sizeof(xfs_attr_leaf_entry_t) +\n\t\tichdr.usedbytes;\n\tif (bytes > (state->args->geo->blksize >> 1)) {\n\t\t*action = 0;\t/* blk over 50%, don't try to join */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (ichdr.count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (ichdr.forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (retval) {\n\t\t\t*action = 0;\n\t\t} else {\n\t\t\t*action = 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink an attribute list over time.\n\t */\n\t/* start with smaller blk num */\n\tforward = ichdr.forw < ichdr.back;\n\tfor (i = 0; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\t\tif (forward)\n\t\t\tblkno = ichdr.forw;\n\t\telse\n\t\t\tblkno = ichdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\terror = xfs_attr3_leaf_read(state->args->trans, state->args->dp,\n\t\t\t\t\tblkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_hdr_from_disk(&ichdr2, bp->b_addr);\n\n\t\tbytes = state->args->geo->blksize -\n\t\t\t(state->args->geo->blksize >> 2) -\n\t\t\tichdr.usedbytes - ichdr2.usedbytes -\n\t\t\t((ichdr.count + ichdr2.count) *\n\t\t\t\t\tsizeof(xfs_attr_leaf_entry_t)) -\n\t\t\txfs_attr3_leaf_hdr_size(leaf);\n\n\t\txfs_trans_brelse(state->args->trans, bp);\n\t\tif (bytes >= 0)\n\t\t\tbreak;\t/* fits with at least 25% to spare */\n\t}\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno) {\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t} else {\n\t\terror = xfs_da3_path_shift(state, &state->path, forward,\n\t\t\t\t\t\t 0, &retval);\n\t}\n\tif (error)\n\t\treturn error;\n\tif (retval) {\n\t\t*action = 0;\n\t} else {\n\t\t*action = 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_figure_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "1562-1645",
    "snippet": "STATIC int\nxfs_attr3_leaf_figure_balance(\n\tstruct xfs_da_state\t\t*state,\n\tstruct xfs_da_state_blk\t\t*blk1,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr1,\n\tstruct xfs_da_state_blk\t\t*blk2,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr2,\n\tint\t\t\t\t*countarg,\n\tint\t\t\t\t*usedbytesarg)\n{\n\tstruct xfs_attr_leafblock\t*leaf1 = blk1->bp->b_addr;\n\tstruct xfs_attr_leafblock\t*leaf2 = blk2->bp->b_addr;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tcount;\n\tint\t\t\t\tmax;\n\tint\t\t\t\tindex;\n\tint\t\t\t\ttotallen = 0;\n\tint\t\t\t\thalf;\n\tint\t\t\t\tlastdelta;\n\tint\t\t\t\tfoundit = 0;\n\tint\t\t\t\ttmp;\n\n\t/*\n\t * Examine entries until we reduce the absolute difference in\n\t * byte usage between the two blocks to a minimum.\n\t */\n\tmax = ichdr1->count + ichdr2->count;\n\thalf = (max + 1) * sizeof(*entry);\n\thalf += ichdr1->usedbytes + ichdr2->usedbytes +\n\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\thalf /= 2;\n\tlastdelta = state->args->geo->blksize;\n\tentry = xfs_attr3_leaf_entryp(leaf1);\n\tfor (count = index = 0; count < max; entry++, index++, count++) {\n\n#define XFS_ATTR_ABS(A)\t(((A) < 0) ? -(A) : (A))\n\t\t/*\n\t\t * The new entry is in the first block, account for it.\n\t\t */\n\t\tif (count == blk1->index) {\n\t\t\ttmp = totallen + sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\t\tbreak;\n\t\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\t\ttotallen = tmp;\n\t\t\tfoundit = 1;\n\t\t}\n\n\t\t/*\n\t\t * Wrap around into the second block if necessary.\n\t\t */\n\t\tif (count == ichdr1->count) {\n\t\t\tleaf1 = leaf2;\n\t\t\tentry = xfs_attr3_leaf_entryp(leaf1);\n\t\t\tindex = 0;\n\t\t}\n\n\t\t/*\n\t\t * Figure out if next leaf entry would be too much.\n\t\t */\n\t\ttmp = totallen + sizeof(*entry) + xfs_attr_leaf_entsize(leaf1,\n\t\t\t\t\t\t\t\t\tindex);\n\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\tbreak;\n\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\ttotallen = tmp;\n#undef XFS_ATTR_ABS\n\t}\n\n\t/*\n\t * Calculate the number of usedbytes that will end up in lower block.\n\t * If new entry not in lower block, fix up the count.\n\t */\n\ttotallen -= count * sizeof(*entry);\n\tif (foundit) {\n\t\ttotallen -= sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t}\n\n\t*countarg = count;\n\t*usedbytesarg = totallen;\n\treturn foundit;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void xfs_attr3_leaf_rebalance(xfs_da_state_t *state,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk1,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk2);",
      "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_leaf_newentsize",
          "args": [
            "state->args",
            "NULL"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_ABS",
          "args": [
            "half - tmp"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_ABS",
          "args": [
            "half - tmp"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_entsize",
          "args": [
            "leaf1",
            "index"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_leaf_entsize_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "819-823",
          "snippet": "static inline int xfs_attr_leaf_entsize_local(int nlen, int vlen)\n{\n\treturn ((uint)sizeof(xfs_attr_leaf_name_local_t) - 1 + (nlen) + (vlen) +\n\t\tXFS_ATTR_LEAF_NAME_ALIGN - 1) & ~(XFS_ATTR_LEAF_NAME_ALIGN - 1);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ATTR_LEAF_NAME_ALIGN\t((uint)sizeof(xfs_dablk_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ATTR_LEAF_NAME_ALIGN\t((uint)sizeof(xfs_dablk_t))\n\nstatic inline int xfs_attr_leaf_entsize_local(int nlen, int vlen)\n{\n\treturn ((uint)sizeof(xfs_attr_leaf_name_local_t) - 1 + (nlen) + (vlen) +\n\t\tXFS_ATTR_LEAF_NAME_ALIGN - 1) & ~(XFS_ATTR_LEAF_NAME_ALIGN - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf1"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_ABS",
          "args": [
            "half - tmp"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_ABS",
          "args": [
            "half - tmp"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_newentsize",
          "args": [
            "state->args",
            "NULL"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_newentsize",
          "args": [
            "state->args",
            "NULL"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_attr3_leaf_rebalance(xfs_da_state_t *state,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk1,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk2);\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nSTATIC int\nxfs_attr3_leaf_figure_balance(\n\tstruct xfs_da_state\t\t*state,\n\tstruct xfs_da_state_blk\t\t*blk1,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr1,\n\tstruct xfs_da_state_blk\t\t*blk2,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr2,\n\tint\t\t\t\t*countarg,\n\tint\t\t\t\t*usedbytesarg)\n{\n\tstruct xfs_attr_leafblock\t*leaf1 = blk1->bp->b_addr;\n\tstruct xfs_attr_leafblock\t*leaf2 = blk2->bp->b_addr;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tcount;\n\tint\t\t\t\tmax;\n\tint\t\t\t\tindex;\n\tint\t\t\t\ttotallen = 0;\n\tint\t\t\t\thalf;\n\tint\t\t\t\tlastdelta;\n\tint\t\t\t\tfoundit = 0;\n\tint\t\t\t\ttmp;\n\n\t/*\n\t * Examine entries until we reduce the absolute difference in\n\t * byte usage between the two blocks to a minimum.\n\t */\n\tmax = ichdr1->count + ichdr2->count;\n\thalf = (max + 1) * sizeof(*entry);\n\thalf += ichdr1->usedbytes + ichdr2->usedbytes +\n\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\thalf /= 2;\n\tlastdelta = state->args->geo->blksize;\n\tentry = xfs_attr3_leaf_entryp(leaf1);\n\tfor (count = index = 0; count < max; entry++, index++, count++) {\n\n#define XFS_ATTR_ABS(A)\t(((A) < 0) ? -(A) : (A))\n\t\t/*\n\t\t * The new entry is in the first block, account for it.\n\t\t */\n\t\tif (count == blk1->index) {\n\t\t\ttmp = totallen + sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\t\tbreak;\n\t\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\t\ttotallen = tmp;\n\t\t\tfoundit = 1;\n\t\t}\n\n\t\t/*\n\t\t * Wrap around into the second block if necessary.\n\t\t */\n\t\tif (count == ichdr1->count) {\n\t\t\tleaf1 = leaf2;\n\t\t\tentry = xfs_attr3_leaf_entryp(leaf1);\n\t\t\tindex = 0;\n\t\t}\n\n\t\t/*\n\t\t * Figure out if next leaf entry would be too much.\n\t\t */\n\t\ttmp = totallen + sizeof(*entry) + xfs_attr_leaf_entsize(leaf1,\n\t\t\t\t\t\t\t\t\tindex);\n\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\tbreak;\n\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\ttotallen = tmp;\n#undef XFS_ATTR_ABS\n\t}\n\n\t/*\n\t * Calculate the number of usedbytes that will end up in lower block.\n\t * If new entry not in lower block, fix up the count.\n\t */\n\ttotallen -= count * sizeof(*entry);\n\tif (foundit) {\n\t\ttotallen -= sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t}\n\n\t*countarg = count;\n\t*usedbytesarg = totallen;\n\treturn foundit;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_rebalance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "1365-1553",
    "snippet": "STATIC void\nxfs_attr3_leaf_rebalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\tint\t\t\tcount;\n\tint\t\t\ttotallen;\n\tint\t\t\tmax;\n\tint\t\t\tspace;\n\tint\t\t\tswap;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(blk1->magic == XFS_ATTR_LEAF_MAGIC);\n\tASSERT(blk2->magic == XFS_ATTR_LEAF_MAGIC);\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(ichdr2.count == 0);\n\targs = state->args;\n\n\ttrace_xfs_attr_leaf_rebalance(args);\n\n\t/*\n\t * Check ordering of blocks, reverse if it makes things simpler.\n\t *\n\t * NOTE: Given that all (current) callers pass in an empty\n\t * second block, this code should never set \"swap\".\n\t */\n\tswap = 0;\n\tif (xfs_attr3_leaf_order(blk1->bp, &ichdr1, blk2->bp, &ichdr2)) {\n\t\tstruct xfs_da_state_blk\t*tmp_blk;\n\t\tstruct xfs_attr3_icleaf_hdr tmp_ichdr;\n\n\t\ttmp_blk = blk1;\n\t\tblk1 = blk2;\n\t\tblk2 = tmp_blk;\n\n\t\t/* struct copies to swap them rather than reconverting */\n\t\ttmp_ichdr = ichdr1;\n\t\tichdr1 = ichdr2;\n\t\tichdr2 = tmp_ichdr;\n\n\t\tleaf1 = blk1->bp->b_addr;\n\t\tleaf2 = blk2->bp->b_addr;\n\t\tswap = 1;\n\t}\n\n\t/*\n\t * Examine entries until we reduce the absolute difference in\n\t * byte usage between the two blocks to a minimum.  Then get\n\t * the direction to copy and the number of elements to move.\n\t *\n\t * \"inleaf\" is true if the new entry should be inserted into blk1.\n\t * If \"swap\" is also true, then reverse the sense of \"inleaf\".\n\t */\n\tstate->inleaf = xfs_attr3_leaf_figure_balance(state, blk1, &ichdr1,\n\t\t\t\t\t\t      blk2, &ichdr2,\n\t\t\t\t\t\t      &count, &totallen);\n\tif (swap)\n\t\tstate->inleaf = !state->inleaf;\n\n\t/*\n\t * Move any entries required from leaf to leaf:\n\t */\n\tif (count < ichdr1.count) {\n\t\t/*\n\t\t * Figure the total bytes to be added to the destination leaf.\n\t\t */\n\t\t/* number entries being moved */\n\t\tcount = ichdr1.count - count;\n\t\tspace  = ichdr1.usedbytes - totallen;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t/*\n\t\t * leaf2 is the destination, compact it if it looks tight.\n\t\t */\n\t\tmax  = ichdr2.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr2.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr2, blk2->bp);\n\n\t\t/*\n\t\t * Move high entries from leaf1 to low end of leaf2.\n\t\t */\n\t\txfs_attr3_leaf_moveents(args, leaf1, &ichdr1,\n\t\t\t\tichdr1.count - count, leaf2, &ichdr2, 0, count);\n\n\t} else if (count > ichdr1.count) {\n\t\t/*\n\t\t * I assert that since all callers pass in an empty\n\t\t * second buffer, this code should never execute.\n\t\t */\n\t\tASSERT(0);\n\n\t\t/*\n\t\t * Figure the total bytes to be added to the destination leaf.\n\t\t */\n\t\t/* number entries being moved */\n\t\tcount -= ichdr1.count;\n\t\tspace  = totallen - ichdr1.usedbytes;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t/*\n\t\t * leaf1 is the destination, compact it if it looks tight.\n\t\t */\n\t\tmax  = ichdr1.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr1.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr1, blk1->bp);\n\n\t\t/*\n\t\t * Move low entries from leaf2 to high end of leaf1.\n\t\t */\n\t\txfs_attr3_leaf_moveents(args, leaf2, &ichdr2, 0, leaf1, &ichdr1,\n\t\t\t\t\tichdr1.count, count);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(leaf1, &ichdr1);\n\txfs_attr3_leaf_hdr_to_disk(leaf2, &ichdr2);\n\txfs_trans_log_buf(args->trans, blk1->bp, 0, args->geo->blksize - 1);\n\txfs_trans_log_buf(args->trans, blk2->bp, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Copy out last hashval in each block for B-tree code.\n\t */\n\tentries1 = xfs_attr3_leaf_entryp(leaf1);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2);\n\tblk1->hashval = be32_to_cpu(entries1[ichdr1.count - 1].hashval);\n\tblk2->hashval = be32_to_cpu(entries2[ichdr2.count - 1].hashval);\n\n\t/*\n\t * Adjust the expected index for insertion.\n\t * NOTE: this code depends on the (current) situation that the\n\t * second block was originally empty.\n\t *\n\t * If the insertion point moved to the 2nd block, we must adjust\n\t * the index.  We must also track the entry just following the\n\t * new entry for use in an \"atomic rename\" operation, that entry\n\t * is always the \"old\" entry and the \"new\" entry is what we are\n\t * inserting.  The index/blkno fields refer to the \"old\" entry,\n\t * while the index2/blkno2 fields refer to the \"new\" entry.\n\t */\n\tif (blk1->index > ichdr1.count) {\n\t\tASSERT(state->inleaf == 0);\n\t\tblk2->index = blk1->index - ichdr1.count;\n\t\targs->index = args->index2 = blk2->index;\n\t\targs->blkno = args->blkno2 = blk2->blkno;\n\t} else if (blk1->index == ichdr1.count) {\n\t\tif (state->inleaf) {\n\t\t\targs->index = blk1->index;\n\t\t\targs->blkno = blk1->blkno;\n\t\t\targs->index2 = 0;\n\t\t\targs->blkno2 = blk2->blkno;\n\t\t} else {\n\t\t\t/*\n\t\t\t * On a double leaf split, the original attr location\n\t\t\t * is already stored in blkno2/index2, so don't\n\t\t\t * overwrite it overwise we corrupt the tree.\n\t\t\t */\n\t\t\tblk2->index = blk1->index - ichdr1.count;\n\t\t\targs->index = blk2->index;\n\t\t\targs->blkno = blk2->blkno;\n\t\t\tif (!state->extravalid) {\n\t\t\t\t/*\n\t\t\t\t * set the new attr location to match the old\n\t\t\t\t * one and let the higher level split code\n\t\t\t\t * decide where in the leaf to place it.\n\t\t\t\t */\n\t\t\t\targs->index2 = blk2->index;\n\t\t\t\targs->blkno2 = blk2->blkno;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tASSERT(state->inleaf == 1);\n\t\targs->index = args->index2 = blk1->index;\n\t\targs->blkno = args->blkno2 = blk1->blkno;\n\t}\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void xfs_attr3_leaf_rebalance(xfs_da_state_t *state,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk1,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk2);",
      "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->inleaf == 1"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->inleaf == 0"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entries2[ichdr2.count - 1].hashval"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entries1[ichdr1.count - 1].hashval"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf2"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "blk2->bp",
            "0",
            "args->geo->blksize - 1"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_to_disk",
          "args": [
            "leaf2",
            "&ichdr2"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "130-171",
          "snippet": "void\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_moveents",
          "args": [
            "args",
            "leaf2",
            "&ichdr2",
            "0",
            "leaf1",
            "&ichdr1",
            "ichdr1.count",
            "count"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_moveents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "2243-2695",
          "snippet": "STATIC void\nxfs_attr3_leaf_moveents(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_attr_leafblock\t*leaf_s,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_s,\n\tint\t\t\t\tstart_s,\n\tstruct xfs_attr_leafblock\t*leaf_d,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_d,\n\tint\t\t\t\tstart_d,\n\tint\t\t\t\tcount)\n{\n\tstruct xfs_attr_leaf_entry\t*entry_s;\n\tstruct xfs_attr_leaf_entry\t*entry_d;\n\tint\t\t\t\tdesti;\n\tint\t\t\t\ttmp;\n\tint\t\t\t\ti;\n\n\t/*\n\t * Check for nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(ichdr_s->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       ichdr_s->magic == XFS_ATTR3_LEAF_MAGIC);\n\tASSERT(ichdr_s->magic == ichdr_d->magic);\n\tASSERT(ichdr_s->count > 0 && ichdr_s->count < args->geo->blksize / 8);\n\tASSERT(ichdr_s->firstused >= (ichdr_s->count * sizeof(*entry_s))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_s));\n\tASSERT(ichdr_d->count < args->geo->blksize / 8);\n\tASSERT(ichdr_d->firstused >= (ichdr_d->count * sizeof(*entry_d))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d));\n\n\tASSERT(start_s < ichdr_s->count);\n\tASSERT(start_d <= ichdr_d->count);\n\tASSERT(count <= ichdr_s->count);\n\n\n\t/*\n\t * Move the entries in the destination leaf up to make a hole?\n\t */\n\tif (start_d < ichdr_d->count) {\n\t\ttmp  = ichdr_d->count - start_d;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d + count];\n\t\tmemmove(entry_d, entry_s, tmp);\n\t}\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate attribute info packed and in sequence.\n\t */\n\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\tdesti = start_d;\n\tfor (i = 0; i < count; entry_s++, entry_d++, desti++, i++) {\n\t\tASSERT(be16_to_cpu(entry_s->nameidx) >= ichdr_s->firstused);\n\t\ttmp = xfs_attr_leaf_entsize(leaf_s, start_s + i);\n#ifdef GROT\n\t\t/*\n\t\t * Code to drop INCOMPLETE entries.  Difficult to use as we\n\t\t * may also need to change the insertion index.  Code turned\n\t\t * off for 6.2, should be revisited later.\n\t\t */\n\t\tif (entry_s->flags & XFS_ATTR_INCOMPLETE) { /* skip partials? */\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tentry_d--;\t/* to compensate for ++ in loop hdr */\n\t\t\tdesti--;\n\t\t\tif ((start_s + i) < offset)\n\t\t\t\tresult++;\t/* insertion index adjustment */\n\t\t} else {\n#endif /* GROT */\n\t\t\tichdr_d->firstused -= tmp;\n\t\t\t/* both on-disk, don't endian flip twice */\n\t\t\tentry_d->hashval = entry_s->hashval;\n\t\t\tentry_d->nameidx = cpu_to_be16(ichdr_d->firstused);\n\t\t\tentry_d->flags = entry_s->flags;\n\t\t\tASSERT(be16_to_cpu(entry_d->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemmove(xfs_attr3_leaf_name(leaf_d, desti),\n\t\t\t\txfs_attr3_leaf_name(leaf_s, start_s + i), tmp);\n\t\t\tASSERT(be16_to_cpu(entry_s->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_d->usedbytes += tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tichdr_d->count += 1;\n\t\t\ttmp = ichdr_d->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d);\n\t\t\tASSERT(ichdr_d->firstused >= tmp);\n#ifdef GROT\n\t\t}\n#endif /* GROT */\n\t}\n\n\t/*\n\t * Zero out the entries we just copied.\n\t */\n\tif (start_s == ichdr_s->count) {\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t} else {\n\t\t/*\n\t\t * Move the remaining entries down to fill the hole,\n\t\t * then zero the entries at the top.\n\t\t */\n\t\ttmp  = (ichdr_s->count - count) * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s + count];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tmemmove(entry_d, entry_s, tmp);\n\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[ichdr_s->count];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t}\n\n\t/*\n\t * Fill in the freemap information\n\t */\n\tichdr_d->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_d);\n\tichdr_d->freemap[0].base += ichdr_d->count * sizeof(xfs_attr_leaf_entry_t);\n\tichdr_d->freemap[0].size = ichdr_d->firstused - ichdr_d->freemap[0].base;\n\tichdr_d->freemap[1].base = 0;\n\tichdr_d->freemap[2].base = 0;\n\tichdr_d->freemap[1].size = 0;\n\tichdr_d->freemap[2].size = 0;\n\tichdr_s->holes = 1;\t/* leaf may not be compact */\n}\n\n/*\n * Pick up the last hashvalue from a leaf block.\n */\nxfs_dahash_t\nxfs_attr_leaf_lasthash(\n\tstruct xfs_buf\t*bp,\n\tint\t\t*count)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, bp->b_addr);\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif (count)\n\t\t*count = ichdr.count;\n\tif (!ichdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(entries[ichdr.count - 1].hashval);\n}\n\n/*\n * Calculate the number of bytes used to store the indicated attribute\n * (whether local or remote only calculate bytes in this block).\n */\nSTATIC int\nxfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index)\n{\n\tstruct xfs_attr_leaf_entry *entries;\n\txfs_attr_leaf_name_local_t *name_loc;\n\txfs_attr_leaf_name_remote_t *name_rmt;\n\tint size;\n\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (entries[index].flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_local(name_loc->namelen,\n\t\t\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_remote(name_rmt->namelen);\n\t}\n\treturn size;\n}\n\n/*\n * Calculate the number of bytes that would be required to store the new\n * attribute (whether local or remote only calculate bytes in this block).\n * This routine decides as a side effect whether the attribute will be\n * a \"local\" or a \"remote\" attribute.\n */\nint\nxfs_attr_leaf_newentsize(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tint\t\t\tsize;\n\n\tsize = xfs_attr_leaf_entsize_local(args->namelen, args->valuelen);\n\tif (size < xfs_attr_leaf_entsize_local_max(args->geo->blksize)) {\n\t\tif (local)\n\t\t\t*local = 1;\n\t\treturn size;\n\t}\n\tif (local)\n\t\t*local = 0;\n\treturn xfs_attr_leaf_entsize_remote(args->namelen);\n}\n\n\n/*========================================================================\n * Manage the INCOMPLETE flag in a leaf entry\n *========================================================================*/\n\n/*\n * Clear the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * Set the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_setflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n#endif\n\n\ttrace_xfs_attr_leaf_setflag(args);\n\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n#endif\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT((entry->flags & XFS_ATTR_INCOMPLETE) == 0);\n\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\tXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif ((entry->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * In a single transaction, clear the INCOMPLETE flag on the leaf entry\n * given by args->blkno/index and set the INCOMPLETE flag on the leaf\n * entry given by args->blkno2/index2.\n *\n * Note that they could be in different blocks, or in the same block.\n */\nint\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll(&args->trans, args->dp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nSTATIC void\nxfs_attr3_leaf_moveents(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_attr_leafblock\t*leaf_s,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_s,\n\tint\t\t\t\tstart_s,\n\tstruct xfs_attr_leafblock\t*leaf_d,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_d,\n\tint\t\t\t\tstart_d,\n\tint\t\t\t\tcount)\n{\n\tstruct xfs_attr_leaf_entry\t*entry_s;\n\tstruct xfs_attr_leaf_entry\t*entry_d;\n\tint\t\t\t\tdesti;\n\tint\t\t\t\ttmp;\n\tint\t\t\t\ti;\n\n\t/*\n\t * Check for nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(ichdr_s->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       ichdr_s->magic == XFS_ATTR3_LEAF_MAGIC);\n\tASSERT(ichdr_s->magic == ichdr_d->magic);\n\tASSERT(ichdr_s->count > 0 && ichdr_s->count < args->geo->blksize / 8);\n\tASSERT(ichdr_s->firstused >= (ichdr_s->count * sizeof(*entry_s))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_s));\n\tASSERT(ichdr_d->count < args->geo->blksize / 8);\n\tASSERT(ichdr_d->firstused >= (ichdr_d->count * sizeof(*entry_d))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d));\n\n\tASSERT(start_s < ichdr_s->count);\n\tASSERT(start_d <= ichdr_d->count);\n\tASSERT(count <= ichdr_s->count);\n\n\n\t/*\n\t * Move the entries in the destination leaf up to make a hole?\n\t */\n\tif (start_d < ichdr_d->count) {\n\t\ttmp  = ichdr_d->count - start_d;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d + count];\n\t\tmemmove(entry_d, entry_s, tmp);\n\t}\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate attribute info packed and in sequence.\n\t */\n\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\tdesti = start_d;\n\tfor (i = 0; i < count; entry_s++, entry_d++, desti++, i++) {\n\t\tASSERT(be16_to_cpu(entry_s->nameidx) >= ichdr_s->firstused);\n\t\ttmp = xfs_attr_leaf_entsize(leaf_s, start_s + i);\n#ifdef GROT\n\t\t/*\n\t\t * Code to drop INCOMPLETE entries.  Difficult to use as we\n\t\t * may also need to change the insertion index.  Code turned\n\t\t * off for 6.2, should be revisited later.\n\t\t */\n\t\tif (entry_s->flags & XFS_ATTR_INCOMPLETE) { /* skip partials? */\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tentry_d--;\t/* to compensate for ++ in loop hdr */\n\t\t\tdesti--;\n\t\t\tif ((start_s + i) < offset)\n\t\t\t\tresult++;\t/* insertion index adjustment */\n\t\t} else {\n#endif /* GROT */\n\t\t\tichdr_d->firstused -= tmp;\n\t\t\t/* both on-disk, don't endian flip twice */\n\t\t\tentry_d->hashval = entry_s->hashval;\n\t\t\tentry_d->nameidx = cpu_to_be16(ichdr_d->firstused);\n\t\t\tentry_d->flags = entry_s->flags;\n\t\t\tASSERT(be16_to_cpu(entry_d->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemmove(xfs_attr3_leaf_name(leaf_d, desti),\n\t\t\t\txfs_attr3_leaf_name(leaf_s, start_s + i), tmp);\n\t\t\tASSERT(be16_to_cpu(entry_s->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_d->usedbytes += tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tichdr_d->count += 1;\n\t\t\ttmp = ichdr_d->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d);\n\t\t\tASSERT(ichdr_d->firstused >= tmp);\n#ifdef GROT\n\t\t}\n#endif /* GROT */\n\t}\n\n\t/*\n\t * Zero out the entries we just copied.\n\t */\n\tif (start_s == ichdr_s->count) {\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t} else {\n\t\t/*\n\t\t * Move the remaining entries down to fill the hole,\n\t\t * then zero the entries at the top.\n\t\t */\n\t\ttmp  = (ichdr_s->count - count) * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s + count];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tmemmove(entry_d, entry_s, tmp);\n\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[ichdr_s->count];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t}\n\n\t/*\n\t * Fill in the freemap information\n\t */\n\tichdr_d->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_d);\n\tichdr_d->freemap[0].base += ichdr_d->count * sizeof(xfs_attr_leaf_entry_t);\n\tichdr_d->freemap[0].size = ichdr_d->firstused - ichdr_d->freemap[0].base;\n\tichdr_d->freemap[1].base = 0;\n\tichdr_d->freemap[2].base = 0;\n\tichdr_d->freemap[1].size = 0;\n\tichdr_d->freemap[2].size = 0;\n\tichdr_s->holes = 1;\t/* leaf may not be compact */\n}\n\n/*\n * Pick up the last hashvalue from a leaf block.\n */\nxfs_dahash_t\nxfs_attr_leaf_lasthash(\n\tstruct xfs_buf\t*bp,\n\tint\t\t*count)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, bp->b_addr);\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif (count)\n\t\t*count = ichdr.count;\n\tif (!ichdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(entries[ichdr.count - 1].hashval);\n}\n\n/*\n * Calculate the number of bytes used to store the indicated attribute\n * (whether local or remote only calculate bytes in this block).\n */\nSTATIC int\nxfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index)\n{\n\tstruct xfs_attr_leaf_entry *entries;\n\txfs_attr_leaf_name_local_t *name_loc;\n\txfs_attr_leaf_name_remote_t *name_rmt;\n\tint size;\n\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (entries[index].flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_local(name_loc->namelen,\n\t\t\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_remote(name_rmt->namelen);\n\t}\n\treturn size;\n}\n\n/*\n * Calculate the number of bytes that would be required to store the new\n * attribute (whether local or remote only calculate bytes in this block).\n * This routine decides as a side effect whether the attribute will be\n * a \"local\" or a \"remote\" attribute.\n */\nint\nxfs_attr_leaf_newentsize(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tint\t\t\tsize;\n\n\tsize = xfs_attr_leaf_entsize_local(args->namelen, args->valuelen);\n\tif (size < xfs_attr_leaf_entsize_local_max(args->geo->blksize)) {\n\t\tif (local)\n\t\t\t*local = 1;\n\t\treturn size;\n\t}\n\tif (local)\n\t\t*local = 0;\n\treturn xfs_attr_leaf_entsize_remote(args->namelen);\n}\n\n\n/*========================================================================\n * Manage the INCOMPLETE flag in a leaf entry\n *========================================================================*/\n\n/*\n * Clear the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * Set the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_setflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n#endif\n\n\ttrace_xfs_attr_leaf_setflag(args);\n\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n#endif\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT((entry->flags & XFS_ATTR_INCOMPLETE) == 0);\n\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\tXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif ((entry->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * In a single transaction, clear the INCOMPLETE flag on the leaf entry\n * given by args->blkno/index and set the INCOMPLETE flag on the leaf\n * entry given by args->blkno2/index2.\n *\n * Note that they could be in different blocks, or in the same block.\n */\nint\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll(&args->trans, args->dp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_compact",
          "args": [
            "args",
            "&ichdr1",
            "blk1->bp"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_compact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1259-1312",
          "snippet": "STATIC void\nxfs_attr3_leaf_compact(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_attr3_icleaf_hdr *ichdr_dst,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf_src;\n\tstruct xfs_attr_leafblock *leaf_dst;\n\tstruct xfs_attr3_icleaf_hdr ichdr_src;\n\tstruct xfs_trans\t*trans = args->trans;\n\tchar\t\t\t*tmpbuffer;\n\n\ttrace_xfs_attr_leaf_compact(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\tleaf_src = (xfs_attr_leafblock_t *)tmpbuffer;\n\tleaf_dst = bp->b_addr;\n\n\t/*\n\t * Copy the on-disk header back into the destination buffer to ensure\n\t * all the information in the header that is not part of the incore\n\t * header structure is preserved.\n\t */\n\tmemcpy(bp->b_addr, tmpbuffer, xfs_attr3_leaf_hdr_size(leaf_src));\n\n\t/* Initialise the incore headers */\n\tichdr_src = *ichdr_dst;\t/* struct copy */\n\tichdr_dst->firstused = args->geo->blksize;\n\tichdr_dst->usedbytes = 0;\n\tichdr_dst->count = 0;\n\tichdr_dst->holes = 0;\n\tichdr_dst->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_src);\n\tichdr_dst->freemap[0].size = ichdr_dst->firstused -\n\t\t\t\t\t\tichdr_dst->freemap[0].base;\n\n\t/* write the header back to initialise the underlying buffer */\n\txfs_attr3_leaf_hdr_to_disk(leaf_dst, ichdr_dst);\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate name/value pairs packed and in sequence.\n\t */\n\txfs_attr3_leaf_moveents(args, leaf_src, &ichdr_src, 0,\n\t\t\t\tleaf_dst, ichdr_dst, 0, ichdr_src.count);\n\t/*\n\t * this logs the entire buffer, but the caller must write the header\n\t * back to the buffer when it is finished modifying it.\n\t */\n\txfs_trans_log_buf(trans, bp, 0, args->geo->blksize - 1);\n\n\tkmem_free(tmpbuffer);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_attr3_leaf_compact(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_attr3_icleaf_hdr *ichdr_dst,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf_src;\n\tstruct xfs_attr_leafblock *leaf_dst;\n\tstruct xfs_attr3_icleaf_hdr ichdr_src;\n\tstruct xfs_trans\t*trans = args->trans;\n\tchar\t\t\t*tmpbuffer;\n\n\ttrace_xfs_attr_leaf_compact(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\tleaf_src = (xfs_attr_leafblock_t *)tmpbuffer;\n\tleaf_dst = bp->b_addr;\n\n\t/*\n\t * Copy the on-disk header back into the destination buffer to ensure\n\t * all the information in the header that is not part of the incore\n\t * header structure is preserved.\n\t */\n\tmemcpy(bp->b_addr, tmpbuffer, xfs_attr3_leaf_hdr_size(leaf_src));\n\n\t/* Initialise the incore headers */\n\tichdr_src = *ichdr_dst;\t/* struct copy */\n\tichdr_dst->firstused = args->geo->blksize;\n\tichdr_dst->usedbytes = 0;\n\tichdr_dst->count = 0;\n\tichdr_dst->holes = 0;\n\tichdr_dst->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_src);\n\tichdr_dst->freemap[0].size = ichdr_dst->firstused -\n\t\t\t\t\t\tichdr_dst->freemap[0].base;\n\n\t/* write the header back to initialise the underlying buffer */\n\txfs_attr3_leaf_hdr_to_disk(leaf_dst, ichdr_dst);\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate name/value pairs packed and in sequence.\n\t */\n\txfs_attr3_leaf_moveents(args, leaf_src, &ichdr_src, 0,\n\t\t\t\tleaf_dst, ichdr_dst, 0, ichdr_src.count);\n\t/*\n\t * this logs the entire buffer, but the caller must write the header\n\t * back to the buffer when it is finished modifying it.\n\t */\n\txfs_trans_log_buf(trans, bp, 0, args->geo->blksize - 1);\n\n\tkmem_free(tmpbuffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_size",
          "args": [
            "leaf1"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "769-775",
          "snippet": "static inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_figure_balance",
          "args": [
            "state",
            "blk1",
            "&ichdr1",
            "blk2",
            "&ichdr2",
            "&count",
            "&totallen"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_figure_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1562-1645",
          "snippet": "STATIC int\nxfs_attr3_leaf_figure_balance(\n\tstruct xfs_da_state\t\t*state,\n\tstruct xfs_da_state_blk\t\t*blk1,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr1,\n\tstruct xfs_da_state_blk\t\t*blk2,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr2,\n\tint\t\t\t\t*countarg,\n\tint\t\t\t\t*usedbytesarg)\n{\n\tstruct xfs_attr_leafblock\t*leaf1 = blk1->bp->b_addr;\n\tstruct xfs_attr_leafblock\t*leaf2 = blk2->bp->b_addr;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tcount;\n\tint\t\t\t\tmax;\n\tint\t\t\t\tindex;\n\tint\t\t\t\ttotallen = 0;\n\tint\t\t\t\thalf;\n\tint\t\t\t\tlastdelta;\n\tint\t\t\t\tfoundit = 0;\n\tint\t\t\t\ttmp;\n\n\t/*\n\t * Examine entries until we reduce the absolute difference in\n\t * byte usage between the two blocks to a minimum.\n\t */\n\tmax = ichdr1->count + ichdr2->count;\n\thalf = (max + 1) * sizeof(*entry);\n\thalf += ichdr1->usedbytes + ichdr2->usedbytes +\n\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\thalf /= 2;\n\tlastdelta = state->args->geo->blksize;\n\tentry = xfs_attr3_leaf_entryp(leaf1);\n\tfor (count = index = 0; count < max; entry++, index++, count++) {\n\n#define XFS_ATTR_ABS(A)\t(((A) < 0) ? -(A) : (A))\n\t\t/*\n\t\t * The new entry is in the first block, account for it.\n\t\t */\n\t\tif (count == blk1->index) {\n\t\t\ttmp = totallen + sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\t\tbreak;\n\t\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\t\ttotallen = tmp;\n\t\t\tfoundit = 1;\n\t\t}\n\n\t\t/*\n\t\t * Wrap around into the second block if necessary.\n\t\t */\n\t\tif (count == ichdr1->count) {\n\t\t\tleaf1 = leaf2;\n\t\t\tentry = xfs_attr3_leaf_entryp(leaf1);\n\t\t\tindex = 0;\n\t\t}\n\n\t\t/*\n\t\t * Figure out if next leaf entry would be too much.\n\t\t */\n\t\ttmp = totallen + sizeof(*entry) + xfs_attr_leaf_entsize(leaf1,\n\t\t\t\t\t\t\t\t\tindex);\n\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\tbreak;\n\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\ttotallen = tmp;\n#undef XFS_ATTR_ABS\n\t}\n\n\t/*\n\t * Calculate the number of usedbytes that will end up in lower block.\n\t * If new entry not in lower block, fix up the count.\n\t */\n\ttotallen -= count * sizeof(*entry);\n\tif (foundit) {\n\t\ttotallen -= sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t}\n\n\t*countarg = count;\n\t*usedbytesarg = totallen;\n\treturn foundit;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void xfs_attr3_leaf_rebalance(xfs_da_state_t *state,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk1,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk2);",
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_attr3_leaf_rebalance(xfs_da_state_t *state,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk1,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk2);\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nSTATIC int\nxfs_attr3_leaf_figure_balance(\n\tstruct xfs_da_state\t\t*state,\n\tstruct xfs_da_state_blk\t\t*blk1,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr1,\n\tstruct xfs_da_state_blk\t\t*blk2,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr2,\n\tint\t\t\t\t*countarg,\n\tint\t\t\t\t*usedbytesarg)\n{\n\tstruct xfs_attr_leafblock\t*leaf1 = blk1->bp->b_addr;\n\tstruct xfs_attr_leafblock\t*leaf2 = blk2->bp->b_addr;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tcount;\n\tint\t\t\t\tmax;\n\tint\t\t\t\tindex;\n\tint\t\t\t\ttotallen = 0;\n\tint\t\t\t\thalf;\n\tint\t\t\t\tlastdelta;\n\tint\t\t\t\tfoundit = 0;\n\tint\t\t\t\ttmp;\n\n\t/*\n\t * Examine entries until we reduce the absolute difference in\n\t * byte usage between the two blocks to a minimum.\n\t */\n\tmax = ichdr1->count + ichdr2->count;\n\thalf = (max + 1) * sizeof(*entry);\n\thalf += ichdr1->usedbytes + ichdr2->usedbytes +\n\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\thalf /= 2;\n\tlastdelta = state->args->geo->blksize;\n\tentry = xfs_attr3_leaf_entryp(leaf1);\n\tfor (count = index = 0; count < max; entry++, index++, count++) {\n\n#define XFS_ATTR_ABS(A)\t(((A) < 0) ? -(A) : (A))\n\t\t/*\n\t\t * The new entry is in the first block, account for it.\n\t\t */\n\t\tif (count == blk1->index) {\n\t\t\ttmp = totallen + sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\t\tbreak;\n\t\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\t\ttotallen = tmp;\n\t\t\tfoundit = 1;\n\t\t}\n\n\t\t/*\n\t\t * Wrap around into the second block if necessary.\n\t\t */\n\t\tif (count == ichdr1->count) {\n\t\t\tleaf1 = leaf2;\n\t\t\tentry = xfs_attr3_leaf_entryp(leaf1);\n\t\t\tindex = 0;\n\t\t}\n\n\t\t/*\n\t\t * Figure out if next leaf entry would be too much.\n\t\t */\n\t\ttmp = totallen + sizeof(*entry) + xfs_attr_leaf_entsize(leaf1,\n\t\t\t\t\t\t\t\t\tindex);\n\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\tbreak;\n\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\ttotallen = tmp;\n#undef XFS_ATTR_ABS\n\t}\n\n\t/*\n\t * Calculate the number of usedbytes that will end up in lower block.\n\t * If new entry not in lower block, fix up the count.\n\t */\n\ttotallen -= count * sizeof(*entry);\n\tif (foundit) {\n\t\ttotallen -= sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t}\n\n\t*countarg = count;\n\t*usedbytesarg = totallen;\n\treturn foundit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_order",
          "args": [
            "blk1->bp",
            "&ichdr1",
            "blk2->bp",
            "&ichdr2"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1318-1338",
          "snippet": "static int\nxfs_attr3_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf1hdr,\n\tstruct xfs_buf\t*leaf2_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf2hdr)\n{\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\n\tentries1 = xfs_attr3_leaf_entryp(leaf1_bp->b_addr);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2_bp->b_addr);\n\tif (leaf1hdr->count > 0 && leaf2hdr->count > 0 &&\n\t    ((be32_to_cpu(entries2[0].hashval) <\n\t      be32_to_cpu(entries1[0].hashval)) ||\n\t     (be32_to_cpu(entries2[leaf2hdr->count - 1].hashval) <\n\t      be32_to_cpu(entries1[leaf1hdr->count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_attr3_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf1hdr,\n\tstruct xfs_buf\t*leaf2_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf2hdr)\n{\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\n\tentries1 = xfs_attr3_leaf_entryp(leaf1_bp->b_addr);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2_bp->b_addr);\n\tif (leaf1hdr->count > 0 && leaf2hdr->count > 0 &&\n\t    ((be32_to_cpu(entries2[0].hashval) <\n\t      be32_to_cpu(entries1[0].hashval)) ||\n\t     (be32_to_cpu(entries2[leaf2hdr->count - 1].hashval) <\n\t      be32_to_cpu(entries1[leaf1hdr->count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_rebalance",
          "args": [
            "args"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr2.count == 0"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&ichdr2",
            "leaf2"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk2->magic == XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk1->magic == XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_attr3_leaf_rebalance(xfs_da_state_t *state,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk1,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk2);\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nSTATIC void\nxfs_attr3_leaf_rebalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\tint\t\t\tcount;\n\tint\t\t\ttotallen;\n\tint\t\t\tmax;\n\tint\t\t\tspace;\n\tint\t\t\tswap;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(blk1->magic == XFS_ATTR_LEAF_MAGIC);\n\tASSERT(blk2->magic == XFS_ATTR_LEAF_MAGIC);\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(ichdr2.count == 0);\n\targs = state->args;\n\n\ttrace_xfs_attr_leaf_rebalance(args);\n\n\t/*\n\t * Check ordering of blocks, reverse if it makes things simpler.\n\t *\n\t * NOTE: Given that all (current) callers pass in an empty\n\t * second block, this code should never set \"swap\".\n\t */\n\tswap = 0;\n\tif (xfs_attr3_leaf_order(blk1->bp, &ichdr1, blk2->bp, &ichdr2)) {\n\t\tstruct xfs_da_state_blk\t*tmp_blk;\n\t\tstruct xfs_attr3_icleaf_hdr tmp_ichdr;\n\n\t\ttmp_blk = blk1;\n\t\tblk1 = blk2;\n\t\tblk2 = tmp_blk;\n\n\t\t/* struct copies to swap them rather than reconverting */\n\t\ttmp_ichdr = ichdr1;\n\t\tichdr1 = ichdr2;\n\t\tichdr2 = tmp_ichdr;\n\n\t\tleaf1 = blk1->bp->b_addr;\n\t\tleaf2 = blk2->bp->b_addr;\n\t\tswap = 1;\n\t}\n\n\t/*\n\t * Examine entries until we reduce the absolute difference in\n\t * byte usage between the two blocks to a minimum.  Then get\n\t * the direction to copy and the number of elements to move.\n\t *\n\t * \"inleaf\" is true if the new entry should be inserted into blk1.\n\t * If \"swap\" is also true, then reverse the sense of \"inleaf\".\n\t */\n\tstate->inleaf = xfs_attr3_leaf_figure_balance(state, blk1, &ichdr1,\n\t\t\t\t\t\t      blk2, &ichdr2,\n\t\t\t\t\t\t      &count, &totallen);\n\tif (swap)\n\t\tstate->inleaf = !state->inleaf;\n\n\t/*\n\t * Move any entries required from leaf to leaf:\n\t */\n\tif (count < ichdr1.count) {\n\t\t/*\n\t\t * Figure the total bytes to be added to the destination leaf.\n\t\t */\n\t\t/* number entries being moved */\n\t\tcount = ichdr1.count - count;\n\t\tspace  = ichdr1.usedbytes - totallen;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t/*\n\t\t * leaf2 is the destination, compact it if it looks tight.\n\t\t */\n\t\tmax  = ichdr2.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr2.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr2, blk2->bp);\n\n\t\t/*\n\t\t * Move high entries from leaf1 to low end of leaf2.\n\t\t */\n\t\txfs_attr3_leaf_moveents(args, leaf1, &ichdr1,\n\t\t\t\tichdr1.count - count, leaf2, &ichdr2, 0, count);\n\n\t} else if (count > ichdr1.count) {\n\t\t/*\n\t\t * I assert that since all callers pass in an empty\n\t\t * second buffer, this code should never execute.\n\t\t */\n\t\tASSERT(0);\n\n\t\t/*\n\t\t * Figure the total bytes to be added to the destination leaf.\n\t\t */\n\t\t/* number entries being moved */\n\t\tcount -= ichdr1.count;\n\t\tspace  = totallen - ichdr1.usedbytes;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t/*\n\t\t * leaf1 is the destination, compact it if it looks tight.\n\t\t */\n\t\tmax  = ichdr1.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr1.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr1, blk1->bp);\n\n\t\t/*\n\t\t * Move low entries from leaf2 to high end of leaf1.\n\t\t */\n\t\txfs_attr3_leaf_moveents(args, leaf2, &ichdr2, 0, leaf1, &ichdr1,\n\t\t\t\t\tichdr1.count, count);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(leaf1, &ichdr1);\n\txfs_attr3_leaf_hdr_to_disk(leaf2, &ichdr2);\n\txfs_trans_log_buf(args->trans, blk1->bp, 0, args->geo->blksize - 1);\n\txfs_trans_log_buf(args->trans, blk2->bp, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Copy out last hashval in each block for B-tree code.\n\t */\n\tentries1 = xfs_attr3_leaf_entryp(leaf1);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2);\n\tblk1->hashval = be32_to_cpu(entries1[ichdr1.count - 1].hashval);\n\tblk2->hashval = be32_to_cpu(entries2[ichdr2.count - 1].hashval);\n\n\t/*\n\t * Adjust the expected index for insertion.\n\t * NOTE: this code depends on the (current) situation that the\n\t * second block was originally empty.\n\t *\n\t * If the insertion point moved to the 2nd block, we must adjust\n\t * the index.  We must also track the entry just following the\n\t * new entry for use in an \"atomic rename\" operation, that entry\n\t * is always the \"old\" entry and the \"new\" entry is what we are\n\t * inserting.  The index/blkno fields refer to the \"old\" entry,\n\t * while the index2/blkno2 fields refer to the \"new\" entry.\n\t */\n\tif (blk1->index > ichdr1.count) {\n\t\tASSERT(state->inleaf == 0);\n\t\tblk2->index = blk1->index - ichdr1.count;\n\t\targs->index = args->index2 = blk2->index;\n\t\targs->blkno = args->blkno2 = blk2->blkno;\n\t} else if (blk1->index == ichdr1.count) {\n\t\tif (state->inleaf) {\n\t\t\targs->index = blk1->index;\n\t\t\targs->blkno = blk1->blkno;\n\t\t\targs->index2 = 0;\n\t\t\targs->blkno2 = blk2->blkno;\n\t\t} else {\n\t\t\t/*\n\t\t\t * On a double leaf split, the original attr location\n\t\t\t * is already stored in blkno2/index2, so don't\n\t\t\t * overwrite it overwise we corrupt the tree.\n\t\t\t */\n\t\t\tblk2->index = blk1->index - ichdr1.count;\n\t\t\targs->index = blk2->index;\n\t\t\targs->blkno = blk2->blkno;\n\t\t\tif (!state->extravalid) {\n\t\t\t\t/*\n\t\t\t\t * set the new attr location to match the old\n\t\t\t\t * one and let the higher level split code\n\t\t\t\t * decide where in the leaf to place it.\n\t\t\t\t */\n\t\t\t\targs->index2 = blk2->index;\n\t\t\t\targs->blkno2 = blk2->blkno;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tASSERT(state->inleaf == 1);\n\t\targs->index = args->index2 = blk1->index;\n\t\targs->blkno = args->blkno2 = blk1->blkno;\n\t}\n}"
  },
  {
    "function_name": "xfs_attr_leaf_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "1340-1351",
    "snippet": "int\nxfs_attr_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_buf\t*leaf2_bp)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1_bp->b_addr);\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2_bp->b_addr);\n\treturn xfs_attr3_leaf_order(leaf1_bp, &ichdr1, leaf2_bp, &ichdr2);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_order",
          "args": [
            "leaf1_bp",
            "&ichdr1",
            "leaf2_bp",
            "&ichdr2"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1318-1338",
          "snippet": "static int\nxfs_attr3_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf1hdr,\n\tstruct xfs_buf\t*leaf2_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf2hdr)\n{\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\n\tentries1 = xfs_attr3_leaf_entryp(leaf1_bp->b_addr);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2_bp->b_addr);\n\tif (leaf1hdr->count > 0 && leaf2hdr->count > 0 &&\n\t    ((be32_to_cpu(entries2[0].hashval) <\n\t      be32_to_cpu(entries1[0].hashval)) ||\n\t     (be32_to_cpu(entries2[leaf2hdr->count - 1].hashval) <\n\t      be32_to_cpu(entries1[leaf1hdr->count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_attr3_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf1hdr,\n\tstruct xfs_buf\t*leaf2_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf2hdr)\n{\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\n\tentries1 = xfs_attr3_leaf_entryp(leaf1_bp->b_addr);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2_bp->b_addr);\n\tif (leaf1hdr->count > 0 && leaf2hdr->count > 0 &&\n\t    ((be32_to_cpu(entries2[0].hashval) <\n\t      be32_to_cpu(entries1[0].hashval)) ||\n\t     (be32_to_cpu(entries2[leaf2hdr->count - 1].hashval) <\n\t      be32_to_cpu(entries1[leaf1hdr->count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&ichdr2",
            "leaf2_bp->b_addr"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_buf\t*leaf2_bp)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1_bp->b_addr);\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2_bp->b_addr);\n\treturn xfs_attr3_leaf_order(leaf1_bp, &ichdr1, leaf2_bp, &ichdr2);\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "1318-1338",
    "snippet": "static int\nxfs_attr3_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf1hdr,\n\tstruct xfs_buf\t*leaf2_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf2hdr)\n{\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\n\tentries1 = xfs_attr3_leaf_entryp(leaf1_bp->b_addr);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2_bp->b_addr);\n\tif (leaf1hdr->count > 0 && leaf2hdr->count > 0 &&\n\t    ((be32_to_cpu(entries2[0].hashval) <\n\t      be32_to_cpu(entries1[0].hashval)) ||\n\t     (be32_to_cpu(entries2[leaf2hdr->count - 1].hashval) <\n\t      be32_to_cpu(entries1[leaf1hdr->count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entries1[leaf1hdr->count - 1].hashval"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entries2[leaf2hdr->count - 1].hashval"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entries1[0].hashval"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entries2[0].hashval"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf2_bp->b_addr"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_attr3_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf1hdr,\n\tstruct xfs_buf\t*leaf2_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf2hdr)\n{\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\n\tentries1 = xfs_attr3_leaf_entryp(leaf1_bp->b_addr);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2_bp->b_addr);\n\tif (leaf1hdr->count > 0 && leaf2hdr->count > 0 &&\n\t    ((be32_to_cpu(entries2[0].hashval) <\n\t      be32_to_cpu(entries1[0].hashval)) ||\n\t     (be32_to_cpu(entries2[leaf2hdr->count - 1].hashval) <\n\t      be32_to_cpu(entries1[leaf1hdr->count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_compact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "1259-1312",
    "snippet": "STATIC void\nxfs_attr3_leaf_compact(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_attr3_icleaf_hdr *ichdr_dst,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf_src;\n\tstruct xfs_attr_leafblock *leaf_dst;\n\tstruct xfs_attr3_icleaf_hdr ichdr_src;\n\tstruct xfs_trans\t*trans = args->trans;\n\tchar\t\t\t*tmpbuffer;\n\n\ttrace_xfs_attr_leaf_compact(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\tleaf_src = (xfs_attr_leafblock_t *)tmpbuffer;\n\tleaf_dst = bp->b_addr;\n\n\t/*\n\t * Copy the on-disk header back into the destination buffer to ensure\n\t * all the information in the header that is not part of the incore\n\t * header structure is preserved.\n\t */\n\tmemcpy(bp->b_addr, tmpbuffer, xfs_attr3_leaf_hdr_size(leaf_src));\n\n\t/* Initialise the incore headers */\n\tichdr_src = *ichdr_dst;\t/* struct copy */\n\tichdr_dst->firstused = args->geo->blksize;\n\tichdr_dst->usedbytes = 0;\n\tichdr_dst->count = 0;\n\tichdr_dst->holes = 0;\n\tichdr_dst->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_src);\n\tichdr_dst->freemap[0].size = ichdr_dst->firstused -\n\t\t\t\t\t\tichdr_dst->freemap[0].base;\n\n\t/* write the header back to initialise the underlying buffer */\n\txfs_attr3_leaf_hdr_to_disk(leaf_dst, ichdr_dst);\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate name/value pairs packed and in sequence.\n\t */\n\txfs_attr3_leaf_moveents(args, leaf_src, &ichdr_src, 0,\n\t\t\t\tleaf_dst, ichdr_dst, 0, ichdr_src.count);\n\t/*\n\t * this logs the entire buffer, but the caller must write the header\n\t * back to the buffer when it is finished modifying it.\n\t */\n\txfs_trans_log_buf(trans, bp, 0, args->geo->blksize - 1);\n\n\tkmem_free(tmpbuffer);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "tmpbuffer"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "trans",
            "bp",
            "0",
            "args->geo->blksize - 1"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_moveents",
          "args": [
            "args",
            "leaf_src",
            "&ichdr_src",
            "0",
            "leaf_dst",
            "ichdr_dst",
            "0",
            "ichdr_src.count"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_moveents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "2243-2695",
          "snippet": "STATIC void\nxfs_attr3_leaf_moveents(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_attr_leafblock\t*leaf_s,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_s,\n\tint\t\t\t\tstart_s,\n\tstruct xfs_attr_leafblock\t*leaf_d,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_d,\n\tint\t\t\t\tstart_d,\n\tint\t\t\t\tcount)\n{\n\tstruct xfs_attr_leaf_entry\t*entry_s;\n\tstruct xfs_attr_leaf_entry\t*entry_d;\n\tint\t\t\t\tdesti;\n\tint\t\t\t\ttmp;\n\tint\t\t\t\ti;\n\n\t/*\n\t * Check for nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(ichdr_s->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       ichdr_s->magic == XFS_ATTR3_LEAF_MAGIC);\n\tASSERT(ichdr_s->magic == ichdr_d->magic);\n\tASSERT(ichdr_s->count > 0 && ichdr_s->count < args->geo->blksize / 8);\n\tASSERT(ichdr_s->firstused >= (ichdr_s->count * sizeof(*entry_s))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_s));\n\tASSERT(ichdr_d->count < args->geo->blksize / 8);\n\tASSERT(ichdr_d->firstused >= (ichdr_d->count * sizeof(*entry_d))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d));\n\n\tASSERT(start_s < ichdr_s->count);\n\tASSERT(start_d <= ichdr_d->count);\n\tASSERT(count <= ichdr_s->count);\n\n\n\t/*\n\t * Move the entries in the destination leaf up to make a hole?\n\t */\n\tif (start_d < ichdr_d->count) {\n\t\ttmp  = ichdr_d->count - start_d;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d + count];\n\t\tmemmove(entry_d, entry_s, tmp);\n\t}\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate attribute info packed and in sequence.\n\t */\n\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\tdesti = start_d;\n\tfor (i = 0; i < count; entry_s++, entry_d++, desti++, i++) {\n\t\tASSERT(be16_to_cpu(entry_s->nameidx) >= ichdr_s->firstused);\n\t\ttmp = xfs_attr_leaf_entsize(leaf_s, start_s + i);\n#ifdef GROT\n\t\t/*\n\t\t * Code to drop INCOMPLETE entries.  Difficult to use as we\n\t\t * may also need to change the insertion index.  Code turned\n\t\t * off for 6.2, should be revisited later.\n\t\t */\n\t\tif (entry_s->flags & XFS_ATTR_INCOMPLETE) { /* skip partials? */\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tentry_d--;\t/* to compensate for ++ in loop hdr */\n\t\t\tdesti--;\n\t\t\tif ((start_s + i) < offset)\n\t\t\t\tresult++;\t/* insertion index adjustment */\n\t\t} else {\n#endif /* GROT */\n\t\t\tichdr_d->firstused -= tmp;\n\t\t\t/* both on-disk, don't endian flip twice */\n\t\t\tentry_d->hashval = entry_s->hashval;\n\t\t\tentry_d->nameidx = cpu_to_be16(ichdr_d->firstused);\n\t\t\tentry_d->flags = entry_s->flags;\n\t\t\tASSERT(be16_to_cpu(entry_d->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemmove(xfs_attr3_leaf_name(leaf_d, desti),\n\t\t\t\txfs_attr3_leaf_name(leaf_s, start_s + i), tmp);\n\t\t\tASSERT(be16_to_cpu(entry_s->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_d->usedbytes += tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tichdr_d->count += 1;\n\t\t\ttmp = ichdr_d->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d);\n\t\t\tASSERT(ichdr_d->firstused >= tmp);\n#ifdef GROT\n\t\t}\n#endif /* GROT */\n\t}\n\n\t/*\n\t * Zero out the entries we just copied.\n\t */\n\tif (start_s == ichdr_s->count) {\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t} else {\n\t\t/*\n\t\t * Move the remaining entries down to fill the hole,\n\t\t * then zero the entries at the top.\n\t\t */\n\t\ttmp  = (ichdr_s->count - count) * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s + count];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tmemmove(entry_d, entry_s, tmp);\n\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[ichdr_s->count];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t}\n\n\t/*\n\t * Fill in the freemap information\n\t */\n\tichdr_d->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_d);\n\tichdr_d->freemap[0].base += ichdr_d->count * sizeof(xfs_attr_leaf_entry_t);\n\tichdr_d->freemap[0].size = ichdr_d->firstused - ichdr_d->freemap[0].base;\n\tichdr_d->freemap[1].base = 0;\n\tichdr_d->freemap[2].base = 0;\n\tichdr_d->freemap[1].size = 0;\n\tichdr_d->freemap[2].size = 0;\n\tichdr_s->holes = 1;\t/* leaf may not be compact */\n}\n\n/*\n * Pick up the last hashvalue from a leaf block.\n */\nxfs_dahash_t\nxfs_attr_leaf_lasthash(\n\tstruct xfs_buf\t*bp,\n\tint\t\t*count)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, bp->b_addr);\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif (count)\n\t\t*count = ichdr.count;\n\tif (!ichdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(entries[ichdr.count - 1].hashval);\n}\n\n/*\n * Calculate the number of bytes used to store the indicated attribute\n * (whether local or remote only calculate bytes in this block).\n */\nSTATIC int\nxfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index)\n{\n\tstruct xfs_attr_leaf_entry *entries;\n\txfs_attr_leaf_name_local_t *name_loc;\n\txfs_attr_leaf_name_remote_t *name_rmt;\n\tint size;\n\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (entries[index].flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_local(name_loc->namelen,\n\t\t\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_remote(name_rmt->namelen);\n\t}\n\treturn size;\n}\n\n/*\n * Calculate the number of bytes that would be required to store the new\n * attribute (whether local or remote only calculate bytes in this block).\n * This routine decides as a side effect whether the attribute will be\n * a \"local\" or a \"remote\" attribute.\n */\nint\nxfs_attr_leaf_newentsize(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tint\t\t\tsize;\n\n\tsize = xfs_attr_leaf_entsize_local(args->namelen, args->valuelen);\n\tif (size < xfs_attr_leaf_entsize_local_max(args->geo->blksize)) {\n\t\tif (local)\n\t\t\t*local = 1;\n\t\treturn size;\n\t}\n\tif (local)\n\t\t*local = 0;\n\treturn xfs_attr_leaf_entsize_remote(args->namelen);\n}\n\n\n/*========================================================================\n * Manage the INCOMPLETE flag in a leaf entry\n *========================================================================*/\n\n/*\n * Clear the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * Set the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_setflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n#endif\n\n\ttrace_xfs_attr_leaf_setflag(args);\n\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n#endif\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT((entry->flags & XFS_ATTR_INCOMPLETE) == 0);\n\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\tXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif ((entry->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * In a single transaction, clear the INCOMPLETE flag on the leaf entry\n * given by args->blkno/index and set the INCOMPLETE flag on the leaf\n * entry given by args->blkno2/index2.\n *\n * Note that they could be in different blocks, or in the same block.\n */\nint\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll(&args->trans, args->dp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nSTATIC void\nxfs_attr3_leaf_moveents(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_attr_leafblock\t*leaf_s,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_s,\n\tint\t\t\t\tstart_s,\n\tstruct xfs_attr_leafblock\t*leaf_d,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_d,\n\tint\t\t\t\tstart_d,\n\tint\t\t\t\tcount)\n{\n\tstruct xfs_attr_leaf_entry\t*entry_s;\n\tstruct xfs_attr_leaf_entry\t*entry_d;\n\tint\t\t\t\tdesti;\n\tint\t\t\t\ttmp;\n\tint\t\t\t\ti;\n\n\t/*\n\t * Check for nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(ichdr_s->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       ichdr_s->magic == XFS_ATTR3_LEAF_MAGIC);\n\tASSERT(ichdr_s->magic == ichdr_d->magic);\n\tASSERT(ichdr_s->count > 0 && ichdr_s->count < args->geo->blksize / 8);\n\tASSERT(ichdr_s->firstused >= (ichdr_s->count * sizeof(*entry_s))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_s));\n\tASSERT(ichdr_d->count < args->geo->blksize / 8);\n\tASSERT(ichdr_d->firstused >= (ichdr_d->count * sizeof(*entry_d))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d));\n\n\tASSERT(start_s < ichdr_s->count);\n\tASSERT(start_d <= ichdr_d->count);\n\tASSERT(count <= ichdr_s->count);\n\n\n\t/*\n\t * Move the entries in the destination leaf up to make a hole?\n\t */\n\tif (start_d < ichdr_d->count) {\n\t\ttmp  = ichdr_d->count - start_d;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d + count];\n\t\tmemmove(entry_d, entry_s, tmp);\n\t}\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate attribute info packed and in sequence.\n\t */\n\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\tdesti = start_d;\n\tfor (i = 0; i < count; entry_s++, entry_d++, desti++, i++) {\n\t\tASSERT(be16_to_cpu(entry_s->nameidx) >= ichdr_s->firstused);\n\t\ttmp = xfs_attr_leaf_entsize(leaf_s, start_s + i);\n#ifdef GROT\n\t\t/*\n\t\t * Code to drop INCOMPLETE entries.  Difficult to use as we\n\t\t * may also need to change the insertion index.  Code turned\n\t\t * off for 6.2, should be revisited later.\n\t\t */\n\t\tif (entry_s->flags & XFS_ATTR_INCOMPLETE) { /* skip partials? */\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tentry_d--;\t/* to compensate for ++ in loop hdr */\n\t\t\tdesti--;\n\t\t\tif ((start_s + i) < offset)\n\t\t\t\tresult++;\t/* insertion index adjustment */\n\t\t} else {\n#endif /* GROT */\n\t\t\tichdr_d->firstused -= tmp;\n\t\t\t/* both on-disk, don't endian flip twice */\n\t\t\tentry_d->hashval = entry_s->hashval;\n\t\t\tentry_d->nameidx = cpu_to_be16(ichdr_d->firstused);\n\t\t\tentry_d->flags = entry_s->flags;\n\t\t\tASSERT(be16_to_cpu(entry_d->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemmove(xfs_attr3_leaf_name(leaf_d, desti),\n\t\t\t\txfs_attr3_leaf_name(leaf_s, start_s + i), tmp);\n\t\t\tASSERT(be16_to_cpu(entry_s->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_d->usedbytes += tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tichdr_d->count += 1;\n\t\t\ttmp = ichdr_d->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d);\n\t\t\tASSERT(ichdr_d->firstused >= tmp);\n#ifdef GROT\n\t\t}\n#endif /* GROT */\n\t}\n\n\t/*\n\t * Zero out the entries we just copied.\n\t */\n\tif (start_s == ichdr_s->count) {\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t} else {\n\t\t/*\n\t\t * Move the remaining entries down to fill the hole,\n\t\t * then zero the entries at the top.\n\t\t */\n\t\ttmp  = (ichdr_s->count - count) * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s + count];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tmemmove(entry_d, entry_s, tmp);\n\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[ichdr_s->count];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t}\n\n\t/*\n\t * Fill in the freemap information\n\t */\n\tichdr_d->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_d);\n\tichdr_d->freemap[0].base += ichdr_d->count * sizeof(xfs_attr_leaf_entry_t);\n\tichdr_d->freemap[0].size = ichdr_d->firstused - ichdr_d->freemap[0].base;\n\tichdr_d->freemap[1].base = 0;\n\tichdr_d->freemap[2].base = 0;\n\tichdr_d->freemap[1].size = 0;\n\tichdr_d->freemap[2].size = 0;\n\tichdr_s->holes = 1;\t/* leaf may not be compact */\n}\n\n/*\n * Pick up the last hashvalue from a leaf block.\n */\nxfs_dahash_t\nxfs_attr_leaf_lasthash(\n\tstruct xfs_buf\t*bp,\n\tint\t\t*count)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, bp->b_addr);\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif (count)\n\t\t*count = ichdr.count;\n\tif (!ichdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(entries[ichdr.count - 1].hashval);\n}\n\n/*\n * Calculate the number of bytes used to store the indicated attribute\n * (whether local or remote only calculate bytes in this block).\n */\nSTATIC int\nxfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index)\n{\n\tstruct xfs_attr_leaf_entry *entries;\n\txfs_attr_leaf_name_local_t *name_loc;\n\txfs_attr_leaf_name_remote_t *name_rmt;\n\tint size;\n\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (entries[index].flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_local(name_loc->namelen,\n\t\t\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_remote(name_rmt->namelen);\n\t}\n\treturn size;\n}\n\n/*\n * Calculate the number of bytes that would be required to store the new\n * attribute (whether local or remote only calculate bytes in this block).\n * This routine decides as a side effect whether the attribute will be\n * a \"local\" or a \"remote\" attribute.\n */\nint\nxfs_attr_leaf_newentsize(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tint\t\t\tsize;\n\n\tsize = xfs_attr_leaf_entsize_local(args->namelen, args->valuelen);\n\tif (size < xfs_attr_leaf_entsize_local_max(args->geo->blksize)) {\n\t\tif (local)\n\t\t\t*local = 1;\n\t\treturn size;\n\t}\n\tif (local)\n\t\t*local = 0;\n\treturn xfs_attr_leaf_entsize_remote(args->namelen);\n}\n\n\n/*========================================================================\n * Manage the INCOMPLETE flag in a leaf entry\n *========================================================================*/\n\n/*\n * Clear the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * Set the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_setflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n#endif\n\n\ttrace_xfs_attr_leaf_setflag(args);\n\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n#endif\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT((entry->flags & XFS_ATTR_INCOMPLETE) == 0);\n\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\tXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif ((entry->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n\n/*\n * In a single transaction, clear the INCOMPLETE flag on the leaf entry\n * given by args->blkno/index and set the INCOMPLETE flag on the leaf\n * entry given by args->blkno2/index2.\n *\n * Note that they could be in different blocks, or in the same block.\n */\nint\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll(&args->trans, args->dp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_to_disk",
          "args": [
            "leaf_dst",
            "ichdr_dst"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "130-171",
          "snippet": "void\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_size",
          "args": [
            "leaf_src"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "769-775",
          "snippet": "static inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bp->b_addr",
            "tmpbuffer",
            "xfs_attr3_leaf_hdr_size(leaf_src)"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp->b_addr",
            "0",
            "args->geo->blksize"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmpbuffer",
            "bp->b_addr",
            "args->geo->blksize"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "args->geo->blksize",
            "KM_SLEEP"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_compact",
          "args": [
            "args"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_attr3_leaf_compact(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_attr3_icleaf_hdr *ichdr_dst,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf_src;\n\tstruct xfs_attr_leafblock *leaf_dst;\n\tstruct xfs_attr3_icleaf_hdr ichdr_src;\n\tstruct xfs_trans\t*trans = args->trans;\n\tchar\t\t\t*tmpbuffer;\n\n\ttrace_xfs_attr_leaf_compact(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\tleaf_src = (xfs_attr_leafblock_t *)tmpbuffer;\n\tleaf_dst = bp->b_addr;\n\n\t/*\n\t * Copy the on-disk header back into the destination buffer to ensure\n\t * all the information in the header that is not part of the incore\n\t * header structure is preserved.\n\t */\n\tmemcpy(bp->b_addr, tmpbuffer, xfs_attr3_leaf_hdr_size(leaf_src));\n\n\t/* Initialise the incore headers */\n\tichdr_src = *ichdr_dst;\t/* struct copy */\n\tichdr_dst->firstused = args->geo->blksize;\n\tichdr_dst->usedbytes = 0;\n\tichdr_dst->count = 0;\n\tichdr_dst->holes = 0;\n\tichdr_dst->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_src);\n\tichdr_dst->freemap[0].size = ichdr_dst->firstused -\n\t\t\t\t\t\tichdr_dst->freemap[0].base;\n\n\t/* write the header back to initialise the underlying buffer */\n\txfs_attr3_leaf_hdr_to_disk(leaf_dst, ichdr_dst);\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate name/value pairs packed and in sequence.\n\t */\n\txfs_attr3_leaf_moveents(args, leaf_src, &ichdr_src, 0,\n\t\t\t\tleaf_dst, ichdr_dst, 0, ichdr_src.count);\n\t/*\n\t * this logs the entire buffer, but the caller must write the header\n\t * back to the buffer when it is finished modifying it.\n\t */\n\txfs_trans_log_buf(trans, bp, 0, args->geo->blksize - 1);\n\n\tkmem_free(tmpbuffer);\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_add_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "1139-1254",
    "snippet": "STATIC int\nxfs_attr3_leaf_add_work(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_attr3_icleaf_hdr *ichdr,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tmapindex)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add_work(args);\n\n\tleaf = bp->b_addr;\n\tASSERT(mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE);\n\tASSERT(args->index >= 0 && args->index <= ichdr->count);\n\n\t/*\n\t * Force open some space in the entry array and fill it in.\n\t */\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (args->index < ichdr->count) {\n\t\ttmp  = ichdr->count - args->index;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tmemmove(entry + 1, entry, tmp);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\n\t}\n\tichdr->count++;\n\n\t/*\n\t * Allocate space for the new string (at the end of the run).\n\t */\n\tmp = args->trans->t_mountp;\n\tASSERT(ichdr->freemap[mapindex].base < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].base & 0x3) == 0);\n\tASSERT(ichdr->freemap[mapindex].size >=\n\t\txfs_attr_leaf_newentsize(args, NULL));\n\tASSERT(ichdr->freemap[mapindex].size < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);\n\n\tichdr->freemap[mapindex].size -= xfs_attr_leaf_newentsize(args, &tmp);\n\n\tentry->nameidx = cpu_to_be16(ichdr->freemap[mapindex].base +\n\t\t\t\t     ichdr->freemap[mapindex].size);\n\tentry->hashval = cpu_to_be32(args->hashval);\n\tentry->flags = tmp ? XFS_ATTR_LOCAL : 0;\n\tentry->flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\tif ((args->blkno2 == args->blkno) &&\n\t\t    (args->index2 <= args->index)) {\n\t\t\targs->index2++;\n\t\t}\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tASSERT((args->index == 0) ||\n\t       (be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval)));\n\tASSERT((args->index == ichdr->count - 1) ||\n\t       (be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval)));\n\n\t/*\n\t * For \"remote\" attribute values, simply note that we need to\n\t * allocate space for the \"remote\" value.  We can't actually\n\t * allocate the extents in this transaction, and we can't decide\n\t * which blocks they should be as we might allocate more blocks\n\t * as part of this transaction (a split operation for example).\n\t */\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tname_loc->namelen = args->namelen;\n\t\tname_loc->valuelen = cpu_to_be16(args->valuelen);\n\t\tmemcpy((char *)name_loc->nameval, args->name, args->namelen);\n\t\tmemcpy((char *)&name_loc->nameval[args->namelen], args->value,\n\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->namelen = args->namelen;\n\t\tmemcpy((char *)name_rmt->name, args->name, args->namelen);\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\t/* just in case */\n\t\tname_rmt->valuelen = 0;\n\t\tname_rmt->valueblk = 0;\n\t\targs->rmtblkno = 1;\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\targs->rmtvaluelen = args->valuelen;\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args->index)));\n\n\t/*\n\t * Update the control info for this leaf node\n\t */\n\tif (be16_to_cpu(entry->nameidx) < ichdr->firstused)\n\t\tichdr->firstused = be16_to_cpu(entry->nameidx);\n\n\tASSERT(ichdr->firstused >= ichdr->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf));\n\ttmp = (ichdr->count - 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr->freemap[i].base == tmp) {\n\t\t\tichdr->freemap[i].base += sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr->freemap[i].size -= sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\t}\n\tichdr->usedbytes += xfs_attr_leaf_entsize(leaf, args->index);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_leaf_entsize",
          "args": [
            "leaf",
            "args->index"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_leaf_entsize_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "819-823",
          "snippet": "static inline int xfs_attr_leaf_entsize_local(int nlen, int vlen)\n{\n\treturn ((uint)sizeof(xfs_attr_leaf_name_local_t) - 1 + (nlen) + (vlen) +\n\t\tXFS_ATTR_LEAF_NAME_ALIGN - 1) & ~(XFS_ATTR_LEAF_NAME_ALIGN - 1);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ATTR_LEAF_NAME_ALIGN\t((uint)sizeof(xfs_dablk_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ATTR_LEAF_NAME_ALIGN\t((uint)sizeof(xfs_dablk_t))\n\nstatic inline int xfs_attr_leaf_entsize_local(int nlen, int vlen)\n{\n\treturn ((uint)sizeof(xfs_attr_leaf_name_local_t) - 1 + (nlen) + (vlen) +\n\t\tXFS_ATTR_LEAF_NAME_ALIGN - 1) & ~(XFS_ATTR_LEAF_NAME_ALIGN - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_size",
          "args": [
            "leaf"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "769-775",
          "snippet": "static inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr->firstused >= ichdr->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf)"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args->index))"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf",
            "xfs_attr3_leaf_name(leaf, args->index)",
            "xfs_attr_leaf_entsize(leaf, args->index)"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name",
          "args": [
            "leaf",
            "args->index"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "802-806",
          "snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_rmt_blocks",
          "args": [
            "mp",
            "args->valuelen"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_rmt_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "50-60",
          "snippet": "int\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)name_rmt->name",
            "args->name",
            "args->namelen"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name_remote",
          "args": [
            "leaf",
            "args->index"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "796-800",
          "snippet": "static inline xfs_attr_leaf_name_remote_t *\nxfs_attr3_leaf_name_remote(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_remote_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_remote_t *\nxfs_attr3_leaf_name_remote(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_remote_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)&name_loc->nameval[args->namelen]",
            "args->value",
            "be16_to_cpu(name_loc->valuelen)"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "name_loc->valuelen"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)name_loc->nameval",
            "args->name",
            "args->namelen"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "args->valuelen"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(args->index == ichdr->count - 1) ||\n\t       (be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval))"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "(entry+1)->hashval"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(args->index == 0) ||\n\t       (be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval))"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "(entry-1)->hashval"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry))"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf",
            "entry",
            "sizeof(*entry)"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_NSP_ARGS_TO_ONDISK",
          "args": [
            "args->flags"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "args->hashval"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "ichdr->freemap[mapindex].base +\n\t\t\t\t     ichdr->freemap[mapindex].size"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_newentsize",
          "args": [
            "args",
            "&tmp"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(ichdr->freemap[mapindex].size & 0x3) == 0"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr->freemap[mapindex].size < args->geo->blksize"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr->freemap[mapindex].size >=\n\t\txfs_attr_leaf_newentsize(args, NULL)"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_newentsize",
          "args": [
            "args",
            "NULL"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(ichdr->freemap[mapindex].base & 0x3) == 0"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ichdr->freemap[mapindex].base < args->geo->blksize"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry))"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf",
            "entry",
            "tmp + sizeof(*entry)"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "entry + 1",
            "entry",
            "tmp"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->index >= 0 && args->index <= ichdr->count"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_add_work",
          "args": [
            "args"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nSTATIC int\nxfs_attr3_leaf_add_work(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_attr3_icleaf_hdr *ichdr,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tmapindex)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add_work(args);\n\n\tleaf = bp->b_addr;\n\tASSERT(mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE);\n\tASSERT(args->index >= 0 && args->index <= ichdr->count);\n\n\t/*\n\t * Force open some space in the entry array and fill it in.\n\t */\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (args->index < ichdr->count) {\n\t\ttmp  = ichdr->count - args->index;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tmemmove(entry + 1, entry, tmp);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\n\t}\n\tichdr->count++;\n\n\t/*\n\t * Allocate space for the new string (at the end of the run).\n\t */\n\tmp = args->trans->t_mountp;\n\tASSERT(ichdr->freemap[mapindex].base < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].base & 0x3) == 0);\n\tASSERT(ichdr->freemap[mapindex].size >=\n\t\txfs_attr_leaf_newentsize(args, NULL));\n\tASSERT(ichdr->freemap[mapindex].size < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);\n\n\tichdr->freemap[mapindex].size -= xfs_attr_leaf_newentsize(args, &tmp);\n\n\tentry->nameidx = cpu_to_be16(ichdr->freemap[mapindex].base +\n\t\t\t\t     ichdr->freemap[mapindex].size);\n\tentry->hashval = cpu_to_be32(args->hashval);\n\tentry->flags = tmp ? XFS_ATTR_LOCAL : 0;\n\tentry->flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\tif ((args->blkno2 == args->blkno) &&\n\t\t    (args->index2 <= args->index)) {\n\t\t\targs->index2++;\n\t\t}\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tASSERT((args->index == 0) ||\n\t       (be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval)));\n\tASSERT((args->index == ichdr->count - 1) ||\n\t       (be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval)));\n\n\t/*\n\t * For \"remote\" attribute values, simply note that we need to\n\t * allocate space for the \"remote\" value.  We can't actually\n\t * allocate the extents in this transaction, and we can't decide\n\t * which blocks they should be as we might allocate more blocks\n\t * as part of this transaction (a split operation for example).\n\t */\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tname_loc->namelen = args->namelen;\n\t\tname_loc->valuelen = cpu_to_be16(args->valuelen);\n\t\tmemcpy((char *)name_loc->nameval, args->name, args->namelen);\n\t\tmemcpy((char *)&name_loc->nameval[args->namelen], args->value,\n\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->namelen = args->namelen;\n\t\tmemcpy((char *)name_rmt->name, args->name, args->namelen);\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\t/* just in case */\n\t\tname_rmt->valuelen = 0;\n\t\tname_rmt->valueblk = 0;\n\t\targs->rmtblkno = 1;\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\targs->rmtvaluelen = args->valuelen;\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args->index)));\n\n\t/*\n\t * Update the control info for this leaf node\n\t */\n\tif (be16_to_cpu(entry->nameidx) < ichdr->firstused)\n\t\tichdr->firstused = be16_to_cpu(entry->nameidx);\n\n\tASSERT(ichdr->firstused >= ichdr->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf));\n\ttmp = (ichdr->count - 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr->freemap[i].base == tmp) {\n\t\t\tichdr->freemap[i].base += sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr->freemap[i].size -= sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\t}\n\tichdr->usedbytes += xfs_attr_leaf_entsize(leaf, args->index);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "1060-1134",
    "snippet": "int\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t/*\n\t * Search through freemap for first-fit on new name length.\n\t * (may need to figure in size of entry struct too)\n\t */\n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t/* no space in this map */\n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t/*\n\t * If there are no holes in the address space of the block,\n\t * and we don't have enough freespace, then compaction will do us\n\t * no good and we should just give up.\n\t */\n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * Compact the entries to coalesce free space.\n\t * This may change the hdr->count via dropping INCOMPLETE entries.\n\t */\n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t/*\n\t * After compaction, the block is guaranteed to have only one\n\t * free region, in freemap[0].  If it is not big enough, give up.\n\t */\n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf))"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "leaf",
            "&leaf->hdr",
            "xfs_attr3_leaf_hdr_size(leaf)"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_size",
          "args": [
            "leaf"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "769-775",
          "snippet": "static inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline int\nxfs_attr3_leaf_hdr_size(struct xfs_attr_leafblock *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn sizeof(struct xfs_attr3_leaf_hdr);\n\treturn sizeof(struct xfs_attr_leaf_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_to_disk",
          "args": [
            "leaf",
            "&ichdr"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "130-171",
          "snippet": "void\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_add_work",
          "args": [
            "bp",
            "&ichdr",
            "args",
            "0"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_add_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1139-1254",
          "snippet": "STATIC int\nxfs_attr3_leaf_add_work(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_attr3_icleaf_hdr *ichdr,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tmapindex)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add_work(args);\n\n\tleaf = bp->b_addr;\n\tASSERT(mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE);\n\tASSERT(args->index >= 0 && args->index <= ichdr->count);\n\n\t/*\n\t * Force open some space in the entry array and fill it in.\n\t */\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (args->index < ichdr->count) {\n\t\ttmp  = ichdr->count - args->index;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tmemmove(entry + 1, entry, tmp);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\n\t}\n\tichdr->count++;\n\n\t/*\n\t * Allocate space for the new string (at the end of the run).\n\t */\n\tmp = args->trans->t_mountp;\n\tASSERT(ichdr->freemap[mapindex].base < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].base & 0x3) == 0);\n\tASSERT(ichdr->freemap[mapindex].size >=\n\t\txfs_attr_leaf_newentsize(args, NULL));\n\tASSERT(ichdr->freemap[mapindex].size < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);\n\n\tichdr->freemap[mapindex].size -= xfs_attr_leaf_newentsize(args, &tmp);\n\n\tentry->nameidx = cpu_to_be16(ichdr->freemap[mapindex].base +\n\t\t\t\t     ichdr->freemap[mapindex].size);\n\tentry->hashval = cpu_to_be32(args->hashval);\n\tentry->flags = tmp ? XFS_ATTR_LOCAL : 0;\n\tentry->flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\tif ((args->blkno2 == args->blkno) &&\n\t\t    (args->index2 <= args->index)) {\n\t\t\targs->index2++;\n\t\t}\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tASSERT((args->index == 0) ||\n\t       (be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval)));\n\tASSERT((args->index == ichdr->count - 1) ||\n\t       (be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval)));\n\n\t/*\n\t * For \"remote\" attribute values, simply note that we need to\n\t * allocate space for the \"remote\" value.  We can't actually\n\t * allocate the extents in this transaction, and we can't decide\n\t * which blocks they should be as we might allocate more blocks\n\t * as part of this transaction (a split operation for example).\n\t */\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tname_loc->namelen = args->namelen;\n\t\tname_loc->valuelen = cpu_to_be16(args->valuelen);\n\t\tmemcpy((char *)name_loc->nameval, args->name, args->namelen);\n\t\tmemcpy((char *)&name_loc->nameval[args->namelen], args->value,\n\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->namelen = args->namelen;\n\t\tmemcpy((char *)name_rmt->name, args->name, args->namelen);\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\t/* just in case */\n\t\tname_rmt->valuelen = 0;\n\t\tname_rmt->valueblk = 0;\n\t\targs->rmtblkno = 1;\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\targs->rmtvaluelen = args->valuelen;\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args->index)));\n\n\t/*\n\t * Update the control info for this leaf node\n\t */\n\tif (be16_to_cpu(entry->nameidx) < ichdr->firstused)\n\t\tichdr->firstused = be16_to_cpu(entry->nameidx);\n\n\tASSERT(ichdr->firstused >= ichdr->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf));\n\ttmp = (ichdr->count - 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr->freemap[i].base == tmp) {\n\t\t\tichdr->freemap[i].base += sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr->freemap[i].size -= sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\t}\n\tichdr->usedbytes += xfs_attr_leaf_entsize(leaf, args->index);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nSTATIC int\nxfs_attr3_leaf_add_work(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_attr3_icleaf_hdr *ichdr,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tmapindex)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add_work(args);\n\n\tleaf = bp->b_addr;\n\tASSERT(mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE);\n\tASSERT(args->index >= 0 && args->index <= ichdr->count);\n\n\t/*\n\t * Force open some space in the entry array and fill it in.\n\t */\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (args->index < ichdr->count) {\n\t\ttmp  = ichdr->count - args->index;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tmemmove(entry + 1, entry, tmp);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\n\t}\n\tichdr->count++;\n\n\t/*\n\t * Allocate space for the new string (at the end of the run).\n\t */\n\tmp = args->trans->t_mountp;\n\tASSERT(ichdr->freemap[mapindex].base < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].base & 0x3) == 0);\n\tASSERT(ichdr->freemap[mapindex].size >=\n\t\txfs_attr_leaf_newentsize(args, NULL));\n\tASSERT(ichdr->freemap[mapindex].size < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);\n\n\tichdr->freemap[mapindex].size -= xfs_attr_leaf_newentsize(args, &tmp);\n\n\tentry->nameidx = cpu_to_be16(ichdr->freemap[mapindex].base +\n\t\t\t\t     ichdr->freemap[mapindex].size);\n\tentry->hashval = cpu_to_be32(args->hashval);\n\tentry->flags = tmp ? XFS_ATTR_LOCAL : 0;\n\tentry->flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\tif ((args->blkno2 == args->blkno) &&\n\t\t    (args->index2 <= args->index)) {\n\t\t\targs->index2++;\n\t\t}\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tASSERT((args->index == 0) ||\n\t       (be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval)));\n\tASSERT((args->index == ichdr->count - 1) ||\n\t       (be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval)));\n\n\t/*\n\t * For \"remote\" attribute values, simply note that we need to\n\t * allocate space for the \"remote\" value.  We can't actually\n\t * allocate the extents in this transaction, and we can't decide\n\t * which blocks they should be as we might allocate more blocks\n\t * as part of this transaction (a split operation for example).\n\t */\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tname_loc->namelen = args->namelen;\n\t\tname_loc->valuelen = cpu_to_be16(args->valuelen);\n\t\tmemcpy((char *)name_loc->nameval, args->name, args->namelen);\n\t\tmemcpy((char *)&name_loc->nameval[args->namelen], args->value,\n\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->namelen = args->namelen;\n\t\tmemcpy((char *)name_rmt->name, args->name, args->namelen);\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\t/* just in case */\n\t\tname_rmt->valuelen = 0;\n\t\tname_rmt->valueblk = 0;\n\t\targs->rmtblkno = 1;\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\targs->rmtvaluelen = args->valuelen;\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args->index)));\n\n\t/*\n\t * Update the control info for this leaf node\n\t */\n\tif (be16_to_cpu(entry->nameidx) < ichdr->firstused)\n\t\tichdr->firstused = be16_to_cpu(entry->nameidx);\n\n\tASSERT(ichdr->firstused >= ichdr->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf));\n\ttmp = (ichdr->count - 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr->freemap[i].base == tmp) {\n\t\t\tichdr->freemap[i].base += sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr->freemap[i].size -= sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\t}\n\tichdr->usedbytes += xfs_attr_leaf_entsize(leaf, args->index);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_compact",
          "args": [
            "args",
            "&ichdr",
            "bp"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_compact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1259-1312",
          "snippet": "STATIC void\nxfs_attr3_leaf_compact(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_attr3_icleaf_hdr *ichdr_dst,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf_src;\n\tstruct xfs_attr_leafblock *leaf_dst;\n\tstruct xfs_attr3_icleaf_hdr ichdr_src;\n\tstruct xfs_trans\t*trans = args->trans;\n\tchar\t\t\t*tmpbuffer;\n\n\ttrace_xfs_attr_leaf_compact(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\tleaf_src = (xfs_attr_leafblock_t *)tmpbuffer;\n\tleaf_dst = bp->b_addr;\n\n\t/*\n\t * Copy the on-disk header back into the destination buffer to ensure\n\t * all the information in the header that is not part of the incore\n\t * header structure is preserved.\n\t */\n\tmemcpy(bp->b_addr, tmpbuffer, xfs_attr3_leaf_hdr_size(leaf_src));\n\n\t/* Initialise the incore headers */\n\tichdr_src = *ichdr_dst;\t/* struct copy */\n\tichdr_dst->firstused = args->geo->blksize;\n\tichdr_dst->usedbytes = 0;\n\tichdr_dst->count = 0;\n\tichdr_dst->holes = 0;\n\tichdr_dst->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_src);\n\tichdr_dst->freemap[0].size = ichdr_dst->firstused -\n\t\t\t\t\t\tichdr_dst->freemap[0].base;\n\n\t/* write the header back to initialise the underlying buffer */\n\txfs_attr3_leaf_hdr_to_disk(leaf_dst, ichdr_dst);\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate name/value pairs packed and in sequence.\n\t */\n\txfs_attr3_leaf_moveents(args, leaf_src, &ichdr_src, 0,\n\t\t\t\tleaf_dst, ichdr_dst, 0, ichdr_src.count);\n\t/*\n\t * this logs the entire buffer, but the caller must write the header\n\t * back to the buffer when it is finished modifying it.\n\t */\n\txfs_trans_log_buf(trans, bp, 0, args->geo->blksize - 1);\n\n\tkmem_free(tmpbuffer);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_attr3_leaf_compact(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_attr3_icleaf_hdr *ichdr_dst,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf_src;\n\tstruct xfs_attr_leafblock *leaf_dst;\n\tstruct xfs_attr3_icleaf_hdr ichdr_src;\n\tstruct xfs_trans\t*trans = args->trans;\n\tchar\t\t\t*tmpbuffer;\n\n\ttrace_xfs_attr_leaf_compact(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\tleaf_src = (xfs_attr_leafblock_t *)tmpbuffer;\n\tleaf_dst = bp->b_addr;\n\n\t/*\n\t * Copy the on-disk header back into the destination buffer to ensure\n\t * all the information in the header that is not part of the incore\n\t * header structure is preserved.\n\t */\n\tmemcpy(bp->b_addr, tmpbuffer, xfs_attr3_leaf_hdr_size(leaf_src));\n\n\t/* Initialise the incore headers */\n\tichdr_src = *ichdr_dst;\t/* struct copy */\n\tichdr_dst->firstused = args->geo->blksize;\n\tichdr_dst->usedbytes = 0;\n\tichdr_dst->count = 0;\n\tichdr_dst->holes = 0;\n\tichdr_dst->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_src);\n\tichdr_dst->freemap[0].size = ichdr_dst->firstused -\n\t\t\t\t\t\tichdr_dst->freemap[0].base;\n\n\t/* write the header back to initialise the underlying buffer */\n\txfs_attr3_leaf_hdr_to_disk(leaf_dst, ichdr_dst);\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate name/value pairs packed and in sequence.\n\t */\n\txfs_attr3_leaf_moveents(args, leaf_src, &ichdr_src, 0,\n\t\t\t\tleaf_dst, ichdr_dst, 0, ichdr_src.count);\n\t/*\n\t * this logs the entire buffer, but the caller must write the header\n\t * back to the buffer when it is finished modifying it.\n\t */\n\txfs_trans_log_buf(trans, bp, 0, args->geo->blksize - 1);\n\n\tkmem_free(tmpbuffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_newentsize",
          "args": [
            "args",
            "NULL"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->index >= 0 && args->index <= ichdr.count"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&ichdr",
            "leaf"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_add",
          "args": [
            "args"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t/*\n\t * Search through freemap for first-fit on new name length.\n\t * (may need to figure in size of entry struct too)\n\t */\n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t/* no space in this map */\n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t/*\n\t * If there are no holes in the address space of the block,\n\t * and we don't have enough freespace, then compaction will do us\n\t * no good and we should just give up.\n\t */\n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * Compact the entries to coalesce free space.\n\t * This may change the hdr->count via dropping INCOMPLETE entries.\n\t */\n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t/*\n\t * After compaction, the block is guaranteed to have only one\n\t * free region, in freemap[0].  If it is not big enough, give up.\n\t */\n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "1001-1055",
    "snippet": "int\nxfs_attr3_leaf_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk)\n{\n\txfs_dablk_t blkno;\n\tint error;\n\n\ttrace_xfs_attr_leaf_split(state->args);\n\n\t/*\n\t * Allocate space for a new leaf node.\n\t */\n\tASSERT(oldblk->magic == XFS_ATTR_LEAF_MAGIC);\n\terror = xfs_da_grow_inode(state->args, &blkno);\n\tif (error)\n\t\treturn error;\n\terror = xfs_attr3_leaf_create(state->args, blkno, &newblk->bp);\n\tif (error)\n\t\treturn error;\n\tnewblk->blkno = blkno;\n\tnewblk->magic = XFS_ATTR_LEAF_MAGIC;\n\n\t/*\n\t * Rebalance the entries across the two leaves.\n\t * NOTE: rebalance() currently depends on the 2nd block being empty.\n\t */\n\txfs_attr3_leaf_rebalance(state, oldblk, newblk);\n\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Save info on \"old\" attribute for \"atomic rename\" ops, leaf_add()\n\t * modifies the index/blkno/rmtblk/rmtblkcnt fields to show the\n\t * \"new\" attrs info.  Will need the \"old\" info to remove it later.\n\t *\n\t * Insert the \"new\" entry in the correct block.\n\t */\n\tif (state->inleaf) {\n\t\ttrace_xfs_attr_leaf_add_old(state->args);\n\t\terror = xfs_attr3_leaf_add(oldblk->bp, state->args);\n\t} else {\n\t\ttrace_xfs_attr_leaf_add_new(state->args);\n\t\terror = xfs_attr3_leaf_add(newblk->bp, state->args);\n\t}\n\n\t/*\n\t * Update last hashval in each block since we added the name.\n\t */\n\toldblk->hashval = xfs_attr_leaf_lasthash(oldblk->bp, NULL);\n\tnewblk->hashval = xfs_attr_leaf_lasthash(newblk->bp, NULL);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_leaf_lasthash",
          "args": [
            "newblk->bp",
            "NULL"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_lasthash",
          "args": [
            "oldblk->bp",
            "NULL"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_add",
          "args": [
            "newblk->bp",
            "state->args"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1060-1134",
          "snippet": "int\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t/*\n\t * Search through freemap for first-fit on new name length.\n\t * (may need to figure in size of entry struct too)\n\t */\n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t/* no space in this map */\n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t/*\n\t * If there are no holes in the address space of the block,\n\t * and we don't have enough freespace, then compaction will do us\n\t * no good and we should just give up.\n\t */\n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * Compact the entries to coalesce free space.\n\t * This may change the hdr->count via dropping INCOMPLETE entries.\n\t */\n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t/*\n\t * After compaction, the block is guaranteed to have only one\n\t * free region, in freemap[0].  If it is not big enough, give up.\n\t */\n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t/*\n\t * Search through freemap for first-fit on new name length.\n\t * (may need to figure in size of entry struct too)\n\t */\n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t/* no space in this map */\n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t/*\n\t * If there are no holes in the address space of the block,\n\t * and we don't have enough freespace, then compaction will do us\n\t * no good and we should just give up.\n\t */\n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * Compact the entries to coalesce free space.\n\t * This may change the hdr->count via dropping INCOMPLETE entries.\n\t */\n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t/*\n\t * After compaction, the block is guaranteed to have only one\n\t * free region, in freemap[0].  If it is not big enough, give up.\n\t */\n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_add_new",
          "args": [
            "state->args"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_add_old",
          "args": [
            "state->args"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_blk_link",
          "args": [
            "state",
            "oldblk",
            "newblk"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_blk_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1638-1726",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_blk_link(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*old_blk,\n\tstruct xfs_da_state_blk\t*new_blk)\n{\n\tstruct xfs_da_blkinfo\t*old_info;\n\tstruct xfs_da_blkinfo\t*new_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tbefore = 0;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t/*\n\t * Set up environment.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\told_info = old_blk->bp->b_addr;\n\tnew_info = new_blk->bp->b_addr;\n\tASSERT(old_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       old_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       old_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\tswitch (old_blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tbefore = xfs_attr_leaf_order(old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tbefore = xfs_dir2_leafn_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tbefore = xfs_da3_node_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Link blocks in appropriate order.\n\t */\n\tif (before) {\n\t\t/*\n\t\t * Link new block in before existing block.\n\t\t */\n\t\ttrace_xfs_da_link_before(args);\n\t\tnew_info->forw = cpu_to_be32(old_blk->blkno);\n\t\tnew_info->back = old_info->back;\n\t\tif (old_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->back),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == old_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->back = cpu_to_be32(new_blk->blkno);\n\t} else {\n\t\t/*\n\t\t * Link new block in after existing block.\n\t\t */\n\t\ttrace_xfs_da_link_after(args);\n\t\tnew_info->forw = old_info->forw;\n\t\tnew_info->back = cpu_to_be32(old_blk->blkno);\n\t\tif (old_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->forw),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == old_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->forw = cpu_to_be32(new_blk->blkno);\n\t}\n\n\txfs_trans_log_buf(args->trans, old_blk->bp, 0, sizeof(*tmp_info) - 1);\n\txfs_trans_log_buf(args->trans, new_blk->bp, 0, sizeof(*tmp_info) - 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_blk_link(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*old_blk,\n\tstruct xfs_da_state_blk\t*new_blk)\n{\n\tstruct xfs_da_blkinfo\t*old_info;\n\tstruct xfs_da_blkinfo\t*new_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tbefore = 0;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t/*\n\t * Set up environment.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\told_info = old_blk->bp->b_addr;\n\tnew_info = new_blk->bp->b_addr;\n\tASSERT(old_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       old_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       old_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\tswitch (old_blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tbefore = xfs_attr_leaf_order(old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tbefore = xfs_dir2_leafn_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tbefore = xfs_da3_node_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Link blocks in appropriate order.\n\t */\n\tif (before) {\n\t\t/*\n\t\t * Link new block in before existing block.\n\t\t */\n\t\ttrace_xfs_da_link_before(args);\n\t\tnew_info->forw = cpu_to_be32(old_blk->blkno);\n\t\tnew_info->back = old_info->back;\n\t\tif (old_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->back),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == old_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->back = cpu_to_be32(new_blk->blkno);\n\t} else {\n\t\t/*\n\t\t * Link new block in after existing block.\n\t\t */\n\t\ttrace_xfs_da_link_after(args);\n\t\tnew_info->forw = old_info->forw;\n\t\tnew_info->back = cpu_to_be32(old_blk->blkno);\n\t\tif (old_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->forw),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == old_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->forw = cpu_to_be32(new_blk->blkno);\n\t}\n\n\txfs_trans_log_buf(args->trans, old_blk->bp, 0, sizeof(*tmp_info) - 1);\n\txfs_trans_log_buf(args->trans, new_blk->bp, 0, sizeof(*tmp_info) - 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_rebalance",
          "args": [
            "state",
            "oldblk",
            "newblk"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_rebalance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1365-1553",
          "snippet": "STATIC void\nxfs_attr3_leaf_rebalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\tint\t\t\tcount;\n\tint\t\t\ttotallen;\n\tint\t\t\tmax;\n\tint\t\t\tspace;\n\tint\t\t\tswap;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(blk1->magic == XFS_ATTR_LEAF_MAGIC);\n\tASSERT(blk2->magic == XFS_ATTR_LEAF_MAGIC);\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(ichdr2.count == 0);\n\targs = state->args;\n\n\ttrace_xfs_attr_leaf_rebalance(args);\n\n\t/*\n\t * Check ordering of blocks, reverse if it makes things simpler.\n\t *\n\t * NOTE: Given that all (current) callers pass in an empty\n\t * second block, this code should never set \"swap\".\n\t */\n\tswap = 0;\n\tif (xfs_attr3_leaf_order(blk1->bp, &ichdr1, blk2->bp, &ichdr2)) {\n\t\tstruct xfs_da_state_blk\t*tmp_blk;\n\t\tstruct xfs_attr3_icleaf_hdr tmp_ichdr;\n\n\t\ttmp_blk = blk1;\n\t\tblk1 = blk2;\n\t\tblk2 = tmp_blk;\n\n\t\t/* struct copies to swap them rather than reconverting */\n\t\ttmp_ichdr = ichdr1;\n\t\tichdr1 = ichdr2;\n\t\tichdr2 = tmp_ichdr;\n\n\t\tleaf1 = blk1->bp->b_addr;\n\t\tleaf2 = blk2->bp->b_addr;\n\t\tswap = 1;\n\t}\n\n\t/*\n\t * Examine entries until we reduce the absolute difference in\n\t * byte usage between the two blocks to a minimum.  Then get\n\t * the direction to copy and the number of elements to move.\n\t *\n\t * \"inleaf\" is true if the new entry should be inserted into blk1.\n\t * If \"swap\" is also true, then reverse the sense of \"inleaf\".\n\t */\n\tstate->inleaf = xfs_attr3_leaf_figure_balance(state, blk1, &ichdr1,\n\t\t\t\t\t\t      blk2, &ichdr2,\n\t\t\t\t\t\t      &count, &totallen);\n\tif (swap)\n\t\tstate->inleaf = !state->inleaf;\n\n\t/*\n\t * Move any entries required from leaf to leaf:\n\t */\n\tif (count < ichdr1.count) {\n\t\t/*\n\t\t * Figure the total bytes to be added to the destination leaf.\n\t\t */\n\t\t/* number entries being moved */\n\t\tcount = ichdr1.count - count;\n\t\tspace  = ichdr1.usedbytes - totallen;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t/*\n\t\t * leaf2 is the destination, compact it if it looks tight.\n\t\t */\n\t\tmax  = ichdr2.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr2.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr2, blk2->bp);\n\n\t\t/*\n\t\t * Move high entries from leaf1 to low end of leaf2.\n\t\t */\n\t\txfs_attr3_leaf_moveents(args, leaf1, &ichdr1,\n\t\t\t\tichdr1.count - count, leaf2, &ichdr2, 0, count);\n\n\t} else if (count > ichdr1.count) {\n\t\t/*\n\t\t * I assert that since all callers pass in an empty\n\t\t * second buffer, this code should never execute.\n\t\t */\n\t\tASSERT(0);\n\n\t\t/*\n\t\t * Figure the total bytes to be added to the destination leaf.\n\t\t */\n\t\t/* number entries being moved */\n\t\tcount -= ichdr1.count;\n\t\tspace  = totallen - ichdr1.usedbytes;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t/*\n\t\t * leaf1 is the destination, compact it if it looks tight.\n\t\t */\n\t\tmax  = ichdr1.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr1.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr1, blk1->bp);\n\n\t\t/*\n\t\t * Move low entries from leaf2 to high end of leaf1.\n\t\t */\n\t\txfs_attr3_leaf_moveents(args, leaf2, &ichdr2, 0, leaf1, &ichdr1,\n\t\t\t\t\tichdr1.count, count);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(leaf1, &ichdr1);\n\txfs_attr3_leaf_hdr_to_disk(leaf2, &ichdr2);\n\txfs_trans_log_buf(args->trans, blk1->bp, 0, args->geo->blksize - 1);\n\txfs_trans_log_buf(args->trans, blk2->bp, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Copy out last hashval in each block for B-tree code.\n\t */\n\tentries1 = xfs_attr3_leaf_entryp(leaf1);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2);\n\tblk1->hashval = be32_to_cpu(entries1[ichdr1.count - 1].hashval);\n\tblk2->hashval = be32_to_cpu(entries2[ichdr2.count - 1].hashval);\n\n\t/*\n\t * Adjust the expected index for insertion.\n\t * NOTE: this code depends on the (current) situation that the\n\t * second block was originally empty.\n\t *\n\t * If the insertion point moved to the 2nd block, we must adjust\n\t * the index.  We must also track the entry just following the\n\t * new entry for use in an \"atomic rename\" operation, that entry\n\t * is always the \"old\" entry and the \"new\" entry is what we are\n\t * inserting.  The index/blkno fields refer to the \"old\" entry,\n\t * while the index2/blkno2 fields refer to the \"new\" entry.\n\t */\n\tif (blk1->index > ichdr1.count) {\n\t\tASSERT(state->inleaf == 0);\n\t\tblk2->index = blk1->index - ichdr1.count;\n\t\targs->index = args->index2 = blk2->index;\n\t\targs->blkno = args->blkno2 = blk2->blkno;\n\t} else if (blk1->index == ichdr1.count) {\n\t\tif (state->inleaf) {\n\t\t\targs->index = blk1->index;\n\t\t\targs->blkno = blk1->blkno;\n\t\t\targs->index2 = 0;\n\t\t\targs->blkno2 = blk2->blkno;\n\t\t} else {\n\t\t\t/*\n\t\t\t * On a double leaf split, the original attr location\n\t\t\t * is already stored in blkno2/index2, so don't\n\t\t\t * overwrite it overwise we corrupt the tree.\n\t\t\t */\n\t\t\tblk2->index = blk1->index - ichdr1.count;\n\t\t\targs->index = blk2->index;\n\t\t\targs->blkno = blk2->blkno;\n\t\t\tif (!state->extravalid) {\n\t\t\t\t/*\n\t\t\t\t * set the new attr location to match the old\n\t\t\t\t * one and let the higher level split code\n\t\t\t\t * decide where in the leaf to place it.\n\t\t\t\t */\n\t\t\t\targs->index2 = blk2->index;\n\t\t\t\targs->blkno2 = blk2->blkno;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tASSERT(state->inleaf == 1);\n\t\targs->index = args->index2 = blk1->index;\n\t\targs->blkno = args->blkno2 = blk1->blkno;\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void xfs_attr3_leaf_rebalance(xfs_da_state_t *state,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk1,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk2);",
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_attr3_leaf_rebalance(xfs_da_state_t *state,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk1,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk2);\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nSTATIC void\nxfs_attr3_leaf_rebalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\tint\t\t\tcount;\n\tint\t\t\ttotallen;\n\tint\t\t\tmax;\n\tint\t\t\tspace;\n\tint\t\t\tswap;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(blk1->magic == XFS_ATTR_LEAF_MAGIC);\n\tASSERT(blk2->magic == XFS_ATTR_LEAF_MAGIC);\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(ichdr2.count == 0);\n\targs = state->args;\n\n\ttrace_xfs_attr_leaf_rebalance(args);\n\n\t/*\n\t * Check ordering of blocks, reverse if it makes things simpler.\n\t *\n\t * NOTE: Given that all (current) callers pass in an empty\n\t * second block, this code should never set \"swap\".\n\t */\n\tswap = 0;\n\tif (xfs_attr3_leaf_order(blk1->bp, &ichdr1, blk2->bp, &ichdr2)) {\n\t\tstruct xfs_da_state_blk\t*tmp_blk;\n\t\tstruct xfs_attr3_icleaf_hdr tmp_ichdr;\n\n\t\ttmp_blk = blk1;\n\t\tblk1 = blk2;\n\t\tblk2 = tmp_blk;\n\n\t\t/* struct copies to swap them rather than reconverting */\n\t\ttmp_ichdr = ichdr1;\n\t\tichdr1 = ichdr2;\n\t\tichdr2 = tmp_ichdr;\n\n\t\tleaf1 = blk1->bp->b_addr;\n\t\tleaf2 = blk2->bp->b_addr;\n\t\tswap = 1;\n\t}\n\n\t/*\n\t * Examine entries until we reduce the absolute difference in\n\t * byte usage between the two blocks to a minimum.  Then get\n\t * the direction to copy and the number of elements to move.\n\t *\n\t * \"inleaf\" is true if the new entry should be inserted into blk1.\n\t * If \"swap\" is also true, then reverse the sense of \"inleaf\".\n\t */\n\tstate->inleaf = xfs_attr3_leaf_figure_balance(state, blk1, &ichdr1,\n\t\t\t\t\t\t      blk2, &ichdr2,\n\t\t\t\t\t\t      &count, &totallen);\n\tif (swap)\n\t\tstate->inleaf = !state->inleaf;\n\n\t/*\n\t * Move any entries required from leaf to leaf:\n\t */\n\tif (count < ichdr1.count) {\n\t\t/*\n\t\t * Figure the total bytes to be added to the destination leaf.\n\t\t */\n\t\t/* number entries being moved */\n\t\tcount = ichdr1.count - count;\n\t\tspace  = ichdr1.usedbytes - totallen;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t/*\n\t\t * leaf2 is the destination, compact it if it looks tight.\n\t\t */\n\t\tmax  = ichdr2.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr2.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr2, blk2->bp);\n\n\t\t/*\n\t\t * Move high entries from leaf1 to low end of leaf2.\n\t\t */\n\t\txfs_attr3_leaf_moveents(args, leaf1, &ichdr1,\n\t\t\t\tichdr1.count - count, leaf2, &ichdr2, 0, count);\n\n\t} else if (count > ichdr1.count) {\n\t\t/*\n\t\t * I assert that since all callers pass in an empty\n\t\t * second buffer, this code should never execute.\n\t\t */\n\t\tASSERT(0);\n\n\t\t/*\n\t\t * Figure the total bytes to be added to the destination leaf.\n\t\t */\n\t\t/* number entries being moved */\n\t\tcount -= ichdr1.count;\n\t\tspace  = totallen - ichdr1.usedbytes;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t/*\n\t\t * leaf1 is the destination, compact it if it looks tight.\n\t\t */\n\t\tmax  = ichdr1.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr1.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr1, blk1->bp);\n\n\t\t/*\n\t\t * Move low entries from leaf2 to high end of leaf1.\n\t\t */\n\t\txfs_attr3_leaf_moveents(args, leaf2, &ichdr2, 0, leaf1, &ichdr1,\n\t\t\t\t\tichdr1.count, count);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(leaf1, &ichdr1);\n\txfs_attr3_leaf_hdr_to_disk(leaf2, &ichdr2);\n\txfs_trans_log_buf(args->trans, blk1->bp, 0, args->geo->blksize - 1);\n\txfs_trans_log_buf(args->trans, blk2->bp, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Copy out last hashval in each block for B-tree code.\n\t */\n\tentries1 = xfs_attr3_leaf_entryp(leaf1);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2);\n\tblk1->hashval = be32_to_cpu(entries1[ichdr1.count - 1].hashval);\n\tblk2->hashval = be32_to_cpu(entries2[ichdr2.count - 1].hashval);\n\n\t/*\n\t * Adjust the expected index for insertion.\n\t * NOTE: this code depends on the (current) situation that the\n\t * second block was originally empty.\n\t *\n\t * If the insertion point moved to the 2nd block, we must adjust\n\t * the index.  We must also track the entry just following the\n\t * new entry for use in an \"atomic rename\" operation, that entry\n\t * is always the \"old\" entry and the \"new\" entry is what we are\n\t * inserting.  The index/blkno fields refer to the \"old\" entry,\n\t * while the index2/blkno2 fields refer to the \"new\" entry.\n\t */\n\tif (blk1->index > ichdr1.count) {\n\t\tASSERT(state->inleaf == 0);\n\t\tblk2->index = blk1->index - ichdr1.count;\n\t\targs->index = args->index2 = blk2->index;\n\t\targs->blkno = args->blkno2 = blk2->blkno;\n\t} else if (blk1->index == ichdr1.count) {\n\t\tif (state->inleaf) {\n\t\t\targs->index = blk1->index;\n\t\t\targs->blkno = blk1->blkno;\n\t\t\targs->index2 = 0;\n\t\t\targs->blkno2 = blk2->blkno;\n\t\t} else {\n\t\t\t/*\n\t\t\t * On a double leaf split, the original attr location\n\t\t\t * is already stored in blkno2/index2, so don't\n\t\t\t * overwrite it overwise we corrupt the tree.\n\t\t\t */\n\t\t\tblk2->index = blk1->index - ichdr1.count;\n\t\t\targs->index = blk2->index;\n\t\t\targs->blkno = blk2->blkno;\n\t\t\tif (!state->extravalid) {\n\t\t\t\t/*\n\t\t\t\t * set the new attr location to match the old\n\t\t\t\t * one and let the higher level split code\n\t\t\t\t * decide where in the leaf to place it.\n\t\t\t\t */\n\t\t\t\targs->index2 = blk2->index;\n\t\t\t\targs->blkno2 = blk2->blkno;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tASSERT(state->inleaf == 1);\n\t\targs->index = args->index2 = blk1->index;\n\t\targs->blkno = args->blkno2 = blk1->blkno;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_create",
          "args": [
            "state->args",
            "blkno",
            "&newblk->bp"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "948-996",
          "snippet": "STATIC int\nxfs_attr3_leaf_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_create(args);\n\n\terror = xfs_da_get_buf(args->trans, args->dp, blkno, -1, &bp,\n\t\t\t\t\t    XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\txfs_trans_buf_set_type(args->trans, bp, XFS_BLFT_ATTR_LEAF_BUF);\n\tleaf = bp->b_addr;\n\tmemset(leaf, 0, args->geo->blksize);\n\n\tmemset(&ichdr, 0, sizeof(ichdr));\n\tichdr.firstused = args->geo->blksize;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_ATTR3_LEAF_MAGIC;\n\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr3_leaf_hdr);\n\t} else {\n\t\tichdr.magic = XFS_ATTR_LEAF_MAGIC;\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr_leaf_hdr);\n\t}\n\tichdr.freemap[0].size = ichdr.firstused - ichdr.freemap[0].base;\n\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp, 0, args->geo->blksize - 1);\n\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
            "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nSTATIC int\nxfs_attr3_leaf_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_create(args);\n\n\terror = xfs_da_get_buf(args->trans, args->dp, blkno, -1, &bp,\n\t\t\t\t\t    XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\txfs_trans_buf_set_type(args->trans, bp, XFS_BLFT_ATTR_LEAF_BUF);\n\tleaf = bp->b_addr;\n\tmemset(leaf, 0, args->geo->blksize);\n\n\tmemset(&ichdr, 0, sizeof(ichdr));\n\tichdr.firstused = args->geo->blksize;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_ATTR3_LEAF_MAGIC;\n\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr3_leaf_hdr);\n\t} else {\n\t\tichdr.magic = XFS_ATTR_LEAF_MAGIC;\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr_leaf_hdr);\n\t}\n\tichdr.freemap[0].size = ichdr.firstused - ichdr.freemap[0].base;\n\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp, 0, args->geo->blksize - 1);\n\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_grow_inode",
          "args": [
            "state->args",
            "&blkno"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2084-2099",
          "snippet": "int\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "oldblk->magic == XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_split",
          "args": [
            "state->args"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk)\n{\n\txfs_dablk_t blkno;\n\tint error;\n\n\ttrace_xfs_attr_leaf_split(state->args);\n\n\t/*\n\t * Allocate space for a new leaf node.\n\t */\n\tASSERT(oldblk->magic == XFS_ATTR_LEAF_MAGIC);\n\terror = xfs_da_grow_inode(state->args, &blkno);\n\tif (error)\n\t\treturn error;\n\terror = xfs_attr3_leaf_create(state->args, blkno, &newblk->bp);\n\tif (error)\n\t\treturn error;\n\tnewblk->blkno = blkno;\n\tnewblk->magic = XFS_ATTR_LEAF_MAGIC;\n\n\t/*\n\t * Rebalance the entries across the two leaves.\n\t * NOTE: rebalance() currently depends on the 2nd block being empty.\n\t */\n\txfs_attr3_leaf_rebalance(state, oldblk, newblk);\n\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Save info on \"old\" attribute for \"atomic rename\" ops, leaf_add()\n\t * modifies the index/blkno/rmtblk/rmtblkcnt fields to show the\n\t * \"new\" attrs info.  Will need the \"old\" info to remove it later.\n\t *\n\t * Insert the \"new\" entry in the correct block.\n\t */\n\tif (state->inleaf) {\n\t\ttrace_xfs_attr_leaf_add_old(state->args);\n\t\terror = xfs_attr3_leaf_add(oldblk->bp, state->args);\n\t} else {\n\t\ttrace_xfs_attr_leaf_add_new(state->args);\n\t\terror = xfs_attr3_leaf_add(newblk->bp, state->args);\n\t}\n\n\t/*\n\t * Update last hashval in each block since we added the name.\n\t */\n\toldblk->hashval = xfs_attr_leaf_lasthash(oldblk->bp, NULL);\n\tnewblk->hashval = xfs_attr_leaf_lasthash(newblk->bp, NULL);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "948-996",
    "snippet": "STATIC int\nxfs_attr3_leaf_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_create(args);\n\n\terror = xfs_da_get_buf(args->trans, args->dp, blkno, -1, &bp,\n\t\t\t\t\t    XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\txfs_trans_buf_set_type(args->trans, bp, XFS_BLFT_ATTR_LEAF_BUF);\n\tleaf = bp->b_addr;\n\tmemset(leaf, 0, args->geo->blksize);\n\n\tmemset(&ichdr, 0, sizeof(ichdr));\n\tichdr.firstused = args->geo->blksize;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_ATTR3_LEAF_MAGIC;\n\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr3_leaf_hdr);\n\t} else {\n\t\tichdr.magic = XFS_ATTR_LEAF_MAGIC;\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr_leaf_hdr);\n\t}\n\tichdr.freemap[0].size = ichdr.firstused - ichdr.freemap[0].base;\n\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp, 0, args->geo->blksize - 1);\n\n\t*bpp = bp;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
      "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "0",
            "args->geo->blksize - 1"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_to_disk",
          "args": [
            "leaf",
            "&ichdr"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "130-171",
          "snippet": "void\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&hdr3->uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "dp->i_ino"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp->b_bn"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ichdr",
            "0",
            "sizeof(ichdr)"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "leaf",
            "0",
            "args->geo->blksize"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "args->trans",
            "bp",
            "XFS_BLFT_ATTR_LEAF_BUF"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_get_buf",
          "args": [
            "args->trans",
            "args->dp",
            "blkno",
            "-1",
            "&bp",
            "XFS_ATTR_FORK"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2529-2572",
          "snippet": "int\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_create",
          "args": [
            "args"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nSTATIC int\nxfs_attr3_leaf_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_create(args);\n\n\terror = xfs_da_get_buf(args->trans, args->dp, blkno, -1, &bp,\n\t\t\t\t\t    XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\txfs_trans_buf_set_type(args->trans, bp, XFS_BLFT_ATTR_LEAF_BUF);\n\tleaf = bp->b_addr;\n\tmemset(leaf, 0, args->geo->blksize);\n\n\tmemset(&ichdr, 0, sizeof(ichdr));\n\tichdr.firstused = args->geo->blksize;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_ATTR3_LEAF_MAGIC;\n\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr3_leaf_hdr);\n\t} else {\n\t\tichdr.magic = XFS_ATTR_LEAF_MAGIC;\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr_leaf_hdr);\n\t}\n\tichdr.freemap[0].size = ichdr.firstused - ichdr.freemap[0].base;\n\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp, 0, args->geo->blksize - 1);\n\n\t*bpp = bp;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_to_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "875-938",
    "snippet": "int\nxfs_attr3_leaf_to_node(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr icleafhdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr icnodehdr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp1 = NULL;\n\tstruct xfs_buf\t\t*bp2 = NULL;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_to_node(args);\n\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\tgoto out;\n\terror = xfs_attr3_leaf_read(args->trans, dp, 0, -1, &bp1);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_da_get_buf(args->trans, dp, blkno, -1, &bp2, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\n\t/* copy leaf to new buffer, update identifiers */\n\txfs_trans_buf_set_type(args->trans, bp2, XFS_BLFT_ATTR_LEAF_BUF);\n\tbp2->b_ops = bp1->b_ops;\n\tmemcpy(bp2->b_addr, bp1->b_addr, args->geo->blksize);\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp2->b_addr;\n\t\thdr3->blkno = cpu_to_be64(bp2->b_bn);\n\t}\n\txfs_trans_log_buf(args->trans, bp2, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Set up the new root node.\n\t */\n\terror = xfs_da3_node_create(args, 0, 1, &bp1, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\tnode = bp1->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&icnodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\n\tleaf = bp2->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&icleafhdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\t/* both on-disk, don't endian-flip twice */\n\tbtree[0].hashval = entries[icleafhdr.count - 1].hashval;\n\tbtree[0].before = cpu_to_be32(blkno);\n\ticnodehdr.count = 1;\n\tdp->d_ops->node_hdr_to_disk(node, &icnodehdr);\n\txfs_trans_log_buf(args->trans, bp1, 0, args->geo->blksize - 1);\n\terror = 0;\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp1",
            "0",
            "args->geo->blksize - 1"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_to_disk",
          "args": [
            "node",
            "&icnodehdr"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "blkno"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&icleafhdr",
            "leaf"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&icnodehdr",
            "node"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_create",
          "args": [
            "args",
            "0",
            "1",
            "&bp1",
            "XFS_ATTR_FORK"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "295-339",
          "snippet": "int\nxfs_da3_node_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tlevel,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_da3_icnode_hdr ichdr = {0};\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\ttrace_xfs_da_node_create(args);\n\tASSERT(level <= XFS_DA_NODE_MAXDEPTH);\n\n\terror = xfs_da_get_buf(tp, dp, blkno, -1, &bp, whichfork);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_da3_node_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\tnode = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_DA3_NODE_MAGIC;\n\t\thdr3->info.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->info.owner = cpu_to_be64(args->dp->i_ino);\n\t\tuuid_copy(&hdr3->info.uuid, &mp->m_sb.sb_uuid);\n\t} else {\n\t\tichdr.magic = XFS_DA_NODE_MAGIC;\n\t}\n\tichdr.level = level;\n\n\tdp->d_ops->node_hdr_to_disk(node, &ichdr);\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tlevel,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_da3_icnode_hdr ichdr = {0};\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\ttrace_xfs_da_node_create(args);\n\tASSERT(level <= XFS_DA_NODE_MAXDEPTH);\n\n\terror = xfs_da_get_buf(tp, dp, blkno, -1, &bp, whichfork);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_da3_node_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\tnode = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_DA3_NODE_MAGIC;\n\t\thdr3->info.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->info.owner = cpu_to_be64(args->dp->i_ino);\n\t\tuuid_copy(&hdr3->info.uuid, &mp->m_sb.sb_uuid);\n\t} else {\n\t\tichdr.magic = XFS_DA_NODE_MAGIC;\n\t}\n\tichdr.level = level;\n\n\tdp->d_ops->node_hdr_to_disk(node, &ichdr);\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp2->b_bn"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bp2->b_addr",
            "bp1->b_addr",
            "args->geo->blksize"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "args->trans",
            "bp2",
            "XFS_BLFT_ATTR_LEAF_BUF"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_get_buf",
          "args": [
            "args->trans",
            "dp",
            "blkno",
            "-1",
            "&bp2",
            "XFS_ATTR_FORK"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2529-2572",
          "snippet": "int\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_read",
          "args": [
            "args->trans",
            "dp",
            "0",
            "-1",
            "&bp1"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "256-271",
          "snippet": "int\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
            "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_grow_inode",
          "args": [
            "args",
            "&blkno"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2084-2099",
          "snippet": "int\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_to_node",
          "args": [
            "args"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_leaf_to_node(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr icleafhdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr icnodehdr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp1 = NULL;\n\tstruct xfs_buf\t\t*bp2 = NULL;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_to_node(args);\n\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\tgoto out;\n\terror = xfs_attr3_leaf_read(args->trans, dp, 0, -1, &bp1);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_da_get_buf(args->trans, dp, blkno, -1, &bp2, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\n\t/* copy leaf to new buffer, update identifiers */\n\txfs_trans_buf_set_type(args->trans, bp2, XFS_BLFT_ATTR_LEAF_BUF);\n\tbp2->b_ops = bp1->b_ops;\n\tmemcpy(bp2->b_addr, bp1->b_addr, args->geo->blksize);\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp2->b_addr;\n\t\thdr3->blkno = cpu_to_be64(bp2->b_bn);\n\t}\n\txfs_trans_log_buf(args->trans, bp2, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Set up the new root node.\n\t */\n\terror = xfs_da3_node_create(args, 0, 1, &bp1, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\tnode = bp1->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&icnodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\n\tleaf = bp2->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&icleafhdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\t/* both on-disk, don't endian-flip twice */\n\tbtree[0].hashval = entries[icleafhdr.count - 1].hashval;\n\tbtree[0].before = cpu_to_be32(blkno);\n\ticnodehdr.count = 1;\n\tdp->d_ops->node_hdr_to_disk(node, &icnodehdr);\n\txfs_trans_log_buf(args->trans, bp1, 0, args->geo->blksize - 1);\n\terror = 0;\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_to_shortform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "790-870",
    "snippet": "int\nxfs_attr3_leaf_to_shortform(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tforkoff)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_da_args\tnargs;\n\tstruct xfs_inode\t*dp = args->dp;\n\tchar\t\t\t*tmpbuffer;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_to_sf(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tif (!tmpbuffer)\n\t\treturn -ENOMEM;\n\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\n\tleaf = (xfs_attr_leafblock_t *)tmpbuffer;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\t/* XXX (dgc): buffer is about to be marked stale - why zero it? */\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\n\t/*\n\t * Clean out the prior contents of the attribute list.\n\t */\n\terror = xfs_da_shrink_inode(args, 0, bp);\n\tif (error)\n\t\tgoto out;\n\n\tif (forkoff == -1) {\n\t\tASSERT(dp->i_mount->m_flags & XFS_MOUNT_ATTR2);\n\t\tASSERT(dp->i_d.di_format != XFS_DINODE_FMT_BTREE);\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t\tgoto out;\n\t}\n\n\txfs_attr_shortform_create(args);\n\n\t/*\n\t * Copy the attributes\n\t */\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.geo = args->geo;\n\tnargs.dp = dp;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t/* don't copy partial entries */\n\t\tif (!entry->nameidx)\n\t\t\tcontinue;\n\t\tASSERT(entry->flags & XFS_ATTR_LOCAL);\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tnargs.name = name_loc->nameval;\n\t\tnargs.namelen = name_loc->namelen;\n\t\tnargs.value = &name_loc->nameval[nargs.namelen];\n\t\tnargs.valuelen = be16_to_cpu(name_loc->valuelen);\n\t\tnargs.hashval = be32_to_cpu(entry->hashval);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(entry->flags);\n\t\txfs_attr_shortform_add(&nargs, forkoff);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "tmpbuffer"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_add",
          "args": [
            "&nargs",
            "forkoff"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "447-495",
          "snippet": "void\nxfs_attr_shortform_add(xfs_da_args_t *args, int forkoff)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i, offset, size;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_add(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tdp->i_d.di_forkoff = forkoff;\n\n\tifp = dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n#ifdef DEBUG\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tASSERT(0);\n#endif\n\t}\n\n\toffset = (char *)sfe - (char *)sf;\n\tsize = XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = (xfs_attr_sf_entry_t *)((char *)sf + offset);\n\n\tsfe->namelen = args->namelen;\n\tsfe->valuelen = args->valuelen;\n\tsfe->flags = XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tmemcpy(sfe->nameval, args->name, args->namelen);\n\tmemcpy(&sfe->nameval[args->namelen], args->value, args->valuelen);\n\tsf->hdr.count++;\n\tbe16_add_cpu(&sf->hdr.totsize, size);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr_shortform_add(xfs_da_args_t *args, int forkoff)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i, offset, size;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_add(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tdp->i_d.di_forkoff = forkoff;\n\n\tifp = dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n#ifdef DEBUG\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tASSERT(0);\n#endif\n\t}\n\n\toffset = (char *)sfe - (char *)sf;\n\tsize = XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = (xfs_attr_sf_entry_t *)((char *)sf + offset);\n\n\tsfe->namelen = args->namelen;\n\tsfe->valuelen = args->valuelen;\n\tsfe->flags = XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tmemcpy(sfe->nameval, args->name, args->namelen);\n\tmemcpy(&sfe->nameval[args->namelen], args->value, args->valuelen);\n\tsf->hdr.count++;\n\tbe16_add_cpu(&sf->hdr.totsize, size);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_NSP_ONDISK_TO_ARGS",
          "args": [
            "entry->flags"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "name_loc->valuelen"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name_local",
          "args": [
            "leaf",
            "i"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "802-806",
          "snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "entry->flags & XFS_ATTR_LOCAL"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&nargs",
            "0",
            "sizeof(nargs)"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_create",
          "args": [
            "args"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "415-441",
          "snippet": "void\nxfs_attr_shortform_create(xfs_da_args_t *args)\n{\n\txfs_attr_sf_hdr_t *hdr;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_create(args);\n\n\tdp = args->dp;\n\tASSERT(dp != NULL);\n\tifp = dp->i_afp;\n\tASSERT(ifp != NULL);\n\tASSERT(ifp->if_bytes == 0);\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS) {\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\t/* just in case */\n\t\tdp->i_d.di_aformat = XFS_DINODE_FMT_LOCAL;\n\t\tifp->if_flags |= XFS_IFINLINE;\n\t} else {\n\t\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t}\n\txfs_idata_realloc(dp, sizeof(*hdr), XFS_ATTR_FORK);\n\thdr = (xfs_attr_sf_hdr_t *)ifp->if_u1.if_data;\n\thdr->count = 0;\n\thdr->totsize = cpu_to_be16(sizeof(*hdr));\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr_shortform_create(xfs_da_args_t *args)\n{\n\txfs_attr_sf_hdr_t *hdr;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_create(args);\n\n\tdp = args->dp;\n\tASSERT(dp != NULL);\n\tifp = dp->i_afp;\n\tASSERT(ifp != NULL);\n\tASSERT(ifp->if_bytes == 0);\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS) {\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\t/* just in case */\n\t\tdp->i_d.di_aformat = XFS_DINODE_FMT_LOCAL;\n\t\tifp->if_flags |= XFS_IFINLINE;\n\t} else {\n\t\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t}\n\txfs_idata_realloc(dp, sizeof(*hdr), XFS_ATTR_FORK);\n\thdr = (xfs_attr_sf_hdr_t *)ifp->if_u1.if_data;\n\thdr->count = 0;\n\thdr->totsize = cpu_to_be16(sizeof(*hdr));\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_fork_reset",
          "args": [
            "dp",
            "args->trans"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_fork_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "501-514",
          "snippet": "STATIC void\nxfs_attr_fork_reset(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tip->i_d.di_forkoff = 0;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_afp == NULL);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_attr_fork_reset(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tip->i_d.di_forkoff = 0;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_afp == NULL);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_d.di_format != XFS_DINODE_FMT_BTREE"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_mount->m_flags & XFS_MOUNT_ATTR2"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da_shrink_inode",
          "args": [
            "args",
            "0",
            "bp"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2332-2369",
          "snippet": "int\nxfs_da_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dablk_t\tdead_blkno,\n\tstruct xfs_buf\t*dead_buf)\n{\n\txfs_inode_t *dp;\n\tint done, error, w, count;\n\txfs_trans_t *tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t/*\n\t\t * Remove extents.  If we get ENOSPC for a dir we have to move\n\t\t * the last block to the place we want to kill.\n\t\t */\n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t    0, args->firstblock, args->flist, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dablk_t\tdead_blkno,\n\tstruct xfs_buf\t*dead_buf)\n{\n\txfs_inode_t *dp;\n\tint done, error, w, count;\n\txfs_trans_t *tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t/*\n\t\t * Remove extents.  If we get ENOSPC for a dir we have to move\n\t\t * the last block to the place we want to kill.\n\t\t */\n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t    0, args->firstblock, args->flist, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp->b_addr",
            "0",
            "args->geo->blksize"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&ichdr",
            "leaf"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmpbuffer",
            "bp->b_addr",
            "args->geo->blksize"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "args->geo->blksize",
            "KM_SLEEP"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_to_sf",
          "args": [
            "args"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_leaf_to_shortform(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tforkoff)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_da_args\tnargs;\n\tstruct xfs_inode\t*dp = args->dp;\n\tchar\t\t\t*tmpbuffer;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_to_sf(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tif (!tmpbuffer)\n\t\treturn -ENOMEM;\n\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\n\tleaf = (xfs_attr_leafblock_t *)tmpbuffer;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\t/* XXX (dgc): buffer is about to be marked stale - why zero it? */\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\n\t/*\n\t * Clean out the prior contents of the attribute list.\n\t */\n\terror = xfs_da_shrink_inode(args, 0, bp);\n\tif (error)\n\t\tgoto out;\n\n\tif (forkoff == -1) {\n\t\tASSERT(dp->i_mount->m_flags & XFS_MOUNT_ATTR2);\n\t\tASSERT(dp->i_d.di_format != XFS_DINODE_FMT_BTREE);\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t\tgoto out;\n\t}\n\n\txfs_attr_shortform_create(args);\n\n\t/*\n\t * Copy the attributes\n\t */\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.geo = args->geo;\n\tnargs.dp = dp;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t/* don't copy partial entries */\n\t\tif (!entry->nameidx)\n\t\t\tcontinue;\n\t\tASSERT(entry->flags & XFS_ATTR_LOCAL);\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tnargs.name = name_loc->nameval;\n\t\tnargs.namelen = name_loc->namelen;\n\t\tnargs.value = &name_loc->nameval[nargs.namelen];\n\t\tnargs.valuelen = be16_to_cpu(name_loc->valuelen);\n\t\tnargs.hashval = be32_to_cpu(entry->hashval);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(entry->flags);\n\t\txfs_attr_shortform_add(&nargs, forkoff);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr_shortform_allfit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "749-785",
    "snippet": "int\nxfs_attr_shortform_allfit(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tint\t\t\tbytes;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\tbytes = sizeof(struct xfs_attr_sf_hdr);\n\tfor (i = 0; i < leafhdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* don't copy partial entries */\n\t\tif (!(entry->flags & XFS_ATTR_LOCAL))\n\t\t\treturn 0;\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tif (name_loc->namelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tif (be16_to_cpu(name_loc->valuelen) >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tbytes += sizeof(struct xfs_attr_sf_entry) - 1\n\t\t\t\t+ name_loc->namelen\n\t\t\t\t+ be16_to_cpu(name_loc->valuelen);\n\t}\n\tif ((dp->i_mount->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    (bytes == sizeof(struct xfs_attr_sf_hdr)))\n\t\treturn -1;\n\treturn xfs_attr_shortform_bytesfit(dp, bytes);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_shortform_bytesfit",
          "args": [
            "dp",
            "bytes"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_bytesfit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "302-392",
          "snippet": "int\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\n{\n\tint offset;\n\tint minforkoff;\t/* lower limit on valid forkoff locations */\n\tint maxforkoff;\t/* upper limit on valid forkoff locations */\n\tint dsize;\n\txfs_mount_t *mp = dp->i_mount;\n\n\t/* rounded down */\n\toffset = (XFS_LITINO(mp, dp->i_d.di_version) - bytes) >> 3;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tminforkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t/*\n\t * If the requested numbers of bytes is smaller or equal to the\n\t * current attribute fork size we can always proceed.\n\t *\n\t * Note that if_bytes in the data fork might actually be larger than\n\t * the current data fork size is due to delalloc extents. In that\n\t * case either the extent count will go down when they are converted\n\t * to real extents, or the delalloc conversion will take care of the\n\t * literal area rebalancing.\n\t */\n\tif (bytes <= XFS_IFORK_ASIZE(dp))\n\t\treturn dp->i_d.di_forkoff;\n\n\t/*\n\t * For attr2 we can try to move the forkoff if there is space in the\n\t * literal area, but for the old format we are done if there is no\n\t * space in the fixed attribute fork.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_ATTR2))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/*\n\t\t * If there is no attr fork and the data fork is extents, \n\t\t * determine if creating the default attr fork will result\n\t\t * in the extents form migrating to btree. If so, the\n\t\t * minimum offset only needs to be the space required for\n\t\t * the btree root.\n\t\t */\n\t\tif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t/*\n\t\t * If we have a data btree then keep forkoff if we have one,\n\t\t * otherwise we are adding a new attr, so then we set\n\t\t * minforkoff to where the btree root can finish so we have\n\t\t * plenty of room for attrs\n\t\t */\n\t\tif (dp->i_d.di_forkoff) {\n\t\t\tif (offset < dp->i_d.di_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_d.di_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A data fork btree root must have space for at least\n\t * MINDBTPTRS key/ptr pairs if the data fork is small or empty.\n\t */\n\tminforkoff = MAX(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t/* attr fork btree root can have at least this many key/ptr pairs */\n\tmaxforkoff = XFS_LITINO(mp, dp->i_d.di_version) -\n\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t/* rounded down */\n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\n{\n\tint offset;\n\tint minforkoff;\t/* lower limit on valid forkoff locations */\n\tint maxforkoff;\t/* upper limit on valid forkoff locations */\n\tint dsize;\n\txfs_mount_t *mp = dp->i_mount;\n\n\t/* rounded down */\n\toffset = (XFS_LITINO(mp, dp->i_d.di_version) - bytes) >> 3;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tminforkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t/*\n\t * If the requested numbers of bytes is smaller or equal to the\n\t * current attribute fork size we can always proceed.\n\t *\n\t * Note that if_bytes in the data fork might actually be larger than\n\t * the current data fork size is due to delalloc extents. In that\n\t * case either the extent count will go down when they are converted\n\t * to real extents, or the delalloc conversion will take care of the\n\t * literal area rebalancing.\n\t */\n\tif (bytes <= XFS_IFORK_ASIZE(dp))\n\t\treturn dp->i_d.di_forkoff;\n\n\t/*\n\t * For attr2 we can try to move the forkoff if there is space in the\n\t * literal area, but for the old format we are done if there is no\n\t * space in the fixed attribute fork.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_ATTR2))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/*\n\t\t * If there is no attr fork and the data fork is extents, \n\t\t * determine if creating the default attr fork will result\n\t\t * in the extents form migrating to btree. If so, the\n\t\t * minimum offset only needs to be the space required for\n\t\t * the btree root.\n\t\t */\n\t\tif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t/*\n\t\t * If we have a data btree then keep forkoff if we have one,\n\t\t * otherwise we are adding a new attr, so then we set\n\t\t * minforkoff to where the btree root can finish so we have\n\t\t * plenty of room for attrs\n\t\t */\n\t\tif (dp->i_d.di_forkoff) {\n\t\t\tif (offset < dp->i_d.di_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_d.di_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A data fork btree root must have space for at least\n\t * MINDBTPTRS key/ptr pairs if the data fork is small or empty.\n\t */\n\tminforkoff = MAX(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t/* attr fork btree root can have at least this many key/ptr pairs */\n\tmaxforkoff = XFS_LITINO(mp, dp->i_d.di_version) -\n\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t/* rounded down */\n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "name_loc->valuelen"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "name_loc->valuelen"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name_local",
          "args": [
            "leaf",
            "i"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "802-806",
          "snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_allfit(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tint\t\t\tbytes;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\tbytes = sizeof(struct xfs_attr_sf_hdr);\n\tfor (i = 0; i < leafhdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* don't copy partial entries */\n\t\tif (!(entry->flags & XFS_ATTR_LOCAL))\n\t\t\treturn 0;\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tif (name_loc->namelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tif (be16_to_cpu(name_loc->valuelen) >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tbytes += sizeof(struct xfs_attr_sf_entry) - 1\n\t\t\t\t+ name_loc->namelen\n\t\t\t\t+ be16_to_cpu(name_loc->valuelen);\n\t}\n\tif ((dp->i_mount->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    (bytes == sizeof(struct xfs_attr_sf_hdr)))\n\t\treturn -1;\n\treturn xfs_attr_shortform_bytesfit(dp, bytes);\n}"
  },
  {
    "function_name": "xfs_attr_shortform_to_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "658-743",
    "snippet": "int\nxfs_attr_shortform_to_leaf(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\terror = xfs_da_shrink_inode(args, 0, bp);\n\t\tbp = NULL;\n\t\tif (error)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "tmpbuffer"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_SF_NEXTENTRY",
          "args": [
            "sfe"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOSPC"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_add",
          "args": [
            "bp",
            "&nargs"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1060-1134",
          "snippet": "int\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t/*\n\t * Search through freemap for first-fit on new name length.\n\t * (may need to figure in size of entry struct too)\n\t */\n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t/* no space in this map */\n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t/*\n\t * If there are no holes in the address space of the block,\n\t * and we don't have enough freespace, then compaction will do us\n\t * no good and we should just give up.\n\t */\n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * Compact the entries to coalesce free space.\n\t * This may change the hdr->count via dropping INCOMPLETE entries.\n\t */\n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t/*\n\t * After compaction, the block is guaranteed to have only one\n\t * free region, in freemap[0].  If it is not big enough, give up.\n\t */\n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t/*\n\t * Search through freemap for first-fit on new name length.\n\t * (may need to figure in size of entry struct too)\n\t */\n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t/* no space in this map */\n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t/*\n\t * If there are no holes in the address space of the block,\n\t * and we don't have enough freespace, then compaction will do us\n\t * no good and we should just give up.\n\t */\n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * Compact the entries to coalesce free space.\n\t * This may change the hdr->count via dropping INCOMPLETE entries.\n\t */\n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t/*\n\t * After compaction, the block is guaranteed to have only one\n\t * free region, in freemap[0].  If it is not big enough, give up.\n\t */\n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error == -ENOATTR"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_lookup_int",
          "args": [
            "bp",
            "&nargs"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "2070-2174",
          "snippet": "int\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_NSP_ONDISK_TO_ARGS",
          "args": [
            "sfe->flags"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da_hashname",
          "args": [
            "sfe->nameval",
            "sfe->namelen"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_hashname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1944-1970",
          "snippet": "xfs_dahash_t\nxfs_da_hashname(const __uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t/*\n\t * Do four characters at a time as long as we can.\n\t */\n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t/*\n\t * Now do the rest of the characters.\n\t */\n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault: /* case 0: */\n\t\treturn hash;\n\t}\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dahash_t\nxfs_da_hashname(const __uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t/*\n\t * Do four characters at a time as long as we can.\n\t */\n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t/*\n\t * Now do the rest of the characters.\n\t */\n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault: /* case 0: */\n\t\treturn hash;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&nargs",
            "0",
            "sizeof(nargs)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ifp->if_u1.if_data",
            "tmpbuffer",
            "size"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "dp",
            "size",
            "XFS_ATTR_FORK"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_shrink_inode",
          "args": [
            "args",
            "0",
            "bp"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2332-2369",
          "snippet": "int\nxfs_da_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dablk_t\tdead_blkno,\n\tstruct xfs_buf\t*dead_buf)\n{\n\txfs_inode_t *dp;\n\tint done, error, w, count;\n\txfs_trans_t *tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t/*\n\t\t * Remove extents.  If we get ENOSPC for a dir we have to move\n\t\t * the last block to the place we want to kill.\n\t\t */\n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t    0, args->firstblock, args->flist, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dablk_t\tdead_blkno,\n\tstruct xfs_buf\t*dead_buf)\n{\n\txfs_inode_t *dp;\n\tint done, error, w, count;\n\txfs_trans_t *tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t/*\n\t\t * Remove extents.  If we get ENOSPC for a dir we have to move\n\t\t * the last block to the place we want to kill.\n\t\t */\n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t    0, args->firstblock, args->flist, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_create",
          "args": [
            "args",
            "blkno",
            "&bp"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "948-996",
          "snippet": "STATIC int\nxfs_attr3_leaf_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_create(args);\n\n\terror = xfs_da_get_buf(args->trans, args->dp, blkno, -1, &bp,\n\t\t\t\t\t    XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\txfs_trans_buf_set_type(args->trans, bp, XFS_BLFT_ATTR_LEAF_BUF);\n\tleaf = bp->b_addr;\n\tmemset(leaf, 0, args->geo->blksize);\n\n\tmemset(&ichdr, 0, sizeof(ichdr));\n\tichdr.firstused = args->geo->blksize;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_ATTR3_LEAF_MAGIC;\n\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr3_leaf_hdr);\n\t} else {\n\t\tichdr.magic = XFS_ATTR_LEAF_MAGIC;\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr_leaf_hdr);\n\t}\n\tichdr.freemap[0].size = ichdr.firstused - ichdr.freemap[0].base;\n\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp, 0, args->geo->blksize - 1);\n\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
            "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nSTATIC int\nxfs_attr3_leaf_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_create(args);\n\n\terror = xfs_da_get_buf(args->trans, args->dp, blkno, -1, &bp,\n\t\t\t\t\t    XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\txfs_trans_buf_set_type(args->trans, bp, XFS_BLFT_ATTR_LEAF_BUF);\n\tleaf = bp->b_addr;\n\tmemset(leaf, 0, args->geo->blksize);\n\n\tmemset(&ichdr, 0, sizeof(ichdr));\n\tichdr.firstused = args->geo->blksize;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_ATTR3_LEAF_MAGIC;\n\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr3_leaf_hdr);\n\t} else {\n\t\tichdr.magic = XFS_ATTR_LEAF_MAGIC;\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr_leaf_hdr);\n\t}\n\tichdr.freemap[0].size = ichdr.firstused - ichdr.freemap[0].base;\n\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp, 0, args->geo->blksize - 1);\n\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blkno == 0"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ifp->if_u1.if_data",
            "tmpbuffer",
            "size"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da_grow_inode",
          "args": [
            "args",
            "&blkno"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2084-2099",
          "snippet": "int\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_local_to_extents_empty",
          "args": [
            "dp",
            "XFS_ATTR_FORK"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_local_to_extents_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "893-908",
          "snippet": "void\nxfs_bmap_local_to_extents_empty(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tASSERT(ifp->if_bytes == 0);\n\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) == 0);\n\n\txfs_bmap_forkoff_reset(ip, whichfork);\n\tifp->if_flags &= ~XFS_IFINLINE;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_local_to_extents_empty(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tASSERT(ifp->if_bytes == 0);\n\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) == 0);\n\n\txfs_bmap_forkoff_reset(ip, whichfork);\n\tifp->if_flags &= ~XFS_IFINLINE;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmpbuffer",
            "ifp->if_u1.if_data",
            "size"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tmpbuffer != NULL"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "size",
            "KM_SLEEP"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "sf->hdr.totsize"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_sf_to_leaf",
          "args": [
            "args"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr_shortform_to_leaf(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\terror = xfs_da_shrink_inode(args, 0, bp);\n\t\tbp = NULL;\n\t\tif (error)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr_shortform_getvalue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "621-653",
    "snippet": "int\nxfs_attr_shortform_getvalue(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\n\tASSERT(args->dp->i_afp->if_flags == XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)args->dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = sfe->valuelen;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (args->valuelen < sfe->valuelen) {\n\t\t\targs->valuelen = sfe->valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = sfe->valuelen;\n\t\tmemcpy(args->value, &sfe->nameval[args->namelen],\n\t\t\t\t\t\t    args->valuelen);\n\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "args->value",
            "&sfe->nameval[args->namelen]",
            "args->valuelen"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_namesp_match",
          "args": [
            "args->flags",
            "sfe->flags"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_namesp_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "281-285",
          "snippet": "STATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "args->name",
            "sfe->nameval",
            "args->namelen"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_SF_NEXTENTRY",
          "args": [
            "sfe"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->dp->i_afp->if_flags == XFS_IFINLINE"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_getvalue(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\n\tASSERT(args->dp->i_afp->if_flags == XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)args->dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = sfe->valuelen;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (args->valuelen < sfe->valuelen) {\n\t\t\targs->valuelen = sfe->valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = sfe->valuelen;\n\t\tmemcpy(args->value, &sfe->nameval[args->namelen],\n\t\t\t\t\t\t    args->valuelen);\n\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}"
  },
  {
    "function_name": "xfs_attr_shortform_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "590-615",
    "snippet": "int\nxfs_attr_shortform_lookup(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_lookup(args);\n\n\tifp = args->dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_namesp_match",
          "args": [
            "args->flags",
            "sfe->flags"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_namesp_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "281-285",
          "snippet": "STATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "args->name",
            "sfe->nameval",
            "args->namelen"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_SF_NEXTENTRY",
          "args": [
            "sfe"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFINLINE"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_sf_lookup",
          "args": [
            "args"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_lookup(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_lookup(args);\n\n\tifp = args->dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}"
  },
  {
    "function_name": "xfs_attr_shortform_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "519-584",
    "snippet": "int\nxfs_attr_shortform_remove(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint base, size=0, end, totsize, i;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\n\ttrace_xfs_attr_sf_remove(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tbase = sizeof(xfs_attr_sf_hdr_t);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tend = sf->hdr.count;\n\tfor (i = 0; i < end; sfe = XFS_ATTR_SF_NEXTENTRY(sfe),\n\t\t\t\t\tbase += size, i++) {\n\t\tsize = XFS_ATTR_SF_ENTSIZE(sfe);\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(sfe->nameval, args->name, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (i == end)\n\t\treturn -ENOATTR;\n\n\t/*\n\t * Fix up the attribute fork data, covering the hole\n\t */\n\tend = base + size;\n\ttotsize = be16_to_cpu(sf->hdr.totsize);\n\tif (end != totsize)\n\t\tmemmove(&((char *)sf)[base], &((char *)sf)[end], totsize - end);\n\tsf->hdr.count--;\n\tbe16_add_cpu(&sf->hdr.totsize, -size);\n\n\t/*\n\t * Fix up the start offset of the attribute fork\n\t */\n\ttotsize -= size;\n\tif (totsize == sizeof(xfs_attr_sf_hdr_t) &&\n\t    (mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    !(args->op_flags & XFS_DA_OP_ADDNAME)) {\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t} else {\n\t\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\t\tdp->i_d.di_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);\n\t\tASSERT(dp->i_d.di_forkoff);\n\t\tASSERT(totsize > sizeof(xfs_attr_sf_hdr_t) ||\n\t\t\t\t(args->op_flags & XFS_DA_OP_ADDNAME) ||\n\t\t\t\t!(mp->m_flags & XFS_MOUNT_ATTR2) ||\n\t\t\t\tdp->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\t\txfs_trans_log_inode(args->trans, dp,\n\t\t\t\t\tXFS_ILOG_CORE | XFS_ILOG_ADATA);\n\t}\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sbversion_add_attr2",
          "args": [
            "mp",
            "args->trans"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sbversion_add_attr2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "397-410",
          "snippet": "STATIC void\nxfs_sbversion_add_attr2(xfs_mount_t *mp, xfs_trans_t *tp)\n{\n\tif ((mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    !(xfs_sb_version_hasattr2(&mp->m_sb))) {\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_sb_version_hasattr2(&mp->m_sb)) {\n\t\t\txfs_sb_version_addattr2(&mp->m_sb);\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t\t\txfs_log_sb(tp);\n\t\t} else\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_sbversion_add_attr2(xfs_mount_t *mp, xfs_trans_t *tp)\n{\n\tif ((mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    !(xfs_sb_version_hasattr2(&mp->m_sb))) {\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_sb_version_hasattr2(&mp->m_sb)) {\n\t\t\txfs_sb_version_addattr2(&mp->m_sb);\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t\t\txfs_log_sb(tp);\n\t\t} else\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args->trans",
            "dp",
            "XFS_ILOG_CORE | XFS_ILOG_ADATA"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "totsize > sizeof(xfs_attr_sf_hdr_t) ||\n\t\t\t\t(args->op_flags & XFS_DA_OP_ADDNAME) ||\n\t\t\t\t!(mp->m_flags & XFS_MOUNT_ATTR2) ||\n\t\t\t\tdp->i_d.di_format == XFS_DINODE_FMT_BTREE"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_d.di_forkoff"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_bytesfit",
          "args": [
            "dp",
            "totsize"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_bytesfit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "302-392",
          "snippet": "int\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\n{\n\tint offset;\n\tint minforkoff;\t/* lower limit on valid forkoff locations */\n\tint maxforkoff;\t/* upper limit on valid forkoff locations */\n\tint dsize;\n\txfs_mount_t *mp = dp->i_mount;\n\n\t/* rounded down */\n\toffset = (XFS_LITINO(mp, dp->i_d.di_version) - bytes) >> 3;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tminforkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t/*\n\t * If the requested numbers of bytes is smaller or equal to the\n\t * current attribute fork size we can always proceed.\n\t *\n\t * Note that if_bytes in the data fork might actually be larger than\n\t * the current data fork size is due to delalloc extents. In that\n\t * case either the extent count will go down when they are converted\n\t * to real extents, or the delalloc conversion will take care of the\n\t * literal area rebalancing.\n\t */\n\tif (bytes <= XFS_IFORK_ASIZE(dp))\n\t\treturn dp->i_d.di_forkoff;\n\n\t/*\n\t * For attr2 we can try to move the forkoff if there is space in the\n\t * literal area, but for the old format we are done if there is no\n\t * space in the fixed attribute fork.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_ATTR2))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/*\n\t\t * If there is no attr fork and the data fork is extents, \n\t\t * determine if creating the default attr fork will result\n\t\t * in the extents form migrating to btree. If so, the\n\t\t * minimum offset only needs to be the space required for\n\t\t * the btree root.\n\t\t */\n\t\tif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t/*\n\t\t * If we have a data btree then keep forkoff if we have one,\n\t\t * otherwise we are adding a new attr, so then we set\n\t\t * minforkoff to where the btree root can finish so we have\n\t\t * plenty of room for attrs\n\t\t */\n\t\tif (dp->i_d.di_forkoff) {\n\t\t\tif (offset < dp->i_d.di_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_d.di_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A data fork btree root must have space for at least\n\t * MINDBTPTRS key/ptr pairs if the data fork is small or empty.\n\t */\n\tminforkoff = MAX(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t/* attr fork btree root can have at least this many key/ptr pairs */\n\tmaxforkoff = XFS_LITINO(mp, dp->i_d.di_version) -\n\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t/* rounded down */\n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\n{\n\tint offset;\n\tint minforkoff;\t/* lower limit on valid forkoff locations */\n\tint maxforkoff;\t/* upper limit on valid forkoff locations */\n\tint dsize;\n\txfs_mount_t *mp = dp->i_mount;\n\n\t/* rounded down */\n\toffset = (XFS_LITINO(mp, dp->i_d.di_version) - bytes) >> 3;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tminforkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t/*\n\t * If the requested numbers of bytes is smaller or equal to the\n\t * current attribute fork size we can always proceed.\n\t *\n\t * Note that if_bytes in the data fork might actually be larger than\n\t * the current data fork size is due to delalloc extents. In that\n\t * case either the extent count will go down when they are converted\n\t * to real extents, or the delalloc conversion will take care of the\n\t * literal area rebalancing.\n\t */\n\tif (bytes <= XFS_IFORK_ASIZE(dp))\n\t\treturn dp->i_d.di_forkoff;\n\n\t/*\n\t * For attr2 we can try to move the forkoff if there is space in the\n\t * literal area, but for the old format we are done if there is no\n\t * space in the fixed attribute fork.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_ATTR2))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/*\n\t\t * If there is no attr fork and the data fork is extents, \n\t\t * determine if creating the default attr fork will result\n\t\t * in the extents form migrating to btree. If so, the\n\t\t * minimum offset only needs to be the space required for\n\t\t * the btree root.\n\t\t */\n\t\tif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t/*\n\t\t * If we have a data btree then keep forkoff if we have one,\n\t\t * otherwise we are adding a new attr, so then we set\n\t\t * minforkoff to where the btree root can finish so we have\n\t\t * plenty of room for attrs\n\t\t */\n\t\tif (dp->i_d.di_forkoff) {\n\t\t\tif (offset < dp->i_d.di_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_d.di_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A data fork btree root must have space for at least\n\t * MINDBTPTRS key/ptr pairs if the data fork is small or empty.\n\t */\n\tminforkoff = MAX(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t/* attr fork btree root can have at least this many key/ptr pairs */\n\tmaxforkoff = XFS_LITINO(mp, dp->i_d.di_version) -\n\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t/* rounded down */\n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "dp",
            "-size",
            "XFS_ATTR_FORK"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_fork_reset",
          "args": [
            "dp",
            "args->trans"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_fork_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "501-514",
          "snippet": "STATIC void\nxfs_attr_fork_reset(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tip->i_d.di_forkoff = 0;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_afp == NULL);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_attr_fork_reset(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tip->i_d.di_forkoff = 0;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_afp == NULL);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_add_cpu",
          "args": [
            "&sf->hdr.totsize",
            "-size"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&((char *)sf)[base]",
            "&((char *)sf)[end]",
            "totsize - end"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "sf->hdr.totsize"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_namesp_match",
          "args": [
            "args->flags",
            "sfe->flags"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_namesp_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "281-285",
          "snippet": "STATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sfe->nameval",
            "args->name",
            "args->namelen"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_SF_ENTSIZE",
          "args": [
            "sfe"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_SF_NEXTENTRY",
          "args": [
            "sfe"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_sf_remove",
          "args": [
            "args"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_remove(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint base, size=0, end, totsize, i;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\n\ttrace_xfs_attr_sf_remove(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tbase = sizeof(xfs_attr_sf_hdr_t);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tend = sf->hdr.count;\n\tfor (i = 0; i < end; sfe = XFS_ATTR_SF_NEXTENTRY(sfe),\n\t\t\t\t\tbase += size, i++) {\n\t\tsize = XFS_ATTR_SF_ENTSIZE(sfe);\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(sfe->nameval, args->name, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (i == end)\n\t\treturn -ENOATTR;\n\n\t/*\n\t * Fix up the attribute fork data, covering the hole\n\t */\n\tend = base + size;\n\ttotsize = be16_to_cpu(sf->hdr.totsize);\n\tif (end != totsize)\n\t\tmemmove(&((char *)sf)[base], &((char *)sf)[end], totsize - end);\n\tsf->hdr.count--;\n\tbe16_add_cpu(&sf->hdr.totsize, -size);\n\n\t/*\n\t * Fix up the start offset of the attribute fork\n\t */\n\ttotsize -= size;\n\tif (totsize == sizeof(xfs_attr_sf_hdr_t) &&\n\t    (mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    !(args->op_flags & XFS_DA_OP_ADDNAME)) {\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t} else {\n\t\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\t\tdp->i_d.di_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);\n\t\tASSERT(dp->i_d.di_forkoff);\n\t\tASSERT(totsize > sizeof(xfs_attr_sf_hdr_t) ||\n\t\t\t\t(args->op_flags & XFS_DA_OP_ADDNAME) ||\n\t\t\t\t!(mp->m_flags & XFS_MOUNT_ATTR2) ||\n\t\t\t\tdp->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\t\txfs_trans_log_inode(args->trans, dp,\n\t\t\t\t\tXFS_ILOG_CORE | XFS_ILOG_ADATA);\n\t}\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr_fork_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "501-514",
    "snippet": "STATIC void\nxfs_attr_fork_reset(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tip->i_d.di_forkoff = 0;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_afp == NULL);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_afp == NULL"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_anextents == 0"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idestroy_fork",
          "args": [
            "ip",
            "XFS_ATTR_FORK"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idestroy_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "678-719",
          "snippet": "void\nxfs_idestroy_fork(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (ifp->if_broot != NULL) {\n\t\tkmem_free(ifp->if_broot);\n\t\tifp->if_broot = NULL;\n\t}\n\n\t/*\n\t * If the format is local, then we can't have an extents\n\t * array so just look for an inline data array.  If we're\n\t * not local then we may or may not have an extents list,\n\t * so check and free it up if we do.\n\t */\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\tif ((ifp->if_u1.if_data != ifp->if_u2.if_inline_data) &&\n\t\t    (ifp->if_u1.if_data != NULL)) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = NULL;\n\t\t\tifp->if_real_bytes = 0;\n\t\t}\n\t} else if ((ifp->if_flags & XFS_IFEXTENTS) &&\n\t\t   ((ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t    ((ifp->if_u1.if_extents != NULL) &&\n\t\t     (ifp->if_u1.if_extents != ifp->if_u2.if_inline_ext)))) {\n\t\tASSERT(ifp->if_real_bytes != 0);\n\t\txfs_iext_destroy(ifp);\n\t}\n\tASSERT(ifp->if_u1.if_extents == NULL ||\n\t       ifp->if_u1.if_extents == ifp->if_u2.if_inline_ext);\n\tASSERT(ifp->if_real_bytes == 0);\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_ifork_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nkmem_zone_t *xfs_ifork_zone;\n\nvoid\nxfs_idestroy_fork(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (ifp->if_broot != NULL) {\n\t\tkmem_free(ifp->if_broot);\n\t\tifp->if_broot = NULL;\n\t}\n\n\t/*\n\t * If the format is local, then we can't have an extents\n\t * array so just look for an inline data array.  If we're\n\t * not local then we may or may not have an extents list,\n\t * so check and free it up if we do.\n\t */\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\tif ((ifp->if_u1.if_data != ifp->if_u2.if_inline_data) &&\n\t\t    (ifp->if_u1.if_data != NULL)) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = NULL;\n\t\t\tifp->if_real_bytes = 0;\n\t\t}\n\t} else if ((ifp->if_flags & XFS_IFEXTENTS) &&\n\t\t   ((ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t    ((ifp->if_u1.if_extents != NULL) &&\n\t\t     (ifp->if_u1.if_extents != ifp->if_u2.if_inline_ext)))) {\n\t\tASSERT(ifp->if_real_bytes != 0);\n\t\txfs_iext_destroy(ifp);\n\t}\n\tASSERT(ifp->if_u1.if_extents == NULL ||\n\t       ifp->if_u1.if_extents == ifp->if_u2.if_inline_ext);\n\tASSERT(ifp->if_real_bytes == 0);\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_attr_fork_reset(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tip->i_d.di_forkoff = 0;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_afp == NULL);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}"
  },
  {
    "function_name": "xfs_attr_shortform_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "447-495",
    "snippet": "void\nxfs_attr_shortform_add(xfs_da_args_t *args, int forkoff)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i, offset, size;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_add(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tdp->i_d.di_forkoff = forkoff;\n\n\tifp = dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n#ifdef DEBUG\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tASSERT(0);\n#endif\n\t}\n\n\toffset = (char *)sfe - (char *)sf;\n\tsize = XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = (xfs_attr_sf_entry_t *)((char *)sf + offset);\n\n\tsfe->namelen = args->namelen;\n\tsfe->valuelen = args->valuelen;\n\tsfe->flags = XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tmemcpy(sfe->nameval, args->name, args->namelen);\n\tmemcpy(&sfe->nameval[args->namelen], args->value, args->valuelen);\n\tsf->hdr.count++;\n\tbe16_add_cpu(&sf->hdr.totsize, size);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sbversion_add_attr2",
          "args": [
            "mp",
            "args->trans"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sbversion_add_attr2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "397-410",
          "snippet": "STATIC void\nxfs_sbversion_add_attr2(xfs_mount_t *mp, xfs_trans_t *tp)\n{\n\tif ((mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    !(xfs_sb_version_hasattr2(&mp->m_sb))) {\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_sb_version_hasattr2(&mp->m_sb)) {\n\t\t\txfs_sb_version_addattr2(&mp->m_sb);\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t\t\txfs_log_sb(tp);\n\t\t} else\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_sbversion_add_attr2(xfs_mount_t *mp, xfs_trans_t *tp)\n{\n\tif ((mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    !(xfs_sb_version_hasattr2(&mp->m_sb))) {\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_sb_version_hasattr2(&mp->m_sb)) {\n\t\t\txfs_sb_version_addattr2(&mp->m_sb);\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t\t\txfs_log_sb(tp);\n\t\t} else\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args->trans",
            "dp",
            "XFS_ILOG_CORE | XFS_ILOG_ADATA"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_add_cpu",
          "args": [
            "&sf->hdr.totsize",
            "size"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&sfe->nameval[args->namelen]",
            "args->value",
            "args->valuelen"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sfe->nameval",
            "args->name",
            "args->namelen"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_NSP_ARGS_TO_ONDISK",
          "args": [
            "args->flags"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "dp",
            "size",
            "XFS_ATTR_FORK"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_SF_ENTSIZE_BYNAME",
          "args": [
            "args->namelen",
            "args->valuelen"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_namesp_match",
          "args": [
            "args->flags",
            "sfe->flags"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_namesp_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "281-285",
          "snippet": "STATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "args->name",
            "sfe->nameval",
            "args->namelen"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_SF_NEXTENTRY",
          "args": [
            "sfe"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFINLINE"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_sf_add",
          "args": [
            "args"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr_shortform_add(xfs_da_args_t *args, int forkoff)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i, offset, size;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_add(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tdp->i_d.di_forkoff = forkoff;\n\n\tifp = dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n#ifdef DEBUG\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tASSERT(0);\n#endif\n\t}\n\n\toffset = (char *)sfe - (char *)sf;\n\tsize = XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = (xfs_attr_sf_entry_t *)((char *)sf + offset);\n\n\tsfe->namelen = args->namelen;\n\tsfe->valuelen = args->valuelen;\n\tsfe->flags = XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tmemcpy(sfe->nameval, args->name, args->namelen);\n\tmemcpy(&sfe->nameval[args->namelen], args->value, args->valuelen);\n\tsf->hdr.count++;\n\tbe16_add_cpu(&sf->hdr.totsize, size);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n}"
  },
  {
    "function_name": "xfs_attr_shortform_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "415-441",
    "snippet": "void\nxfs_attr_shortform_create(xfs_da_args_t *args)\n{\n\txfs_attr_sf_hdr_t *hdr;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_create(args);\n\n\tdp = args->dp;\n\tASSERT(dp != NULL);\n\tifp = dp->i_afp;\n\tASSERT(ifp != NULL);\n\tASSERT(ifp->if_bytes == 0);\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS) {\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\t/* just in case */\n\t\tdp->i_d.di_aformat = XFS_DINODE_FMT_LOCAL;\n\t\tifp->if_flags |= XFS_IFINLINE;\n\t} else {\n\t\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t}\n\txfs_idata_realloc(dp, sizeof(*hdr), XFS_ATTR_FORK);\n\thdr = (xfs_attr_sf_hdr_t *)ifp->if_u1.if_data;\n\thdr->count = 0;\n\thdr->totsize = cpu_to_be16(sizeof(*hdr));\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args->trans",
            "dp",
            "XFS_ILOG_CORE | XFS_ILOG_ADATA"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "sizeof(*hdr)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "dp",
            "sizeof(*hdr)",
            "XFS_ATTR_FORK"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFINLINE"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_bytes == 0"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp != NULL"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp != NULL"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_sf_create",
          "args": [
            "args"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr_shortform_create(xfs_da_args_t *args)\n{\n\txfs_attr_sf_hdr_t *hdr;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_create(args);\n\n\tdp = args->dp;\n\tASSERT(dp != NULL);\n\tifp = dp->i_afp;\n\tASSERT(ifp != NULL);\n\tASSERT(ifp->if_bytes == 0);\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS) {\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\t/* just in case */\n\t\tdp->i_d.di_aformat = XFS_DINODE_FMT_LOCAL;\n\t\tifp->if_flags |= XFS_IFINLINE;\n\t} else {\n\t\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t}\n\txfs_idata_realloc(dp, sizeof(*hdr), XFS_ATTR_FORK);\n\thdr = (xfs_attr_sf_hdr_t *)ifp->if_u1.if_data;\n\thdr->count = 0;\n\thdr->totsize = cpu_to_be16(sizeof(*hdr));\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n}"
  },
  {
    "function_name": "xfs_sbversion_add_attr2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "397-410",
    "snippet": "STATIC void\nxfs_sbversion_add_attr2(xfs_mount_t *mp, xfs_trans_t *tp)\n{\n\tif ((mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    !(xfs_sb_version_hasattr2(&mp->m_sb))) {\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_sb_version_hasattr2(&mp->m_sb)) {\n\t\t\txfs_sb_version_addattr2(&mp->m_sb);\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t\t\txfs_log_sb(tp);\n\t\t} else\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t}\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_sb",
          "args": [
            "tp"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "767-777",
          "snippet": "void\nxfs_log_sb(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*bp = xfs_trans_getsb(tp, mp, 0);\n\n\txfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\txfs_trans_log_buf(tp, bp, 0, sizeof(struct xfs_dsb));\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_log_sb(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*bp = xfs_trans_getsb(tp, mp, 0);\n\n\txfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\txfs_trans_log_buf(tp, bp, 0, sizeof(struct xfs_dsb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_addattr2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_addattr2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "455-459",
          "snippet": "static inline void xfs_sb_version_addattr2(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_MOREBITSBIT;\n\tsbp->sb_features2 |= XFS_SB_VERSION2_ATTR2BIT;\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */",
            "#define\tXFS_SB_VERSION_MOREBITSBIT\t0x8000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */\n#define\tXFS_SB_VERSION_MOREBITSBIT\t0x8000\n\nstatic inline void xfs_sb_version_addattr2(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_MOREBITSBIT;\n\tsbp->sb_features2 |= XFS_SB_VERSION2_ATTR2BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasattr2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasattr2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "448-453",
          "snippet": "static inline bool xfs_sb_version_hasattr2(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasattr2(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_sbversion_add_attr2(xfs_mount_t *mp, xfs_trans_t *tp)\n{\n\tif ((mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    !(xfs_sb_version_hasattr2(&mp->m_sb))) {\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_sb_version_hasattr2(&mp->m_sb)) {\n\t\t\txfs_sb_version_addattr2(&mp->m_sb);\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t\t\txfs_log_sb(tp);\n\t\t} else\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t}\n}"
  },
  {
    "function_name": "xfs_attr_shortform_bytesfit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "302-392",
    "snippet": "int\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\n{\n\tint offset;\n\tint minforkoff;\t/* lower limit on valid forkoff locations */\n\tint maxforkoff;\t/* upper limit on valid forkoff locations */\n\tint dsize;\n\txfs_mount_t *mp = dp->i_mount;\n\n\t/* rounded down */\n\toffset = (XFS_LITINO(mp, dp->i_d.di_version) - bytes) >> 3;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tminforkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t/*\n\t * If the requested numbers of bytes is smaller or equal to the\n\t * current attribute fork size we can always proceed.\n\t *\n\t * Note that if_bytes in the data fork might actually be larger than\n\t * the current data fork size is due to delalloc extents. In that\n\t * case either the extent count will go down when they are converted\n\t * to real extents, or the delalloc conversion will take care of the\n\t * literal area rebalancing.\n\t */\n\tif (bytes <= XFS_IFORK_ASIZE(dp))\n\t\treturn dp->i_d.di_forkoff;\n\n\t/*\n\t * For attr2 we can try to move the forkoff if there is space in the\n\t * literal area, but for the old format we are done if there is no\n\t * space in the fixed attribute fork.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_ATTR2))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/*\n\t\t * If there is no attr fork and the data fork is extents, \n\t\t * determine if creating the default attr fork will result\n\t\t * in the extents form migrating to btree. If so, the\n\t\t * minimum offset only needs to be the space required for\n\t\t * the btree root.\n\t\t */\n\t\tif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t/*\n\t\t * If we have a data btree then keep forkoff if we have one,\n\t\t * otherwise we are adding a new attr, so then we set\n\t\t * minforkoff to where the btree root can finish so we have\n\t\t * plenty of room for attrs\n\t\t */\n\t\tif (dp->i_d.di_forkoff) {\n\t\t\tif (offset < dp->i_d.di_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_d.di_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A data fork btree root must have space for at least\n\t * MINDBTPTRS key/ptr pairs if the data fork is small or empty.\n\t */\n\tminforkoff = MAX(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t/* attr fork btree root can have at least this many key/ptr pairs */\n\tmaxforkoff = XFS_LITINO(mp, dp->i_d.di_version) -\n\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t/* rounded down */\n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BMDR_SPACE_CALC",
          "args": [
            "MINABTPTRS"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LITINO",
          "args": [
            "mp",
            "dp->i_d.di_version"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "minforkoff",
            "8"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "dsize",
            "XFS_BMDR_SPACE_CALC(MINDBTPTRS)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMDR_SPACE_CALC",
          "args": [
            "MINDBTPTRS"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_SPACE",
          "args": [
            "mp",
            "dp->i_df.if_broot"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMDR_SPACE_CALC",
          "args": [
            "MINDBTPTRS"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_default_attroffset",
          "args": [
            "dp"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_default_attroffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "208-224",
          "snippet": "uint\nxfs_default_attroffset(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\toffset;\n\n\tif (mp->m_sb.sb_inodesize == 256) {\n\t\toffset = XFS_LITINO(mp, ip->i_d.di_version) -\n\t\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\t} else {\n\t\toffset = XFS_BMDR_SPACE_CALC(6 * MINABTPTRS);\n\t}\n\n\tASSERT(offset < XFS_LITINO(mp, ip->i_d.di_version));\n\treturn offset;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nuint\nxfs_default_attroffset(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\toffset;\n\n\tif (mp->m_sb.sb_inodesize == 256) {\n\t\toffset = XFS_LITINO(mp, ip->i_d.di_version) -\n\t\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\t} else {\n\t\toffset = XFS_BMDR_SPACE_CALC(6 * MINABTPTRS);\n\t}\n\n\tASSERT(offset < XFS_LITINO(mp, ip->i_d.di_version));\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_ASIZE",
          "args": [
            "dp"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LITINO",
          "args": [
            "mp",
            "dp->i_d.di_version"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\n{\n\tint offset;\n\tint minforkoff;\t/* lower limit on valid forkoff locations */\n\tint maxforkoff;\t/* upper limit on valid forkoff locations */\n\tint dsize;\n\txfs_mount_t *mp = dp->i_mount;\n\n\t/* rounded down */\n\toffset = (XFS_LITINO(mp, dp->i_d.di_version) - bytes) >> 3;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tminforkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t/*\n\t * If the requested numbers of bytes is smaller or equal to the\n\t * current attribute fork size we can always proceed.\n\t *\n\t * Note that if_bytes in the data fork might actually be larger than\n\t * the current data fork size is due to delalloc extents. In that\n\t * case either the extent count will go down when they are converted\n\t * to real extents, or the delalloc conversion will take care of the\n\t * literal area rebalancing.\n\t */\n\tif (bytes <= XFS_IFORK_ASIZE(dp))\n\t\treturn dp->i_d.di_forkoff;\n\n\t/*\n\t * For attr2 we can try to move the forkoff if there is space in the\n\t * literal area, but for the old format we are done if there is no\n\t * space in the fixed attribute fork.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_ATTR2))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/*\n\t\t * If there is no attr fork and the data fork is extents, \n\t\t * determine if creating the default attr fork will result\n\t\t * in the extents form migrating to btree. If so, the\n\t\t * minimum offset only needs to be the space required for\n\t\t * the btree root.\n\t\t */\n\t\tif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t/*\n\t\t * If we have a data btree then keep forkoff if we have one,\n\t\t * otherwise we are adding a new attr, so then we set\n\t\t * minforkoff to where the btree root can finish so we have\n\t\t * plenty of room for attrs\n\t\t */\n\t\tif (dp->i_d.di_forkoff) {\n\t\t\tif (offset < dp->i_d.di_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_d.di_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A data fork btree root must have space for at least\n\t * MINDBTPTRS key/ptr pairs if the data fork is small or empty.\n\t */\n\tminforkoff = MAX(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t/* attr fork btree root can have at least this many key/ptr pairs */\n\tmaxforkoff = XFS_LITINO(mp, dp->i_d.di_version) -\n\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t/* rounded down */\n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr_namesp_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "281-285",
    "snippet": "STATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_ATTR_NSP_ARGS_TO_ONDISK",
          "args": [
            "arg_flags"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_NSP_ONDISK",
          "args": [
            "ondisk_flags"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "256-271",
    "snippet": "int\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
      "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "*bpp",
            "XFS_BLFT_ATTR_LEAF_BUF"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_read_buf",
          "args": [
            "tp",
            "dp",
            "bno",
            "mappedbno",
            "bpp",
            "XFS_ATTR_FORK",
            "&xfs_attr3_leaf_buf_ops"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2577-2621",
          "snippet": "int\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "235-249",
    "snippet": "static void\nxfs_attr3_leaf_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_ATTR3_LEAF_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_attr3_leaf_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_verify",
          "args": [
            "bp"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "173-204",
          "snippet": "static bool\nxfs_attr3_leaf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_attr_leafblock *leaf = bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_ATTR3_LEAF_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_ATTR_LEAF_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/* XXX: need to range check rest of attr header values */\n\t/* XXX: hash order check? */\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_attr3_leaf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_attr_leafblock *leaf = bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_ATTR3_LEAF_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_ATTR_LEAF_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/* XXX: need to range check rest of attr header values */\n\t/* XXX: hash order check? */\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_verify_cksum",
          "args": [
            "bp",
            "XFS_ATTR3_LEAF_CRC_OFF"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "367-372",
          "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_attr3_leaf_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_ATTR3_LEAF_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_attr3_leaf_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "206-227",
    "snippet": "static void\nxfs_attr3_leaf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_attr3_leaf_hdr *hdr3 = bp->b_addr;\n\n\tif (!xfs_attr3_leaf_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_ATTR3_LEAF_CRC_OFF);\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_update_cksum",
          "args": [
            "bp",
            "XFS_ATTR3_LEAF_CRC_OFF"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "374-379",
          "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_verify",
          "args": [
            "bp"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "173-204",
          "snippet": "static bool\nxfs_attr3_leaf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_attr_leafblock *leaf = bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_ATTR3_LEAF_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_ATTR_LEAF_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/* XXX: need to range check rest of attr header values */\n\t/* XXX: hash order check? */\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_attr3_leaf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_attr_leafblock *leaf = bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_ATTR3_LEAF_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_ATTR_LEAF_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/* XXX: need to range check rest of attr header values */\n\t/* XXX: hash order check? */\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_attr3_leaf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_attr3_leaf_hdr *hdr3 = bp->b_addr;\n\n\tif (!xfs_attr3_leaf_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_ATTR3_LEAF_CRC_OFF);\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "173-204",
    "snippet": "static bool\nxfs_attr3_leaf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_attr_leafblock *leaf = bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_ATTR3_LEAF_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_ATTR_LEAF_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/* XXX: need to range check rest of attr header values */\n\t/* XXX: hash order check? */\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "hdr3->info.blkno"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&hdr3->info.uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&ichdr",
            "leaf"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_attr3_leaf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_attr_leafblock *leaf = bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_ATTR3_LEAF_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_ATTR_LEAF_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/* XXX: need to range check rest of attr header values */\n\t/* XXX: hash order check? */\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_hdr_to_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "130-171",
    "snippet": "void\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->freemap[i].size"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->freemap[i].base"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->firstused"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->usedbytes"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->count"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->magic"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->back"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->forw"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->freemap[i].size"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->freemap[i].base"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->firstused"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->usedbytes"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->count"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->magic"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->back"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->forw"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\thdr3->firstused = cpu_to_be16(from->firstused);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\tto->hdr.firstused = cpu_to_be16(from->firstused);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_hdr_from_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
    "lines": "89-128",
    "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->hdr.freemap[i].size"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->hdr.freemap[i].base"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->hdr.firstused"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->hdr.usedbytes"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->hdr.count"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->hdr.info.magic"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->hdr.info.back"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->hdr.info.forw"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr3->freemap[i].size"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr3->freemap[i].base"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr3->firstused"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr3->usedbytes"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr3->count"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr3->info.hdr.magic"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hdr3->info.hdr.back"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hdr3->info.hdr.forw"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_ATTR3_LEAF_MAGIC"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_ATTR3_LEAF_MAGIC"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
  }
]