[
  {
    "function_name": "SMB2_lease_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2629-2658",
    "snippet": "int\nSMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u8 *lease_key, const __le32 lease_state)\n{\n\tint rc;\n\tstruct smb2_lease_ack *req = NULL;\n\n\tcifs_dbg(FYI, \"SMB2_lease_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\treq->StructureSize = cpu_to_le16(36);\n\tinc_rfc1001_len(req, 12);\n\n\tmemcpy(req->LeaseKey, lease_key, 16);\n\treq->LeaseState = lease_state;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\n\t/* SMB2 buffer freed by function above */\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Lease Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in Lease Break = %d\\n\"",
            "rc"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_OPLOCK_BREAK_HE"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "tcon->ses",
            "(char *) req",
            "CIFS_OBREAK_OP"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "req->LeaseKey",
            "lease_key",
            "16"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "req",
            "12"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "36"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_OPLOCK_BREAK",
            "tcon",
            "(void **) &req"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SMB2_lease_break\\n\""
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u8 *lease_key, const __le32 lease_state)\n{\n\tint rc;\n\tstruct smb2_lease_ack *req = NULL;\n\n\tcifs_dbg(FYI, \"SMB2_lease_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\treq->StructureSize = cpu_to_le16(36);\n\tinc_rfc1001_len(req, 12);\n\n\tmemcpy(req->LeaseKey, lease_key, 16);\n\treq->LeaseState = lease_state;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\n\t/* SMB2 buffer freed by function above */\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Lease Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2612-2627",
    "snippet": "int\nSMB2_lock(const unsigned int xid, struct cifs_tcon *tcon,\n\t  const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t  const __u64 length, const __u64 offset, const __u32 lock_flags,\n\t  const bool wait)\n{\n\tstruct smb2_lock_element lock;\n\n\tlock.Offset = cpu_to_le64(offset);\n\tlock.Length = cpu_to_le64(length);\n\tlock.Flags = cpu_to_le32(lock_flags);\n\tif (!wait && lock_flags != SMB2_LOCKFLAG_UNLOCK)\n\t\tlock.Flags |= cpu_to_le32(SMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\n\treturn smb2_lockv(xid, tcon, persist_fid, volatile_fid, pid, 1, &lock);\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb2_lockv",
          "args": [
            "xid",
            "tcon",
            "persist_fid",
            "volatile_fid",
            "pid",
            "1",
            "&lock"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_lockv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2570-2610",
          "snippet": "int\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t   const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t   const __u32 num_lock, struct smb2_lock_element *buf)\n{\n\tint rc = 0;\n\tstruct smb2_lock_req *req = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\tunsigned int count;\n\n\tcifs_dbg(FYI, \"smb2_lockv num lock %d\\n\", num_lock);\n\n\trc = small_smb2_init(SMB2_LOCK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\treq->LockCount = cpu_to_le16(num_lock);\n\n\treq->PersistentFileId = persist_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tcount = num_lock * sizeof(struct smb2_lock_element);\n\tinc_rfc1001_len(req, count - sizeof(struct smb2_lock_element));\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and count for all locks */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - count;\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = count;\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in smb2_lockv = %d\\n\", rc);\n\t\tcifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t   const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t   const __u32 num_lock, struct smb2_lock_element *buf)\n{\n\tint rc = 0;\n\tstruct smb2_lock_req *req = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\tunsigned int count;\n\n\tcifs_dbg(FYI, \"smb2_lockv num lock %d\\n\", num_lock);\n\n\trc = small_smb2_init(SMB2_LOCK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\treq->LockCount = cpu_to_le16(num_lock);\n\n\treq->PersistentFileId = persist_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tcount = num_lock * sizeof(struct smb2_lock_element);\n\tinc_rfc1001_len(req, count - sizeof(struct smb2_lock_element));\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and count for all locks */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - count;\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = count;\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in smb2_lockv = %d\\n\", rc);\n\t\tcifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "SMB2_LOCKFLAG_FAIL_IMMEDIATELY"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lock_flags"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "length"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "offset"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_lock(const unsigned int xid, struct cifs_tcon *tcon,\n\t  const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t  const __u64 length, const __u64 offset, const __u32 lock_flags,\n\t  const bool wait)\n{\n\tstruct smb2_lock_element lock;\n\n\tlock.Offset = cpu_to_le64(offset);\n\tlock.Length = cpu_to_le64(length);\n\tlock.Flags = cpu_to_le32(lock_flags);\n\tif (!wait && lock_flags != SMB2_LOCKFLAG_UNLOCK)\n\t\tlock.Flags |= cpu_to_le32(SMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\n\treturn smb2_lockv(xid, tcon, persist_fid, volatile_fid, pid, 1, &lock);\n}"
  },
  {
    "function_name": "smb2_lockv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2570-2610",
    "snippet": "int\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t   const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t   const __u32 num_lock, struct smb2_lock_element *buf)\n{\n\tint rc = 0;\n\tstruct smb2_lock_req *req = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\tunsigned int count;\n\n\tcifs_dbg(FYI, \"smb2_lockv num lock %d\\n\", num_lock);\n\n\trc = small_smb2_init(SMB2_LOCK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\treq->LockCount = cpu_to_le16(num_lock);\n\n\treq->PersistentFileId = persist_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tcount = num_lock * sizeof(struct smb2_lock_element);\n\tinc_rfc1001_len(req, count - sizeof(struct smb2_lock_element));\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and count for all locks */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - count;\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = count;\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in smb2_lockv = %d\\n\", rc);\n\t\tcifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_LOCK_HE"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in smb2_lockv = %d\\n\"",
            "rc"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "tcon->ses",
            "iov",
            "2",
            "&resp_buf_type",
            "CIFS_NO_RESP"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_locks"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "req",
            "count - sizeof(struct smb2_lock_element)"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "num_lock"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "pid"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_LOCK",
            "tcon",
            "(void **) &req"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"smb2_lockv num lock %d\\n\"",
            "num_lock"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t   const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t   const __u32 num_lock, struct smb2_lock_element *buf)\n{\n\tint rc = 0;\n\tstruct smb2_lock_req *req = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\tunsigned int count;\n\n\tcifs_dbg(FYI, \"smb2_lockv num lock %d\\n\", num_lock);\n\n\trc = small_smb2_init(SMB2_LOCK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\treq->LockCount = cpu_to_le16(num_lock);\n\n\treq->PersistentFileId = persist_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tcount = num_lock * sizeof(struct smb2_lock_element);\n\tinc_rfc1001_len(req, count - sizeof(struct smb2_lock_element));\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and count for all locks */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - count;\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = count;\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in smb2_lockv = %d\\n\", rc);\n\t\tcifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_QFS_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2507-2568",
    "snippet": "int\nSMB2_QFS_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, int level)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tint rc = 0;\n\tint resp_buftype, max_len, min_len;\n\tstruct cifs_ses *ses = tcon->ses;\n\tunsigned int rsp_len, offset;\n\n\tif (level == FS_DEVICE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t\tmin_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t} else if (level == FS_ATTRIBUTE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_ATTRIBUTE_INFO);\n\t\tmin_len = MIN_FS_ATTR_INFO_SIZE;\n\t} else if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tmax_len = sizeof(struct smb3_fs_ss_info);\n\t\tmin_len = sizeof(struct smb3_fs_ss_info);\n\t} else {\n\t\tcifs_dbg(FYI, \"Invalid qfsinfo level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\trc = build_qfs_info_req(&iov, tcon, level, max_len,\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsattr_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)iov.iov_base;\n\n\trsp_len = le32_to_cpu(rsp->OutputBufferLength);\n\toffset = le16_to_cpu(rsp->OutputBufferOffset);\n\trc = validate_buf(offset, rsp_len, &rsp->hdr, min_len);\n\tif (rc)\n\t\tgoto qfsattr_exit;\n\n\tif (level == FS_ATTRIBUTE_INFORMATION)\n\t\tmemcpy(&tcon->fsAttrInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, min_t(unsigned int,\n\t\t\trsp_len, max_len));\n\telse if (level == FS_DEVICE_INFORMATION)\n\t\tmemcpy(&tcon->fsDevInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, sizeof(FILE_SYSTEM_DEVICE_INFO));\n\telse if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tstruct smb3_fs_ss_info *ss_info = (struct smb3_fs_ss_info *)\n\t\t\t(4 /* RFC1001 len */ + offset + (char *)&rsp->hdr);\n\t\ttcon->ss_flags = le32_to_cpu(ss_info->Flags);\n\t\ttcon->perf_sector_size =\n\t\t\tle32_to_cpu(ss_info->PhysicalBytesPerSectorForPerf);\n\t}\n\nqfsattr_exit:\n\tfree_rsp_buf(resp_buftype, iov.iov_base);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "iov.iov_base"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ss_info->PhysicalBytesPerSectorForPerf"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tcon->fsDevInfo",
            "4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr",
            "sizeof(FILE_SYSTEM_DEVICE_INFO)"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tcon->fsAttrInfo",
            "4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr",
            "min_t(unsigned int,\n\t\t\trsp_len, max_len)"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "rsp_len",
            "max_len"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_buf",
          "args": [
            "offset",
            "rsp_len",
            "&rsp->hdr",
            "min_len"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "validate_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1418-1448",
          "snippet": "static int\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\n\t     struct smb2_hdr *hdr, unsigned int min_buf_size)\n\n{\n\tunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\n\tchar *end_of_smb = smb_len + 4 /* RFC1001 length field */ + (char *)hdr;\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"illegal server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\n\t     struct smb2_hdr *hdr, unsigned int min_buf_size)\n\n{\n\tunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\n\tchar *end_of_smb = smb_len + 4 /* RFC1001 length field */ + (char *)hdr;\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"illegal server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rsp->OutputBufferOffset"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_QUERY_INFO_HE"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "&iov",
            "1",
            "&resp_buftype",
            "0"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_qfs_info_req",
          "args": [
            "&iov",
            "tcon",
            "level",
            "max_len",
            "persistent_fid",
            "volatile_fid"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "build_qfs_info_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2438-2468",
          "snippet": "static int\nbuild_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon, int level,\n\t\t   int outbuf_len, u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct smb2_query_info_req *req;\n\n\tcifs_dbg(FYI, \"Query FSInfo level %d\\n\", level);\n\n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILESYSTEM;\n\treq->FileInfoClass = level;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\treq->InputBufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(\n\t\toutbuf_len + sizeof(struct smb2_query_info_rsp) - 1 - 4);\n\n\tiov->iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov->iov_len = get_rfc1002_length(req) + 4;\n\treturn 0;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nbuild_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon, int level,\n\t\t   int outbuf_len, u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct smb2_query_info_req *req;\n\n\tcifs_dbg(FYI, \"Query FSInfo level %d\\n\", level);\n\n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILESYSTEM;\n\treq->FileInfoClass = level;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\treq->InputBufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(\n\t\toutbuf_len + sizeof(struct smb2_query_info_rsp) - 1 - 4);\n\n\tiov->iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov->iov_len = get_rfc1002_length(req) + 4;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Invalid qfsinfo level %d\\n\"",
            "level"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_QFS_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, int level)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tint rc = 0;\n\tint resp_buftype, max_len, min_len;\n\tstruct cifs_ses *ses = tcon->ses;\n\tunsigned int rsp_len, offset;\n\n\tif (level == FS_DEVICE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t\tmin_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t} else if (level == FS_ATTRIBUTE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_ATTRIBUTE_INFO);\n\t\tmin_len = MIN_FS_ATTR_INFO_SIZE;\n\t} else if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tmax_len = sizeof(struct smb3_fs_ss_info);\n\t\tmin_len = sizeof(struct smb3_fs_ss_info);\n\t} else {\n\t\tcifs_dbg(FYI, \"Invalid qfsinfo level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\trc = build_qfs_info_req(&iov, tcon, level, max_len,\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsattr_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)iov.iov_base;\n\n\trsp_len = le32_to_cpu(rsp->OutputBufferLength);\n\toffset = le16_to_cpu(rsp->OutputBufferOffset);\n\trc = validate_buf(offset, rsp_len, &rsp->hdr, min_len);\n\tif (rc)\n\t\tgoto qfsattr_exit;\n\n\tif (level == FS_ATTRIBUTE_INFORMATION)\n\t\tmemcpy(&tcon->fsAttrInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, min_t(unsigned int,\n\t\t\trsp_len, max_len));\n\telse if (level == FS_DEVICE_INFORMATION)\n\t\tmemcpy(&tcon->fsDevInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, sizeof(FILE_SYSTEM_DEVICE_INFO));\n\telse if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tstruct smb3_fs_ss_info *ss_info = (struct smb3_fs_ss_info *)\n\t\t\t(4 /* RFC1001 len */ + offset + (char *)&rsp->hdr);\n\t\ttcon->ss_flags = le32_to_cpu(ss_info->Flags);\n\t\ttcon->perf_sector_size =\n\t\t\tle32_to_cpu(ss_info->PhysicalBytesPerSectorForPerf);\n\t}\n\nqfsattr_exit:\n\tfree_rsp_buf(resp_buftype, iov.iov_base);\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_QFS_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2470-2505",
    "snippet": "int\nSMB2_QFS_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, struct kstatfs *fsdata)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct smb2_fs_full_size_info *info = NULL;\n\n\trc = build_qfs_info_req(&iov, tcon, FS_FULL_SIZE_INFORMATION,\n\t\t\t\tsizeof(struct smb2_fs_full_size_info),\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsinf_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)iov.iov_base;\n\n\tinfo = (struct smb2_fs_full_size_info *)(4 /* RFC1001 len */ +\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)&rsp->hdr);\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tcopy_fs_info_to_kstatfs(info, fsdata);\n\nqfsinf_exit:\n\tfree_rsp_buf(resp_buftype, iov.iov_base);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "iov.iov_base"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fs_info_to_kstatfs",
          "args": [
            "info",
            "fsdata"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fs_info_to_kstatfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2426-2436",
          "snippet": "static void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_buf",
          "args": [
            "le16_to_cpu(rsp->OutputBufferOffset)",
            "le32_to_cpu(rsp->OutputBufferLength)",
            "&rsp->hdr",
            "sizeof(struct smb2_fs_full_size_info)"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "validate_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1418-1448",
          "snippet": "static int\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\n\t     struct smb2_hdr *hdr, unsigned int min_buf_size)\n\n{\n\tunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\n\tchar *end_of_smb = smb_len + 4 /* RFC1001 length field */ + (char *)hdr;\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"illegal server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\n\t     struct smb2_hdr *hdr, unsigned int min_buf_size)\n\n{\n\tunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\n\tchar *end_of_smb = smb_len + 4 /* RFC1001 length field */ + (char *)hdr;\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"illegal server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rsp->OutputBufferLength"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rsp->OutputBufferOffset"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_QUERY_INFO_HE"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "&iov",
            "1",
            "&resp_buftype",
            "0"
          ],
          "line": 2487
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_qfs_info_req",
          "args": [
            "&iov",
            "tcon",
            "FS_FULL_SIZE_INFORMATION",
            "sizeof(struct smb2_fs_full_size_info)",
            "persistent_fid",
            "volatile_fid"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "build_qfs_info_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2438-2468",
          "snippet": "static int\nbuild_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon, int level,\n\t\t   int outbuf_len, u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct smb2_query_info_req *req;\n\n\tcifs_dbg(FYI, \"Query FSInfo level %d\\n\", level);\n\n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILESYSTEM;\n\treq->FileInfoClass = level;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\treq->InputBufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(\n\t\toutbuf_len + sizeof(struct smb2_query_info_rsp) - 1 - 4);\n\n\tiov->iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov->iov_len = get_rfc1002_length(req) + 4;\n\treturn 0;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nbuild_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon, int level,\n\t\t   int outbuf_len, u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct smb2_query_info_req *req;\n\n\tcifs_dbg(FYI, \"Query FSInfo level %d\\n\", level);\n\n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILESYSTEM;\n\treq->FileInfoClass = level;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\treq->InputBufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(\n\t\toutbuf_len + sizeof(struct smb2_query_info_rsp) - 1 - 4);\n\n\tiov->iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov->iov_len = get_rfc1002_length(req) + 4;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_QFS_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, struct kstatfs *fsdata)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct smb2_fs_full_size_info *info = NULL;\n\n\trc = build_qfs_info_req(&iov, tcon, FS_FULL_SIZE_INFORMATION,\n\t\t\t\tsizeof(struct smb2_fs_full_size_info),\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsinf_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)iov.iov_base;\n\n\tinfo = (struct smb2_fs_full_size_info *)(4 /* RFC1001 len */ +\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)&rsp->hdr);\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tcopy_fs_info_to_kstatfs(info, fsdata);\n\nqfsinf_exit:\n\tfree_rsp_buf(resp_buftype, iov.iov_base);\n\treturn rc;\n}"
  },
  {
    "function_name": "build_qfs_info_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2438-2468",
    "snippet": "static int\nbuild_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon, int level,\n\t\t   int outbuf_len, u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct smb2_query_info_req *req;\n\n\tcifs_dbg(FYI, \"Query FSInfo level %d\\n\", level);\n\n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILESYSTEM;\n\treq->FileInfoClass = level;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\treq->InputBufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(\n\t\toutbuf_len + sizeof(struct smb2_query_info_rsp) - 1 - 4);\n\n\tiov->iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov->iov_len = get_rfc1002_length(req) + 4;\n\treturn 0;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "outbuf_len + sizeof(struct smb2_query_info_rsp) - 1 - 4"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sizeof(struct smb2_query_info_req) - 1 - 4"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_QUERY_INFO",
            "tcon",
            "(void **) &req"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Query FSInfo level %d\\n\"",
            "level"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nbuild_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon, int level,\n\t\t   int outbuf_len, u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct smb2_query_info_req *req;\n\n\tcifs_dbg(FYI, \"Query FSInfo level %d\\n\", level);\n\n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILESYSTEM;\n\treq->FileInfoClass = level;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\treq->InputBufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(\n\t\toutbuf_len + sizeof(struct smb2_query_info_rsp) - 1 - 4);\n\n\tiov->iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov->iov_len = get_rfc1002_length(req) + 4;\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_fs_info_to_kstatfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2426-2436",
    "snippet": "static void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "pfs_inf->CallerAvailableAllocationUnits"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pfs_inf->SectorsPerAllocationUnit"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}"
  },
  {
    "function_name": "SMB2_oplock_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2396-2424",
    "snippet": "int\nSMB2_oplock_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  const u64 persistent_fid, const u64 volatile_fid,\n\t\t  __u8 oplock_level)\n{\n\tint rc;\n\tstruct smb2_oplock_break *req = NULL;\n\n\tcifs_dbg(FYI, \"SMB2_oplock_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\n\tif (rc)\n\t\treturn rc;\n\n\treq->VolatileFid = volatile_fid;\n\treq->PersistentFid = persistent_fid;\n\treq->OplockLevel = oplock_level;\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\n\t/* SMB2 buffer freed by function above */\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Oplock Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in Oplock Break = %d\\n\"",
            "rc"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_OPLOCK_BREAK_HE"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "tcon->ses",
            "(char *) req",
            "CIFS_OBREAK_OP"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_OPLOCK_BREAK",
            "tcon",
            "(void **) &req"
          ],
          "line": 2405
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SMB2_oplock_break\\n\""
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_oplock_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  const u64 persistent_fid, const u64 volatile_fid,\n\t\t  __u8 oplock_level)\n{\n\tint rc;\n\tstruct smb2_oplock_break *req = NULL;\n\n\tcifs_dbg(FYI, \"SMB2_oplock_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\n\tif (rc)\n\t\treturn rc;\n\n\treq->VolatileFid = volatile_fid;\n\treq->PersistentFid = persistent_fid;\n\treq->OplockLevel = oplock_level;\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\n\t/* SMB2 buffer freed by function above */\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Oplock Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_set_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2385-2394",
    "snippet": "int\nSMB2_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, FILE_BASIC_INFO *buf)\n{\n\tunsigned int size;\n\tsize = sizeof(FILE_BASIC_INFO);\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t     current->tgid, FILE_BASIC_INFORMATION, 1,\n\t\t\t     (void **)&buf, &size);\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_set_info",
          "args": [
            "xid",
            "tcon",
            "persistent_fid",
            "volatile_fid",
            "current->tgid",
            "FILE_BASIC_INFORMATION",
            "1",
            "(void **)&buf",
            "&size"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "send_set_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2231-2299",
          "snippet": "static int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\n\t       unsigned int num, void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tunsigned int i;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tiov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\trc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tinc_rfc1001_len(req, *size - 1 /* Buffer */);\n\n\tmemcpy(req->Buffer, *data, *size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\tfor (i = 1; i < num; i++) {\n\t\tinc_rfc1001_len(req, size[i]);\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num, &resp_buftype, 0);\n\trsp = (struct smb2_set_info_rsp *)iov[0].iov_base;\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\n\t       unsigned int num, void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tunsigned int i;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tiov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\trc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tinc_rfc1001_len(req, *size - 1 /* Buffer */);\n\n\tmemcpy(req->Buffer, *data, *size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\tfor (i = 1; i < num; i++) {\n\t\tinc_rfc1001_len(req, size[i]);\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num, &resp_buftype, 0);\n\trsp = (struct smb2_set_info_rsp *)iov[0].iov_base;\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, FILE_BASIC_INFO *buf)\n{\n\tunsigned int size;\n\tsize = sizeof(FILE_BASIC_INFO);\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t     current->tgid, FILE_BASIC_INFORMATION, 1,\n\t\t\t     (void **)&buf, &size);\n}"
  },
  {
    "function_name": "SMB2_set_eof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2364-2383",
    "snippet": "int\nSMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t     u64 volatile_fid, u32 pid, __le64 *eof, bool is_falloc)\n{\n\tstruct smb2_file_eof_info info;\n\tvoid *data;\n\tunsigned int size;\n\n\tinfo.EndOfFile = *eof;\n\n\tdata = &info;\n\tsize = sizeof(struct smb2_file_eof_info);\n\n\tif (is_falloc)\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_ALLOCATION_INFORMATION, 1, &data, &size);\n\telse\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_END_OF_FILE_INFORMATION, 1, &data, &size);\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_set_info",
          "args": [
            "xid",
            "tcon",
            "persistent_fid",
            "volatile_fid",
            "pid",
            "FILE_END_OF_FILE_INFORMATION",
            "1",
            "&data",
            "&size"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "send_set_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2231-2299",
          "snippet": "static int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\n\t       unsigned int num, void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tunsigned int i;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tiov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\trc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tinc_rfc1001_len(req, *size - 1 /* Buffer */);\n\n\tmemcpy(req->Buffer, *data, *size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\tfor (i = 1; i < num; i++) {\n\t\tinc_rfc1001_len(req, size[i]);\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num, &resp_buftype, 0);\n\trsp = (struct smb2_set_info_rsp *)iov[0].iov_base;\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\n\t       unsigned int num, void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tunsigned int i;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tiov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\trc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tinc_rfc1001_len(req, *size - 1 /* Buffer */);\n\n\tmemcpy(req->Buffer, *data, *size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\tfor (i = 1; i < num; i++) {\n\t\tinc_rfc1001_len(req, size[i]);\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num, &resp_buftype, 0);\n\trsp = (struct smb2_set_info_rsp *)iov[0].iov_base;\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t     u64 volatile_fid, u32 pid, __le64 *eof, bool is_falloc)\n{\n\tstruct smb2_file_eof_info info;\n\tvoid *data;\n\tunsigned int size;\n\n\tinfo.EndOfFile = *eof;\n\n\tdata = &info;\n\tsize = sizeof(struct smb2_file_eof_info);\n\n\tif (is_falloc)\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_ALLOCATION_INFORMATION, 1, &data, &size);\n\telse\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_END_OF_FILE_INFORMATION, 1, &data, &size);\n}"
  },
  {
    "function_name": "SMB2_set_hardlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2333-2362",
    "snippet": "int\nSMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  u64 persistent_fid, u64 volatile_fid, __le16 *target_file)\n{\n\tstruct smb2_file_link_info info;\n\tvoid **data;\n\tunsigned int size[2];\n\tint rc;\n\tint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\n\n\tdata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinfo.ReplaceIfExists = 0; /* 1 = replace existing link with new */\n\t\t\t      /* 0 = fail if link already exists */\n\tinfo.RootDirectory = 0;  /* MBZ for network ops (why does spec say?) */\n\tinfo.FileNameLength = cpu_to_le32(len);\n\n\tdata[0] = &info;\n\tsize[0] = sizeof(struct smb2_file_link_info);\n\n\tdata[1] = target_file;\n\tsize[1] = len + 2 /* null */;\n\n\trc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t   current->tgid, FILE_LINK_INFORMATION, 2, data, size);\n\tkfree(data);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_set_info",
          "args": [
            "xid",
            "tcon",
            "persistent_fid",
            "volatile_fid",
            "current->tgid",
            "FILE_LINK_INFORMATION",
            "2",
            "data",
            "size"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "send_set_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2231-2299",
          "snippet": "static int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\n\t       unsigned int num, void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tunsigned int i;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tiov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\trc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tinc_rfc1001_len(req, *size - 1 /* Buffer */);\n\n\tmemcpy(req->Buffer, *data, *size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\tfor (i = 1; i < num; i++) {\n\t\tinc_rfc1001_len(req, size[i]);\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num, &resp_buftype, 0);\n\trsp = (struct smb2_set_info_rsp *)iov[0].iov_base;\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\n\t       unsigned int num, void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tunsigned int i;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tiov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\trc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tinc_rfc1001_len(req, *size - 1 /* Buffer */);\n\n\tmemcpy(req->Buffer, *data, *size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\tfor (i = 1; i < num; i++) {\n\t\tinc_rfc1001_len(req, size[i]);\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num, &resp_buftype, 0);\n\trsp = (struct smb2_set_info_rsp *)iov[0].iov_base;\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(void *) * 2",
            "GFP_KERNEL"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UniStrnlen",
          "args": [
            "(wchar_t *)target_file",
            "PATH_MAX"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "UniStrnlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.h",
          "lines": "207-218",
          "snippet": "static inline size_t\nUniStrnlen(const wchar_t *ucs1, int maxlen)\n{\n\tint i = 0;\n\n\twhile (*ucs1++) {\n\t\ti++;\n\t\tif (i >= maxlen)\n\t\t\tbreak;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n#include <asm/byteorder.h>\n\nstatic inline size_t\nUniStrnlen(const wchar_t *ucs1, int maxlen)\n{\n\tint i = 0;\n\n\twhile (*ucs1++) {\n\t\ti++;\n\t\tif (i >= maxlen)\n\t\t\tbreak;\n\t}\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  u64 persistent_fid, u64 volatile_fid, __le16 *target_file)\n{\n\tstruct smb2_file_link_info info;\n\tvoid **data;\n\tunsigned int size[2];\n\tint rc;\n\tint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\n\n\tdata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinfo.ReplaceIfExists = 0; /* 1 = replace existing link with new */\n\t\t\t      /* 0 = fail if link already exists */\n\tinfo.RootDirectory = 0;  /* MBZ for network ops (why does spec say?) */\n\tinfo.FileNameLength = cpu_to_le32(len);\n\n\tdata[0] = &info;\n\tsize[0] = sizeof(struct smb2_file_link_info);\n\n\tdata[1] = target_file;\n\tsize[1] = len + 2 /* null */;\n\n\trc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t   current->tgid, FILE_LINK_INFORMATION, 2, data, size);\n\tkfree(data);\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2301-2331",
    "snippet": "int\nSMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,\n\t    u64 persistent_fid, u64 volatile_fid, __le16 *target_file)\n{\n\tstruct smb2_file_rename_info info;\n\tvoid **data;\n\tunsigned int size[2];\n\tint rc;\n\tint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\n\n\tdata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinfo.ReplaceIfExists = 1; /* 1 = replace existing target with new */\n\t\t\t      /* 0 = fail if target already exists */\n\tinfo.RootDirectory = 0;  /* MBZ for network ops (why does spec say?) */\n\tinfo.FileNameLength = cpu_to_le32(len);\n\n\tdata[0] = &info;\n\tsize[0] = sizeof(struct smb2_file_rename_info);\n\n\tdata[1] = target_file;\n\tsize[1] = len + 2 /* null */;\n\n\trc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t   current->tgid, FILE_RENAME_INFORMATION, 2, data,\n\t\t\t   size);\n\tkfree(data);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_set_info",
          "args": [
            "xid",
            "tcon",
            "persistent_fid",
            "volatile_fid",
            "current->tgid",
            "FILE_RENAME_INFORMATION",
            "2",
            "data",
            "size"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "send_set_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2231-2299",
          "snippet": "static int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\n\t       unsigned int num, void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tunsigned int i;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tiov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\trc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tinc_rfc1001_len(req, *size - 1 /* Buffer */);\n\n\tmemcpy(req->Buffer, *data, *size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\tfor (i = 1; i < num; i++) {\n\t\tinc_rfc1001_len(req, size[i]);\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num, &resp_buftype, 0);\n\trsp = (struct smb2_set_info_rsp *)iov[0].iov_base;\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\n\t       unsigned int num, void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tunsigned int i;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tiov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\trc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tinc_rfc1001_len(req, *size - 1 /* Buffer */);\n\n\tmemcpy(req->Buffer, *data, *size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\tfor (i = 1; i < num; i++) {\n\t\tinc_rfc1001_len(req, size[i]);\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num, &resp_buftype, 0);\n\trsp = (struct smb2_set_info_rsp *)iov[0].iov_base;\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(void *) * 2",
            "GFP_KERNEL"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UniStrnlen",
          "args": [
            "(wchar_t *)target_file",
            "PATH_MAX"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "UniStrnlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.h",
          "lines": "207-218",
          "snippet": "static inline size_t\nUniStrnlen(const wchar_t *ucs1, int maxlen)\n{\n\tint i = 0;\n\n\twhile (*ucs1++) {\n\t\ti++;\n\t\tif (i >= maxlen)\n\t\t\tbreak;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n#include <asm/byteorder.h>\n\nstatic inline size_t\nUniStrnlen(const wchar_t *ucs1, int maxlen)\n{\n\tint i = 0;\n\n\twhile (*ucs1++) {\n\t\ti++;\n\t\tif (i >= maxlen)\n\t\t\tbreak;\n\t}\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,\n\t    u64 persistent_fid, u64 volatile_fid, __le16 *target_file)\n{\n\tstruct smb2_file_rename_info info;\n\tvoid **data;\n\tunsigned int size[2];\n\tint rc;\n\tint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\n\n\tdata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinfo.ReplaceIfExists = 1; /* 1 = replace existing target with new */\n\t\t\t      /* 0 = fail if target already exists */\n\tinfo.RootDirectory = 0;  /* MBZ for network ops (why does spec say?) */\n\tinfo.FileNameLength = cpu_to_le32(len);\n\n\tdata[0] = &info;\n\tsize[0] = sizeof(struct smb2_file_rename_info);\n\n\tdata[1] = target_file;\n\tsize[1] = len + 2 /* null */;\n\n\trc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t   current->tgid, FILE_RENAME_INFORMATION, 2, data,\n\t\t\t   size);\n\tkfree(data);\n\treturn rc;\n}"
  },
  {
    "function_name": "send_set_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2231-2299",
    "snippet": "static int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\n\t       unsigned int num, void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tunsigned int i;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tiov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\trc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tinc_rfc1001_len(req, *size - 1 /* Buffer */);\n\n\tmemcpy(req->Buffer, *data, *size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\tfor (i = 1; i < num; i++) {\n\t\tinc_rfc1001_len(req, size[i]);\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num, &resp_buftype, 0);\n\trsp = (struct smb2_set_info_rsp *)iov[0].iov_base;\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iov"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "rsp"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_SET_INFO_HE"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "iov",
            "num",
            "&resp_buftype",
            "0"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&req->BufferLength",
            "size[i]"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "req",
            "size[i]"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "req->Buffer",
            "*data",
            "*size"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "*size"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sizeof(struct smb2_set_info_req) - 1 - 4"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "pid"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iov"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_SET_INFO",
            "tcon",
            "(void **) &req"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct kvec) * num",
            "GFP_KERNEL"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\n\t       unsigned int num, void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tunsigned int i;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tiov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\trc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\treq->hdr.ProcessId = cpu_to_le32(pid);\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tinc_rfc1001_len(req, *size - 1 /* Buffer */);\n\n\tmemcpy(req->Buffer, *data, *size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\tfor (i = 1; i < num; i++) {\n\t\tinc_rfc1001_len(req, size[i]);\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num, &resp_buftype, 0);\n\trsp = (struct smb2_set_info_rsp *)iov[0].iov_base;\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_query_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2107-2229",
    "snippet": "int\nSMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid, int index,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\tstruct smb2_query_directory_req *req;\n\tstruct smb2_query_directory_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint len;\n\tint resp_buftype;\n\tunsigned char *bufptr;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\t__le16 asteriks = cpu_to_le16('*');\n\tchar *end_of_smb;\n\tunsigned int output_size = CIFSMaxBufSize;\n\tsize_t info_buf_size;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_DIRECTORY, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (srch_inf->info_level) {\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\treq->FileInformationClass = FILE_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(FILE_DIRECTORY_INFO) - 1;\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\treq->FileInformationClass = FILEID_FULL_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(SEARCH_ID_FULL_DIR_INFO) - 1;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"info level %u isn't supported\\n\",\n\t\t\t srch_inf->info_level);\n\t\trc = -EINVAL;\n\t\tgoto qdir_exit;\n\t}\n\n\treq->FileIndex = cpu_to_le32(index);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tlen = 0x2;\n\tbufptr = req->Buffer;\n\tmemcpy(bufptr, &asteriks, len);\n\n\treq->FileNameOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_directory_req) - 1 - 4);\n\treq->FileNameLength = cpu_to_le16(len);\n\t/*\n\t * BB could be 30 bytes or so longer if we used SMB2 specific\n\t * buffer lengths, but this is safe and close enough.\n\t */\n\toutput_size = min_t(unsigned int, output_size, server->maxBuf);\n\toutput_size = min_t(unsigned int, output_size, 2 << 15);\n\treq->OutputBufferLength = cpu_to_le32(output_size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\tiov[1].iov_base = (char *)(req->Buffer);\n\tiov[1].iov_len = len;\n\n\tinc_rfc1001_len(req, len - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\n\trsp = (struct smb2_query_directory_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tif (rc == -ENODATA && rsp->hdr.Status == STATUS_NO_MORE_FILES) {\n\t\t\tsrch_inf->endOfSearch = true;\n\t\t\trc = 0;\n\t\t}\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_DIRECTORY_HE);\n\t\tgoto qdir_exit;\n\t}\n\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  info_buf_size);\n\tif (rc)\n\t\tgoto qdir_exit;\n\n\tsrch_inf->unicode = true;\n\n\tif (srch_inf->ntwrk_buf_start) {\n\t\tif (srch_inf->smallBuf)\n\t\t\tcifs_small_buf_release(srch_inf->ntwrk_buf_start);\n\t\telse\n\t\t\tcifs_buf_release(srch_inf->ntwrk_buf_start);\n\t}\n\tsrch_inf->ntwrk_buf_start = (char *)rsp;\n\tsrch_inf->srch_entries_start = srch_inf->last_entry = 4 /* rfclen */ +\n\t\t(char *)&rsp->hdr + le16_to_cpu(rsp->OutputBufferOffset);\n\t/* 4 for rfc1002 length field */\n\tend_of_smb = get_rfc1002_length(rsp) + 4 + (char *)&rsp->hdr;\n\tsrch_inf->entries_in_buffer =\n\t\t\tnum_entries(srch_inf->srch_entries_start, end_of_smb,\n\t\t\t\t    &srch_inf->last_entry, info_buf_size);\n\tsrch_inf->index_of_last_entry += srch_inf->entries_in_buffer;\n\tcifs_dbg(FYI, \"num entries %d last_index %lld srch start %p srch end %p\\n\",\n\t\t srch_inf->entries_in_buffer, srch_inf->index_of_last_entry,\n\t\t srch_inf->srch_entries_start, srch_inf->last_entry);\n\tif (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tsrch_inf->smallBuf = false;\n\telse if (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tsrch_inf->smallBuf = true;\n\telse\n\t\tcifs_dbg(VFS, \"illegal search buffer type\\n\");\n\n\treturn rc;\n\nqdir_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "rsp"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"illegal search buffer type\\n\""
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"num entries %d last_index %lld srch start %p srch end %p\\n\"",
            "srch_inf->entries_in_buffer",
            "srch_inf->index_of_last_entry",
            "srch_inf->srch_entries_start",
            "srch_inf->last_entry"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_entries",
          "args": [
            "srch_inf->srch_entries_start",
            "end_of_smb",
            "&srch_inf->last_entry",
            "info_buf_size"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "num_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2064-2102",
          "snippet": "static unsigned int\nnum_entries(char *bufstart, char *end_of_buf, char **lastentry, size_t size)\n{\n\tint len;\n\tunsigned int entrycount = 0;\n\tunsigned int next_offset = 0;\n\tFILE_DIRECTORY_INFO *entryptr;\n\n\tif (bufstart == NULL)\n\t\treturn 0;\n\n\tentryptr = (FILE_DIRECTORY_INFO *)bufstart;\n\n\twhile (1) {\n\t\tentryptr = (FILE_DIRECTORY_INFO *)\n\t\t\t\t\t((char *)entryptr + next_offset);\n\n\t\tif ((char *)entryptr + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"malformed search entry would overflow\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = le32_to_cpu(entryptr->FileNameLength);\n\t\tif ((char *)entryptr + len + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"directory entry name would overflow frame end of buf %p\\n\",\n\t\t\t\t end_of_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\t*lastentry = (char *)entryptr;\n\t\tentrycount++;\n\n\t\tnext_offset = le32_to_cpu(entryptr->NextEntryOffset);\n\t\tif (!next_offset)\n\t\t\tbreak;\n\t}\n\n\treturn entrycount;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic unsigned int\nnum_entries(char *bufstart, char *end_of_buf, char **lastentry, size_t size)\n{\n\tint len;\n\tunsigned int entrycount = 0;\n\tunsigned int next_offset = 0;\n\tFILE_DIRECTORY_INFO *entryptr;\n\n\tif (bufstart == NULL)\n\t\treturn 0;\n\n\tentryptr = (FILE_DIRECTORY_INFO *)bufstart;\n\n\twhile (1) {\n\t\tentryptr = (FILE_DIRECTORY_INFO *)\n\t\t\t\t\t((char *)entryptr + next_offset);\n\n\t\tif ((char *)entryptr + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"malformed search entry would overflow\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = le32_to_cpu(entryptr->FileNameLength);\n\t\tif ((char *)entryptr + len + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"directory entry name would overflow frame end of buf %p\\n\",\n\t\t\t\t end_of_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\t*lastentry = (char *)entryptr;\n\t\tentrycount++;\n\n\t\tnext_offset = le32_to_cpu(entryptr->NextEntryOffset);\n\t\tif (!next_offset)\n\t\t\tbreak;\n\t}\n\n\treturn entrycount;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "rsp"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rsp->OutputBufferOffset"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "srch_inf->ntwrk_buf_start"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "srch_inf->ntwrk_buf_start"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_buf",
          "args": [
            "le16_to_cpu(rsp->OutputBufferOffset)",
            "le32_to_cpu(rsp->OutputBufferLength)",
            "&rsp->hdr",
            "info_buf_size"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "validate_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1418-1448",
          "snippet": "static int\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\n\t     struct smb2_hdr *hdr, unsigned int min_buf_size)\n\n{\n\tunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\n\tchar *end_of_smb = smb_len + 4 /* RFC1001 length field */ + (char *)hdr;\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"illegal server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\n\t     struct smb2_hdr *hdr, unsigned int min_buf_size)\n\n{\n\tunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\n\tchar *end_of_smb = smb_len + 4 /* RFC1001 length field */ + (char *)hdr;\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"illegal server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rsp->OutputBufferLength"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_QUERY_DIRECTORY_HE"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "iov",
            "2",
            "&resp_buftype",
            "0"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "req",
            "len - 1/* Buffer */"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "output_size"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "output_size",
            "2 << 15"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "output_size",
            "server->maxBuf"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sizeof(struct smb2_query_directory_req) - 1 - 4"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bufptr",
            "&asteriks",
            "len"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "index"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"info level %u isn't supported\\n\"",
            "srch_inf->info_level"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_QUERY_DIRECTORY",
            "tcon",
            "(void **) &req"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'*'"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid, int index,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\tstruct smb2_query_directory_req *req;\n\tstruct smb2_query_directory_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint len;\n\tint resp_buftype;\n\tunsigned char *bufptr;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\t__le16 asteriks = cpu_to_le16('*');\n\tchar *end_of_smb;\n\tunsigned int output_size = CIFSMaxBufSize;\n\tsize_t info_buf_size;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_DIRECTORY, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (srch_inf->info_level) {\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\treq->FileInformationClass = FILE_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(FILE_DIRECTORY_INFO) - 1;\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\treq->FileInformationClass = FILEID_FULL_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(SEARCH_ID_FULL_DIR_INFO) - 1;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"info level %u isn't supported\\n\",\n\t\t\t srch_inf->info_level);\n\t\trc = -EINVAL;\n\t\tgoto qdir_exit;\n\t}\n\n\treq->FileIndex = cpu_to_le32(index);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tlen = 0x2;\n\tbufptr = req->Buffer;\n\tmemcpy(bufptr, &asteriks, len);\n\n\treq->FileNameOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_directory_req) - 1 - 4);\n\treq->FileNameLength = cpu_to_le16(len);\n\t/*\n\t * BB could be 30 bytes or so longer if we used SMB2 specific\n\t * buffer lengths, but this is safe and close enough.\n\t */\n\toutput_size = min_t(unsigned int, output_size, server->maxBuf);\n\toutput_size = min_t(unsigned int, output_size, 2 << 15);\n\treq->OutputBufferLength = cpu_to_le32(output_size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\tiov[1].iov_base = (char *)(req->Buffer);\n\tiov[1].iov_len = len;\n\n\tinc_rfc1001_len(req, len - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\n\trsp = (struct smb2_query_directory_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tif (rc == -ENODATA && rsp->hdr.Status == STATUS_NO_MORE_FILES) {\n\t\t\tsrch_inf->endOfSearch = true;\n\t\t\trc = 0;\n\t\t}\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_DIRECTORY_HE);\n\t\tgoto qdir_exit;\n\t}\n\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  info_buf_size);\n\tif (rc)\n\t\tgoto qdir_exit;\n\n\tsrch_inf->unicode = true;\n\n\tif (srch_inf->ntwrk_buf_start) {\n\t\tif (srch_inf->smallBuf)\n\t\t\tcifs_small_buf_release(srch_inf->ntwrk_buf_start);\n\t\telse\n\t\t\tcifs_buf_release(srch_inf->ntwrk_buf_start);\n\t}\n\tsrch_inf->ntwrk_buf_start = (char *)rsp;\n\tsrch_inf->srch_entries_start = srch_inf->last_entry = 4 /* rfclen */ +\n\t\t(char *)&rsp->hdr + le16_to_cpu(rsp->OutputBufferOffset);\n\t/* 4 for rfc1002 length field */\n\tend_of_smb = get_rfc1002_length(rsp) + 4 + (char *)&rsp->hdr;\n\tsrch_inf->entries_in_buffer =\n\t\t\tnum_entries(srch_inf->srch_entries_start, end_of_smb,\n\t\t\t\t    &srch_inf->last_entry, info_buf_size);\n\tsrch_inf->index_of_last_entry += srch_inf->entries_in_buffer;\n\tcifs_dbg(FYI, \"num entries %d last_index %lld srch start %p srch end %p\\n\",\n\t\t srch_inf->entries_in_buffer, srch_inf->index_of_last_entry,\n\t\t srch_inf->srch_entries_start, srch_inf->last_entry);\n\tif (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tsrch_inf->smallBuf = false;\n\telse if (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tsrch_inf->smallBuf = true;\n\telse\n\t\tcifs_dbg(VFS, \"illegal search buffer type\\n\");\n\n\treturn rc;\n\nqdir_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
  },
  {
    "function_name": "num_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2064-2102",
    "snippet": "static unsigned int\nnum_entries(char *bufstart, char *end_of_buf, char **lastentry, size_t size)\n{\n\tint len;\n\tunsigned int entrycount = 0;\n\tunsigned int next_offset = 0;\n\tFILE_DIRECTORY_INFO *entryptr;\n\n\tif (bufstart == NULL)\n\t\treturn 0;\n\n\tentryptr = (FILE_DIRECTORY_INFO *)bufstart;\n\n\twhile (1) {\n\t\tentryptr = (FILE_DIRECTORY_INFO *)\n\t\t\t\t\t((char *)entryptr + next_offset);\n\n\t\tif ((char *)entryptr + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"malformed search entry would overflow\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = le32_to_cpu(entryptr->FileNameLength);\n\t\tif ((char *)entryptr + len + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"directory entry name would overflow frame end of buf %p\\n\",\n\t\t\t\t end_of_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\t*lastentry = (char *)entryptr;\n\t\tentrycount++;\n\n\t\tnext_offset = le32_to_cpu(entryptr->NextEntryOffset);\n\t\tif (!next_offset)\n\t\t\tbreak;\n\t}\n\n\treturn entrycount;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entryptr->NextEntryOffset"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"directory entry name would overflow frame end of buf %p\\n\"",
            "end_of_buf"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"malformed search entry would overflow\\n\""
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic unsigned int\nnum_entries(char *bufstart, char *end_of_buf, char **lastentry, size_t size)\n{\n\tint len;\n\tunsigned int entrycount = 0;\n\tunsigned int next_offset = 0;\n\tFILE_DIRECTORY_INFO *entryptr;\n\n\tif (bufstart == NULL)\n\t\treturn 0;\n\n\tentryptr = (FILE_DIRECTORY_INFO *)bufstart;\n\n\twhile (1) {\n\t\tentryptr = (FILE_DIRECTORY_INFO *)\n\t\t\t\t\t((char *)entryptr + next_offset);\n\n\t\tif ((char *)entryptr + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"malformed search entry would overflow\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = le32_to_cpu(entryptr->FileNameLength);\n\t\tif ((char *)entryptr + len + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"directory entry name would overflow frame end of buf %p\\n\",\n\t\t\t\t end_of_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\t*lastentry = (char *)entryptr;\n\t\tentrycount++;\n\n\t\tnext_offset = le32_to_cpu(entryptr->NextEntryOffset);\n\t\tif (!next_offset)\n\t\t\tbreak;\n\t}\n\n\treturn entrycount;\n}"
  },
  {
    "function_name": "SMB2_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "2009-2062",
    "snippet": "int\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = small_smb2_init(SMB2_WRITE, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\treq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\t/* 4 for rfc1002 length field */\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer) - 4);\n\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* length of entire message including data to be written */\n\tinc_rfc1001_len(req, io_parms->length - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, n_vec + 1,\n\t\t\t  &resp_buftype, 0);\n\trsp = (struct smb2_write_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "rsp"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rsp->DataLength"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Send error in write = %d\\n\"",
            "rc"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "io_parms->tcon",
            "SMB2_WRITE_HE"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "io_parms->tcon->ses",
            "iov",
            "n_vec + 1",
            "&resp_buftype",
            "0"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "req",
            "io_parms->length - 1/* Buffer */"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct smb2_write_req, Buffer) - 4"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "io_parms->offset"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "io_parms->length"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "io_parms->pid"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_WRITE",
            "io_parms->tcon",
            "(void **) &req"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = small_smb2_init(SMB2_WRITE, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\treq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\t/* 4 for rfc1002 length field */\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer) - 4);\n\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* length of entire message including data to be written */\n\tinc_rfc1001_len(req, io_parms->length - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, n_vec + 1,\n\t\t\t  &resp_buftype, 0);\n\trsp = (struct smb2_write_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_async_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1923-2001",
    "snippet": "int\nsmb2_async_writev(struct cifs_writedata *wdata,\n\t\t  void (*release)(struct kref *kref))\n{\n\tint rc = -EACCES, flags = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct kvec iov;\n\tstruct smb_rqst rqst;\n\n\trc = small_smb2_init(SMB2_WRITE, tcon, (void **) &req);\n\tif (rc) {\n\t\tif (rc == -EAGAIN && wdata->credits) {\n\t\t\t/* credits was reset by reconnect */\n\t\t\twdata->credits = 0;\n\t\t\t/* reduce in_flight value since we won't send the req */\n\t\t\tspin_lock(&server->req_lock);\n\t\t\tserver->in_flight--;\n\t\t\tspin_unlock(&server->req_lock);\n\t\t}\n\t\tgoto async_writev_out;\n\t}\n\n\treq->hdr.ProcessId = cpu_to_le32(wdata->cfile->pid);\n\n\treq->PersistentFileId = wdata->cfile->fid.persistent_fid;\n\treq->VolatileFileId = wdata->cfile->fid.volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Offset = cpu_to_le64(wdata->offset);\n\t/* 4 for rfc1002 length field */\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer) - 4);\n\treq->RemainingBytes = 0;\n\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\tiov.iov_len = get_rfc1002_length(req) + 4 - 1;\n\tiov.iov_base = req;\n\n\trqst.rq_iov = &iov;\n\trqst.rq_nvec = 1;\n\trqst.rq_pages = wdata->pages;\n\trqst.rq_npages = wdata->nr_pages;\n\trqst.rq_pagesz = wdata->pagesz;\n\trqst.rq_tailsz = wdata->tailsz;\n\n\tcifs_dbg(FYI, \"async write at %llu %u bytes\\n\",\n\t\t wdata->offset, wdata->bytes);\n\n\treq->Length = cpu_to_le32(wdata->bytes);\n\n\tinc_rfc1001_len(&req->hdr, wdata->bytes - 1 /* Buffer */);\n\n\tif (wdata->credits) {\n\t\treq->hdr.CreditCharge = cpu_to_le16(DIV_ROUND_UP(wdata->bytes,\n\t\t\t\t\t\t    SMB2_MAX_BUFFER_SIZE));\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += wdata->credits -\n\t\t\t\t\tle16_to_cpu(req->hdr.CreditCharge);\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\t\tflags = CIFS_HAS_CREDITS;\n\t}\n\n\tkref_get(&wdata->refcount);\n\trc = cifs_call_async(server, &rqst, NULL, smb2_writev_callback, wdata,\n\t\t\t     flags);\n\n\tif (rc) {\n\t\tkref_put(&wdata->refcount, release);\n\t\tcifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\n\t}\n\nasync_writev_out:\n\tcifs_small_buf_release(req);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "req"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_WRITE_HE"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wdata->refcount",
            "release"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_call_async",
          "args": [
            "server",
            "&rqst",
            "NULL",
            "smb2_writev_callback",
            "wdata",
            "flags"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_call_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "536-589",
          "snippet": "int\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&wdata->refcount"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&server->request_q"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_wake_up_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "40-44",
          "snippet": "void\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->req_lock"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "req->hdr.CreditCharge"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->req_lock"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "DIV_ROUND_UP(wdata->bytes,\n\t\t\t\t\t\t    SMB2_MAX_BUFFER_SIZE)"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "wdata->bytes",
            "SMB2_MAX_BUFFER_SIZE"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "&req->hdr",
            "wdata->bytes - 1/* Buffer */"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "wdata->bytes"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"async write at %llu %u bytes\\n\"",
            "wdata->offset",
            "wdata->bytes"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct smb2_write_req, Buffer) - 4"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "wdata->offset"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "wdata->cfile->pid"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_WRITE",
            "tcon",
            "(void **) &req"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "wdata->cfile->tlink"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmb2_async_writev(struct cifs_writedata *wdata,\n\t\t  void (*release)(struct kref *kref))\n{\n\tint rc = -EACCES, flags = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct kvec iov;\n\tstruct smb_rqst rqst;\n\n\trc = small_smb2_init(SMB2_WRITE, tcon, (void **) &req);\n\tif (rc) {\n\t\tif (rc == -EAGAIN && wdata->credits) {\n\t\t\t/* credits was reset by reconnect */\n\t\t\twdata->credits = 0;\n\t\t\t/* reduce in_flight value since we won't send the req */\n\t\t\tspin_lock(&server->req_lock);\n\t\t\tserver->in_flight--;\n\t\t\tspin_unlock(&server->req_lock);\n\t\t}\n\t\tgoto async_writev_out;\n\t}\n\n\treq->hdr.ProcessId = cpu_to_le32(wdata->cfile->pid);\n\n\treq->PersistentFileId = wdata->cfile->fid.persistent_fid;\n\treq->VolatileFileId = wdata->cfile->fid.volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Offset = cpu_to_le64(wdata->offset);\n\t/* 4 for rfc1002 length field */\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer) - 4);\n\treq->RemainingBytes = 0;\n\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\tiov.iov_len = get_rfc1002_length(req) + 4 - 1;\n\tiov.iov_base = req;\n\n\trqst.rq_iov = &iov;\n\trqst.rq_nvec = 1;\n\trqst.rq_pages = wdata->pages;\n\trqst.rq_npages = wdata->nr_pages;\n\trqst.rq_pagesz = wdata->pagesz;\n\trqst.rq_tailsz = wdata->tailsz;\n\n\tcifs_dbg(FYI, \"async write at %llu %u bytes\\n\",\n\t\t wdata->offset, wdata->bytes);\n\n\treq->Length = cpu_to_le32(wdata->bytes);\n\n\tinc_rfc1001_len(&req->hdr, wdata->bytes - 1 /* Buffer */);\n\n\tif (wdata->credits) {\n\t\treq->hdr.CreditCharge = cpu_to_le16(DIV_ROUND_UP(wdata->bytes,\n\t\t\t\t\t\t    SMB2_MAX_BUFFER_SIZE));\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += wdata->credits -\n\t\t\t\t\tle16_to_cpu(req->hdr.CreditCharge);\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\t\tflags = CIFS_HAS_CREDITS;\n\t}\n\n\tkref_get(&wdata->refcount);\n\trc = cifs_call_async(server, &rqst, NULL, smb2_writev_callback, wdata,\n\t\t\t     flags);\n\n\tif (rc) {\n\t\tkref_put(&wdata->refcount, release);\n\t\tcifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\n\t}\n\nasync_writev_out:\n\tcifs_small_buf_release(req);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_writev_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1874-1920",
    "snippet": "static void\nsmb2_writev_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_writedata *wdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tunsigned int written;\n\tstruct smb2_write_rsp *rsp = (struct smb2_write_rsp *)mid->resp_buf;\n\tunsigned int credits_received = 1;\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tcredits_received = le16_to_cpu(rsp->hdr.CreditRequest);\n\t\twdata->result = smb2_check_receive(mid, tcon->ses->server, 0);\n\t\tif (wdata->result != 0)\n\t\t\tbreak;\n\n\t\twritten = le32_to_cpu(rsp->DataLength);\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned\n\t\t * by the server is greater than bytes requested by the\n\t\t * client. OS/2 servers are known to set incorrect\n\t\t * CountHigh values.\n\t\t */\n\t\tif (written > wdata->bytes)\n\t\t\twritten &= 0xFFFF;\n\n\t\tif (written < wdata->bytes)\n\t\t\twdata->result = -ENOSPC;\n\t\telse\n\t\t\twdata->bytes = written;\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\twdata->result = -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\twdata->result = -EIO;\n\t\tbreak;\n\t}\n\n\tif (wdata->result)\n\t\tcifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\n\n\tqueue_work(cifsiod_wq, &wdata->work);\n\tDeleteMidQEntry(mid);\n\tadd_credits(tcon->ses->server, credits_received, 0);\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_credits",
          "args": [
            "tcon->ses->server",
            "credits_received",
            "0"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_add_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "116-125",
          "snippet": "static void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeleteMidQEntry",
          "args": [
            "mid"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteMidQEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "83-112",
          "snippet": "void\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "cifsiod_wq",
            "&wdata->work"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_WRITE_HE"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rsp->DataLength"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb2_check_receive",
          "args": [
            "mid",
            "tcon->ses->server",
            "0"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_check_receive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2transport.c",
          "lines": "546-570",
          "snippet": "int\nsmb2_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t   bool log_error)\n{\n\tunsigned int len = get_rfc1002_length(mid->resp_buf);\n\tstruct kvec iov;\n\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t .rq_nvec = 1 };\n\n\tiov.iov_base = (char *)mid->resp_buf;\n\tiov.iov_len = get_rfc1002_length(mid->resp_buf) + 4;\n\n\tdump_smb(mid->resp_buf, min_t(u32, 80, len));\n\t/* convert the length into a more usable form */\n\tif (len > 24 && server->sign) {\n\t\tint rc;\n\n\t\trc = smb2_verify_signature(&rqst, server);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\treturn map_smb2_to_linux_error(mid->resp_buf, log_error);\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/highmem.h>\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nsmb2_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t   bool log_error)\n{\n\tunsigned int len = get_rfc1002_length(mid->resp_buf);\n\tstruct kvec iov;\n\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t .rq_nvec = 1 };\n\n\tiov.iov_base = (char *)mid->resp_buf;\n\tiov.iov_len = get_rfc1002_length(mid->resp_buf) + 4;\n\n\tdump_smb(mid->resp_buf, min_t(u32, 80, len));\n\t/* convert the length into a more usable form */\n\tif (len > 24 && server->sign) {\n\t\tint rc;\n\n\t\trc = smb2_verify_signature(&rqst, server);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\treturn map_smb2_to_linux_error(mid->resp_buf, log_error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rsp->hdr.CreditRequest"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "wdata->cfile->tlink"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\nsmb2_writev_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_writedata *wdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tunsigned int written;\n\tstruct smb2_write_rsp *rsp = (struct smb2_write_rsp *)mid->resp_buf;\n\tunsigned int credits_received = 1;\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tcredits_received = le16_to_cpu(rsp->hdr.CreditRequest);\n\t\twdata->result = smb2_check_receive(mid, tcon->ses->server, 0);\n\t\tif (wdata->result != 0)\n\t\t\tbreak;\n\n\t\twritten = le32_to_cpu(rsp->DataLength);\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned\n\t\t * by the server is greater than bytes requested by the\n\t\t * client. OS/2 servers are known to set incorrect\n\t\t * CountHigh values.\n\t\t */\n\t\tif (written > wdata->bytes)\n\t\t\twritten &= 0xFFFF;\n\n\t\tif (written < wdata->bytes)\n\t\t\twdata->result = -ENOSPC;\n\t\telse\n\t\t\twdata->bytes = written;\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\twdata->result = -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\twdata->result = -EIO;\n\t\tbreak;\n\t}\n\n\tif (wdata->result)\n\t\tcifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\n\n\tqueue_work(cifsiod_wq, &wdata->work);\n\tDeleteMidQEntry(mid);\n\tadd_credits(tcon->ses->server, credits_received, 0);\n}"
  },
  {
    "function_name": "SMB2_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1819-1868",
    "snippet": "int\nSMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req(iov, io_parms, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, 1,\n\t\t\t  &resp_buftype, CIFS_LOG_ERROR);\n\n\trsp = (struct smb2_read_rsp *)iov[0].iov_base;\n\n\tif (rsp->hdr.Status == STATUS_END_OF_FILE) {\n\t\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\t\treturn 0;\n\t}\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t\t    (*nbytes > io_parms->length)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t *nbytes, io_parms->length);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t}\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp->hdr.ProtocolId + rsp->DataOffset,\n\t\t       *nbytes);\n\t\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "iov[0].iov_base"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*buf",
            "(char *)rsp->hdr.ProtocolId + rsp->DataOffset",
            "*nbytes"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"bad length %d for count %d\\n\"",
            "*nbytes",
            "io_parms->length"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rsp->DataLength"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Send error in read = %d\\n\"",
            "rc"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "io_parms->tcon",
            "SMB2_READ_HE"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "io_parms->tcon->ses",
            "iov",
            "1",
            "&resp_buftype",
            "CIFS_LOG_ERROR"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb2_new_read_req",
          "args": [
            "iov",
            "io_parms",
            "0",
            "0"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_new_read_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1643-1695",
          "snippet": "static int\nsmb2_new_read_req(struct kvec *iov, struct cifs_io_parms *io_parms,\n\t\t  unsigned int remaining_bytes, int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_req *req = NULL;\n\n\trc = small_smb2_init(SMB2_READ, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\treq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0; /* reserved */\n\treq->ReadChannelInfoLength = 0; /* reserved */\n\treq->Channel = 0; /* reserved */\n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t/* 4 for rfc1002 length field */\n\t\t\treq->hdr.NextCommand =\n\t\t\t\tcpu_to_le32(get_rfc1002_length(req) + 4);\n\t\t} else /* END_OF_CHAIN */\n\t\t\treq->hdr.NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t/*\n\t\t\t * Related requests use info from previous read request\n\t\t\t * in chain.\n\t\t\t */\n\t\t\treq->hdr.SessionId = 0xFFFFFFFF;\n\t\t\treq->hdr.TreeId = 0xFFFFFFFF;\n\t\t\treq->PersistentFileId = 0xFFFFFFFF;\n\t\t\treq->VolatileFileId = 0xFFFFFFFF;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_new_read_req(struct kvec *iov, struct cifs_io_parms *io_parms,\n\t\t  unsigned int remaining_bytes, int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_req *req = NULL;\n\n\trc = small_smb2_init(SMB2_READ, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\treq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0; /* reserved */\n\treq->ReadChannelInfoLength = 0; /* reserved */\n\treq->Channel = 0; /* reserved */\n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t/* 4 for rfc1002 length field */\n\t\t\treq->hdr.NextCommand =\n\t\t\t\tcpu_to_le32(get_rfc1002_length(req) + 4);\n\t\t} else /* END_OF_CHAIN */\n\t\t\treq->hdr.NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t/*\n\t\t\t * Related requests use info from previous read request\n\t\t\t * in chain.\n\t\t\t */\n\t\t\treq->hdr.SessionId = 0xFFFFFFFF;\n\t\t\treq->hdr.TreeId = 0xFFFFFFFF;\n\t\t\treq->PersistentFileId = 0xFFFFFFFF;\n\t\t\treq->VolatileFileId = 0xFFFFFFFF;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req(iov, io_parms, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, 1,\n\t\t\t  &resp_buftype, CIFS_LOG_ERROR);\n\n\trsp = (struct smb2_read_rsp *)iov[0].iov_base;\n\n\tif (rsp->hdr.Status == STATUS_END_OF_FILE) {\n\t\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\t\treturn 0;\n\t}\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t\t    (*nbytes > io_parms->length)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t *nbytes, io_parms->length);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t}\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp->hdr.ProtocolId + rsp->DataOffset,\n\t\t       *nbytes);\n\t\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_async_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1756-1817",
    "snippet": "int\nsmb2_async_readv(struct cifs_readdata *rdata)\n{\n\tint rc, flags = 0;\n\tstruct smb2_hdr *buf;\n\tstruct cifs_io_parms io_parms;\n\tstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\n\t\t\t\t .rq_nvec = 1 };\n\tstruct TCP_Server_Info *server;\n\n\tcifs_dbg(FYI, \"%s: offset=%llu bytes=%u\\n\",\n\t\t __func__, rdata->offset, rdata->bytes);\n\n\tio_parms.tcon = tlink_tcon(rdata->cfile->tlink);\n\tio_parms.offset = rdata->offset;\n\tio_parms.length = rdata->bytes;\n\tio_parms.persistent_fid = rdata->cfile->fid.persistent_fid;\n\tio_parms.volatile_fid = rdata->cfile->fid.volatile_fid;\n\tio_parms.pid = rdata->pid;\n\n\tserver = io_parms.tcon->ses->server;\n\n\trc = smb2_new_read_req(&rdata->iov, &io_parms, 0, 0);\n\tif (rc) {\n\t\tif (rc == -EAGAIN && rdata->credits) {\n\t\t\t/* credits was reset by reconnect */\n\t\t\trdata->credits = 0;\n\t\t\t/* reduce in_flight value since we won't send the req */\n\t\t\tspin_lock(&server->req_lock);\n\t\t\tserver->in_flight--;\n\t\t\tspin_unlock(&server->req_lock);\n\t\t}\n\t\treturn rc;\n\t}\n\n\tbuf = (struct smb2_hdr *)rdata->iov.iov_base;\n\t/* 4 for rfc1002 length field */\n\trdata->iov.iov_len = get_rfc1002_length(rdata->iov.iov_base) + 4;\n\n\tif (rdata->credits) {\n\t\tbuf->CreditCharge = cpu_to_le16(DIV_ROUND_UP(rdata->bytes,\n\t\t\t\t\t\tSMB2_MAX_BUFFER_SIZE));\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += rdata->credits -\n\t\t\t\t\t\tle16_to_cpu(buf->CreditCharge);\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\t\tflags = CIFS_HAS_CREDITS;\n\t}\n\n\tkref_get(&rdata->refcount);\n\trc = cifs_call_async(io_parms.tcon->ses->server, &rqst,\n\t\t\t     cifs_readv_receive, smb2_readv_callback,\n\t\t\t     rdata, flags);\n\tif (rc) {\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t\tcifs_stats_fail_inc(io_parms.tcon, SMB2_READ_HE);\n\t}\n\n\tcifs_small_buf_release(buf);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "buf"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "io_parms.tcon",
            "SMB2_READ_HE"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rdata->refcount",
            "cifs_readdata_release"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_call_async",
          "args": [
            "io_parms.tcon->ses->server",
            "&rqst",
            "cifs_readv_receive",
            "smb2_readv_callback",
            "rdata",
            "flags"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_call_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "536-589",
          "snippet": "int\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&rdata->refcount"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&server->request_q"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_wake_up_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "40-44",
          "snippet": "void\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->req_lock"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "buf->CreditCharge"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->req_lock"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "DIV_ROUND_UP(rdata->bytes,\n\t\t\t\t\t\tSMB2_MAX_BUFFER_SIZE)"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "rdata->bytes",
            "SMB2_MAX_BUFFER_SIZE"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "rdata->iov.iov_base"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb2_new_read_req",
          "args": [
            "&rdata->iov",
            "&io_parms",
            "0",
            "0"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_new_read_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1643-1695",
          "snippet": "static int\nsmb2_new_read_req(struct kvec *iov, struct cifs_io_parms *io_parms,\n\t\t  unsigned int remaining_bytes, int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_req *req = NULL;\n\n\trc = small_smb2_init(SMB2_READ, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\treq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0; /* reserved */\n\treq->ReadChannelInfoLength = 0; /* reserved */\n\treq->Channel = 0; /* reserved */\n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t/* 4 for rfc1002 length field */\n\t\t\treq->hdr.NextCommand =\n\t\t\t\tcpu_to_le32(get_rfc1002_length(req) + 4);\n\t\t} else /* END_OF_CHAIN */\n\t\t\treq->hdr.NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t/*\n\t\t\t * Related requests use info from previous read request\n\t\t\t * in chain.\n\t\t\t */\n\t\t\treq->hdr.SessionId = 0xFFFFFFFF;\n\t\t\treq->hdr.TreeId = 0xFFFFFFFF;\n\t\t\treq->PersistentFileId = 0xFFFFFFFF;\n\t\t\treq->VolatileFileId = 0xFFFFFFFF;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_new_read_req(struct kvec *iov, struct cifs_io_parms *io_parms,\n\t\t  unsigned int remaining_bytes, int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_req *req = NULL;\n\n\trc = small_smb2_init(SMB2_READ, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\treq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0; /* reserved */\n\treq->ReadChannelInfoLength = 0; /* reserved */\n\treq->Channel = 0; /* reserved */\n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t/* 4 for rfc1002 length field */\n\t\t\treq->hdr.NextCommand =\n\t\t\t\tcpu_to_le32(get_rfc1002_length(req) + 4);\n\t\t} else /* END_OF_CHAIN */\n\t\t\treq->hdr.NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t/*\n\t\t\t * Related requests use info from previous read request\n\t\t\t * in chain.\n\t\t\t */\n\t\t\treq->hdr.SessionId = 0xFFFFFFFF;\n\t\t\treq->hdr.TreeId = 0xFFFFFFFF;\n\t\t\treq->PersistentFileId = 0xFFFFFFFF;\n\t\t\treq->VolatileFileId = 0xFFFFFFFF;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "rdata->cfile->tlink"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: offset=%llu bytes=%u\\n\"",
            "__func__",
            "rdata->offset",
            "rdata->bytes"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmb2_async_readv(struct cifs_readdata *rdata)\n{\n\tint rc, flags = 0;\n\tstruct smb2_hdr *buf;\n\tstruct cifs_io_parms io_parms;\n\tstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\n\t\t\t\t .rq_nvec = 1 };\n\tstruct TCP_Server_Info *server;\n\n\tcifs_dbg(FYI, \"%s: offset=%llu bytes=%u\\n\",\n\t\t __func__, rdata->offset, rdata->bytes);\n\n\tio_parms.tcon = tlink_tcon(rdata->cfile->tlink);\n\tio_parms.offset = rdata->offset;\n\tio_parms.length = rdata->bytes;\n\tio_parms.persistent_fid = rdata->cfile->fid.persistent_fid;\n\tio_parms.volatile_fid = rdata->cfile->fid.volatile_fid;\n\tio_parms.pid = rdata->pid;\n\n\tserver = io_parms.tcon->ses->server;\n\n\trc = smb2_new_read_req(&rdata->iov, &io_parms, 0, 0);\n\tif (rc) {\n\t\tif (rc == -EAGAIN && rdata->credits) {\n\t\t\t/* credits was reset by reconnect */\n\t\t\trdata->credits = 0;\n\t\t\t/* reduce in_flight value since we won't send the req */\n\t\t\tspin_lock(&server->req_lock);\n\t\t\tserver->in_flight--;\n\t\t\tspin_unlock(&server->req_lock);\n\t\t}\n\t\treturn rc;\n\t}\n\n\tbuf = (struct smb2_hdr *)rdata->iov.iov_base;\n\t/* 4 for rfc1002 length field */\n\trdata->iov.iov_len = get_rfc1002_length(rdata->iov.iov_base) + 4;\n\n\tif (rdata->credits) {\n\t\tbuf->CreditCharge = cpu_to_le16(DIV_ROUND_UP(rdata->bytes,\n\t\t\t\t\t\tSMB2_MAX_BUFFER_SIZE));\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += rdata->credits -\n\t\t\t\t\t\tle16_to_cpu(buf->CreditCharge);\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\t\tflags = CIFS_HAS_CREDITS;\n\t}\n\n\tkref_get(&rdata->refcount);\n\trc = cifs_call_async(io_parms.tcon->ses->server, &rqst,\n\t\t\t     cifs_readv_receive, smb2_readv_callback,\n\t\t\t     rdata, flags);\n\tif (rc) {\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t\tcifs_stats_fail_inc(io_parms.tcon, SMB2_READ_HE);\n\t}\n\n\tcifs_small_buf_release(buf);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_readv_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1697-1753",
    "snippet": "static void\nsmb2_readv_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct smb2_hdr *buf = (struct smb2_hdr *)rdata->iov.iov_base;\n\tunsigned int credits_received = 1;\n\tstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\n\t\t\t\t .rq_nvec = 1,\n\t\t\t\t .rq_pages = rdata->pages,\n\t\t\t\t .rq_npages = rdata->nr_pages,\n\t\t\t\t .rq_pagesz = rdata->pagesz,\n\t\t\t\t .rq_tailsz = rdata->tailsz };\n\n\tcifs_dbg(FYI, \"%s: mid=%llu state=%d result=%d bytes=%u\\n\",\n\t\t __func__, mid->mid, mid->mid_state, rdata->result,\n\t\t rdata->bytes);\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tcredits_received = le16_to_cpu(buf->CreditRequest);\n\t\t/* result already set, check signature */\n\t\tif (server->sign) {\n\t\t\tint rc;\n\n\t\t\trc = smb2_verify_signature(&rqst, server);\n\t\t\tif (rc)\n\t\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t\t rc);\n\t\t}\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\trdata->result = -EAGAIN;\n\t\tif (server->sign && rdata->got_bytes)\n\t\t\t/* reset bytes number since we can not check a sign */\n\t\t\trdata->got_bytes = 0;\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tdefault:\n\t\tif (rdata->result != -ENODATA)\n\t\t\trdata->result = -EIO;\n\t}\n\n\tif (rdata->result)\n\t\tcifs_stats_fail_inc(tcon, SMB2_READ_HE);\n\n\tqueue_work(cifsiod_wq, &rdata->work);\n\tDeleteMidQEntry(mid);\n\tadd_credits(server, credits_received, 0);\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_credits",
          "args": [
            "server",
            "credits_received",
            "0"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_add_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "116-125",
          "snippet": "static void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeleteMidQEntry",
          "args": [
            "mid"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteMidQEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "83-112",
          "snippet": "void\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "cifsiod_wq",
            "&rdata->work"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_READ_HE"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_bytes_read",
          "args": [
            "tcon",
            "rdata->got_bytes"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_bytes_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1213-1219",
          "snippet": "static inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,\n\t\t\t\t\t unsigned int bytes)\n{\n\tspin_lock(&tcon->stat_lock);\n\ttcon->bytes_read += bytes;\n\tspin_unlock(&tcon->stat_lock);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,\n\t\t\t\t\t unsigned int bytes)\n{\n\tspin_lock(&tcon->stat_lock);\n\ttcon->bytes_read += bytes;\n\tspin_unlock(&tcon->stat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_io_account_read",
          "args": [
            "rdata->got_bytes"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_account_read",
          "args": [
            "rdata->got_bytes"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"SMB signature verification returned error = %d\\n\"",
            "rc"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb2_verify_signature",
          "args": [
            "&rqst",
            "server"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_verify_signature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2transport.c",
          "lines": "417-460",
          "snippet": "int\nsmb2_verify_signature(struct smb_rqst *rqst, struct TCP_Server_Info *server)\n{\n\tunsigned int rc;\n\tchar server_response_sig[16];\n\tstruct smb2_hdr *smb2_pdu = (struct smb2_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif ((smb2_pdu->Command == SMB2_NEGOTIATE) ||\n\t    (smb2_pdu->Command == SMB2_SESSION_SETUP) ||\n\t    (smb2_pdu->Command == SMB2_OPLOCK_BREAK) ||\n\t    (!server->session_estab))\n\t\treturn 0;\n\n\t/*\n\t * BB what if signatures are supposed to be on for session but\n\t * server does not send one? BB\n\t */\n\n\t/* Do not need to verify session setups with signature \"BSRSPYL \" */\n\tif (memcmp(smb2_pdu->Signature, \"BSRSPYL \", 8) == 0)\n\t\tcifs_dbg(FYI, \"dummy signature received for smb command 0x%x\\n\",\n\t\t\t smb2_pdu->Command);\n\n\t/*\n\t * Save off the origiginal signature so we can modify the smb and check\n\t * our calculated signature against what the server sent.\n\t */\n\tmemcpy(server_response_sig, smb2_pdu->Signature, SMB2_SIGNATURE_SIZE);\n\n\tmemset(smb2_pdu->Signature, 0, SMB2_SIGNATURE_SIZE);\n\n\tmutex_lock(&server->srv_mutex);\n\trc = server->ops->calc_signature(rqst, server);\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (memcmp(server_response_sig, smb2_pdu->Signature,\n\t\t   SMB2_SIGNATURE_SIZE))\n\t\treturn -EACCES;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/highmem.h>\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nsmb2_verify_signature(struct smb_rqst *rqst, struct TCP_Server_Info *server)\n{\n\tunsigned int rc;\n\tchar server_response_sig[16];\n\tstruct smb2_hdr *smb2_pdu = (struct smb2_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif ((smb2_pdu->Command == SMB2_NEGOTIATE) ||\n\t    (smb2_pdu->Command == SMB2_SESSION_SETUP) ||\n\t    (smb2_pdu->Command == SMB2_OPLOCK_BREAK) ||\n\t    (!server->session_estab))\n\t\treturn 0;\n\n\t/*\n\t * BB what if signatures are supposed to be on for session but\n\t * server does not send one? BB\n\t */\n\n\t/* Do not need to verify session setups with signature \"BSRSPYL \" */\n\tif (memcmp(smb2_pdu->Signature, \"BSRSPYL \", 8) == 0)\n\t\tcifs_dbg(FYI, \"dummy signature received for smb command 0x%x\\n\",\n\t\t\t smb2_pdu->Command);\n\n\t/*\n\t * Save off the origiginal signature so we can modify the smb and check\n\t * our calculated signature against what the server sent.\n\t */\n\tmemcpy(server_response_sig, smb2_pdu->Signature, SMB2_SIGNATURE_SIZE);\n\n\tmemset(smb2_pdu->Signature, 0, SMB2_SIGNATURE_SIZE);\n\n\tmutex_lock(&server->srv_mutex);\n\trc = server->ops->calc_signature(rqst, server);\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (memcmp(server_response_sig, smb2_pdu->Signature,\n\t\t   SMB2_SIGNATURE_SIZE))\n\t\treturn -EACCES;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "buf->CreditRequest"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: mid=%llu state=%d result=%d bytes=%u\\n\"",
            "__func__",
            "mid->mid",
            "mid->mid_state",
            "rdata->result",
            "rdata->bytes"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "rdata->cfile->tlink"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\nsmb2_readv_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct smb2_hdr *buf = (struct smb2_hdr *)rdata->iov.iov_base;\n\tunsigned int credits_received = 1;\n\tstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\n\t\t\t\t .rq_nvec = 1,\n\t\t\t\t .rq_pages = rdata->pages,\n\t\t\t\t .rq_npages = rdata->nr_pages,\n\t\t\t\t .rq_pagesz = rdata->pagesz,\n\t\t\t\t .rq_tailsz = rdata->tailsz };\n\n\tcifs_dbg(FYI, \"%s: mid=%llu state=%d result=%d bytes=%u\\n\",\n\t\t __func__, mid->mid, mid->mid_state, rdata->result,\n\t\t rdata->bytes);\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tcredits_received = le16_to_cpu(buf->CreditRequest);\n\t\t/* result already set, check signature */\n\t\tif (server->sign) {\n\t\t\tint rc;\n\n\t\t\trc = smb2_verify_signature(&rqst, server);\n\t\t\tif (rc)\n\t\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t\t rc);\n\t\t}\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\trdata->result = -EAGAIN;\n\t\tif (server->sign && rdata->got_bytes)\n\t\t\t/* reset bytes number since we can not check a sign */\n\t\t\trdata->got_bytes = 0;\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tdefault:\n\t\tif (rdata->result != -ENODATA)\n\t\t\trdata->result = -EIO;\n\t}\n\n\tif (rdata->result)\n\t\tcifs_stats_fail_inc(tcon, SMB2_READ_HE);\n\n\tqueue_work(cifsiod_wq, &rdata->work);\n\tDeleteMidQEntry(mid);\n\tadd_credits(server, credits_received, 0);\n}"
  },
  {
    "function_name": "smb2_new_read_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1643-1695",
    "snippet": "static int\nsmb2_new_read_req(struct kvec *iov, struct cifs_io_parms *io_parms,\n\t\t  unsigned int remaining_bytes, int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_req *req = NULL;\n\n\trc = small_smb2_init(SMB2_READ, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\treq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0; /* reserved */\n\treq->ReadChannelInfoLength = 0; /* reserved */\n\treq->Channel = 0; /* reserved */\n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t/* 4 for rfc1002 length field */\n\t\t\treq->hdr.NextCommand =\n\t\t\t\tcpu_to_le32(get_rfc1002_length(req) + 4);\n\t\t} else /* END_OF_CHAIN */\n\t\t\treq->hdr.NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t/*\n\t\t\t * Related requests use info from previous read request\n\t\t\t * in chain.\n\t\t\t */\n\t\t\treq->hdr.SessionId = 0xFFFFFFFF;\n\t\t\treq->hdr.TreeId = 0xFFFFFFFF;\n\t\t\treq->PersistentFileId = 0xFFFFFFFF;\n\t\t\treq->VolatileFileId = 0xFFFFFFFF;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "remaining_bytes"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "get_rfc1002_length(req) + 4"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "io_parms->offset"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "io_parms->length"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "io_parms->pid"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_READ",
            "io_parms->tcon",
            "(void **) &req"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_new_read_req(struct kvec *iov, struct cifs_io_parms *io_parms,\n\t\t  unsigned int remaining_bytes, int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_req *req = NULL;\n\n\trc = small_smb2_init(SMB2_READ, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\treq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0; /* reserved */\n\treq->ReadChannelInfoLength = 0; /* reserved */\n\treq->Channel = 0; /* reserved */\n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t/* 4 for rfc1002 length field */\n\t\t\treq->hdr.NextCommand =\n\t\t\t\tcpu_to_le32(get_rfc1002_length(req) + 4);\n\t\t} else /* END_OF_CHAIN */\n\t\t\treq->hdr.NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t/*\n\t\t\t * Related requests use info from previous read request\n\t\t\t * in chain.\n\t\t\t */\n\t\t\treq->hdr.SessionId = 0xFFFFFFFF;\n\t\t\treq->hdr.TreeId = 0xFFFFFFFF;\n\t\t\treq->PersistentFileId = 0xFFFFFFFF;\n\t\t\treq->VolatileFileId = 0xFFFFFFFF;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1601-1637",
    "snippet": "int\nSMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct smb2_flush_req *req;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Flush\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_FLUSH, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\n\tif ((rc != 0) && tcon)\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\n\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "iov[0].iov_base"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_FLUSH_HE"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "iov",
            "1",
            "&resp_buftype",
            "0"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_FLUSH",
            "tcon",
            "(void **) &req"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Flush\\n\""
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct smb2_flush_req *req;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Flush\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_FLUSH, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\n\tif ((rc != 0) && tcon)\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\n\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_echo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1571-1599",
    "snippet": "int\nSMB2_echo(struct TCP_Server_Info *server)\n{\n\tstruct smb2_echo_req *req;\n\tint rc = 0;\n\tstruct kvec iov;\n\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t .rq_nvec = 1 };\n\n\tcifs_dbg(FYI, \"In echo request\\n\");\n\n\trc = small_smb2_init(SMB2_ECHO, NULL, (void **)&req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\n\tiov.iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov.iov_len = get_rfc1002_length(req) + 4;\n\n\trc = cifs_call_async(server, &rqst, NULL, smb2_echo_callback, server,\n\t\t\t     CIFS_ECHO_OP);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Echo request failed: %d\\n\", rc);\n\n\tcifs_small_buf_release(req);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "req"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Echo request failed: %d\\n\"",
            "rc"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_call_async",
          "args": [
            "server",
            "&rqst",
            "NULL",
            "smb2_echo_callback",
            "server",
            "CIFS_ECHO_OP"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_call_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "536-589",
          "snippet": "int\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_ECHO",
            "NULL",
            "(void **)&req"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In echo request\\n\""
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_echo(struct TCP_Server_Info *server)\n{\n\tstruct smb2_echo_req *req;\n\tint rc = 0;\n\tstruct kvec iov;\n\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t .rq_nvec = 1 };\n\n\tcifs_dbg(FYI, \"In echo request\\n\");\n\n\trc = small_smb2_init(SMB2_ECHO, NULL, (void **)&req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\n\tiov.iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov.iov_len = get_rfc1002_length(req) + 4;\n\n\trc = cifs_call_async(server, &rqst, NULL, smb2_echo_callback, server,\n\t\t\t     CIFS_ECHO_OP);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Echo request failed: %d\\n\", rc);\n\n\tcifs_small_buf_release(req);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_echo_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1557-1569",
    "snippet": "static void\nsmb2_echo_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->callback_data;\n\tstruct smb2_echo_rsp *smb2 = (struct smb2_echo_rsp *)mid->resp_buf;\n\tunsigned int credits_received = 1;\n\n\tif (mid->mid_state == MID_RESPONSE_RECEIVED)\n\t\tcredits_received = le16_to_cpu(smb2->hdr.CreditRequest);\n\n\tDeleteMidQEntry(mid);\n\tadd_credits(server, credits_received, CIFS_ECHO_OP);\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_credits",
          "args": [
            "server",
            "credits_received",
            "CIFS_ECHO_OP"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_add_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "116-125",
          "snippet": "static void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeleteMidQEntry",
          "args": [
            "mid"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteMidQEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "83-112",
          "snippet": "void\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "smb2->hdr.CreditRequest"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\nsmb2_echo_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->callback_data;\n\tstruct smb2_echo_rsp *smb2 = (struct smb2_echo_rsp *)mid->resp_buf;\n\tunsigned int credits_received = 1;\n\n\tif (mid->mid_state == MID_RESPONSE_RECEIVED)\n\t\tcredits_received = le16_to_cpu(smb2->hdr.CreditRequest);\n\n\tDeleteMidQEntry(mid);\n\tadd_credits(server, credits_received, CIFS_ECHO_OP);\n}"
  },
  {
    "function_name": "SMB2_get_srv_num",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1540-1548",
    "snippet": "int\nSMB2_get_srv_num(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u64 persistent_fid, u64 volatile_fid, __le64 *uniqueid)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_INTERNAL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_internal_info),\n\t\t\t  sizeof(struct smb2_file_internal_info), uniqueid);\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "query_info",
          "args": [
            "xid",
            "tcon",
            "persistent_fid",
            "volatile_fid",
            "FILE_INTERNAL_INFORMATION",
            "sizeof(struct smb2_file_internal_info)",
            "sizeof(struct smb2_file_internal_info)",
            "uniqueid"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "query_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1475-1527",
          "snippet": "static int\nquery_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid, u8 info_class,\n\t   size_t output_len, size_t min_len, void *data)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"Query Info\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\treq->InputBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(output_len);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_query_info_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qinf_exit;\n\t}\n\n\trc = validate_and_copy_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t\t   le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t\t   &rsp->hdr, min_len, data);\n\nqinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nquery_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid, u8 info_class,\n\t   size_t output_len, size_t min_len, void *data)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"Query Info\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\treq->InputBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(output_len);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_query_info_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qinf_exit;\n\t}\n\n\trc = validate_and_copy_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t\t   le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t\t   &rsp->hdr, min_len, data);\n\nqinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_get_srv_num(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u64 persistent_fid, u64 volatile_fid, __le64 *uniqueid)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_INTERNAL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_internal_info),\n\t\t\t  sizeof(struct smb2_file_internal_info), uniqueid);\n}"
  },
  {
    "function_name": "SMB2_query_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1529-1538",
    "snippet": "int\nSMB2_query_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid,\n\t\tstruct smb2_file_all_info *data)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_ALL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t  sizeof(struct smb2_file_all_info), data);\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "query_info",
          "args": [
            "xid",
            "tcon",
            "persistent_fid",
            "volatile_fid",
            "FILE_ALL_INFORMATION",
            "sizeof(struct smb2_file_all_info) + PATH_MAX * 2",
            "sizeof(struct smb2_file_all_info)",
            "data"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "query_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1475-1527",
          "snippet": "static int\nquery_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid, u8 info_class,\n\t   size_t output_len, size_t min_len, void *data)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"Query Info\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\treq->InputBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(output_len);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_query_info_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qinf_exit;\n\t}\n\n\trc = validate_and_copy_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t\t   le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t\t   &rsp->hdr, min_len, data);\n\nqinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nquery_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid, u8 info_class,\n\t   size_t output_len, size_t min_len, void *data)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"Query Info\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\treq->InputBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(output_len);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_query_info_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qinf_exit;\n\t}\n\n\trc = validate_and_copy_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t\t   le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t\t   &rsp->hdr, min_len, data);\n\nqinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_query_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid,\n\t\tstruct smb2_file_all_info *data)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_ALL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t  sizeof(struct smb2_file_all_info), data);\n}"
  },
  {
    "function_name": "query_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1475-1527",
    "snippet": "static int\nquery_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid, u8 info_class,\n\t   size_t output_len, size_t min_len, void *data)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"Query Info\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\treq->InputBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(output_len);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_query_info_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qinf_exit;\n\t}\n\n\trc = validate_and_copy_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t\t   le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t\t   &rsp->hdr, min_len, data);\n\nqinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "rsp"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_and_copy_buf",
          "args": [
            "le16_to_cpu(rsp->OutputBufferOffset)",
            "le32_to_cpu(rsp->OutputBufferLength)",
            "&rsp->hdr",
            "min_len",
            "data"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "validate_and_copy_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1454-1473",
          "snippet": "static int\nvalidate_and_copy_buf(unsigned int offset, unsigned int buffer_length,\n\t\t      struct smb2_hdr *hdr, unsigned int minbufsize,\n\t\t      char *data)\n\n{\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tint rc;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\trc = validate_buf(offset, buffer_length, hdr, minbufsize);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(data, begin_of_buf, buffer_length);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nvalidate_and_copy_buf(unsigned int offset, unsigned int buffer_length,\n\t\t      struct smb2_hdr *hdr, unsigned int minbufsize,\n\t\t      char *data)\n\n{\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tint rc;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\trc = validate_buf(offset, buffer_length, hdr, minbufsize);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(data, begin_of_buf, buffer_length);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rsp->OutputBufferLength"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rsp->OutputBufferOffset"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_QUERY_INFO_HE"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "iov",
            "1",
            "&resp_buftype",
            "0"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "output_len"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sizeof(struct smb2_query_info_req) - 1 - 4"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_QUERY_INFO",
            "tcon",
            "(void **) &req"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Query Info\\n\""
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nquery_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid, u8 info_class,\n\t   size_t output_len, size_t min_len, void *data)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"Query Info\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\treq->InputBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(output_len);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_query_info_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qinf_exit;\n\t}\n\n\trc = validate_and_copy_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t\t   le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t\t   &rsp->hdr, min_len, data);\n\nqinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
  },
  {
    "function_name": "validate_and_copy_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1454-1473",
    "snippet": "static int\nvalidate_and_copy_buf(unsigned int offset, unsigned int buffer_length,\n\t\t      struct smb2_hdr *hdr, unsigned int minbufsize,\n\t\t      char *data)\n\n{\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tint rc;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\trc = validate_buf(offset, buffer_length, hdr, minbufsize);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(data, begin_of_buf, buffer_length);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "begin_of_buf",
            "buffer_length"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_buf",
          "args": [
            "offset",
            "buffer_length",
            "hdr",
            "minbufsize"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "validate_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1418-1448",
          "snippet": "static int\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\n\t     struct smb2_hdr *hdr, unsigned int min_buf_size)\n\n{\n\tunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\n\tchar *end_of_smb = smb_len + 4 /* RFC1001 length field */ + (char *)hdr;\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"illegal server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\n\t     struct smb2_hdr *hdr, unsigned int min_buf_size)\n\n{\n\tunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\n\tchar *end_of_smb = smb_len + 4 /* RFC1001 length field */ + (char *)hdr;\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"illegal server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nvalidate_and_copy_buf(unsigned int offset, unsigned int buffer_length,\n\t\t      struct smb2_hdr *hdr, unsigned int minbufsize,\n\t\t      char *data)\n\n{\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tint rc;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\trc = validate_buf(offset, buffer_length, hdr, minbufsize);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(data, begin_of_buf, buffer_length);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "validate_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1418-1448",
    "snippet": "static int\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\n\t     struct smb2_hdr *hdr, unsigned int min_buf_size)\n\n{\n\tunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\n\tchar *end_of_smb = smb_len + 4 /* RFC1001 length field */ + (char *)hdr;\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"illegal server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"illegal server response, bad offset to data\\n\""
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"buffer length %d or smb length %d too large\\n\"",
            "buffer_length",
            "smb_len"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"buffer length %d smaller than minimum size %d\\n\"",
            "buffer_length",
            "min_buf_size"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hdr->smb2_buf_length"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\n\t     struct smb2_hdr *hdr, unsigned int min_buf_size)\n\n{\n\tunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\n\tchar *end_of_smb = smb_len + 4 /* RFC1001 length field */ + (char *)hdr;\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"illegal server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "SMB2_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1373-1416",
    "snippet": "int\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "rsp"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_CLOSE_HE"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "iov",
            "1",
            "&resp_buftype",
            "0"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_CLOSE",
            "tcon",
            "(void **) &req"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Close\\n\""
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_set_compression",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1352-1371",
    "snippet": "int\nSMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct  compress_ioctl fsctl_input;\n\tchar *ret_data = NULL;\n\n\tfsctl_input.CompressionState =\n\t\t\tcpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SET_COMPRESSION, true /* is_fsctl */,\n\t\t\t(char *)&fsctl_input /* data input */,\n\t\t\t2 /* in data len */, &ret_data /* out data */, NULL);\n\n\tcifs_dbg(FYI, \"set compression rc %d\\n\", rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"set compression rc %d\\n\"",
            "rc"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_ioctl",
          "args": [
            "xid",
            "tcon",
            "persistent_fid",
            "volatile_fid",
            "FSCTL_SET_COMPRESSION",
            "true/* is_fsctl */",
            "(char *)&fsctl_input/* data input */",
            "2/* in data len */",
            "&ret_data/* out data */",
            "NULL"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1213-1346",
          "snippet": "int\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "COMPRESSION_FORMAT_DEFAULT"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct  compress_ioctl fsctl_input;\n\tchar *ret_data = NULL;\n\n\tfsctl_input.CompressionState =\n\t\t\tcpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SET_COMPRESSION, true /* is_fsctl */,\n\t\t\t(char *)&fsctl_input /* data input */,\n\t\t\t2 /* in data len */, &ret_data /* out data */, NULL);\n\n\tcifs_dbg(FYI, \"set compression rc %d\\n\", rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1213-1346",
    "snippet": "int\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "rsp"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*out_data",
            "rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset)",
            "*plen"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rsp->OutputOffset"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "*plen",
            "GFP_KERNEL"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Malformed ioctl resp: len %d offset %d\\n\"",
            "*plen",
            "le32_to_cpu(rsp->OutputOffset)"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "rsp"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"srv returned invalid ioctl length: %d\\n\"",
            "*plen"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_IOCTL_HE"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "iov",
            "num_iovecs",
            "&resp_buftype",
            "0"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "req",
            "indatalen - 1"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "SMB2_0_IOCTL_IS_FSCTL"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0xFF00"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "offsetof(struct smb2_ioctl_req, Buffer) - 4"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "indatalen"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "opcode"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_IOCTL",
            "tcon",
            "(void **) &req"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SMB2 IOCTL\\n\""
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1067-1208",
    "snippet": "int\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "rsp"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dhc_buf"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lc_buf"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "copy_path"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_lease_state",
          "args": [
            "server",
            "rsp",
            "&oparms->fid->epoch"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "parse_lease_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "993-1016",
          "snippet": "static __u8\nparse_lease_state(struct TCP_Server_Info *server, struct smb2_create_rsp *rsp,\n\t\t  unsigned int *epoch)\n{\n\tchar *data_offset;\n\tstruct create_context *cc;\n\tunsigned int next = 0;\n\tchar *name;\n\n\tdata_offset = (char *)rsp + 4 + le32_to_cpu(rsp->CreateContextsOffset);\n\tcc = (struct create_context *)data_offset;\n\tdo {\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t\tname = le16_to_cpu(cc->NameOffset) + (char *)cc;\n\t\tif (le16_to_cpu(cc->NameLength) != 4 ||\n\t\t    strncmp(name, \"RqLs\", 4)) {\n\t\t\tnext = le32_to_cpu(cc->Next);\n\t\t\tcontinue;\n\t\t}\n\t\treturn server->ops->parse_lease_buf(cc, epoch);\n\t} while (next != 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic __u8\nparse_lease_state(struct TCP_Server_Info *server, struct smb2_create_rsp *rsp,\n\t\t  unsigned int *epoch)\n{\n\tchar *data_offset;\n\tstruct create_context *cc;\n\tunsigned int next = 0;\n\tchar *name;\n\n\tdata_offset = (char *)rsp + 4 + le32_to_cpu(rsp->CreateContextsOffset);\n\tcc = (struct create_context *)data_offset;\n\tdo {\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t\tname = le16_to_cpu(cc->NameOffset) + (char *)cc;\n\t\tif (le16_to_cpu(cc->NameLength) != 4 ||\n\t\t    strncmp(name, \"RqLs\", 4)) {\n\t\t\tnext = le32_to_cpu(cc->Next);\n\t\t\tcontinue;\n\t\t}\n\t\treturn server->ops->parse_lease_buf(cc, epoch);\n\t} while (next != 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&rsp->CreationTime",
            "32"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "rsp",
            "get_rfc1002_length(rsp) + 4",
            "GFP_KERNEL"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "rsp"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_CREATE_HE"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "iov",
            "num_iovecs",
            "&resp_buftype",
            "0"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lc_buf"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "copy_path"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "req"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_durable_context",
          "args": [
            "iov",
            "&num_iovecs",
            "oparms"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "add_durable_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1041-1065",
          "snippet": "static int\nadd_durable_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tif (oparms->reconnect) {\n\t\tiov[num].iov_base = create_reconnect_durable_buf(oparms->fid);\n\t\t/* indicate that we don't need to relock the file */\n\t\toparms->reconnect = false;\n\t} else\n\t\tiov[num].iov_base = create_durable_buf();\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) - 4 +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_durable));\n\tinc_rfc1001_len(&req->hdr, sizeof(struct create_durable));\n\t*num_iovec = num + 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nadd_durable_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tif (oparms->reconnect) {\n\t\tiov[num].iov_base = create_reconnect_durable_buf(oparms->fid);\n\t\t/* indicate that we don't need to relock the file */\n\t\toparms->reconnect = false;\n\t} else\n\t\tiov[num].iov_base = create_durable_buf();\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) - 4 +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_durable));\n\tinc_rfc1001_len(&req->hdr, sizeof(struct create_durable));\n\t*num_iovec = num + 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "server->vals->create_lease_size"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "copy_path"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_lease_context",
          "args": [
            "server",
            "iov",
            "&num_iovecs",
            "oplock"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "add_lease_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1018-1039",
          "snippet": "static int\nadd_lease_context(struct TCP_Server_Info *server, struct kvec *iov,\n\t\t  unsigned int *num_iovec, __u8 *oplock)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = server->ops->create_lease_buf(oplock+1, *oplock);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = server->vals->create_lease_size;\n\treq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\t\tsizeof(struct smb2_create_req) - 4 +\n\t\t\t\tiov[num - 1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength,\n\t\t     server->vals->create_lease_size);\n\tinc_rfc1001_len(&req->hdr, server->vals->create_lease_size);\n\t*num_iovec = num + 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nadd_lease_context(struct TCP_Server_Info *server, struct kvec *iov,\n\t\t  unsigned int *num_iovec, __u8 *oplock)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = server->ops->create_lease_buf(oplock+1, *oplock);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = server->vals->create_lease_size;\n\treq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\t\tsizeof(struct smb2_create_req) - 4 +\n\t\t\t\tiov[num - 1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength,\n\t\t     server->vals->create_lease_size);\n\tinc_rfc1001_len(&req->hdr, server->vals->create_lease_size);\n\t*num_iovec = num + 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "req",
            "uni_path_len - 1"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)copy_path",
            "(const char *)path",
            "uni_path_len"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "copy_size",
            "GFP_KERNEL"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "uni_path_len - 2"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sizeof(struct smb2_create_req) - 4"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UniStrnlen",
          "args": [
            "(wchar_t *)path",
            "PATH_MAX"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "UniStrnlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.h",
          "lines": "207-218",
          "snippet": "static inline size_t\nUniStrnlen(const wchar_t *ucs1, int maxlen)\n{\n\tint i = 0;\n\n\twhile (*ucs1++) {\n\t\ti++;\n\t\tif (i >= maxlen)\n\t\t\tbreak;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n#include <asm/byteorder.h>\n\nstatic inline size_t\nUniStrnlen(const wchar_t *ucs1, int maxlen)\n{\n\tint i = 0;\n\n\twhile (*ucs1++) {\n\t\ti++;\n\t\tif (i >= maxlen)\n\t\t\tbreak;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "oparms->create_options & CREATE_OPTIONS_MASK"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "oparms->disposition"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "file_attributes"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "oparms->desired_access"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_CREATE",
            "tcon",
            "(void **) &req"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"create/open\\n\""
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
  },
  {
    "function_name": "add_durable_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1041-1065",
    "snippet": "static int\nadd_durable_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tif (oparms->reconnect) {\n\t\tiov[num].iov_base = create_reconnect_durable_buf(oparms->fid);\n\t\t/* indicate that we don't need to relock the file */\n\t\toparms->reconnect = false;\n\t} else\n\t\tiov[num].iov_base = create_durable_buf();\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) - 4 +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_durable));\n\tinc_rfc1001_len(&req->hdr, sizeof(struct create_durable));\n\t*num_iovec = num + 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "&req->hdr",
            "sizeof(struct create_durable)"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&req->CreateContextsLength",
            "sizeof(struct create_durable)"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sizeof(struct smb2_create_req) - 4 +\n\t\t\t\t\t\t\t\tiov[1].iov_len"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_durable_buf",
          "args": [],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "create_durable_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "945-966",
          "snippet": "static struct create_durable *\ncreate_durable_buf(void)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_DURABLE_HANDLE_REQUEST is \"DHnQ\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic struct create_durable *\ncreate_durable_buf(void)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_DURABLE_HANDLE_REQUEST is \"DHnQ\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_reconnect_durable_buf",
          "args": [
            "oparms->fid"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "create_reconnect_durable_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "968-991",
          "snippet": "static struct create_durable *\ncreate_reconnect_durable_buf(struct cifs_fid *fid)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Data.Fid.PersistentFileId = fid->persistent_fid;\n\tbuf->Data.Fid.VolatileFileId = fid->volatile_fid;\n\t/* SMB2_CREATE_DURABLE_HANDLE_RECONNECT is \"DHnC\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'C';\n\treturn buf;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic struct create_durable *\ncreate_reconnect_durable_buf(struct cifs_fid *fid)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Data.Fid.PersistentFileId = fid->persistent_fid;\n\tbuf->Data.Fid.VolatileFileId = fid->volatile_fid;\n\t/* SMB2_CREATE_DURABLE_HANDLE_RECONNECT is \"DHnC\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'C';\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nadd_durable_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tif (oparms->reconnect) {\n\t\tiov[num].iov_base = create_reconnect_durable_buf(oparms->fid);\n\t\t/* indicate that we don't need to relock the file */\n\t\toparms->reconnect = false;\n\t} else\n\t\tiov[num].iov_base = create_durable_buf();\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) - 4 +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_durable));\n\tinc_rfc1001_len(&req->hdr, sizeof(struct create_durable));\n\t*num_iovec = num + 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "add_lease_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "1018-1039",
    "snippet": "static int\nadd_lease_context(struct TCP_Server_Info *server, struct kvec *iov,\n\t\t  unsigned int *num_iovec, __u8 *oplock)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = server->ops->create_lease_buf(oplock+1, *oplock);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = server->vals->create_lease_size;\n\treq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\t\tsizeof(struct smb2_create_req) - 4 +\n\t\t\t\tiov[num - 1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength,\n\t\t     server->vals->create_lease_size);\n\tinc_rfc1001_len(&req->hdr, server->vals->create_lease_size);\n\t*num_iovec = num + 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "&req->hdr",
            "server->vals->create_lease_size"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&req->CreateContextsLength",
            "server->vals->create_lease_size"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sizeof(struct smb2_create_req) - 4 +\n\t\t\t\tiov[num - 1].iov_len"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->create_lease_buf",
          "args": [
            "oplock+1",
            "*oplock"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nadd_lease_context(struct TCP_Server_Info *server, struct kvec *iov,\n\t\t  unsigned int *num_iovec, __u8 *oplock)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = server->ops->create_lease_buf(oplock+1, *oplock);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = server->vals->create_lease_size;\n\treq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\t\tsizeof(struct smb2_create_req) - 4 +\n\t\t\t\tiov[num - 1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength,\n\t\t     server->vals->create_lease_size);\n\tinc_rfc1001_len(&req->hdr, server->vals->create_lease_size);\n\t*num_iovec = num + 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_lease_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "993-1016",
    "snippet": "static __u8\nparse_lease_state(struct TCP_Server_Info *server, struct smb2_create_rsp *rsp,\n\t\t  unsigned int *epoch)\n{\n\tchar *data_offset;\n\tstruct create_context *cc;\n\tunsigned int next = 0;\n\tchar *name;\n\n\tdata_offset = (char *)rsp + 4 + le32_to_cpu(rsp->CreateContextsOffset);\n\tcc = (struct create_context *)data_offset;\n\tdo {\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t\tname = le16_to_cpu(cc->NameOffset) + (char *)cc;\n\t\tif (le16_to_cpu(cc->NameLength) != 4 ||\n\t\t    strncmp(name, \"RqLs\", 4)) {\n\t\t\tnext = le32_to_cpu(cc->Next);\n\t\t\tcontinue;\n\t\t}\n\t\treturn server->ops->parse_lease_buf(cc, epoch);\n\t} while (next != 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "server->ops->parse_lease_buf",
          "args": [
            "cc",
            "epoch"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "cc->Next"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "\"RqLs\"",
            "4"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cc->NameLength"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic __u8\nparse_lease_state(struct TCP_Server_Info *server, struct smb2_create_rsp *rsp,\n\t\t  unsigned int *epoch)\n{\n\tchar *data_offset;\n\tstruct create_context *cc;\n\tunsigned int next = 0;\n\tchar *name;\n\n\tdata_offset = (char *)rsp + 4 + le32_to_cpu(rsp->CreateContextsOffset);\n\tcc = (struct create_context *)data_offset;\n\tdo {\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t\tname = le16_to_cpu(cc->NameOffset) + (char *)cc;\n\t\tif (le16_to_cpu(cc->NameLength) != 4 ||\n\t\t    strncmp(name, \"RqLs\", 4)) {\n\t\t\tnext = le32_to_cpu(cc->Next);\n\t\t\tcontinue;\n\t\t}\n\t\treturn server->ops->parse_lease_buf(cc, epoch);\n\t} while (next != 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "create_reconnect_durable_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "968-991",
    "snippet": "static struct create_durable *\ncreate_reconnect_durable_buf(struct cifs_fid *fid)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Data.Fid.PersistentFileId = fid->persistent_fid;\n\tbuf->Data.Fid.VolatileFileId = fid->volatile_fid;\n\t/* SMB2_CREATE_DURABLE_HANDLE_RECONNECT is \"DHnC\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'C';\n\treturn buf;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof\n\t\t\t\t(struct create_durable, Name)"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "16"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof\n\t\t\t\t\t(struct create_durable, Data)"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct create_durable)",
            "GFP_KERNEL"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic struct create_durable *\ncreate_reconnect_durable_buf(struct cifs_fid *fid)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Data.Fid.PersistentFileId = fid->persistent_fid;\n\tbuf->Data.Fid.VolatileFileId = fid->volatile_fid;\n\t/* SMB2_CREATE_DURABLE_HANDLE_RECONNECT is \"DHnC\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'C';\n\treturn buf;\n}"
  },
  {
    "function_name": "create_durable_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "945-966",
    "snippet": "static struct create_durable *\ncreate_durable_buf(void)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_DURABLE_HANDLE_REQUEST is \"DHnQ\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof\n\t\t\t\t(struct create_durable, Name)"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "16"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof\n\t\t\t\t\t(struct create_durable, Data)"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct create_durable)",
            "GFP_KERNEL"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic struct create_durable *\ncreate_durable_buf(void)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_DURABLE_HANDLE_REQUEST is \"DHnQ\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}"
  },
  {
    "function_name": "SMB2_tdis",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "915-942",
    "snippet": "int\nSMB2_tdis(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tstruct smb2_tree_disconnect_req *req; /* response is trivial */\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"Tree Disconnect\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\n\t\treturn 0;\n\n\trc = small_smb2_init(SMB2_TREE_DISCONNECT, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceiveNoRsp(xid, ses, (char *)&req->hdr, 0);\n\tif (rc)\n\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_DISCONNECT_HE);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_TREE_DISCONNECT_HE"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "ses",
            "(char *)&req->hdr",
            "0"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_TREE_DISCONNECT",
            "tcon",
            "(void **) &req"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Tree Disconnect\\n\""
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_tdis(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tstruct smb2_tree_disconnect_req *req; /* response is trivial */\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"Tree Disconnect\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\n\t\treturn 0;\n\n\trc = small_smb2_init(SMB2_TREE_DISCONNECT, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceiveNoRsp(xid, ses, (char *)&req->hdr, 0);\n\tif (rc)\n\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_DISCONNECT_HE);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_tcon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "797-913",
    "snippet": "int\nSMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,\n\t  struct cifs_tcon *tcon, const struct nls_table *cp)\n{\n\tstruct smb2_tree_connect_req *req;\n\tstruct smb2_tree_connect_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype;\n\tint unc_path_len;\n\tstruct TCP_Server_Info *server;\n\t__le16 *unc_path = NULL;\n\n\tcifs_dbg(FYI, \"TCON\\n\");\n\n\tif ((ses->server) && tree)\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (tcon && tcon->bad_network_name)\n\t\treturn -ENOENT;\n\n\tunc_path = kmalloc(MAX_SHARENAME_LENGTH * 2, GFP_KERNEL);\n\tif (unc_path == NULL)\n\t\treturn -ENOMEM;\n\n\tunc_path_len = cifs_strtoUTF16(unc_path, tree, strlen(tree), cp) + 1;\n\tunc_path_len *= 2;\n\tif (unc_path_len < 2) {\n\t\tkfree(unc_path);\n\t\treturn -EINVAL;\n\t}\n\n\trc = small_smb2_init(SMB2_TREE_CONNECT, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(unc_path);\n\t\treturn rc;\n\t}\n\n\tif (tcon == NULL) {\n\t\t/* since no tcon, smb2_init can not do this, so do here */\n\t\treq->hdr.SessionId = ses->Suid;\n\t\t/* if (ses->server->sec_mode & SECMODE_SIGN_REQUIRED)\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED; */\n\t}\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->PathOffset = cpu_to_le16(sizeof(struct smb2_tree_connect_req)\n\t\t\t- 1 /* pad */ - 4 /* do not count rfc1001 len field */);\n\treq->PathLength = cpu_to_le16(unc_path_len - 2);\n\tiov[1].iov_base = unc_path;\n\tiov[1].iov_len = unc_path_len;\n\n\tinc_rfc1001_len(req, unc_path_len - 1 /* pad */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\n\trsp = (struct smb2_tree_connect_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tif (tcon) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_CONNECT_HE);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t\tgoto tcon_error_exit;\n\t}\n\n\tif (tcon == NULL) {\n\t\tses->ipc_tid = rsp->hdr.TreeId;\n\t\tgoto tcon_exit;\n\t}\n\n\tif (rsp->ShareType & SMB2_SHARE_TYPE_DISK)\n\t\tcifs_dbg(FYI, \"connection to disk share\\n\");\n\telse if (rsp->ShareType & SMB2_SHARE_TYPE_PIPE) {\n\t\ttcon->ipc = true;\n\t\tcifs_dbg(FYI, \"connection to pipe share\\n\");\n\t} else if (rsp->ShareType & SMB2_SHARE_TYPE_PRINT) {\n\t\ttcon->print = true;\n\t\tcifs_dbg(FYI, \"connection to printer\\n\");\n\t} else {\n\t\tcifs_dbg(VFS, \"unknown share type %d\\n\", rsp->ShareType);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto tcon_error_exit;\n\t}\n\n\ttcon->share_flags = le32_to_cpu(rsp->ShareFlags);\n\ttcon->capabilities = rsp->Capabilities; /* we keep caps little endian */\n\ttcon->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\ttcon->tidStatus = CifsGood;\n\ttcon->need_reconnect = false;\n\ttcon->tid = rsp->hdr.TreeId;\n\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\tif ((rsp->Capabilities & SMB2_SHARE_CAP_DFS) &&\n\t    ((tcon->share_flags & SHI1005_FLAGS_DFS) == 0))\n\t\tcifs_dbg(VFS, \"DFS capability contradicts DFS flag\\n\");\n\tinit_copy_chunk_defaults(tcon);\n\tif (tcon->ses->server->ops->validate_negotiate)\n\t\trc = tcon->ses->server->ops->validate_negotiate(xid, tcon);\ntcon_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(unc_path);\n\treturn rc;\n\ntcon_error_exit:\n\tif (rsp->hdr.Status == STATUS_BAD_NETWORK_NAME) {\n\t\tcifs_dbg(VFS, \"BAD_NETWORK_NAME: %s\\n\", tree);\n\t\tif (tcon)\n\t\t\ttcon->bad_network_name = true;\n\t}\n\tgoto tcon_exit;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MAX_SHARENAME_LENGTH (255 /* server */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"BAD_NETWORK_NAME: %s\\n\"",
            "tree"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "unc_path"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "rsp"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->validate_negotiate",
          "args": [
            "xid",
            "tcon"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_copy_chunk_defaults",
          "args": [
            "tcon"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "init_copy_chunk_defaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "790-795",
          "snippet": "static inline void init_copy_chunk_defaults(struct cifs_tcon *tcon)\n{\n\ttcon->max_chunks = 256;\n\ttcon->max_bytes_chunk = 1048576;\n\ttcon->max_bytes_copy = 16777216;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void init_copy_chunk_defaults(struct cifs_tcon *tcon)\n{\n\ttcon->max_chunks = 256;\n\ttcon->max_bytes_chunk = 1048576;\n\ttcon->max_bytes_copy = 16777216;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"DFS capability contradicts DFS flag\\n\""
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "tcon->treeName",
            "tree",
            "sizeof(tcon->treeName)"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rsp->MaximalAccess"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"unknown share type %d\\n\"",
            "rsp->ShareType"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"connection to printer\\n\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"connection to pipe share\\n\""
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"connection to disk share\\n\""
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_fail_inc",
          "args": [
            "tcon",
            "SMB2_TREE_CONNECT_HE"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_fail_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "782-785",
          "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "iov",
            "2",
            "&resp_buftype",
            "0"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "req",
            "unc_path_len - 1/* pad */"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "unc_path_len - 2"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sizeof(struct smb2_tree_connect_req)\n\t\t\t- 1 /* pad */ - 4/* do not count rfc1001 len field */"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "unc_path"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_TREE_CONNECT",
            "tcon",
            "(void **) &req"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "unc_path"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_strtoUTF16",
          "args": [
            "unc_path",
            "tree",
            "strlen(tree)",
            "cp"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strtoUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "252-296",
          "snippet": "int\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tree"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "MAX_SHARENAME_LENGTH * 2",
            "GFP_KERNEL"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"TCON\\n\""
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\n#define MAX_SHARENAME_LENGTH (255 /* server */\n\nint\nSMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,\n\t  struct cifs_tcon *tcon, const struct nls_table *cp)\n{\n\tstruct smb2_tree_connect_req *req;\n\tstruct smb2_tree_connect_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype;\n\tint unc_path_len;\n\tstruct TCP_Server_Info *server;\n\t__le16 *unc_path = NULL;\n\n\tcifs_dbg(FYI, \"TCON\\n\");\n\n\tif ((ses->server) && tree)\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (tcon && tcon->bad_network_name)\n\t\treturn -ENOENT;\n\n\tunc_path = kmalloc(MAX_SHARENAME_LENGTH * 2, GFP_KERNEL);\n\tif (unc_path == NULL)\n\t\treturn -ENOMEM;\n\n\tunc_path_len = cifs_strtoUTF16(unc_path, tree, strlen(tree), cp) + 1;\n\tunc_path_len *= 2;\n\tif (unc_path_len < 2) {\n\t\tkfree(unc_path);\n\t\treturn -EINVAL;\n\t}\n\n\trc = small_smb2_init(SMB2_TREE_CONNECT, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(unc_path);\n\t\treturn rc;\n\t}\n\n\tif (tcon == NULL) {\n\t\t/* since no tcon, smb2_init can not do this, so do here */\n\t\treq->hdr.SessionId = ses->Suid;\n\t\t/* if (ses->server->sec_mode & SECMODE_SIGN_REQUIRED)\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED; */\n\t}\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->PathOffset = cpu_to_le16(sizeof(struct smb2_tree_connect_req)\n\t\t\t- 1 /* pad */ - 4 /* do not count rfc1001 len field */);\n\treq->PathLength = cpu_to_le16(unc_path_len - 2);\n\tiov[1].iov_base = unc_path;\n\tiov[1].iov_len = unc_path_len;\n\n\tinc_rfc1001_len(req, unc_path_len - 1 /* pad */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\n\trsp = (struct smb2_tree_connect_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tif (tcon) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_CONNECT_HE);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t\tgoto tcon_error_exit;\n\t}\n\n\tif (tcon == NULL) {\n\t\tses->ipc_tid = rsp->hdr.TreeId;\n\t\tgoto tcon_exit;\n\t}\n\n\tif (rsp->ShareType & SMB2_SHARE_TYPE_DISK)\n\t\tcifs_dbg(FYI, \"connection to disk share\\n\");\n\telse if (rsp->ShareType & SMB2_SHARE_TYPE_PIPE) {\n\t\ttcon->ipc = true;\n\t\tcifs_dbg(FYI, \"connection to pipe share\\n\");\n\t} else if (rsp->ShareType & SMB2_SHARE_TYPE_PRINT) {\n\t\ttcon->print = true;\n\t\tcifs_dbg(FYI, \"connection to printer\\n\");\n\t} else {\n\t\tcifs_dbg(VFS, \"unknown share type %d\\n\", rsp->ShareType);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto tcon_error_exit;\n\t}\n\n\ttcon->share_flags = le32_to_cpu(rsp->ShareFlags);\n\ttcon->capabilities = rsp->Capabilities; /* we keep caps little endian */\n\ttcon->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\ttcon->tidStatus = CifsGood;\n\ttcon->need_reconnect = false;\n\ttcon->tid = rsp->hdr.TreeId;\n\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\tif ((rsp->Capabilities & SMB2_SHARE_CAP_DFS) &&\n\t    ((tcon->share_flags & SHI1005_FLAGS_DFS) == 0))\n\t\tcifs_dbg(VFS, \"DFS capability contradicts DFS flag\\n\");\n\tinit_copy_chunk_defaults(tcon);\n\tif (tcon->ses->server->ops->validate_negotiate)\n\t\trc = tcon->ses->server->ops->validate_negotiate(xid, tcon);\ntcon_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(unc_path);\n\treturn rc;\n\ntcon_error_exit:\n\tif (rsp->hdr.Status == STATUS_BAD_NETWORK_NAME) {\n\t\tcifs_dbg(VFS, \"BAD_NETWORK_NAME: %s\\n\", tree);\n\t\tif (tcon)\n\t\t\ttcon->bad_network_name = true;\n\t}\n\tgoto tcon_exit;\n}"
  },
  {
    "function_name": "init_copy_chunk_defaults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "790-795",
    "snippet": "static inline void init_copy_chunk_defaults(struct cifs_tcon *tcon)\n{\n\ttcon->max_chunks = 256;\n\ttcon->max_bytes_chunk = 1048576;\n\ttcon->max_bytes_copy = 16777216;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void init_copy_chunk_defaults(struct cifs_tcon *tcon)\n{\n\ttcon->max_chunks = 256;\n\ttcon->max_bytes_chunk = 1048576;\n\ttcon->max_bytes_copy = 16777216;\n}"
  },
  {
    "function_name": "cifs_stats_fail_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "782-785",
    "snippet": "static inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.smb2_stats.smb2_com_failed[code]"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}"
  },
  {
    "function_name": "SMB2_logoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "745-780",
    "snippet": "int\nSMB2_logoff(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb2_logoff_req *req; /* response is also trivial struct */\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\n\tcifs_dbg(FYI, \"disconnect session %p\\n\", ses);\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\t/* no need to send SMB logoff if uid already closed due to reconnect */\n\tif (ses->need_reconnect)\n\t\tgoto smb2_session_already_dead;\n\n\trc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\t /* since no tcon, smb2_init can not do this, so do here */\n\treq->hdr.SessionId = ses->Suid;\n\tif (server->sign)\n\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED;\n\n\trc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\nsmb2_session_already_dead:\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "ses",
            "(char *) &req->hdr",
            "0"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_LOGOFF",
            "NULL",
            "(void **) &req"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"disconnect session %p\\n\"",
            "ses"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_logoff(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb2_logoff_req *req; /* response is also trivial struct */\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\n\tcifs_dbg(FYI, \"disconnect session %p\\n\", ses);\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\t/* no need to send SMB logoff if uid already closed due to reconnect */\n\tif (ses->need_reconnect)\n\t\tgoto smb2_session_already_dead;\n\n\trc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\t /* since no tcon, smb2_init can not do this, so do here */\n\treq->hdr.SessionId = ses->Suid;\n\tif (server->sign)\n\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED;\n\n\trc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\nsmb2_session_already_dead:\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_sess_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "524-743",
    "snippet": "int\nSMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,\n\t\tconst struct nls_table *nls_cp)\n{\n\tstruct smb2_sess_setup_req *req;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype = CIFS_NO_BUFFER;\n\t__le32 phase = NtLmNegotiate; /* NTLMSSP, if needed, is multistage */\n\tstruct TCP_Server_Info *server = ses->server;\n\tu16 blob_length = 0;\n\tchar *security_blob;\n\tchar *ntlmssp_blob = NULL;\n\tbool use_spnego = false; /* else use raw ntlmssp */\n\n\tcifs_dbg(FYI, \"Session Setup\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * If we are here due to reconnect, free per-smb session key\n\t * in case signing was required.\n\t */\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\n\t/*\n\t * If memory allocation is successful, caller of this function\n\t * frees it.\n\t */\n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp)\n\t\treturn -ENOMEM;\n\tses->ntlmssp->sesskey_per_smbsess = true;\n\n\t/* FIXME: allow for other auth types besides NTLMSSP (e.g. krb5) */\n\tses->sectype = RawNTLMSSP;\n\nssetup_ntlmssp_authenticate:\n\tif (phase == NtLmChallenge)\n\t\tphase = NtLmAuthenticate; /* if ntlmssp, now final phase */\n\n\trc = small_smb2_init(SMB2_SESSION_SETUP, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.SessionId = 0; /* First session, not a reauthenticate */\n\treq->VcNumber = 0; /* MBZ */\n\t/* to enable echos and oplocks */\n\treq->hdr.CreditRequest = cpu_to_le16(3);\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (server->sign)\n\t\treq->SecurityMode = SMB2_NEGOTIATE_SIGNING_REQUIRED;\n\telse if (global_secflags & CIFSSEC_MAY_SIGN) /* one flag unlike MUST_ */\n\t\treq->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = 0;\n\treq->Channel = 0; /* MBZ */\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\tif (phase == NtLmNegotiate) {\n\t\tntlmssp_blob = kmalloc(sizeof(struct _NEGOTIATE_MESSAGE),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (ntlmssp_blob == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto ssetup_exit;\n\t\t}\n\t\tbuild_ntlmssp_negotiate_blob(ntlmssp_blob, ses);\n\t\tif (use_spnego) {\n\t\t\t/* blob_length = build_spnego_ntlmssp_blob(\n\t\t\t\t\t&security_blob,\n\t\t\t\t\tsizeof(struct _NEGOTIATE_MESSAGE),\n\t\t\t\t\tntlmssp_blob); */\n\t\t\t/* BB eventually need to add this */\n\t\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tkfree(ntlmssp_blob);\n\t\t\tgoto ssetup_exit;\n\t\t} else {\n\t\t\tblob_length = sizeof(struct _NEGOTIATE_MESSAGE);\n\t\t\t/* with raw NTLMSSP we don't encapsulate in SPNEGO */\n\t\t\tsecurity_blob = ntlmssp_blob;\n\t\t}\n\t} else if (phase == NtLmAuthenticate) {\n\t\treq->hdr.SessionId = ses->Suid;\n\t\tntlmssp_blob = kzalloc(sizeof(struct _NEGOTIATE_MESSAGE) + 500,\n\t\t\t\t       GFP_KERNEL);\n\t\tif (ntlmssp_blob == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto ssetup_exit;\n\t\t}\n\t\trc = build_ntlmssp_auth_blob(ntlmssp_blob, &blob_length, ses,\n\t\t\t\t\t     nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"build_ntlmssp_auth_blob failed %d\\n\",\n\t\t\t\t rc);\n\t\t\tgoto ssetup_exit; /* BB double check error handling */\n\t\t}\n\t\tif (use_spnego) {\n\t\t\t/* blob_length = build_spnego_ntlmssp_blob(\n\t\t\t\t\t\t\t&security_blob,\n\t\t\t\t\t\t\tblob_length,\n\t\t\t\t\t\t\tntlmssp_blob); */\n\t\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tkfree(ntlmssp_blob);\n\t\t\tgoto ssetup_exit;\n\t\t} else {\n\t\t\tsecurity_blob = ntlmssp_blob;\n\t\t}\n\t} else {\n\t\tcifs_dbg(VFS, \"illegal ntlmssp phase\\n\");\n\t\trc = -EIO;\n\t\tgoto ssetup_exit;\n\t}\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->SecurityBufferOffset =\n\t\t\t\tcpu_to_le16(sizeof(struct smb2_sess_setup_req) -\n\t\t\t\t\t    1 /* pad */ - 4 /* rfc1001 len */);\n\treq->SecurityBufferLength = cpu_to_le16(blob_length);\n\tiov[1].iov_base = security_blob;\n\tiov[1].iov_len = blob_length;\n\n\tinc_rfc1001_len(req, blob_length - 1 /* pad */);\n\n\t/* BB add code to build os and lm fields */\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype,\n\t\t\t  CIFS_LOG_ERROR | CIFS_NEG_OP);\n\n\tkfree(security_blob);\n\trsp = (struct smb2_sess_setup_rsp *)iov[0].iov_base;\n\tif (resp_buftype != CIFS_NO_BUFFER &&\n\t    rsp->hdr.Status == STATUS_MORE_PROCESSING_REQUIRED) {\n\t\tif (phase != NtLmNegotiate) {\n\t\t\tcifs_dbg(VFS, \"Unexpected more processing error\\n\");\n\t\t\tgoto ssetup_exit;\n\t\t}\n\t\tif (offsetof(struct smb2_sess_setup_rsp, Buffer) - 4 !=\n\t\t\t\tle16_to_cpu(rsp->SecurityBufferOffset)) {\n\t\t\tcifs_dbg(VFS, \"Invalid security buffer offset %d\\n\",\n\t\t\t\t le16_to_cpu(rsp->SecurityBufferOffset));\n\t\t\trc = -EIO;\n\t\t\tgoto ssetup_exit;\n\t\t}\n\n\t\t/* NTLMSSP Negotiate sent now processing challenge (response) */\n\t\tphase = NtLmChallenge; /* process ntlmssp challenge */\n\t\trc = 0; /* MORE_PROCESSING is not an error here but expected */\n\t\tses->Suid = rsp->hdr.SessionId;\n\t\trc = decode_ntlmssp_challenge(rsp->Buffer,\n\t\t\t\tle16_to_cpu(rsp->SecurityBufferLength), ses);\n\t}\n\n\t/*\n\t * BB eventually add code for SPNEGO decoding of NtlmChallenge blob,\n\t * but at least the raw NTLMSSP case works.\n\t */\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc != 0)\n\t\tgoto ssetup_exit;\n\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tcifs_dbg(VFS, \"SMB3 encryption not supported yet\\n\");\nssetup_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\n\t/* if ntlmssp, and negotiate succeeded, proceed to authenticate phase */\n\tif ((phase == NtLmChallenge) && (rc == 0))\n\t\tgoto ssetup_ntlmssp_authenticate;\n\n\tif (!rc) {\n\t\tmutex_lock(&server->srv_mutex);\n\t\tif (server->sign && server->ops->generate_signingkey) {\n\t\t\trc = server->ops->generate_signingkey(ses);\n\t\t\tkfree(ses->auth_key.response);\n\t\t\tses->auth_key.response = NULL;\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI,\n\t\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\t\tmutex_unlock(&server->srv_mutex);\n\t\t\t\tgoto keygen_exit;\n\t\t\t}\n\t\t}\n\t\tif (!server->session_estab) {\n\t\t\tserver->sequence_number = 0x2;\n\t\t\tserver->session_estab = true;\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\n\t\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tses->status = CifsGood;\n\t\tses->need_reconnect = false;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\nkeygen_exit:\n\tif (!server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\tkfree(ses->ntlmssp);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->ntlmssp"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->auth_key.response"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SMB2/3 session established successfully\\n\""
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SMB3 session key generation failed\\n\""
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->auth_key.response"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->generate_signingkey",
          "args": [
            "ses"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "rsp"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"SMB3 encryption not supported yet\\n\""
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rsp->SessionFlags"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_ntlmssp_challenge",
          "args": [
            "rsp->Buffer",
            "le16_to_cpu(rsp->SecurityBufferLength)",
            "ses"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "decode_ntlmssp_challenge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "280-328",
          "snippet": "int decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\n\t\t\t\t    struct cifs_ses *ses)\n{\n\tunsigned int tioffset; /* challenge message target info area */\n\tunsigned int tilen; /* challenge message target info area length  */\n\n\tCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\n\n\tif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\n\t\tcifs_dbg(VFS, \"challenge blob len %d too small\\n\", blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(pblob->Signature, \"NTLMSSP\", 8)) {\n\t\tcifs_dbg(VFS, \"blob signature incorrect %s\\n\",\n\t\t\t pblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\tif (pblob->MessageType != NtLmChallenge) {\n\t\tcifs_dbg(VFS, \"Incorrect message type %d\\n\",\n\t\t\t pblob->MessageType);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\n\t/* BB we could decode pblob->NegotiateFlags; some may be useful */\n\t/* In particular we can examine sign flags */\n\t/* BB spec says that if AvId field of MsvAvTimestamp is populated then\n\t\twe must set the MIC field of the AUTHENTICATE_MESSAGE */\n\tses->ntlmssp->server_flags = le32_to_cpu(pblob->NegotiateFlags);\n\ttioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\n\ttilen = le16_to_cpu(pblob->TargetInfoArray.Length);\n\tif (tioffset > blob_len || tioffset + tilen > blob_len) {\n\t\tcifs_dbg(VFS, \"tioffset + tilen too high %u + %u\",\n\t\t\ttioffset, tilen);\n\t\treturn -EINVAL;\n\t}\n\tif (tilen) {\n\t\tses->auth_key.response = kmemdup(bcc_ptr + tioffset, tilen,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Challenge target info alloc failure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tses->auth_key.len = tilen;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nint decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\n\t\t\t\t    struct cifs_ses *ses)\n{\n\tunsigned int tioffset; /* challenge message target info area */\n\tunsigned int tilen; /* challenge message target info area length  */\n\n\tCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\n\n\tif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\n\t\tcifs_dbg(VFS, \"challenge blob len %d too small\\n\", blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(pblob->Signature, \"NTLMSSP\", 8)) {\n\t\tcifs_dbg(VFS, \"blob signature incorrect %s\\n\",\n\t\t\t pblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\tif (pblob->MessageType != NtLmChallenge) {\n\t\tcifs_dbg(VFS, \"Incorrect message type %d\\n\",\n\t\t\t pblob->MessageType);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\n\t/* BB we could decode pblob->NegotiateFlags; some may be useful */\n\t/* In particular we can examine sign flags */\n\t/* BB spec says that if AvId field of MsvAvTimestamp is populated then\n\t\twe must set the MIC field of the AUTHENTICATE_MESSAGE */\n\tses->ntlmssp->server_flags = le32_to_cpu(pblob->NegotiateFlags);\n\ttioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\n\ttilen = le16_to_cpu(pblob->TargetInfoArray.Length);\n\tif (tioffset > blob_len || tioffset + tilen > blob_len) {\n\t\tcifs_dbg(VFS, \"tioffset + tilen too high %u + %u\",\n\t\t\ttioffset, tilen);\n\t\treturn -EINVAL;\n\t}\n\tif (tilen) {\n\t\tses->auth_key.response = kmemdup(bcc_ptr + tioffset, tilen,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Challenge target info alloc failure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tses->auth_key.len = tilen;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Invalid security buffer offset %d\\n\"",
            "le16_to_cpu(rsp->SecurityBufferOffset)"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Unexpected more processing error\\n\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "security_blob"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "iov",
            "2",
            "&resp_buftype",
            "CIFS_LOG_ERROR | CIFS_NEG_OP"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "req",
            "blob_length - 1/* pad */"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "blob_length"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sizeof(struct smb2_sess_setup_req) -\n\t\t\t\t\t    1 /* pad */ - 4/* rfc1001 len */"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"illegal ntlmssp phase\\n\""
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ntlmssp_blob"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"spnego not supported for SMB2 yet\\n\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"build_ntlmssp_auth_blob failed %d\\n\"",
            "rc"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_ntlmssp_auth_blob",
          "args": [
            "ntlmssp_blob",
            "&blob_length",
            "ses",
            "nls_cp"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "build_ntlmssp_auth_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "370-472",
          "snippet": "int build_ntlmssp_auth_blob(unsigned char *pbuffer,\n\t\t\t\t\tu16 *buflen,\n\t\t\t\t   struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tint rc;\n\tAUTHENTICATE_MESSAGE *sec_blob = (AUTHENTICATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tunsigned char *tmp;\n\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmAuthenticate;\n\n\tflags = NTLMSSP_NEGOTIATE_56 |\n\t\tNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\ttmp = pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->LmChallengeResponse.BufferOffset =\n\t\t\t\tcpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));\n\tsec_blob->LmChallengeResponse.Length = 0;\n\tsec_blob->LmChallengeResponse.MaximumLength = 0;\n\n\tsec_blob->NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\trc = setup_ntlmv2_rsp(ses, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLMSSP authentication\\n\", rc);\n\t\tgoto setup_ntlmv2_ret;\n\t}\n\tmemcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\ttmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\tsec_blob->NtChallengeResponse.Length =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\tsec_blob->NtChallengeResponse.MaximumLength =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\n\tif (ses->domainName == NULL) {\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->DomainName.Length = 0;\n\t\tsec_blob->DomainName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->DomainName.Length = cpu_to_le16(len);\n\t\tsec_blob->DomainName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tif (ses->user_name == NULL) {\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->UserName.Length = 0;\n\t\tsec_blob->UserName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->UserName.Length = cpu_to_le16(len);\n\t\tsec_blob->UserName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tsec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\ttmp += 2;\n\n\tif (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||\n\t\t(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))\n\t\t\t&& !calc_seckey(ses)) {\n\t\tmemcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.MaximumLength =\n\t\t\t\tcpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\ttmp += CIFS_CPHTXT_SIZE;\n\t} else {\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->SessionKey.Length = 0;\n\t\tsec_blob->SessionKey.MaximumLength = 0;\n\t}\n\nsetup_ntlmv2_ret:\n\t*buflen = tmp - pbuffer;\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nint build_ntlmssp_auth_blob(unsigned char *pbuffer,\n\t\t\t\t\tu16 *buflen,\n\t\t\t\t   struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tint rc;\n\tAUTHENTICATE_MESSAGE *sec_blob = (AUTHENTICATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tunsigned char *tmp;\n\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmAuthenticate;\n\n\tflags = NTLMSSP_NEGOTIATE_56 |\n\t\tNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\ttmp = pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->LmChallengeResponse.BufferOffset =\n\t\t\t\tcpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));\n\tsec_blob->LmChallengeResponse.Length = 0;\n\tsec_blob->LmChallengeResponse.MaximumLength = 0;\n\n\tsec_blob->NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\trc = setup_ntlmv2_rsp(ses, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLMSSP authentication\\n\", rc);\n\t\tgoto setup_ntlmv2_ret;\n\t}\n\tmemcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\ttmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\tsec_blob->NtChallengeResponse.Length =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\tsec_blob->NtChallengeResponse.MaximumLength =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\n\tif (ses->domainName == NULL) {\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->DomainName.Length = 0;\n\t\tsec_blob->DomainName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->DomainName.Length = cpu_to_le16(len);\n\t\tsec_blob->DomainName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tif (ses->user_name == NULL) {\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->UserName.Length = 0;\n\t\tsec_blob->UserName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->UserName.Length = cpu_to_le16(len);\n\t\tsec_blob->UserName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tsec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\ttmp += 2;\n\n\tif (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||\n\t\t(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))\n\t\t\t&& !calc_seckey(ses)) {\n\t\tmemcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.MaximumLength =\n\t\t\t\tcpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\ttmp += CIFS_CPHTXT_SIZE;\n\t} else {\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\n\t\tsec_blob->SessionKey.Length = 0;\n\t\tsec_blob->SessionKey.MaximumLength = 0;\n\t}\n\nsetup_ntlmv2_ret:\n\t*buflen = tmp - pbuffer;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct _NEGOTIATE_MESSAGE) + 500",
            "GFP_KERNEL"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ntlmssp_blob"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"spnego not supported for SMB2 yet\\n\""
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_ntlmssp_negotiate_blob",
          "args": [
            "ntlmssp_blob",
            "ses"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "build_ntlmssp_negotiate_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "334-365",
          "snippet": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t/* BB is NTLMV2 session security format easier to use here? */\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\n\t/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nvoid build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t/* BB is NTLMV2 session security format easier to use here? */\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\n\t/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct _NEGOTIATE_MESSAGE)",
            "GFP_KERNEL"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "3"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_SESSION_SETUP",
            "NULL",
            "(void **) &req"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->auth_key.response"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"%s: server is NULL!\\n\"",
            "__func__"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Session Setup\\n\""
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,\n\t\tconst struct nls_table *nls_cp)\n{\n\tstruct smb2_sess_setup_req *req;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype = CIFS_NO_BUFFER;\n\t__le32 phase = NtLmNegotiate; /* NTLMSSP, if needed, is multistage */\n\tstruct TCP_Server_Info *server = ses->server;\n\tu16 blob_length = 0;\n\tchar *security_blob;\n\tchar *ntlmssp_blob = NULL;\n\tbool use_spnego = false; /* else use raw ntlmssp */\n\n\tcifs_dbg(FYI, \"Session Setup\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * If we are here due to reconnect, free per-smb session key\n\t * in case signing was required.\n\t */\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\n\t/*\n\t * If memory allocation is successful, caller of this function\n\t * frees it.\n\t */\n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp)\n\t\treturn -ENOMEM;\n\tses->ntlmssp->sesskey_per_smbsess = true;\n\n\t/* FIXME: allow for other auth types besides NTLMSSP (e.g. krb5) */\n\tses->sectype = RawNTLMSSP;\n\nssetup_ntlmssp_authenticate:\n\tif (phase == NtLmChallenge)\n\t\tphase = NtLmAuthenticate; /* if ntlmssp, now final phase */\n\n\trc = small_smb2_init(SMB2_SESSION_SETUP, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.SessionId = 0; /* First session, not a reauthenticate */\n\treq->VcNumber = 0; /* MBZ */\n\t/* to enable echos and oplocks */\n\treq->hdr.CreditRequest = cpu_to_le16(3);\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (server->sign)\n\t\treq->SecurityMode = SMB2_NEGOTIATE_SIGNING_REQUIRED;\n\telse if (global_secflags & CIFSSEC_MAY_SIGN) /* one flag unlike MUST_ */\n\t\treq->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = 0;\n\treq->Channel = 0; /* MBZ */\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\tif (phase == NtLmNegotiate) {\n\t\tntlmssp_blob = kmalloc(sizeof(struct _NEGOTIATE_MESSAGE),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (ntlmssp_blob == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto ssetup_exit;\n\t\t}\n\t\tbuild_ntlmssp_negotiate_blob(ntlmssp_blob, ses);\n\t\tif (use_spnego) {\n\t\t\t/* blob_length = build_spnego_ntlmssp_blob(\n\t\t\t\t\t&security_blob,\n\t\t\t\t\tsizeof(struct _NEGOTIATE_MESSAGE),\n\t\t\t\t\tntlmssp_blob); */\n\t\t\t/* BB eventually need to add this */\n\t\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tkfree(ntlmssp_blob);\n\t\t\tgoto ssetup_exit;\n\t\t} else {\n\t\t\tblob_length = sizeof(struct _NEGOTIATE_MESSAGE);\n\t\t\t/* with raw NTLMSSP we don't encapsulate in SPNEGO */\n\t\t\tsecurity_blob = ntlmssp_blob;\n\t\t}\n\t} else if (phase == NtLmAuthenticate) {\n\t\treq->hdr.SessionId = ses->Suid;\n\t\tntlmssp_blob = kzalloc(sizeof(struct _NEGOTIATE_MESSAGE) + 500,\n\t\t\t\t       GFP_KERNEL);\n\t\tif (ntlmssp_blob == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto ssetup_exit;\n\t\t}\n\t\trc = build_ntlmssp_auth_blob(ntlmssp_blob, &blob_length, ses,\n\t\t\t\t\t     nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"build_ntlmssp_auth_blob failed %d\\n\",\n\t\t\t\t rc);\n\t\t\tgoto ssetup_exit; /* BB double check error handling */\n\t\t}\n\t\tif (use_spnego) {\n\t\t\t/* blob_length = build_spnego_ntlmssp_blob(\n\t\t\t\t\t\t\t&security_blob,\n\t\t\t\t\t\t\tblob_length,\n\t\t\t\t\t\t\tntlmssp_blob); */\n\t\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tkfree(ntlmssp_blob);\n\t\t\tgoto ssetup_exit;\n\t\t} else {\n\t\t\tsecurity_blob = ntlmssp_blob;\n\t\t}\n\t} else {\n\t\tcifs_dbg(VFS, \"illegal ntlmssp phase\\n\");\n\t\trc = -EIO;\n\t\tgoto ssetup_exit;\n\t}\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->SecurityBufferOffset =\n\t\t\t\tcpu_to_le16(sizeof(struct smb2_sess_setup_req) -\n\t\t\t\t\t    1 /* pad */ - 4 /* rfc1001 len */);\n\treq->SecurityBufferLength = cpu_to_le16(blob_length);\n\tiov[1].iov_base = security_blob;\n\tiov[1].iov_len = blob_length;\n\n\tinc_rfc1001_len(req, blob_length - 1 /* pad */);\n\n\t/* BB add code to build os and lm fields */\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype,\n\t\t\t  CIFS_LOG_ERROR | CIFS_NEG_OP);\n\n\tkfree(security_blob);\n\trsp = (struct smb2_sess_setup_rsp *)iov[0].iov_base;\n\tif (resp_buftype != CIFS_NO_BUFFER &&\n\t    rsp->hdr.Status == STATUS_MORE_PROCESSING_REQUIRED) {\n\t\tif (phase != NtLmNegotiate) {\n\t\t\tcifs_dbg(VFS, \"Unexpected more processing error\\n\");\n\t\t\tgoto ssetup_exit;\n\t\t}\n\t\tif (offsetof(struct smb2_sess_setup_rsp, Buffer) - 4 !=\n\t\t\t\tle16_to_cpu(rsp->SecurityBufferOffset)) {\n\t\t\tcifs_dbg(VFS, \"Invalid security buffer offset %d\\n\",\n\t\t\t\t le16_to_cpu(rsp->SecurityBufferOffset));\n\t\t\trc = -EIO;\n\t\t\tgoto ssetup_exit;\n\t\t}\n\n\t\t/* NTLMSSP Negotiate sent now processing challenge (response) */\n\t\tphase = NtLmChallenge; /* process ntlmssp challenge */\n\t\trc = 0; /* MORE_PROCESSING is not an error here but expected */\n\t\tses->Suid = rsp->hdr.SessionId;\n\t\trc = decode_ntlmssp_challenge(rsp->Buffer,\n\t\t\t\tle16_to_cpu(rsp->SecurityBufferLength), ses);\n\t}\n\n\t/*\n\t * BB eventually add code for SPNEGO decoding of NtlmChallenge blob,\n\t * but at least the raw NTLMSSP case works.\n\t */\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc != 0)\n\t\tgoto ssetup_exit;\n\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tcifs_dbg(VFS, \"SMB3 encryption not supported yet\\n\");\nssetup_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\n\t/* if ntlmssp, and negotiate succeeded, proceed to authenticate phase */\n\tif ((phase == NtLmChallenge) && (rc == 0))\n\t\tgoto ssetup_ntlmssp_authenticate;\n\n\tif (!rc) {\n\t\tmutex_lock(&server->srv_mutex);\n\t\tif (server->sign && server->ops->generate_signingkey) {\n\t\t\trc = server->ops->generate_signingkey(ses);\n\t\t\tkfree(ses->auth_key.response);\n\t\t\tses->auth_key.response = NULL;\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI,\n\t\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\t\tmutex_unlock(&server->srv_mutex);\n\t\t\t\tgoto keygen_exit;\n\t\t\t}\n\t\t}\n\t\tif (!server->session_estab) {\n\t\t\tserver->sequence_number = 0x2;\n\t\t\tserver->session_estab = true;\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\n\t\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tses->status = CifsGood;\n\t\tses->need_reconnect = false;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\nkeygen_exit:\n\tif (!server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\tkfree(ses->ntlmssp);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smb3_validate_negotiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "448-522",
    "snippet": "int smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc = 0;\n\tstruct validate_negotiate_info_req vneg_inbuf;\n\tstruct validate_negotiate_info_rsp *pneg_rsp;\n\tu32 rsplen;\n\n\tcifs_dbg(FYI, \"validate negotiate\\n\");\n\n\t/*\n\t * validation ioctl must be signed, so no point sending this if we\n\t * can not sign it.  We could eventually change this to selectively\n\t * sign just this, the first and only signed request on a connection.\n\t * This is good enough for now since a user who wants better security\n\t * would also enable signing on the mount. Having validation of\n\t * negotiate info for signed connections helps reduce attack vectors\n\t */\n\tif (tcon->ses->server->sign == false)\n\t\treturn 0; /* validation requires signing */\n\n\tvneg_inbuf.Capabilities =\n\t\t\tcpu_to_le32(tcon->ses->server->vals->req_capabilities);\n\tmemcpy(vneg_inbuf.Guid, tcon->ses->server->client_guid,\n\t\t\t\t\tSMB2_CLIENT_GUID_SIZE);\n\n\tif (tcon->ses->sign)\n\t\tvneg_inbuf.SecurityMode =\n\t\t\tcpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\tvneg_inbuf.SecurityMode =\n\t\t\tcpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\tvneg_inbuf.SecurityMode = 0;\n\n\tvneg_inbuf.DialectCount = cpu_to_le16(1);\n\tvneg_inbuf.Dialects[0] =\n\t\tcpu_to_le16(tcon->ses->server->vals->protocol_id);\n\n\trc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\n\t\tFSCTL_VALIDATE_NEGOTIATE_INFO, true /* is_fsctl */,\n\t\t(char *)&vneg_inbuf, sizeof(struct validate_negotiate_info_req),\n\t\t(char **)&pneg_rsp, &rsplen);\n\n\tif (rc != 0) {\n\t\tcifs_dbg(VFS, \"validate protocol negotiate failed: %d\\n\", rc);\n\t\treturn -EIO;\n\t}\n\n\tif (rsplen != sizeof(struct validate_negotiate_info_rsp)) {\n\t\tcifs_dbg(VFS, \"invalid size of protocol negotiate response\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* check validate negotiate info response matches what we got earlier */\n\tif (pneg_rsp->Dialect !=\n\t\t\tcpu_to_le16(tcon->ses->server->vals->protocol_id))\n\t\tgoto vneg_out;\n\n\tif (pneg_rsp->SecurityMode != cpu_to_le16(tcon->ses->server->sec_mode))\n\t\tgoto vneg_out;\n\n\t/* do not validate server guid because not saved at negprot time yet */\n\n\tif ((le32_to_cpu(pneg_rsp->Capabilities) | SMB2_NT_FIND |\n\t      SMB2_LARGE_FILES) != tcon->ses->server->capabilities)\n\t\tgoto vneg_out;\n\n\t/* validate negotiate successful */\n\tcifs_dbg(FYI, \"validate negotiate info successful\\n\");\n\treturn 0;\n\nvneg_out:\n\tcifs_dbg(VFS, \"protocol revalidation - security settings mismatch\\n\");\n\treturn -EIO;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"protocol revalidation - security settings mismatch\\n\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"validate negotiate info successful\\n\""
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pneg_rsp->Capabilities"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "tcon->ses->server->sec_mode"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "tcon->ses->server->vals->protocol_id"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"invalid size of protocol negotiate response\\n\""
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"validate protocol negotiate failed: %d\\n\"",
            "rc"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_ioctl",
          "args": [
            "xid",
            "tcon",
            "NO_FILE_ID",
            "NO_FILE_ID",
            "FSCTL_VALIDATE_NEGOTIATE_INFO",
            "true/* is_fsctl */",
            "(char *)&vneg_inbuf",
            "sizeof(struct validate_negotiate_info_req)",
            "(char **)&pneg_rsp",
            "&rsplen"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1213-1346",
          "snippet": "int\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "tcon->ses->server->vals->protocol_id"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB2_NEGOTIATE_SIGNING_ENABLED"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB2_NEGOTIATE_SIGNING_REQUIRED"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vneg_inbuf.Guid",
            "tcon->ses->server->client_guid",
            "SMB2_CLIENT_GUID_SIZE"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tcon->ses->server->vals->req_capabilities"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"validate negotiate\\n\""
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc = 0;\n\tstruct validate_negotiate_info_req vneg_inbuf;\n\tstruct validate_negotiate_info_rsp *pneg_rsp;\n\tu32 rsplen;\n\n\tcifs_dbg(FYI, \"validate negotiate\\n\");\n\n\t/*\n\t * validation ioctl must be signed, so no point sending this if we\n\t * can not sign it.  We could eventually change this to selectively\n\t * sign just this, the first and only signed request on a connection.\n\t * This is good enough for now since a user who wants better security\n\t * would also enable signing on the mount. Having validation of\n\t * negotiate info for signed connections helps reduce attack vectors\n\t */\n\tif (tcon->ses->server->sign == false)\n\t\treturn 0; /* validation requires signing */\n\n\tvneg_inbuf.Capabilities =\n\t\t\tcpu_to_le32(tcon->ses->server->vals->req_capabilities);\n\tmemcpy(vneg_inbuf.Guid, tcon->ses->server->client_guid,\n\t\t\t\t\tSMB2_CLIENT_GUID_SIZE);\n\n\tif (tcon->ses->sign)\n\t\tvneg_inbuf.SecurityMode =\n\t\t\tcpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\tvneg_inbuf.SecurityMode =\n\t\t\tcpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\tvneg_inbuf.SecurityMode = 0;\n\n\tvneg_inbuf.DialectCount = cpu_to_le16(1);\n\tvneg_inbuf.Dialects[0] =\n\t\tcpu_to_le16(tcon->ses->server->vals->protocol_id);\n\n\trc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\n\t\tFSCTL_VALIDATE_NEGOTIATE_INFO, true /* is_fsctl */,\n\t\t(char *)&vneg_inbuf, sizeof(struct validate_negotiate_info_req),\n\t\t(char **)&pneg_rsp, &rsplen);\n\n\tif (rc != 0) {\n\t\tcifs_dbg(VFS, \"validate protocol negotiate failed: %d\\n\", rc);\n\t\treturn -EIO;\n\t}\n\n\tif (rsplen != sizeof(struct validate_negotiate_info_rsp)) {\n\t\tcifs_dbg(VFS, \"invalid size of protocol negotiate response\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* check validate negotiate info response matches what we got earlier */\n\tif (pneg_rsp->Dialect !=\n\t\t\tcpu_to_le16(tcon->ses->server->vals->protocol_id))\n\t\tgoto vneg_out;\n\n\tif (pneg_rsp->SecurityMode != cpu_to_le16(tcon->ses->server->sec_mode))\n\t\tgoto vneg_out;\n\n\t/* do not validate server guid because not saved at negprot time yet */\n\n\tif ((le32_to_cpu(pneg_rsp->Capabilities) | SMB2_NT_FIND |\n\t      SMB2_LARGE_FILES) != tcon->ses->server->capabilities)\n\t\tgoto vneg_out;\n\n\t/* validate negotiate successful */\n\tcifs_dbg(FYI, \"validate negotiate info successful\\n\");\n\treturn 0;\n\nvneg_out:\n\tcifs_dbg(VFS, \"protocol revalidation - security settings mismatch\\n\");\n\treturn -EIO;\n}"
  },
  {
    "function_name": "SMB2_negotiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "322-446",
    "snippet": "int\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb2_negotiate_req *req;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct kvec iov[1];\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server = ses->server;\n\tint blob_offset, blob_length;\n\tchar *security_blob;\n\tint flags = CIFS_NEG_OP;\n\n\tcifs_dbg(FYI, \"Negotiate protocol\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = small_smb2_init(SMB2_NEGOTIATE, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.SessionId = 0;\n\n\treq->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id);\n\n\treq->DialectCount = cpu_to_le16(1); /* One vers= at a time for now */\n\tinc_rfc1001_len(req, 2);\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (ses->sign)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);\n\n\t/* ClientGUID must be zero for SMB2.02 dialect */\n\tif (ses->server->vals->protocol_id == SMB20_PROT_ID)\n\t\tmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\telse\n\t\tmemcpy(req->ClientGUID, server->client_guid,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags);\n\n\trsp = (struct smb2_negotiate_rsp *)iov[0].iov_base;\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc != 0)\n\t\tgoto neg_exit;\n\n\tcifs_dbg(FYI, \"mode 0x%x\\n\", rsp->SecurityMode);\n\n\t/* BB we may eventually want to match the negotiated vs. requested\n\t   dialect, even though we are only requesting one at a time */\n\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.1 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.02 dialect\\n\");\n\telse {\n\t\tcifs_dbg(VFS, \"Illegal dialect returned by server %d\\n\",\n\t\t\t le16_to_cpu(rsp->DialectRevision));\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n\tserver->dialect = le16_to_cpu(rsp->DialectRevision);\n\n\t/* SMB2 only has an extended negflavor */\n\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t/* set it to the maximum buffer size value we can send with 1 credit */\n\tserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\n\t\t\t       SMB2_MAX_BUFFER_SIZE);\n\tserver->max_read = le32_to_cpu(rsp->MaxReadSize);\n\tserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\n\t/* BB Do we need to validate the SecurityMode? */\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tserver->capabilities = le32_to_cpu(rsp->Capabilities);\n\t/* Internal types */\n\tserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\n\n\tsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\n\t\t\t\t\t       &rsp->hdr);\n\t/*\n\t * See MS-SMB2 section 2.2.4: if no blob, client picks default which\n\t * for us will be\n\t *\tses->sectype = RawNTLMSSP;\n\t * but for time being this is our only auth choice so doesn't matter.\n\t * We just found a server which sets blob length to zero expecting raw.\n\t */\n\tif (blob_length == 0)\n\t\tcifs_dbg(FYI, \"missing security blob on negprot\\n\");\n\n\trc = cifs_enable_signing(server, ses->sign);\n#ifdef CONFIG_SMB2_ASN1  /* BB REMOVEME when updated asn1.c ready */\n\tif (rc)\n\t\tgoto neg_exit;\n\tif (blob_length)\n\t\trc = decode_negTokenInit(security_blob, blob_length, server);\n\tif (rc == 1)\n\t\trc = 0;\n\telse if (rc == 0) {\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n#endif\n\nneg_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buftype",
            "rsp"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_negTokenInit",
          "args": [
            "security_blob",
            "blob_length",
            "server"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "decode_negTokenInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/asn1.c",
          "lines": "493-623",
          "snippet": "int\ndecode_negTokenInit(unsigned char *security_blob, int length,\n\t\t    struct TCP_Server_Info *server)\n{\n\tstruct asn1_ctx ctx;\n\tunsigned char *end;\n\tunsigned char *sequence_end;\n\tunsigned long *oid = NULL;\n\tunsigned int cls, con, tag, oidlen, rc;\n\n\t/* cifs_dump_mem(\" Received SecBlob \", security_blob, length); */\n\n\tasn1_open(&ctx, security_blob, length);\n\n\t/* GSSAPI header */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit header\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_APL) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_EOC)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d\\n\", cls, con, tag);\n\t\treturn 0;\n\t}\n\n\t/* Check for SPNEGO OID -- remember to free obj->oid */\n\trc = asn1_header_decode(&ctx, &end, &cls, &con, &tag);\n\tif (rc) {\n\t\tif ((tag == ASN1_OJI) && (con == ASN1_PRI) &&\n\t\t    (cls == ASN1_UNI)) {\n\t\t\trc = asn1_oid_decode(&ctx, end, &oid, &oidlen);\n\t\t\tif (rc) {\n\t\t\t\trc = compare_oid(oid, oidlen, SPNEGO_OID,\n\t\t\t\t\t\t SPNEGO_OID_LEN);\n\t\t\t\tkfree(oid);\n\t\t\t}\n\t\t} else\n\t\t\trc = 0;\n\t}\n\n\t/* SPNEGO OID not present or garbled -- bail out */\n\tif (!rc) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit header\\n\");\n\t\treturn 0;\n\t}\n\n\t/* SPNEGO */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_CTX) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_EOC)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 0\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* negTokenInit */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_UNI) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_SEQ)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 1\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* sequence */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding 2nd part of negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_CTX) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_EOC)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 0\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* sequence of */\n\tif (asn1_header_decode\n\t    (&ctx, &sequence_end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding 2nd part of negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_UNI) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_SEQ)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 1\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* list of security mechanisms */\n\twhile (!asn1_eoc_decode(&ctx, sequence_end)) {\n\t\trc = asn1_header_decode(&ctx, &end, &cls, &con, &tag);\n\t\tif (!rc) {\n\t\t\tcifs_dbg(FYI, \"Error decoding negTokenInit hdr exit2\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif ((tag == ASN1_OJI) && (con == ASN1_PRI)) {\n\t\t\tif (asn1_oid_decode(&ctx, end, &oid, &oidlen)) {\n\n\t\t\t\tcifs_dbg(FYI, \"OID len = %d oid = 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t\t\t\t oidlen, *oid, *(oid + 1), *(oid + 2),\n\t\t\t\t\t *(oid + 3));\n\n\t\t\t\tif (compare_oid(oid, oidlen, MSKRB5_OID,\n\t\t\t\t\t\tMSKRB5_OID_LEN))\n\t\t\t\t\tserver->sec_mskerberos = true;\n\t\t\t\telse if (compare_oid(oid, oidlen, KRB5U2U_OID,\n\t\t\t\t\t\t     KRB5U2U_OID_LEN))\n\t\t\t\t\tserver->sec_kerberosu2u = true;\n\t\t\t\telse if (compare_oid(oid, oidlen, KRB5_OID,\n\t\t\t\t\t\t     KRB5_OID_LEN))\n\t\t\t\t\tserver->sec_kerberos = true;\n\t\t\t\telse if (compare_oid(oid, oidlen, NTLMSSP_OID,\n\t\t\t\t\t\t     NTLMSSP_OID_LEN))\n\t\t\t\t\tserver->sec_ntlmssp = true;\n\n\t\t\t\tkfree(oid);\n\t\t\t}\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"Should be an oid what is going on?\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We currently ignore anything at the end of the SPNEGO blob after\n\t * the mechTypes have been parsed, since none of that info is\n\t * used at the moment.\n\t */\n\treturn 1;\n}",
          "includes": [
            "#include \"cifsproto.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MSKRB5_OID_LEN  7",
            "#define KRB5U2U_OID_LEN  8",
            "#define KRB5_OID_LEN  7",
            "#define NTLMSSP_OID_LEN  10",
            "#define SPNEGO_OID_LEN 7",
            "#define ASN1_CON\t1\t/* Constructed */",
            "#define ASN1_PRI\t0\t/* Primitive */",
            "#define ASN1_SEQ\t16\t/* Sequence */",
            "#define ASN1_OJI\t6\t/* Object Identifier  */",
            "#define ASN1_EOC\t0\t/* End Of Contents or N/A */",
            "#define ASN1_CTX\t2\t/* Context */",
            "#define ASN1_APL\t1\t/* Application */",
            "#define ASN1_UNI\t0\t/* Universal */"
          ],
          "globals_used": [
            "static unsigned long SPNEGO_OID[7] = { 1, 3, 6, 1, 5, 5, 2 };",
            "static unsigned long NTLMSSP_OID[10] = { 1, 3, 6, 1, 4, 1, 311, 2, 2, 10 };",
            "static unsigned long KRB5_OID[7] = { 1, 2, 840, 113554, 1, 2, 2 };",
            "static unsigned long KRB5U2U_OID[8] = { 1, 2, 840, 113554, 1, 2, 2, 3 };",
            "static unsigned long MSKRB5_OID[7] = { 1, 2, 840, 48018, 1, 2, 2 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define MSKRB5_OID_LEN  7\n#define KRB5U2U_OID_LEN  8\n#define KRB5_OID_LEN  7\n#define NTLMSSP_OID_LEN  10\n#define SPNEGO_OID_LEN 7\n#define ASN1_CON\t1\t/* Constructed */\n#define ASN1_PRI\t0\t/* Primitive */\n#define ASN1_SEQ\t16\t/* Sequence */\n#define ASN1_OJI\t6\t/* Object Identifier  */\n#define ASN1_EOC\t0\t/* End Of Contents or N/A */\n#define ASN1_CTX\t2\t/* Context */\n#define ASN1_APL\t1\t/* Application */\n#define ASN1_UNI\t0\t/* Universal */\n\nstatic unsigned long SPNEGO_OID[7] = { 1, 3, 6, 1, 5, 5, 2 };\nstatic unsigned long NTLMSSP_OID[10] = { 1, 3, 6, 1, 4, 1, 311, 2, 2, 10 };\nstatic unsigned long KRB5_OID[7] = { 1, 2, 840, 113554, 1, 2, 2 };\nstatic unsigned long KRB5U2U_OID[8] = { 1, 2, 840, 113554, 1, 2, 2, 3 };\nstatic unsigned long MSKRB5_OID[7] = { 1, 2, 840, 48018, 1, 2, 2 };\n\nint\ndecode_negTokenInit(unsigned char *security_blob, int length,\n\t\t    struct TCP_Server_Info *server)\n{\n\tstruct asn1_ctx ctx;\n\tunsigned char *end;\n\tunsigned char *sequence_end;\n\tunsigned long *oid = NULL;\n\tunsigned int cls, con, tag, oidlen, rc;\n\n\t/* cifs_dump_mem(\" Received SecBlob \", security_blob, length); */\n\n\tasn1_open(&ctx, security_blob, length);\n\n\t/* GSSAPI header */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit header\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_APL) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_EOC)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d\\n\", cls, con, tag);\n\t\treturn 0;\n\t}\n\n\t/* Check for SPNEGO OID -- remember to free obj->oid */\n\trc = asn1_header_decode(&ctx, &end, &cls, &con, &tag);\n\tif (rc) {\n\t\tif ((tag == ASN1_OJI) && (con == ASN1_PRI) &&\n\t\t    (cls == ASN1_UNI)) {\n\t\t\trc = asn1_oid_decode(&ctx, end, &oid, &oidlen);\n\t\t\tif (rc) {\n\t\t\t\trc = compare_oid(oid, oidlen, SPNEGO_OID,\n\t\t\t\t\t\t SPNEGO_OID_LEN);\n\t\t\t\tkfree(oid);\n\t\t\t}\n\t\t} else\n\t\t\trc = 0;\n\t}\n\n\t/* SPNEGO OID not present or garbled -- bail out */\n\tif (!rc) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit header\\n\");\n\t\treturn 0;\n\t}\n\n\t/* SPNEGO */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_CTX) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_EOC)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 0\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* negTokenInit */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_UNI) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_SEQ)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 1\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* sequence */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding 2nd part of negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_CTX) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_EOC)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 0\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* sequence of */\n\tif (asn1_header_decode\n\t    (&ctx, &sequence_end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding 2nd part of negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_UNI) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_SEQ)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 1\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* list of security mechanisms */\n\twhile (!asn1_eoc_decode(&ctx, sequence_end)) {\n\t\trc = asn1_header_decode(&ctx, &end, &cls, &con, &tag);\n\t\tif (!rc) {\n\t\t\tcifs_dbg(FYI, \"Error decoding negTokenInit hdr exit2\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif ((tag == ASN1_OJI) && (con == ASN1_PRI)) {\n\t\t\tif (asn1_oid_decode(&ctx, end, &oid, &oidlen)) {\n\n\t\t\t\tcifs_dbg(FYI, \"OID len = %d oid = 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t\t\t\t oidlen, *oid, *(oid + 1), *(oid + 2),\n\t\t\t\t\t *(oid + 3));\n\n\t\t\t\tif (compare_oid(oid, oidlen, MSKRB5_OID,\n\t\t\t\t\t\tMSKRB5_OID_LEN))\n\t\t\t\t\tserver->sec_mskerberos = true;\n\t\t\t\telse if (compare_oid(oid, oidlen, KRB5U2U_OID,\n\t\t\t\t\t\t     KRB5U2U_OID_LEN))\n\t\t\t\t\tserver->sec_kerberosu2u = true;\n\t\t\t\telse if (compare_oid(oid, oidlen, KRB5_OID,\n\t\t\t\t\t\t     KRB5_OID_LEN))\n\t\t\t\t\tserver->sec_kerberos = true;\n\t\t\t\telse if (compare_oid(oid, oidlen, NTLMSSP_OID,\n\t\t\t\t\t\t     NTLMSSP_OID_LEN))\n\t\t\t\t\tserver->sec_ntlmssp = true;\n\n\t\t\t\tkfree(oid);\n\t\t\t}\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"Should be an oid what is going on?\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We currently ignore anything at the end of the SPNEGO blob after\n\t * the mechTypes have been parsed, since none of that info is\n\t * used at the moment.\n\t */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_enable_signing",
          "args": [
            "server",
            "ses->sign"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_enable_signing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "403-444",
          "snippet": "int\ncifs_enable_signing(struct TCP_Server_Info *server, bool mnt_sign_required)\n{\n\tbool srv_sign_required = server->sec_mode & server->vals->signing_required;\n\tbool srv_sign_enabled = server->sec_mode & server->vals->signing_enabled;\n\tbool mnt_sign_enabled = global_secflags & CIFSSEC_MAY_SIGN;\n\n\t/*\n\t * Is signing required by mnt options? If not then check\n\t * global_secflags to see if it is there.\n\t */\n\tif (!mnt_sign_required)\n\t\tmnt_sign_required = ((global_secflags & CIFSSEC_MUST_SIGN) ==\n\t\t\t\t\t\tCIFSSEC_MUST_SIGN);\n\n\t/*\n\t * If signing is required then it's automatically enabled too,\n\t * otherwise, check to see if the secflags allow it.\n\t */\n\tmnt_sign_enabled = mnt_sign_required ? mnt_sign_required :\n\t\t\t\t(global_secflags & CIFSSEC_MAY_SIGN);\n\n\t/* If server requires signing, does client allow it? */\n\tif (srv_sign_required) {\n\t\tif (!mnt_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server requires signing, but it's disabled in SecurityFlags!\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\t/* If client requires signing, does server allow it? */\n\tif (mnt_sign_required) {\n\t\tif (!srv_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server does not support signing!\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\ncifs_enable_signing(struct TCP_Server_Info *server, bool mnt_sign_required)\n{\n\tbool srv_sign_required = server->sec_mode & server->vals->signing_required;\n\tbool srv_sign_enabled = server->sec_mode & server->vals->signing_enabled;\n\tbool mnt_sign_enabled = global_secflags & CIFSSEC_MAY_SIGN;\n\n\t/*\n\t * Is signing required by mnt options? If not then check\n\t * global_secflags to see if it is there.\n\t */\n\tif (!mnt_sign_required)\n\t\tmnt_sign_required = ((global_secflags & CIFSSEC_MUST_SIGN) ==\n\t\t\t\t\t\tCIFSSEC_MUST_SIGN);\n\n\t/*\n\t * If signing is required then it's automatically enabled too,\n\t * otherwise, check to see if the secflags allow it.\n\t */\n\tmnt_sign_enabled = mnt_sign_required ? mnt_sign_required :\n\t\t\t\t(global_secflags & CIFSSEC_MAY_SIGN);\n\n\t/* If server requires signing, does client allow it? */\n\tif (srv_sign_required) {\n\t\tif (!mnt_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server requires signing, but it's disabled in SecurityFlags!\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\t/* If client requires signing, does server allow it? */\n\tif (mnt_sign_required) {\n\t\tif (!srv_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server does not support signing!\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"missing security blob on negprot\\n\""
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb2_get_data_area_len",
          "args": [
            "&blob_offset",
            "&blob_length",
            "&rsp->hdr"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_get_data_area_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "237-328",
          "snippet": "char *\nsmb2_get_data_area_len(int *off, int *len, struct smb2_hdr *hdr)\n{\n\t*off = 0;\n\t*len = 0;\n\n\t/* error responses do not have data area */\n\tif (hdr->Status && hdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\n\t    (((struct smb2_err_rsp *)hdr)->StructureSize) ==\n\t\t\t\t\t\tSMB2_ERROR_STRUCTURE_SIZE2)\n\t\treturn NULL;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_NEGOTIATE:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_negotiate_rsp *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t    ((struct smb2_negotiate_rsp *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t    ((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t\t*off = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)hdr)->CreateContextsOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)hdr)->CreateContextsLength);\n\t\tbreak;\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)hdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)hdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = ((struct smb2_read_rsp *)hdr)->DataOffset;\n\t\t*len = le32_to_cpu(((struct smb2_read_rsp *)hdr)->DataLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)hdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)hdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(\n\t\t  ((struct smb2_ioctl_rsp *)hdr)->OutputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_rsp *)hdr)->OutputCount);\n\t\tbreak;\n\tcase SMB2_CHANGE_NOTIFY:\n\tdefault:\n\t\t/* BB FIXME for unimplemented cases above */\n\t\tcifs_dbg(VFS, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\t/*\n\t * Invalid length or offset probably means data area is invalid, but\n\t * we have little choice but to ignore the data area in this case.\n\t */\n\tif (*off > 4096) {\n\t\tcifs_dbg(VFS, \"offset %d too large, data area ignored\\n\", *off);\n\t\t*len = 0;\n\t\t*off = 0;\n\t} else if (*off < 0) {\n\t\tcifs_dbg(VFS, \"negative offset %d to data invalid ignore data area\\n\",\n\t\t\t *off);\n\t\t*off = 0;\n\t\t*len = 0;\n\t} else if (*len < 0) {\n\t\tcifs_dbg(VFS, \"negative data length %d invalid, data area ignored\\n\",\n\t\t\t *len);\n\t\t*len = 0;\n\t} else if (*len > 128 * 1024) {\n\t\tcifs_dbg(VFS, \"data area larger than 128K: %d\\n\", *len);\n\t\t*len = 0;\n\t}\n\n\t/* return pointer to beginning of data area, ie offset from SMB start */\n\tif ((*off != 0) && (*len != 0))\n\t\treturn hdr->ProtocolId + *off;\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nchar *\nsmb2_get_data_area_len(int *off, int *len, struct smb2_hdr *hdr)\n{\n\t*off = 0;\n\t*len = 0;\n\n\t/* error responses do not have data area */\n\tif (hdr->Status && hdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\n\t    (((struct smb2_err_rsp *)hdr)->StructureSize) ==\n\t\t\t\t\t\tSMB2_ERROR_STRUCTURE_SIZE2)\n\t\treturn NULL;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_NEGOTIATE:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_negotiate_rsp *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t    ((struct smb2_negotiate_rsp *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t    ((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t\t*off = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)hdr)->CreateContextsOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)hdr)->CreateContextsLength);\n\t\tbreak;\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)hdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)hdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = ((struct smb2_read_rsp *)hdr)->DataOffset;\n\t\t*len = le32_to_cpu(((struct smb2_read_rsp *)hdr)->DataLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)hdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)hdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(\n\t\t  ((struct smb2_ioctl_rsp *)hdr)->OutputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_rsp *)hdr)->OutputCount);\n\t\tbreak;\n\tcase SMB2_CHANGE_NOTIFY:\n\tdefault:\n\t\t/* BB FIXME for unimplemented cases above */\n\t\tcifs_dbg(VFS, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\t/*\n\t * Invalid length or offset probably means data area is invalid, but\n\t * we have little choice but to ignore the data area in this case.\n\t */\n\tif (*off > 4096) {\n\t\tcifs_dbg(VFS, \"offset %d too large, data area ignored\\n\", *off);\n\t\t*len = 0;\n\t\t*off = 0;\n\t} else if (*off < 0) {\n\t\tcifs_dbg(VFS, \"negative offset %d to data invalid ignore data area\\n\",\n\t\t\t *off);\n\t\t*off = 0;\n\t\t*len = 0;\n\t} else if (*len < 0) {\n\t\tcifs_dbg(VFS, \"negative data length %d invalid, data area ignored\\n\",\n\t\t\t *len);\n\t\t*len = 0;\n\t} else if (*len > 128 * 1024) {\n\t\tcifs_dbg(VFS, \"data area larger than 128K: %d\\n\", *len);\n\t\t*len = 0;\n\t}\n\n\t/* return pointer to beginning of data area, ie offset from SMB start */\n\tif ((*off != 0) && (*len != 0))\n\t\treturn hdr->ProtocolId + *off;\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rsp->Capabilities"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rsp->SecurityMode"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "le32_to_cpu(rsp->MaxTransactSize)",
            "SMB2_MAX_BUFFER_SIZE"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Illegal dialect returned by server %d\\n\"",
            "le16_to_cpu(rsp->DialectRevision)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"negotiated smb3.02 dialect\\n\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB302_PROT_ID"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"negotiated smb3.0 dialect\\n\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB30_PROT_ID"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"negotiated smb2.1 dialect\\n\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB21_PROT_ID"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"negotiated smb2.0 dialect\\n\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB20_PROT_ID"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"mode 0x%x\\n\"",
            "rsp->SecurityMode"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "iov",
            "1",
            "&resp_buftype",
            "flags"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "req"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "req->ClientGUID",
            "server->client_guid",
            "SMB2_CLIENT_GUID_SIZE"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "req->ClientGUID",
            "0",
            "SMB2_CLIENT_GUID_SIZE"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ses->server->vals->req_capabilities"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB2_NEGOTIATE_SIGNING_ENABLED"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB2_NEGOTIATE_SIGNING_REQUIRED"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "req",
            "2"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ses->server->vals->protocol_id"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb2_init",
          "args": [
            "SMB2_NEGOTIATE",
            "NULL",
            "(void **) &req"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb2_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "277-305",
          "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"%s: server is NULL!\\n\"",
            "__func__"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Negotiate protocol\\n\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb2_negotiate_req *req;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct kvec iov[1];\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server = ses->server;\n\tint blob_offset, blob_length;\n\tchar *security_blob;\n\tint flags = CIFS_NEG_OP;\n\n\tcifs_dbg(FYI, \"Negotiate protocol\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = small_smb2_init(SMB2_NEGOTIATE, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.SessionId = 0;\n\n\treq->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id);\n\n\treq->DialectCount = cpu_to_le16(1); /* One vers= at a time for now */\n\tinc_rfc1001_len(req, 2);\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (ses->sign)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);\n\n\t/* ClientGUID must be zero for SMB2.02 dialect */\n\tif (ses->server->vals->protocol_id == SMB20_PROT_ID)\n\t\tmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\telse\n\t\tmemcpy(req->ClientGUID, server->client_guid,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags);\n\n\trsp = (struct smb2_negotiate_rsp *)iov[0].iov_base;\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc != 0)\n\t\tgoto neg_exit;\n\n\tcifs_dbg(FYI, \"mode 0x%x\\n\", rsp->SecurityMode);\n\n\t/* BB we may eventually want to match the negotiated vs. requested\n\t   dialect, even though we are only requesting one at a time */\n\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.1 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.02 dialect\\n\");\n\telse {\n\t\tcifs_dbg(VFS, \"Illegal dialect returned by server %d\\n\",\n\t\t\t le16_to_cpu(rsp->DialectRevision));\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n\tserver->dialect = le16_to_cpu(rsp->DialectRevision);\n\n\t/* SMB2 only has an extended negflavor */\n\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t/* set it to the maximum buffer size value we can send with 1 credit */\n\tserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\n\t\t\t       SMB2_MAX_BUFFER_SIZE);\n\tserver->max_read = le32_to_cpu(rsp->MaxReadSize);\n\tserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\n\t/* BB Do we need to validate the SecurityMode? */\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tserver->capabilities = le32_to_cpu(rsp->Capabilities);\n\t/* Internal types */\n\tserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\n\n\tsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\n\t\t\t\t\t       &rsp->hdr);\n\t/*\n\t * See MS-SMB2 section 2.2.4: if no blob, client picks default which\n\t * for us will be\n\t *\tses->sectype = RawNTLMSSP;\n\t * but for time being this is our only auth choice so doesn't matter.\n\t * We just found a server which sets blob length to zero expecting raw.\n\t */\n\tif (blob_length == 0)\n\t\tcifs_dbg(FYI, \"missing security blob on negprot\\n\");\n\n\trc = cifs_enable_signing(server, ses->sign);\n#ifdef CONFIG_SMB2_ASN1  /* BB REMOVEME when updated asn1.c ready */\n\tif (rc)\n\t\tgoto neg_exit;\n\tif (blob_length)\n\t\trc = decode_negTokenInit(security_blob, blob_length, server);\n\tif (rc == 1)\n\t\trc = 0;\n\telse if (rc == 0) {\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n#endif\n\nneg_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
  },
  {
    "function_name": "small_smb2_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "277-305",
    "snippet": "static int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->num_smbs_sent"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.smb2_stats.smb2_com_sent[com_code]"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "smb2_command"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb2_hdr_assemble",
          "args": [
            "(struct smb2_hdr *) *request_buf",
            "smb2_command",
            "tcon"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_hdr_assemble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "80-141",
          "snippet": "static void\nsmb2_hdr_assemble(struct smb2_hdr *hdr, __le16 smb2_cmd /* command */ ,\n\t\t  const struct cifs_tcon *tcon)\n{\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\n\tchar *temp = (char *)hdr;\n\t/* lookup word count ie StructureSize from table */\n\t__u16 parmsize = smb2_req_struct_sizes[le16_to_cpu(smb2_cmd)];\n\n\t/*\n\t * smaller than SMALL_BUFFER_SIZE but bigger than fixed area of\n\t * largest operations (Create)\n\t */\n\tmemset(temp, 0, 256);\n\n\t/* Note this is only network field converted to big endian */\n\thdr->smb2_buf_length = cpu_to_be32(parmsize + sizeof(struct smb2_hdr)\n\t\t\t- 4 /*  RFC 1001 length field itself not counted */);\n\n\thdr->ProtocolId[0] = 0xFE;\n\thdr->ProtocolId[1] = 'S';\n\thdr->ProtocolId[2] = 'M';\n\thdr->ProtocolId[3] = 'B';\n\thdr->StructureSize = cpu_to_le16(64);\n\thdr->Command = smb2_cmd;\n\thdr->CreditRequest = cpu_to_le16(2); /* BB make this dynamic */\n\thdr->ProcessId = cpu_to_le32((__u16)current->tgid);\n\n\tif (!tcon)\n\t\tgoto out;\n\n\t/* GLOBAL_CAP_LARGE_MTU will only be set if dialect > SMB2.02 */\n\t/* See sections 2.2.4 and 3.2.4.1.5 of MS-SMB2 */\n\tif ((tcon->ses) &&\n\t    (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\thdr->CreditCharge = cpu_to_le16(1);\n\t/* else CreditCharge MBZ */\n\n\thdr->TreeId = tcon->tid;\n\t/* Uid is not converted */\n\tif (tcon->ses)\n\t\thdr->SessionId = tcon->ses->Suid;\n\n\t/*\n\t * If we would set SMB2_FLAGS_DFS_OPERATIONS on open we also would have\n\t * to pass the path on the Open SMB prefixed by \\\\server\\share.\n\t * Not sure when we would need to do the augmented path (if ever) and\n\t * setting this flag breaks the SMB2 open operation since it is\n\t * illegal to send an empty path name (without \\\\server\\share prefix)\n\t * when the DFS flag is set in the SMB open header. We could\n\t * consider setting the flag on all operations other than open\n\t * but it is safer to net set it for now.\n\t */\n/*\tif (tcon->share_flags & SHI1005_FLAGS_DFS)\n\t\thdr->Flags |= SMB2_FLAGS_DFS_OPERATIONS; */\n\n\tif (tcon->ses && tcon->ses->server && tcon->ses->server->sign)\n\t\thdr->Flags |= SMB2_FLAGS_SIGNED;\nout:\n\tpdu->StructureSize2 = cpu_to_le16(parmsize);\n\treturn;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int smb2_req_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ 36,\n\t/* SMB2_SESSION_SETUP */ 25,\n\t/* SMB2_LOGOFF */ 4,\n\t/* SMB2_TREE_CONNECT */\t9,\n\t/* SMB2_TREE_DISCONNECT */ 4,\n\t/* SMB2_CREATE */ 57,\n\t/* SMB2_CLOSE */ 24,\n\t/* SMB2_FLUSH */ 24,\n\t/* SMB2_READ */\t49,\n\t/* SMB2_WRITE */ 49,\n\t/* SMB2_LOCK */\t48,\n\t/* SMB2_IOCTL */ 57,\n\t/* SMB2_CANCEL */ 4,\n\t/* SMB2_ECHO */ 4,\n\t/* SMB2_QUERY_DIRECTORY */ 33,\n\t/* SMB2_CHANGE_NOTIFY */ 32,\n\t/* SMB2_QUERY_INFO */ 41,\n\t/* SMB2_SET_INFO */ 33,\n\t/* SMB2_OPLOCK_BREAK */ 24 /* BB this is 36 for LEASE_BREAK variant */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic const int smb2_req_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ 36,\n\t/* SMB2_SESSION_SETUP */ 25,\n\t/* SMB2_LOGOFF */ 4,\n\t/* SMB2_TREE_CONNECT */\t9,\n\t/* SMB2_TREE_DISCONNECT */ 4,\n\t/* SMB2_CREATE */ 57,\n\t/* SMB2_CLOSE */ 24,\n\t/* SMB2_FLUSH */ 24,\n\t/* SMB2_READ */\t49,\n\t/* SMB2_WRITE */ 49,\n\t/* SMB2_LOCK */\t48,\n\t/* SMB2_IOCTL */ 57,\n\t/* SMB2_CANCEL */ 4,\n\t/* SMB2_ECHO */ 4,\n\t/* SMB2_QUERY_DIRECTORY */ 33,\n\t/* SMB2_CHANGE_NOTIFY */ 32,\n\t/* SMB2_QUERY_INFO */ 41,\n\t/* SMB2_SET_INFO */ 33,\n\t/* SMB2_OPLOCK_BREAK */ 24 /* BB this is 36 for LEASE_BREAK variant */\n};\n\nstatic void\nsmb2_hdr_assemble(struct smb2_hdr *hdr, __le16 smb2_cmd /* command */ ,\n\t\t  const struct cifs_tcon *tcon)\n{\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\n\tchar *temp = (char *)hdr;\n\t/* lookup word count ie StructureSize from table */\n\t__u16 parmsize = smb2_req_struct_sizes[le16_to_cpu(smb2_cmd)];\n\n\t/*\n\t * smaller than SMALL_BUFFER_SIZE but bigger than fixed area of\n\t * largest operations (Create)\n\t */\n\tmemset(temp, 0, 256);\n\n\t/* Note this is only network field converted to big endian */\n\thdr->smb2_buf_length = cpu_to_be32(parmsize + sizeof(struct smb2_hdr)\n\t\t\t- 4 /*  RFC 1001 length field itself not counted */);\n\n\thdr->ProtocolId[0] = 0xFE;\n\thdr->ProtocolId[1] = 'S';\n\thdr->ProtocolId[2] = 'M';\n\thdr->ProtocolId[3] = 'B';\n\thdr->StructureSize = cpu_to_le16(64);\n\thdr->Command = smb2_cmd;\n\thdr->CreditRequest = cpu_to_le16(2); /* BB make this dynamic */\n\thdr->ProcessId = cpu_to_le32((__u16)current->tgid);\n\n\tif (!tcon)\n\t\tgoto out;\n\n\t/* GLOBAL_CAP_LARGE_MTU will only be set if dialect > SMB2.02 */\n\t/* See sections 2.2.4 and 3.2.4.1.5 of MS-SMB2 */\n\tif ((tcon->ses) &&\n\t    (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\thdr->CreditCharge = cpu_to_le16(1);\n\t/* else CreditCharge MBZ */\n\n\thdr->TreeId = tcon->tid;\n\t/* Uid is not converted */\n\tif (tcon->ses)\n\t\thdr->SessionId = tcon->ses->Suid;\n\n\t/*\n\t * If we would set SMB2_FLAGS_DFS_OPERATIONS on open we also would have\n\t * to pass the path on the Open SMB prefixed by \\\\server\\share.\n\t * Not sure when we would need to do the augmented path (if ever) and\n\t * setting this flag breaks the SMB2 open operation since it is\n\t * illegal to send an empty path name (without \\\\server\\share prefix)\n\t * when the DFS flag is set in the SMB open header. We could\n\t * consider setting the flag on all operations other than open\n\t * but it is safer to net set it for now.\n\t */\n/*\tif (tcon->share_flags & SHI1005_FLAGS_DFS)\n\t\thdr->Flags |= SMB2_FLAGS_DFS_OPERATIONS; */\n\n\tif (tcon->ses && tcon->ses->server && tcon->ses->server->sign)\n\t\thdr->Flags |= SMB2_FLAGS_SIGNED;\nout:\n\tpdu->StructureSize2 = cpu_to_le16(parmsize);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_get",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "193-213",
          "snippet": "struct smb_hdr *\ncifs_small_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\n/* We could use negotiated size instead of max_msgsize -\n   but it may be more efficient to always alloc same size\n   albeit slightly larger than necessary and maxbuffersize\n   defaults to this and can not be bigger */\n\tret_buf = mempool_alloc(cifs_sm_req_poolp, GFP_NOFS);\n\tif (ret_buf) {\n\t/* No need to clear memory here, cleared in header assemble */\n\t/*\tmemset(ret_buf, 0, sizeof(struct smb_hdr) + 27);*/\n\t\tatomic_inc(&smBufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totSmBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\n\t}\n\treturn ret_buf;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nstruct smb_hdr *\ncifs_small_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\n/* We could use negotiated size instead of max_msgsize -\n   but it may be more efficient to always alloc same size\n   albeit slightly larger than necessary and maxbuffersize\n   defaults to this and can not be bigger */\n\tret_buf = mempool_alloc(cifs_sm_req_poolp, GFP_NOFS);\n\tif (ret_buf) {\n\t/* No need to clear memory here, cleared in header assemble */\n\t/*\tmemset(ret_buf, 0, sizeof(struct smb_hdr) + 27);*/\n\t\tatomic_inc(&smBufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totSmBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\n\t}\n\treturn ret_buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb2_reconnect",
          "args": [
            "smb2_command",
            "tcon"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_reconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "143-270",
          "snippet": "static int\nsmb2_reconnect(__le16 smb2_command, struct cifs_tcon *tcon)\n{\n\tint rc = 0;\n\tstruct nls_table *nls_codepage;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\n\t/*\n\t * SMB2s NegProt, SessSetup, Logoff do not have tcon yet so\n\t * check for tcp and smb session status done differently\n\t * for those three - in the calling routine.\n\t */\n\tif (tcon == NULL)\n\t\treturn rc;\n\n\tif (smb2_command == SMB2_TREE_CONNECT)\n\t\treturn rc;\n\n\tif (tcon->tidStatus == CifsExiting) {\n\t\t/*\n\t\t * only tree disconnect, open, and write,\n\t\t * (and ulogoff which does not have tcon)\n\t\t * are allowed as we start force umount.\n\t\t */\n\t\tif ((smb2_command != SMB2_WRITE) &&\n\t\t   (smb2_command != SMB2_CREATE) &&\n\t\t   (smb2_command != SMB2_TREE_DISCONNECT)) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb2_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif ((!tcon->ses) || (tcon->ses->status == CifsExiting) ||\n\t    (!tcon->ses->server))\n\t\treturn -EIO;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\t/*\n\t\t * Return to caller for TREE_DISCONNECT and LOGOFF and CLOSE\n\t\t * here since they are implicitly done when session drops.\n\t\t */\n\t\tswitch (smb2_command) {\n\t\t/*\n\t\t * BB Should we keep oplock break and add flush to exceptions?\n\t\t */\n\t\tcase SMB2_TREE_DISCONNECT:\n\t\tcase SMB2_CANCEL:\n\t\tcase SMB2_CLOSE:\n\t\tcase SMB2_OPLOCK_BREAK:\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!tcon->ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn rc;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously reconnect\n\t * the same SMB session\n\t */\n\tmutex_lock(&tcon->ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, tcon->ses);\n\tif (!rc && tcon->ses->need_reconnect)\n\t\trc = cifs_setup_session(0, tcon->ses, nls_codepage);\n\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&tcon->ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\trc = SMB2_tcon(0, tcon->ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&tcon->ses->session_mutex);\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out;\n\tatomic_inc(&tconInfoReconnectCount);\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle.\n\t */\n\t/*\n\t * BB Is flush done by server on drop of tcp session? Should we special\n\t * case it and skip above?\n\t */\n\tswitch (smb2_command) {\n\tcase SMB2_FLUSH:\n\tcase SMB2_READ:\n\tcase SMB2_WRITE:\n\tcase SMB2_LOCK:\n\tcase SMB2_IOCTL:\n\tcase SMB2_QUERY_DIRECTORY:\n\tcase SMB2_CHANGE_NOTIFY:\n\tcase SMB2_QUERY_INFO:\n\tcase SMB2_SET_INFO:\n\t\treturn -EAGAIN;\n\t}\n\tunload_nls(nls_codepage);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_reconnect(__le16 smb2_command, struct cifs_tcon *tcon)\n{\n\tint rc = 0;\n\tstruct nls_table *nls_codepage;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\n\t/*\n\t * SMB2s NegProt, SessSetup, Logoff do not have tcon yet so\n\t * check for tcp and smb session status done differently\n\t * for those three - in the calling routine.\n\t */\n\tif (tcon == NULL)\n\t\treturn rc;\n\n\tif (smb2_command == SMB2_TREE_CONNECT)\n\t\treturn rc;\n\n\tif (tcon->tidStatus == CifsExiting) {\n\t\t/*\n\t\t * only tree disconnect, open, and write,\n\t\t * (and ulogoff which does not have tcon)\n\t\t * are allowed as we start force umount.\n\t\t */\n\t\tif ((smb2_command != SMB2_WRITE) &&\n\t\t   (smb2_command != SMB2_CREATE) &&\n\t\t   (smb2_command != SMB2_TREE_DISCONNECT)) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb2_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif ((!tcon->ses) || (tcon->ses->status == CifsExiting) ||\n\t    (!tcon->ses->server))\n\t\treturn -EIO;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\t/*\n\t\t * Return to caller for TREE_DISCONNECT and LOGOFF and CLOSE\n\t\t * here since they are implicitly done when session drops.\n\t\t */\n\t\tswitch (smb2_command) {\n\t\t/*\n\t\t * BB Should we keep oplock break and add flush to exceptions?\n\t\t */\n\t\tcase SMB2_TREE_DISCONNECT:\n\t\tcase SMB2_CANCEL:\n\t\tcase SMB2_CLOSE:\n\t\tcase SMB2_OPLOCK_BREAK:\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!tcon->ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn rc;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously reconnect\n\t * the same SMB session\n\t */\n\tmutex_lock(&tcon->ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, tcon->ses);\n\tif (!rc && tcon->ses->need_reconnect)\n\t\trc = cifs_setup_session(0, tcon->ses, nls_codepage);\n\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&tcon->ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\trc = SMB2_tcon(0, tcon->ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&tcon->ses->session_mutex);\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out;\n\tatomic_inc(&tconInfoReconnectCount);\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle.\n\t */\n\t/*\n\t * BB Is flush done by server on drop of tcp session? Should we special\n\t * case it and skip above?\n\t */\n\tswitch (smb2_command) {\n\tcase SMB2_FLUSH:\n\tcase SMB2_READ:\n\tcase SMB2_WRITE:\n\tcase SMB2_LOCK:\n\tcase SMB2_IOCTL:\n\tcase SMB2_QUERY_DIRECTORY:\n\tcase SMB2_CHANGE_NOTIFY:\n\tcase SMB2_QUERY_INFO:\n\tcase SMB2_SET_INFO:\n\t\treturn -EAGAIN;\n\t}\n\tunload_nls(nls_codepage);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc = 0;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_reconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "143-270",
    "snippet": "static int\nsmb2_reconnect(__le16 smb2_command, struct cifs_tcon *tcon)\n{\n\tint rc = 0;\n\tstruct nls_table *nls_codepage;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\n\t/*\n\t * SMB2s NegProt, SessSetup, Logoff do not have tcon yet so\n\t * check for tcp and smb session status done differently\n\t * for those three - in the calling routine.\n\t */\n\tif (tcon == NULL)\n\t\treturn rc;\n\n\tif (smb2_command == SMB2_TREE_CONNECT)\n\t\treturn rc;\n\n\tif (tcon->tidStatus == CifsExiting) {\n\t\t/*\n\t\t * only tree disconnect, open, and write,\n\t\t * (and ulogoff which does not have tcon)\n\t\t * are allowed as we start force umount.\n\t\t */\n\t\tif ((smb2_command != SMB2_WRITE) &&\n\t\t   (smb2_command != SMB2_CREATE) &&\n\t\t   (smb2_command != SMB2_TREE_DISCONNECT)) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb2_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif ((!tcon->ses) || (tcon->ses->status == CifsExiting) ||\n\t    (!tcon->ses->server))\n\t\treturn -EIO;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\t/*\n\t\t * Return to caller for TREE_DISCONNECT and LOGOFF and CLOSE\n\t\t * here since they are implicitly done when session drops.\n\t\t */\n\t\tswitch (smb2_command) {\n\t\t/*\n\t\t * BB Should we keep oplock break and add flush to exceptions?\n\t\t */\n\t\tcase SMB2_TREE_DISCONNECT:\n\t\tcase SMB2_CANCEL:\n\t\tcase SMB2_CLOSE:\n\t\tcase SMB2_OPLOCK_BREAK:\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!tcon->ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn rc;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously reconnect\n\t * the same SMB session\n\t */\n\tmutex_lock(&tcon->ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, tcon->ses);\n\tif (!rc && tcon->ses->need_reconnect)\n\t\trc = cifs_setup_session(0, tcon->ses, nls_codepage);\n\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&tcon->ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\trc = SMB2_tcon(0, tcon->ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&tcon->ses->session_mutex);\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out;\n\tatomic_inc(&tconInfoReconnectCount);\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle.\n\t */\n\t/*\n\t * BB Is flush done by server on drop of tcp session? Should we special\n\t * case it and skip above?\n\t */\n\tswitch (smb2_command) {\n\tcase SMB2_FLUSH:\n\tcase SMB2_READ:\n\tcase SMB2_WRITE:\n\tcase SMB2_LOCK:\n\tcase SMB2_IOCTL:\n\tcase SMB2_QUERY_DIRECTORY:\n\tcase SMB2_CHANGE_NOTIFY:\n\tcase SMB2_QUERY_INFO:\n\tcase SMB2_SET_INFO:\n\t\treturn -EAGAIN;\n\t}\n\tunload_nls(nls_codepage);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "nls_codepage"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&tconInfoReconnectCount"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"reconnect tcon rc = %d\\n\"",
            "rc"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tcon->ses->session_mutex"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_tcon",
          "args": [
            "0",
            "tcon->ses",
            "tcon->treeName",
            "tcon",
            "nls_codepage"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "797-913",
          "snippet": "int\nSMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,\n\t  struct cifs_tcon *tcon, const struct nls_table *cp)\n{\n\tstruct smb2_tree_connect_req *req;\n\tstruct smb2_tree_connect_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype;\n\tint unc_path_len;\n\tstruct TCP_Server_Info *server;\n\t__le16 *unc_path = NULL;\n\n\tcifs_dbg(FYI, \"TCON\\n\");\n\n\tif ((ses->server) && tree)\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (tcon && tcon->bad_network_name)\n\t\treturn -ENOENT;\n\n\tunc_path = kmalloc(MAX_SHARENAME_LENGTH * 2, GFP_KERNEL);\n\tif (unc_path == NULL)\n\t\treturn -ENOMEM;\n\n\tunc_path_len = cifs_strtoUTF16(unc_path, tree, strlen(tree), cp) + 1;\n\tunc_path_len *= 2;\n\tif (unc_path_len < 2) {\n\t\tkfree(unc_path);\n\t\treturn -EINVAL;\n\t}\n\n\trc = small_smb2_init(SMB2_TREE_CONNECT, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(unc_path);\n\t\treturn rc;\n\t}\n\n\tif (tcon == NULL) {\n\t\t/* since no tcon, smb2_init can not do this, so do here */\n\t\treq->hdr.SessionId = ses->Suid;\n\t\t/* if (ses->server->sec_mode & SECMODE_SIGN_REQUIRED)\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED; */\n\t}\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->PathOffset = cpu_to_le16(sizeof(struct smb2_tree_connect_req)\n\t\t\t- 1 /* pad */ - 4 /* do not count rfc1001 len field */);\n\treq->PathLength = cpu_to_le16(unc_path_len - 2);\n\tiov[1].iov_base = unc_path;\n\tiov[1].iov_len = unc_path_len;\n\n\tinc_rfc1001_len(req, unc_path_len - 1 /* pad */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\n\trsp = (struct smb2_tree_connect_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tif (tcon) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_CONNECT_HE);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t\tgoto tcon_error_exit;\n\t}\n\n\tif (tcon == NULL) {\n\t\tses->ipc_tid = rsp->hdr.TreeId;\n\t\tgoto tcon_exit;\n\t}\n\n\tif (rsp->ShareType & SMB2_SHARE_TYPE_DISK)\n\t\tcifs_dbg(FYI, \"connection to disk share\\n\");\n\telse if (rsp->ShareType & SMB2_SHARE_TYPE_PIPE) {\n\t\ttcon->ipc = true;\n\t\tcifs_dbg(FYI, \"connection to pipe share\\n\");\n\t} else if (rsp->ShareType & SMB2_SHARE_TYPE_PRINT) {\n\t\ttcon->print = true;\n\t\tcifs_dbg(FYI, \"connection to printer\\n\");\n\t} else {\n\t\tcifs_dbg(VFS, \"unknown share type %d\\n\", rsp->ShareType);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto tcon_error_exit;\n\t}\n\n\ttcon->share_flags = le32_to_cpu(rsp->ShareFlags);\n\ttcon->capabilities = rsp->Capabilities; /* we keep caps little endian */\n\ttcon->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\ttcon->tidStatus = CifsGood;\n\ttcon->need_reconnect = false;\n\ttcon->tid = rsp->hdr.TreeId;\n\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\tif ((rsp->Capabilities & SMB2_SHARE_CAP_DFS) &&\n\t    ((tcon->share_flags & SHI1005_FLAGS_DFS) == 0))\n\t\tcifs_dbg(VFS, \"DFS capability contradicts DFS flag\\n\");\n\tinit_copy_chunk_defaults(tcon);\n\tif (tcon->ses->server->ops->validate_negotiate)\n\t\trc = tcon->ses->server->ops->validate_negotiate(xid, tcon);\ntcon_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(unc_path);\n\treturn rc;\n\ntcon_error_exit:\n\tif (rsp->hdr.Status == STATUS_BAD_NETWORK_NAME) {\n\t\tcifs_dbg(VFS, \"BAD_NETWORK_NAME: %s\\n\", tree);\n\t\tif (tcon)\n\t\t\ttcon->bad_network_name = true;\n\t}\n\tgoto tcon_exit;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_SHARENAME_LENGTH (255 /* server */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\n#define MAX_SHARENAME_LENGTH (255 /* server */\n\nint\nSMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,\n\t  struct cifs_tcon *tcon, const struct nls_table *cp)\n{\n\tstruct smb2_tree_connect_req *req;\n\tstruct smb2_tree_connect_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype;\n\tint unc_path_len;\n\tstruct TCP_Server_Info *server;\n\t__le16 *unc_path = NULL;\n\n\tcifs_dbg(FYI, \"TCON\\n\");\n\n\tif ((ses->server) && tree)\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (tcon && tcon->bad_network_name)\n\t\treturn -ENOENT;\n\n\tunc_path = kmalloc(MAX_SHARENAME_LENGTH * 2, GFP_KERNEL);\n\tif (unc_path == NULL)\n\t\treturn -ENOMEM;\n\n\tunc_path_len = cifs_strtoUTF16(unc_path, tree, strlen(tree), cp) + 1;\n\tunc_path_len *= 2;\n\tif (unc_path_len < 2) {\n\t\tkfree(unc_path);\n\t\treturn -EINVAL;\n\t}\n\n\trc = small_smb2_init(SMB2_TREE_CONNECT, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(unc_path);\n\t\treturn rc;\n\t}\n\n\tif (tcon == NULL) {\n\t\t/* since no tcon, smb2_init can not do this, so do here */\n\t\treq->hdr.SessionId = ses->Suid;\n\t\t/* if (ses->server->sec_mode & SECMODE_SIGN_REQUIRED)\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED; */\n\t}\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->PathOffset = cpu_to_le16(sizeof(struct smb2_tree_connect_req)\n\t\t\t- 1 /* pad */ - 4 /* do not count rfc1001 len field */);\n\treq->PathLength = cpu_to_le16(unc_path_len - 2);\n\tiov[1].iov_base = unc_path;\n\tiov[1].iov_len = unc_path_len;\n\n\tinc_rfc1001_len(req, unc_path_len - 1 /* pad */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\n\trsp = (struct smb2_tree_connect_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tif (tcon) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_CONNECT_HE);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t\tgoto tcon_error_exit;\n\t}\n\n\tif (tcon == NULL) {\n\t\tses->ipc_tid = rsp->hdr.TreeId;\n\t\tgoto tcon_exit;\n\t}\n\n\tif (rsp->ShareType & SMB2_SHARE_TYPE_DISK)\n\t\tcifs_dbg(FYI, \"connection to disk share\\n\");\n\telse if (rsp->ShareType & SMB2_SHARE_TYPE_PIPE) {\n\t\ttcon->ipc = true;\n\t\tcifs_dbg(FYI, \"connection to pipe share\\n\");\n\t} else if (rsp->ShareType & SMB2_SHARE_TYPE_PRINT) {\n\t\ttcon->print = true;\n\t\tcifs_dbg(FYI, \"connection to printer\\n\");\n\t} else {\n\t\tcifs_dbg(VFS, \"unknown share type %d\\n\", rsp->ShareType);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto tcon_error_exit;\n\t}\n\n\ttcon->share_flags = le32_to_cpu(rsp->ShareFlags);\n\ttcon->capabilities = rsp->Capabilities; /* we keep caps little endian */\n\ttcon->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\ttcon->tidStatus = CifsGood;\n\ttcon->need_reconnect = false;\n\ttcon->tid = rsp->hdr.TreeId;\n\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\tif ((rsp->Capabilities & SMB2_SHARE_CAP_DFS) &&\n\t    ((tcon->share_flags & SHI1005_FLAGS_DFS) == 0))\n\t\tcifs_dbg(VFS, \"DFS capability contradicts DFS flag\\n\");\n\tinit_copy_chunk_defaults(tcon);\n\tif (tcon->ses->server->ops->validate_negotiate)\n\t\trc = tcon->ses->server->ops->validate_negotiate(xid, tcon);\ntcon_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(unc_path);\n\treturn rc;\n\ntcon_error_exit:\n\tif (rsp->hdr.Status == STATUS_BAD_NETWORK_NAME) {\n\t\tcifs_dbg(VFS, \"BAD_NETWORK_NAME: %s\\n\", tree);\n\t\tif (tcon)\n\t\t\ttcon->bad_network_name = true;\n\t}\n\tgoto tcon_exit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_mark_open_files_invalid",
          "args": [
            "tcon"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_mark_open_files_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "93-112",
          "snippet": "void\ncifs_mark_open_files_invalid(struct cifs_tcon *tcon)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *tmp1;\n\n\t/* list all files open on tree connection and mark them invalid */\n\tspin_lock(&cifs_file_list_lock);\n\tlist_for_each_safe(tmp, tmp1, &tcon->openFileList) {\n\t\topen_file = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\topen_file->invalidHandle = true;\n\t\topen_file->oplock_break_cancelled = true;\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\t/*\n\t * BB Add call to invalidate_inodes(sb) for all superblocks mounted\n\t * to this tcon.\n\t */\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nvoid\ncifs_mark_open_files_invalid(struct cifs_tcon *tcon)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *tmp1;\n\n\t/* list all files open on tree connection and mark them invalid */\n\tspin_lock(&cifs_file_list_lock);\n\tlist_for_each_safe(tmp, tmp1, &tcon->openFileList) {\n\t\topen_file = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\topen_file->invalidHandle = true;\n\t\topen_file->oplock_break_cancelled = true;\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\t/*\n\t * BB Add call to invalidate_inodes(sb) for all superblocks mounted\n\t * to this tcon.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tcon->ses->session_mutex"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_setup_session",
          "args": [
            "0",
            "tcon->ses",
            "nls_codepage"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_setup_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3855-3876",
          "snippet": "int\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, nls_info);\n\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, nls_info);\n\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_negotiate_protocol",
          "args": [
            "0",
            "tcon->ses"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_negotiate_protocol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3827-3853",
          "snippet": "int\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t/* only send once per connect */\n\tif (!server->ops->need_neg(server))\n\t\treturn 0;\n\n\tset_credits(server, 1);\n\n\trc = server->ops->negotiate(xid, ses);\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t/* only send once per connect */\n\tif (!server->ops->need_neg(server))\n\t\treturn 0;\n\n\tset_credits(server, 1);\n\n\trc = server->ops->negotiate(xid, ses);\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tcon->ses->session_mutex"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_nls_default",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "load_nls_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "532-541",
          "snippet": "struct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nls_table default_table;",
            "static struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct nls_table default_table;\nstatic struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};\n\nstruct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"gave up waiting on reconnect in smb_init\\n\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "server->response_q",
            "(server->tcpStatus != CifsNeedReconnect)",
            "10 * HZ"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"can not send cmd %d while umounting\\n\"",
            "smb2_command"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb2_reconnect(__le16 smb2_command, struct cifs_tcon *tcon)\n{\n\tint rc = 0;\n\tstruct nls_table *nls_codepage;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\n\t/*\n\t * SMB2s NegProt, SessSetup, Logoff do not have tcon yet so\n\t * check for tcp and smb session status done differently\n\t * for those three - in the calling routine.\n\t */\n\tif (tcon == NULL)\n\t\treturn rc;\n\n\tif (smb2_command == SMB2_TREE_CONNECT)\n\t\treturn rc;\n\n\tif (tcon->tidStatus == CifsExiting) {\n\t\t/*\n\t\t * only tree disconnect, open, and write,\n\t\t * (and ulogoff which does not have tcon)\n\t\t * are allowed as we start force umount.\n\t\t */\n\t\tif ((smb2_command != SMB2_WRITE) &&\n\t\t   (smb2_command != SMB2_CREATE) &&\n\t\t   (smb2_command != SMB2_TREE_DISCONNECT)) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb2_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif ((!tcon->ses) || (tcon->ses->status == CifsExiting) ||\n\t    (!tcon->ses->server))\n\t\treturn -EIO;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\t/*\n\t\t * Return to caller for TREE_DISCONNECT and LOGOFF and CLOSE\n\t\t * here since they are implicitly done when session drops.\n\t\t */\n\t\tswitch (smb2_command) {\n\t\t/*\n\t\t * BB Should we keep oplock break and add flush to exceptions?\n\t\t */\n\t\tcase SMB2_TREE_DISCONNECT:\n\t\tcase SMB2_CANCEL:\n\t\tcase SMB2_CLOSE:\n\t\tcase SMB2_OPLOCK_BREAK:\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!tcon->ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn rc;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously reconnect\n\t * the same SMB session\n\t */\n\tmutex_lock(&tcon->ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, tcon->ses);\n\tif (!rc && tcon->ses->need_reconnect)\n\t\trc = cifs_setup_session(0, tcon->ses, nls_codepage);\n\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&tcon->ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\trc = SMB2_tcon(0, tcon->ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&tcon->ses->session_mutex);\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out;\n\tatomic_inc(&tconInfoReconnectCount);\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle.\n\t */\n\t/*\n\t * BB Is flush done by server on drop of tcp session? Should we special\n\t * case it and skip above?\n\t */\n\tswitch (smb2_command) {\n\tcase SMB2_FLUSH:\n\tcase SMB2_READ:\n\tcase SMB2_WRITE:\n\tcase SMB2_LOCK:\n\tcase SMB2_IOCTL:\n\tcase SMB2_QUERY_DIRECTORY:\n\tcase SMB2_CHANGE_NOTIFY:\n\tcase SMB2_QUERY_INFO:\n\tcase SMB2_SET_INFO:\n\t\treturn -EAGAIN;\n\t}\n\tunload_nls(nls_codepage);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_hdr_assemble",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
    "lines": "80-141",
    "snippet": "static void\nsmb2_hdr_assemble(struct smb2_hdr *hdr, __le16 smb2_cmd /* command */ ,\n\t\t  const struct cifs_tcon *tcon)\n{\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\n\tchar *temp = (char *)hdr;\n\t/* lookup word count ie StructureSize from table */\n\t__u16 parmsize = smb2_req_struct_sizes[le16_to_cpu(smb2_cmd)];\n\n\t/*\n\t * smaller than SMALL_BUFFER_SIZE but bigger than fixed area of\n\t * largest operations (Create)\n\t */\n\tmemset(temp, 0, 256);\n\n\t/* Note this is only network field converted to big endian */\n\thdr->smb2_buf_length = cpu_to_be32(parmsize + sizeof(struct smb2_hdr)\n\t\t\t- 4 /*  RFC 1001 length field itself not counted */);\n\n\thdr->ProtocolId[0] = 0xFE;\n\thdr->ProtocolId[1] = 'S';\n\thdr->ProtocolId[2] = 'M';\n\thdr->ProtocolId[3] = 'B';\n\thdr->StructureSize = cpu_to_le16(64);\n\thdr->Command = smb2_cmd;\n\thdr->CreditRequest = cpu_to_le16(2); /* BB make this dynamic */\n\thdr->ProcessId = cpu_to_le32((__u16)current->tgid);\n\n\tif (!tcon)\n\t\tgoto out;\n\n\t/* GLOBAL_CAP_LARGE_MTU will only be set if dialect > SMB2.02 */\n\t/* See sections 2.2.4 and 3.2.4.1.5 of MS-SMB2 */\n\tif ((tcon->ses) &&\n\t    (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\thdr->CreditCharge = cpu_to_le16(1);\n\t/* else CreditCharge MBZ */\n\n\thdr->TreeId = tcon->tid;\n\t/* Uid is not converted */\n\tif (tcon->ses)\n\t\thdr->SessionId = tcon->ses->Suid;\n\n\t/*\n\t * If we would set SMB2_FLAGS_DFS_OPERATIONS on open we also would have\n\t * to pass the path on the Open SMB prefixed by \\\\server\\share.\n\t * Not sure when we would need to do the augmented path (if ever) and\n\t * setting this flag breaks the SMB2 open operation since it is\n\t * illegal to send an empty path name (without \\\\server\\share prefix)\n\t * when the DFS flag is set in the SMB open header. We could\n\t * consider setting the flag on all operations other than open\n\t * but it is safer to net set it for now.\n\t */\n/*\tif (tcon->share_flags & SHI1005_FLAGS_DFS)\n\t\thdr->Flags |= SMB2_FLAGS_DFS_OPERATIONS; */\n\n\tif (tcon->ses && tcon->ses->server && tcon->ses->server->sign)\n\t\thdr->Flags |= SMB2_FLAGS_SIGNED;\nout:\n\tpdu->StructureSize2 = cpu_to_le16(parmsize);\n\treturn;\n}",
    "includes": [
      "#include \"cifspdu.h\"",
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const int smb2_req_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ 36,\n\t/* SMB2_SESSION_SETUP */ 25,\n\t/* SMB2_LOGOFF */ 4,\n\t/* SMB2_TREE_CONNECT */\t9,\n\t/* SMB2_TREE_DISCONNECT */ 4,\n\t/* SMB2_CREATE */ 57,\n\t/* SMB2_CLOSE */ 24,\n\t/* SMB2_FLUSH */ 24,\n\t/* SMB2_READ */\t49,\n\t/* SMB2_WRITE */ 49,\n\t/* SMB2_LOCK */\t48,\n\t/* SMB2_IOCTL */ 57,\n\t/* SMB2_CANCEL */ 4,\n\t/* SMB2_ECHO */ 4,\n\t/* SMB2_QUERY_DIRECTORY */ 33,\n\t/* SMB2_CHANGE_NOTIFY */ 32,\n\t/* SMB2_QUERY_INFO */ 41,\n\t/* SMB2_SET_INFO */ 33,\n\t/* SMB2_OPLOCK_BREAK */ 24 /* BB this is 36 for LEASE_BREAK variant */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "parmsize"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(__u16)current->tgid"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "64"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "parmsize + sizeof(struct smb2_hdr)\n\t\t\t- 4/*  RFC 1001 length field itself not counted */"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "temp",
            "0",
            "256"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "smb2_cmd"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic const int smb2_req_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ 36,\n\t/* SMB2_SESSION_SETUP */ 25,\n\t/* SMB2_LOGOFF */ 4,\n\t/* SMB2_TREE_CONNECT */\t9,\n\t/* SMB2_TREE_DISCONNECT */ 4,\n\t/* SMB2_CREATE */ 57,\n\t/* SMB2_CLOSE */ 24,\n\t/* SMB2_FLUSH */ 24,\n\t/* SMB2_READ */\t49,\n\t/* SMB2_WRITE */ 49,\n\t/* SMB2_LOCK */\t48,\n\t/* SMB2_IOCTL */ 57,\n\t/* SMB2_CANCEL */ 4,\n\t/* SMB2_ECHO */ 4,\n\t/* SMB2_QUERY_DIRECTORY */ 33,\n\t/* SMB2_CHANGE_NOTIFY */ 32,\n\t/* SMB2_QUERY_INFO */ 41,\n\t/* SMB2_SET_INFO */ 33,\n\t/* SMB2_OPLOCK_BREAK */ 24 /* BB this is 36 for LEASE_BREAK variant */\n};\n\nstatic void\nsmb2_hdr_assemble(struct smb2_hdr *hdr, __le16 smb2_cmd /* command */ ,\n\t\t  const struct cifs_tcon *tcon)\n{\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\n\tchar *temp = (char *)hdr;\n\t/* lookup word count ie StructureSize from table */\n\t__u16 parmsize = smb2_req_struct_sizes[le16_to_cpu(smb2_cmd)];\n\n\t/*\n\t * smaller than SMALL_BUFFER_SIZE but bigger than fixed area of\n\t * largest operations (Create)\n\t */\n\tmemset(temp, 0, 256);\n\n\t/* Note this is only network field converted to big endian */\n\thdr->smb2_buf_length = cpu_to_be32(parmsize + sizeof(struct smb2_hdr)\n\t\t\t- 4 /*  RFC 1001 length field itself not counted */);\n\n\thdr->ProtocolId[0] = 0xFE;\n\thdr->ProtocolId[1] = 'S';\n\thdr->ProtocolId[2] = 'M';\n\thdr->ProtocolId[3] = 'B';\n\thdr->StructureSize = cpu_to_le16(64);\n\thdr->Command = smb2_cmd;\n\thdr->CreditRequest = cpu_to_le16(2); /* BB make this dynamic */\n\thdr->ProcessId = cpu_to_le32((__u16)current->tgid);\n\n\tif (!tcon)\n\t\tgoto out;\n\n\t/* GLOBAL_CAP_LARGE_MTU will only be set if dialect > SMB2.02 */\n\t/* See sections 2.2.4 and 3.2.4.1.5 of MS-SMB2 */\n\tif ((tcon->ses) &&\n\t    (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\thdr->CreditCharge = cpu_to_le16(1);\n\t/* else CreditCharge MBZ */\n\n\thdr->TreeId = tcon->tid;\n\t/* Uid is not converted */\n\tif (tcon->ses)\n\t\thdr->SessionId = tcon->ses->Suid;\n\n\t/*\n\t * If we would set SMB2_FLAGS_DFS_OPERATIONS on open we also would have\n\t * to pass the path on the Open SMB prefixed by \\\\server\\share.\n\t * Not sure when we would need to do the augmented path (if ever) and\n\t * setting this flag breaks the SMB2 open operation since it is\n\t * illegal to send an empty path name (without \\\\server\\share prefix)\n\t * when the DFS flag is set in the SMB open header. We could\n\t * consider setting the flag on all operations other than open\n\t * but it is safer to net set it for now.\n\t */\n/*\tif (tcon->share_flags & SHI1005_FLAGS_DFS)\n\t\thdr->Flags |= SMB2_FLAGS_DFS_OPERATIONS; */\n\n\tif (tcon->ses && tcon->ses->server && tcon->ses->server->sign)\n\t\thdr->Flags |= SMB2_FLAGS_SIGNED;\nout:\n\tpdu->StructureSize2 = cpu_to_le16(parmsize);\n\treturn;\n}"
  }
]