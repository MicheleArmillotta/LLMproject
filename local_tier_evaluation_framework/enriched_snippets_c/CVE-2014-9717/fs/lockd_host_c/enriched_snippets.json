[
  {
    "function_name": "nlm_gc_hosts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "639-675",
    "snippet": "static void\nnlm_gc_hosts(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct hlist_node *next;\n\tstruct nlm_host\t*host;\n\n\tdprintk(\"lockd: host garbage collection for net %p\\n\", net);\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\thost->h_inuse = 0;\n\t}\n\n\t/* Mark all hosts that hold locks, blocks or shares */\n\tnlmsvc_mark_resources(net);\n\n\tfor_each_host_safe(host, next, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\tif (atomic_read(&host->h_count) || host->h_inuse\n\t\t || time_before(jiffies, host->h_expires)) {\n\t\t\tdprintk(\"nlm_gc_hosts skipping %s \"\n\t\t\t\t\"(cnt %d use %d exp %ld net %p)\\n\",\n\t\t\t\thost->h_name, atomic_read(&host->h_count),\n\t\t\t\thost->h_inuse, host->h_expires, host->net);\n\t\t\tcontinue;\n\t\t}\n\t\tnlm_destroy_host_locked(host);\n\t}\n\n\tif (net) {\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tln->next_gc = jiffies + NLM_HOST_COLLECT;\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NLM_HOST_COLLECT\t(120 * HZ)"
    ],
    "globals_used": [
      "static struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];",
      "static void\t\t\tnlm_gc_hosts(struct net *net);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "lockd_net_id"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_destroy_host_locked",
          "args": [
            "host"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_destroy_host_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "174-193",
          "snippet": "static void nlm_destroy_host_locked(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\tstruct lockd_net *ln = net_generic(host->net, lockd_net_id);\n\n\tdprintk(\"lockd: destroy host %s\\n\", host->h_name);\n\n\thlist_del_init(&host->h_hash);\n\n\tnsm_unmonitor(host);\n\tnsm_release(host->h_nsmhandle);\n\n\tclnt = host->h_rpcclnt;\n\tif (clnt != NULL)\n\t\trpc_shutdown_client(clnt);\n\tkfree(host);\n\n\tln->nrhosts--;\n\tnrhosts--;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long\t\tnrhosts;",
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic unsigned long\t\tnrhosts;\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstatic void nlm_destroy_host_locked(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\tstruct lockd_net *ln = net_generic(host->net, lockd_net_id);\n\n\tdprintk(\"lockd: destroy host %s\\n\", host->h_name);\n\n\thlist_del_init(&host->h_hash);\n\n\tnsm_unmonitor(host);\n\tnsm_release(host->h_nsmhandle);\n\n\tclnt = host->h_rpcclnt;\n\tif (clnt != NULL)\n\t\trpc_shutdown_client(clnt);\n\tkfree(host);\n\n\tln->nrhosts--;\n\tnrhosts--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nlm_gc_hosts skipping %s \"\n\t\t\t\t\"(cnt %d use %d exp %ld net %p)\\n\"",
            "host->h_name",
            "atomic_read(&host->h_count)",
            "host->h_inuse",
            "host->h_expires",
            "host->net"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&host->h_count"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "host->h_expires"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&host->h_count"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_host_safe",
          "args": [
            "host",
            "next",
            "chain",
            "nlm_server_hosts"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_mark_resources",
          "args": [
            "net"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_mark_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcsubs.c",
          "lines": "368-376",
          "snippet": "void\nnlmsvc_mark_resources(struct net *net)\n{\n\tstruct nlm_host hint;\n\n\tdprintk(\"lockd: nlmsvc_mark_resources for net %p\\n\", net);\n\thint.net = net;\n\tnlm_traverse_files(&hint, nlmsvc_mark_host, NULL);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/in.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nvoid\nnlmsvc_mark_resources(struct net *net)\n{\n\tstruct nlm_host hint;\n\n\tdprintk(\"lockd: nlmsvc_mark_resources for net %p\\n\", net);\n\thint.net = net;\n\tnlm_traverse_files(&hint, nlmsvc_mark_host, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_host",
          "args": [
            "host",
            "chain",
            "nlm_server_hosts"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: host garbage collection for net %p\\n\"",
            "net"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_COLLECT\t(120 * HZ)\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstatic void\nnlm_gc_hosts(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct hlist_node *next;\n\tstruct nlm_host\t*host;\n\n\tdprintk(\"lockd: host garbage collection for net %p\\n\", net);\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\thost->h_inuse = 0;\n\t}\n\n\t/* Mark all hosts that hold locks, blocks or shares */\n\tnlmsvc_mark_resources(net);\n\n\tfor_each_host_safe(host, next, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\tif (atomic_read(&host->h_count) || host->h_inuse\n\t\t || time_before(jiffies, host->h_expires)) {\n\t\t\tdprintk(\"nlm_gc_hosts skipping %s \"\n\t\t\t\t\"(cnt %d use %d exp %ld net %p)\\n\",\n\t\t\t\thost->h_name, atomic_read(&host->h_count),\n\t\t\t\thost->h_inuse, host->h_expires, host->net);\n\t\t\tcontinue;\n\t\t}\n\t\tnlm_destroy_host_locked(host);\n\t}\n\n\tif (net) {\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tln->next_gc = jiffies + NLM_HOST_COLLECT;\n\t}\n}"
  },
  {
    "function_name": "nlm_shutdown_hosts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "627-632",
    "snippet": "void\nnlm_shutdown_hosts(void)\n{\n\tdprintk(\"lockd: shutting down host module\\n\");\n\tnlm_shutdown_hosts_net(NULL);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_shutdown_hosts_net",
          "args": [
            "NULL"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_shutdown_hosts_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "596-621",
          "snippet": "void\nnlm_shutdown_hosts_net(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\n\tmutex_lock(&nlm_host_mutex);\n\n\t/* First, make all hosts eligible for gc */\n\tdprintk(\"lockd: nuking all hosts in net %p...\\n\", net);\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\thost->h_expires = jiffies - 1;\n\t\tif (host->h_rpcclnt) {\n\t\t\trpc_shutdown_client(host->h_rpcclnt);\n\t\t\thost->h_rpcclnt = NULL;\n\t\t}\n\t}\n\n\t/* Then, perform a garbage collection pass */\n\tnlm_gc_hosts(net);\n\tmutex_unlock(&nlm_host_mutex);\n\n\tnlm_complain_hosts(net);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];",
            "static DEFINE_MUTEX(nlm_host_mutex);",
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic DEFINE_MUTEX(nlm_host_mutex);\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nvoid\nnlm_shutdown_hosts_net(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\n\tmutex_lock(&nlm_host_mutex);\n\n\t/* First, make all hosts eligible for gc */\n\tdprintk(\"lockd: nuking all hosts in net %p...\\n\", net);\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\thost->h_expires = jiffies - 1;\n\t\tif (host->h_rpcclnt) {\n\t\t\trpc_shutdown_client(host->h_rpcclnt);\n\t\t\thost->h_rpcclnt = NULL;\n\t\t}\n\t}\n\n\t/* Then, perform a garbage collection pass */\n\tnlm_gc_hosts(net);\n\tmutex_unlock(&nlm_host_mutex);\n\n\tnlm_complain_hosts(net);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: shutting down host module\\n\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid\nnlm_shutdown_hosts(void)\n{\n\tdprintk(\"lockd: shutting down host module\\n\");\n\tnlm_shutdown_hosts_net(NULL);\n}"
  },
  {
    "function_name": "nlm_shutdown_hosts_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "596-621",
    "snippet": "void\nnlm_shutdown_hosts_net(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\n\tmutex_lock(&nlm_host_mutex);\n\n\t/* First, make all hosts eligible for gc */\n\tdprintk(\"lockd: nuking all hosts in net %p...\\n\", net);\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\thost->h_expires = jiffies - 1;\n\t\tif (host->h_rpcclnt) {\n\t\t\trpc_shutdown_client(host->h_rpcclnt);\n\t\t\thost->h_rpcclnt = NULL;\n\t\t}\n\t}\n\n\t/* Then, perform a garbage collection pass */\n\tnlm_gc_hosts(net);\n\tmutex_unlock(&nlm_host_mutex);\n\n\tnlm_complain_hosts(net);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];",
      "static DEFINE_MUTEX(nlm_host_mutex);",
      "static void\t\t\tnlm_gc_hosts(struct net *net);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_complain_hosts",
          "args": [
            "net"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_complain_hosts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "568-594",
          "snippet": "static void nlm_complain_hosts(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\n\tif (net) {\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tif (ln->nrhosts == 0)\n\t\t\treturn;\n\t\tprintk(KERN_WARNING \"lockd: couldn't shutdown host module for net %p!\\n\", net);\n\t\tdprintk(\"lockd: %lu hosts left in net %p:\\n\", ln->nrhosts, net);\n\t} else {\n\t\tif (nrhosts == 0)\n\t\t\treturn;\n\t\tprintk(KERN_WARNING \"lockd: couldn't shutdown host module!\\n\");\n\t\tdprintk(\"lockd: %lu hosts left:\\n\", nrhosts);\n\t}\n\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\tdprintk(\"       %s (cnt %d use %d exp %ld net %p)\\n\",\n\t\t\thost->h_name, atomic_read(&host->h_count),\n\t\t\thost->h_inuse, host->h_expires, host->net);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];",
            "static unsigned long\t\tnrhosts;",
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic unsigned long\t\tnrhosts;\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstatic void nlm_complain_hosts(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\n\tif (net) {\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tif (ln->nrhosts == 0)\n\t\t\treturn;\n\t\tprintk(KERN_WARNING \"lockd: couldn't shutdown host module for net %p!\\n\", net);\n\t\tdprintk(\"lockd: %lu hosts left in net %p:\\n\", ln->nrhosts, net);\n\t} else {\n\t\tif (nrhosts == 0)\n\t\t\treturn;\n\t\tprintk(KERN_WARNING \"lockd: couldn't shutdown host module!\\n\");\n\t\tdprintk(\"lockd: %lu hosts left:\\n\", nrhosts);\n\t}\n\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\tdprintk(\"       %s (cnt %d use %d exp %ld net %p)\\n\",\n\t\t\thost->h_name, atomic_read(&host->h_count),\n\t\t\thost->h_inuse, host->h_expires, host->net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nlm_host_mutex"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_gc_hosts",
          "args": [
            "net"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_gc_hosts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "639-675",
          "snippet": "static void\nnlm_gc_hosts(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct hlist_node *next;\n\tstruct nlm_host\t*host;\n\n\tdprintk(\"lockd: host garbage collection for net %p\\n\", net);\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\thost->h_inuse = 0;\n\t}\n\n\t/* Mark all hosts that hold locks, blocks or shares */\n\tnlmsvc_mark_resources(net);\n\n\tfor_each_host_safe(host, next, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\tif (atomic_read(&host->h_count) || host->h_inuse\n\t\t || time_before(jiffies, host->h_expires)) {\n\t\t\tdprintk(\"nlm_gc_hosts skipping %s \"\n\t\t\t\t\"(cnt %d use %d exp %ld net %p)\\n\",\n\t\t\t\thost->h_name, atomic_read(&host->h_count),\n\t\t\t\thost->h_inuse, host->h_expires, host->net);\n\t\t\tcontinue;\n\t\t}\n\t\tnlm_destroy_host_locked(host);\n\t}\n\n\tif (net) {\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tln->next_gc = jiffies + NLM_HOST_COLLECT;\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_COLLECT\t(120 * HZ)"
          ],
          "globals_used": [
            "static struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];",
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_COLLECT\t(120 * HZ)\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstatic void\nnlm_gc_hosts(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct hlist_node *next;\n\tstruct nlm_host\t*host;\n\n\tdprintk(\"lockd: host garbage collection for net %p\\n\", net);\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\thost->h_inuse = 0;\n\t}\n\n\t/* Mark all hosts that hold locks, blocks or shares */\n\tnlmsvc_mark_resources(net);\n\n\tfor_each_host_safe(host, next, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\tif (atomic_read(&host->h_count) || host->h_inuse\n\t\t || time_before(jiffies, host->h_expires)) {\n\t\t\tdprintk(\"nlm_gc_hosts skipping %s \"\n\t\t\t\t\"(cnt %d use %d exp %ld net %p)\\n\",\n\t\t\t\thost->h_name, atomic_read(&host->h_count),\n\t\t\t\thost->h_inuse, host->h_expires, host->net);\n\t\t\tcontinue;\n\t\t}\n\t\tnlm_destroy_host_locked(host);\n\t}\n\n\tif (net) {\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tln->next_gc = jiffies + NLM_HOST_COLLECT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_shutdown_client",
          "args": [
            "host->h_rpcclnt"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_host",
          "args": [
            "host",
            "chain",
            "nlm_server_hosts"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: nuking all hosts in net %p...\\n\"",
            "net"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nlm_host_mutex"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic DEFINE_MUTEX(nlm_host_mutex);\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nvoid\nnlm_shutdown_hosts_net(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\n\tmutex_lock(&nlm_host_mutex);\n\n\t/* First, make all hosts eligible for gc */\n\tdprintk(\"lockd: nuking all hosts in net %p...\\n\", net);\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\thost->h_expires = jiffies - 1;\n\t\tif (host->h_rpcclnt) {\n\t\t\trpc_shutdown_client(host->h_rpcclnt);\n\t\t\thost->h_rpcclnt = NULL;\n\t\t}\n\t}\n\n\t/* Then, perform a garbage collection pass */\n\tnlm_gc_hosts(net);\n\tmutex_unlock(&nlm_host_mutex);\n\n\tnlm_complain_hosts(net);\n}"
  },
  {
    "function_name": "nlm_complain_hosts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "568-594",
    "snippet": "static void nlm_complain_hosts(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\n\tif (net) {\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tif (ln->nrhosts == 0)\n\t\t\treturn;\n\t\tprintk(KERN_WARNING \"lockd: couldn't shutdown host module for net %p!\\n\", net);\n\t\tdprintk(\"lockd: %lu hosts left in net %p:\\n\", ln->nrhosts, net);\n\t} else {\n\t\tif (nrhosts == 0)\n\t\t\treturn;\n\t\tprintk(KERN_WARNING \"lockd: couldn't shutdown host module!\\n\");\n\t\tdprintk(\"lockd: %lu hosts left:\\n\", nrhosts);\n\t}\n\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\tdprintk(\"       %s (cnt %d use %d exp %ld net %p)\\n\",\n\t\t\thost->h_name, atomic_read(&host->h_count),\n\t\t\thost->h_inuse, host->h_expires, host->net);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];",
      "static unsigned long\t\tnrhosts;",
      "static void\t\t\tnlm_gc_hosts(struct net *net);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"       %s (cnt %d use %d exp %ld net %p)\\n\"",
            "host->h_name",
            "atomic_read(&host->h_count)",
            "host->h_inuse",
            "host->h_expires",
            "host->net"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&host->h_count"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_host",
          "args": [
            "host",
            "chain",
            "nlm_server_hosts"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: %lu hosts left:\\n\"",
            "nrhosts"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"lockd: couldn't shutdown host module!\\n\""
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: %lu hosts left in net %p:\\n\"",
            "ln->nrhosts",
            "net"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "lockd_net_id"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic unsigned long\t\tnrhosts;\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstatic void nlm_complain_hosts(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\n\tif (net) {\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tif (ln->nrhosts == 0)\n\t\t\treturn;\n\t\tprintk(KERN_WARNING \"lockd: couldn't shutdown host module for net %p!\\n\", net);\n\t\tdprintk(\"lockd: %lu hosts left in net %p:\\n\", ln->nrhosts, net);\n\t} else {\n\t\tif (nrhosts == 0)\n\t\t\treturn;\n\t\tprintk(KERN_WARNING \"lockd: couldn't shutdown host module!\\n\");\n\t\tdprintk(\"lockd: %lu hosts left:\\n\", nrhosts);\n\t}\n\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\tdprintk(\"       %s (cnt %d use %d exp %ld net %p)\\n\",\n\t\t\thost->h_name, atomic_read(&host->h_count),\n\t\t\thost->h_inuse, host->h_expires, host->net);\n\t}\n}"
  },
  {
    "function_name": "nlm_host_rebooted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "542-566",
    "snippet": "void nlm_host_rebooted(const struct nlm_reboot *info)\n{\n\tstruct nsm_handle *nsm;\n\tstruct nlm_host\t*host;\n\n\tnsm = nsm_reboot_lookup(info);\n\tif (unlikely(nsm == NULL))\n\t\treturn;\n\n\t/* Mark all hosts tied to this NSM state as having rebooted.\n\t * We run the loop repeatedly, because we drop the host table\n\t * lock for this.\n\t * To avoid processing a host several times, we match the nsmstate.\n\t */\n\twhile ((host = next_host_state(nlm_server_hosts, nsm, info)) != NULL) {\n\t\tnlmsvc_free_host_resources(host);\n\t\tnlmsvc_release_host(host);\n\t}\n\twhile ((host = next_host_state(nlm_client_hosts, nsm, info)) != NULL) {\n\t\tnlmclnt_recovery(host);\n\t\tnlmclnt_release_host(host);\n\t}\n\n\tnsm_release(nsm);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];",
      "static struct hlist_head\tnlm_client_hosts[NLM_HOST_NRHASH];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nsm_release",
          "args": [
            "nsm"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "nsm_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/mon.c",
          "lines": "454-463",
          "snippet": "void nsm_release(struct nsm_handle *nsm)\n{\n\tif (atomic_dec_and_lock(&nsm->sm_count, &nsm_lock)) {\n\t\tlist_del(&nsm->sm_link);\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: destroyed nsm_handle for %s (%s)\\n\",\n\t\t\t\tnsm->sm_name, nsm->sm_addrbuf);\n\t\tkfree(nsm);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/ktime.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static\t\t\t\tDEFINE_SPINLOCK(nsm_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <asm/unaligned.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/ktime.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic\t\t\t\tDEFINE_SPINLOCK(nsm_lock);\n\nvoid nsm_release(struct nsm_handle *nsm)\n{\n\tif (atomic_dec_and_lock(&nsm->sm_count, &nsm_lock)) {\n\t\tlist_del(&nsm->sm_link);\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: destroyed nsm_handle for %s (%s)\\n\",\n\t\t\t\tnsm->sm_name, nsm->sm_addrbuf);\n\t\tkfree(nsm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_release_host",
          "args": [
            "host"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "282-300",
          "snippet": "void nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_host_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_host_mutex);\n\nvoid nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_recovery",
          "args": [
            "host"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
          "lines": "211-224",
          "snippet": "void\nnlmclnt_recovery(struct nlm_host *host)\n{\n\tstruct task_struct *task;\n\n\tif (!host->h_reclaiming++) {\n\t\tnlm_get_host(host);\n\t\ttask = kthread_run(reclaimer, host, \"%s-reclaim\", host->h_name);\n\t\tif (IS_ERR(task))\n\t\t\tprintk(KERN_ERR \"lockd: unable to spawn reclaimer \"\n\t\t\t\t\"thread. Locks for %s won't be reclaimed! \"\n\t\t\t\t\"(%ld)\\n\", host->h_name, PTR_ERR(task));\n\t}\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nvoid\nnlmclnt_recovery(struct nlm_host *host)\n{\n\tstruct task_struct *task;\n\n\tif (!host->h_reclaiming++) {\n\t\tnlm_get_host(host);\n\t\ttask = kthread_run(reclaimer, host, \"%s-reclaim\", host->h_name);\n\t\tif (IS_ERR(task))\n\t\t\tprintk(KERN_ERR \"lockd: unable to spawn reclaimer \"\n\t\t\t\t\"thread. Locks for %s won't be reclaimed! \"\n\t\t\t\t\"(%ld)\\n\", host->h_name, PTR_ERR(task));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_host_state",
          "args": [
            "nlm_client_hosts",
            "nsm",
            "info"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "next_host_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "511-533",
          "snippet": "static struct nlm_host *next_host_state(struct hlist_head *cache,\n\t\t\t\t\tstruct nsm_handle *nsm,\n\t\t\t\t\tconst struct nlm_reboot *info)\n{\n\tstruct nlm_host *host;\n\tstruct hlist_head *chain;\n\n\tmutex_lock(&nlm_host_mutex);\n\tfor_each_host(host, chain, cache) {\n\t\tif (host->h_nsmhandle == nsm\n\t\t    && host->h_nsmstate != info->state) {\n\t\t\thost->h_nsmstate = info->state;\n\t\t\thost->h_state++;\n\n\t\t\tnlm_get_host(host);\n\t\t\tmutex_unlock(&nlm_host_mutex);\n\t\t\treturn host;\n\t\t}\n\t}\n\n\tmutex_unlock(&nlm_host_mutex);\n\treturn NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_host_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_host_mutex);\n\nstatic struct nlm_host *next_host_state(struct hlist_head *cache,\n\t\t\t\t\tstruct nsm_handle *nsm,\n\t\t\t\t\tconst struct nlm_reboot *info)\n{\n\tstruct nlm_host *host;\n\tstruct hlist_head *chain;\n\n\tmutex_lock(&nlm_host_mutex);\n\tfor_each_host(host, chain, cache) {\n\t\tif (host->h_nsmhandle == nsm\n\t\t    && host->h_nsmstate != info->state) {\n\t\t\thost->h_nsmstate = info->state;\n\t\t\thost->h_state++;\n\n\t\t\tnlm_get_host(host);\n\t\t\tmutex_unlock(&nlm_host_mutex);\n\t\t\treturn host;\n\t\t}\n\t}\n\n\tmutex_unlock(&nlm_host_mutex);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_host",
          "args": [
            "host"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "403-412",
          "snippet": "void nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_free_host_resources",
          "args": [
            "host"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_free_host_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcsubs.c",
          "lines": "381-392",
          "snippet": "void\nnlmsvc_free_host_resources(struct nlm_host *host)\n{\n\tdprintk(\"lockd: nlmsvc_free_host_resources\\n\");\n\n\tif (nlm_traverse_files(host, nlmsvc_same_host, NULL)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"lockd: couldn't remove all locks held by %s\\n\",\n\t\t\thost->h_name);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/in.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nvoid\nnlmsvc_free_host_resources(struct nlm_host *host)\n{\n\tdprintk(\"lockd: nlmsvc_free_host_resources\\n\");\n\n\tif (nlm_traverse_files(host, nlmsvc_same_host, NULL)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"lockd: couldn't remove all locks held by %s\\n\",\n\t\t\thost->h_name);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nsm == NULL"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsm_reboot_lookup",
          "args": [
            "info"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "nsm_reboot_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/mon.c",
          "lines": "426-447",
          "snippet": "struct nsm_handle *nsm_reboot_lookup(const struct nlm_reboot *info)\n{\n\tstruct nsm_handle *cached;\n\n\tspin_lock(&nsm_lock);\n\n\tcached = nsm_lookup_priv(&info->priv);\n\tif (unlikely(cached == NULL)) {\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: never saw rebooted peer '%.*s' before\\n\",\n\t\t\t\tinfo->len, info->mon);\n\t\treturn cached;\n\t}\n\n\tatomic_inc(&cached->sm_count);\n\tspin_unlock(&nsm_lock);\n\n\tdprintk(\"lockd: host %s (%s) rebooted, cnt %d\\n\",\n\t\t\tcached->sm_name, cached->sm_addrbuf,\n\t\t\tatomic_read(&cached->sm_count));\n\treturn cached;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/ktime.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static\t\t\t\tDEFINE_SPINLOCK(nsm_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <asm/unaligned.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/ktime.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic\t\t\t\tDEFINE_SPINLOCK(nsm_lock);\n\nstruct nsm_handle *nsm_reboot_lookup(const struct nlm_reboot *info)\n{\n\tstruct nsm_handle *cached;\n\n\tspin_lock(&nsm_lock);\n\n\tcached = nsm_lookup_priv(&info->priv);\n\tif (unlikely(cached == NULL)) {\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: never saw rebooted peer '%.*s' before\\n\",\n\t\t\t\tinfo->len, info->mon);\n\t\treturn cached;\n\t}\n\n\tatomic_inc(&cached->sm_count);\n\tspin_unlock(&nsm_lock);\n\n\tdprintk(\"lockd: host %s (%s) rebooted, cnt %d\\n\",\n\t\t\tcached->sm_name, cached->sm_addrbuf,\n\t\t\tatomic_read(&cached->sm_count));\n\treturn cached;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic struct hlist_head\tnlm_client_hosts[NLM_HOST_NRHASH];\n\nvoid nlm_host_rebooted(const struct nlm_reboot *info)\n{\n\tstruct nsm_handle *nsm;\n\tstruct nlm_host\t*host;\n\n\tnsm = nsm_reboot_lookup(info);\n\tif (unlikely(nsm == NULL))\n\t\treturn;\n\n\t/* Mark all hosts tied to this NSM state as having rebooted.\n\t * We run the loop repeatedly, because we drop the host table\n\t * lock for this.\n\t * To avoid processing a host several times, we match the nsmstate.\n\t */\n\twhile ((host = next_host_state(nlm_server_hosts, nsm, info)) != NULL) {\n\t\tnlmsvc_free_host_resources(host);\n\t\tnlmsvc_release_host(host);\n\t}\n\twhile ((host = next_host_state(nlm_client_hosts, nsm, info)) != NULL) {\n\t\tnlmclnt_recovery(host);\n\t\tnlmclnt_release_host(host);\n\t}\n\n\tnsm_release(nsm);\n}"
  },
  {
    "function_name": "next_host_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "511-533",
    "snippet": "static struct nlm_host *next_host_state(struct hlist_head *cache,\n\t\t\t\t\tstruct nsm_handle *nsm,\n\t\t\t\t\tconst struct nlm_reboot *info)\n{\n\tstruct nlm_host *host;\n\tstruct hlist_head *chain;\n\n\tmutex_lock(&nlm_host_mutex);\n\tfor_each_host(host, chain, cache) {\n\t\tif (host->h_nsmhandle == nsm\n\t\t    && host->h_nsmstate != info->state) {\n\t\t\thost->h_nsmstate = info->state;\n\t\t\thost->h_state++;\n\n\t\t\tnlm_get_host(host);\n\t\t\tmutex_unlock(&nlm_host_mutex);\n\t\t\treturn host;\n\t\t}\n\t}\n\n\tmutex_unlock(&nlm_host_mutex);\n\treturn NULL;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nlm_host_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nlm_host_mutex"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nlm_host_mutex"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_get_host",
          "args": [
            "host"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_get_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "501-509",
          "snippet": "struct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_EXPIRE\t\t(300 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_EXPIRE\t\t(300 * HZ)\n\nstruct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_host",
          "args": [
            "host",
            "chain",
            "cache"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nlm_host_mutex"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_host_mutex);\n\nstatic struct nlm_host *next_host_state(struct hlist_head *cache,\n\t\t\t\t\tstruct nsm_handle *nsm,\n\t\t\t\t\tconst struct nlm_reboot *info)\n{\n\tstruct nlm_host *host;\n\tstruct hlist_head *chain;\n\n\tmutex_lock(&nlm_host_mutex);\n\tfor_each_host(host, chain, cache) {\n\t\tif (host->h_nsmhandle == nsm\n\t\t    && host->h_nsmstate != info->state) {\n\t\t\thost->h_nsmstate = info->state;\n\t\t\thost->h_state++;\n\n\t\t\tnlm_get_host(host);\n\t\t\tmutex_unlock(&nlm_host_mutex);\n\t\t\treturn host;\n\t\t}\n\t}\n\n\tmutex_unlock(&nlm_host_mutex);\n\treturn NULL;\n}"
  },
  {
    "function_name": "nlm_get_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "501-509",
    "snippet": "struct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NLM_HOST_EXPIRE\t\t(300 * HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&host->h_count"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: get host %s\\n\"",
            "host->h_name"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_EXPIRE\t\t(300 * HZ)\n\nstruct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}"
  },
  {
    "function_name": "nlm_rebind_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "488-496",
    "snippet": "void\nnlm_rebind_host(struct nlm_host *host)\n{\n\tdprintk(\"lockd: rebind host %s\\n\", host->h_name);\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NLM_HOST_REBIND\t\t(60 * HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_force_rebind",
          "args": [
            "host->h_rpcclnt"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "host->h_nextrebind"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: rebind host %s\\n\"",
            "host->h_name"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nvoid\nnlm_rebind_host(struct nlm_host *host)\n{\n\tdprintk(\"lockd: rebind host %s\\n\", host->h_name);\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}"
  },
  {
    "function_name": "nlm_bind_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "417-483",
    "snippet": "struct rpc_clnt *\nnlm_bind_host(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\n\tdprintk(\"lockd: nlm_bind_host %s (%s)\\n\",\n\t\t\thost->h_name, host->h_addrbuf);\n\n\t/* Lock host handle */\n\tmutex_lock(&host->h_mutex);\n\n\t/* If we've already created an RPC client, check whether\n\t * RPC rebind is required\n\t */\n\tif ((clnt = host->h_rpcclnt) != NULL) {\n\t\tif (time_after_eq(jiffies, host->h_nextrebind)) {\n\t\t\trpc_force_rebind(clnt);\n\t\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t\t\tdprintk(\"lockd: next rebind in %lu jiffies\\n\",\n\t\t\t\t\thost->h_nextrebind - jiffies);\n\t\t}\n\t} else {\n\t\tunsigned long increment = nlmsvc_timeout;\n\t\tstruct rpc_timeout timeparms = {\n\t\t\t.to_initval\t= increment,\n\t\t\t.to_increment\t= increment,\n\t\t\t.to_maxval\t= increment * 6UL,\n\t\t\t.to_retries\t= 5U,\n\t\t};\n\t\tstruct rpc_create_args args = {\n\t\t\t.net\t\t= host->net,\n\t\t\t.protocol\t= host->h_proto,\n\t\t\t.address\t= nlm_addr(host),\n\t\t\t.addrsize\t= host->h_addrlen,\n\t\t\t.timeout\t= &timeparms,\n\t\t\t.servername\t= host->h_name,\n\t\t\t.program\t= &nlm_program,\n\t\t\t.version\t= host->h_version,\n\t\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING |\n\t\t\t\t\t   RPC_CLNT_CREATE_AUTOBIND),\n\t\t};\n\n\t\t/*\n\t\t * lockd retries server side blocks automatically so we want\n\t\t * those to be soft RPC calls. Client side calls need to be\n\t\t * hard RPC tasks.\n\t\t */\n\t\tif (!host->h_server)\n\t\t\targs.flags |= RPC_CLNT_CREATE_HARDRTRY;\n\t\tif (host->h_noresvport)\n\t\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\t\tif (host->h_srcaddrlen)\n\t\t\targs.saddress = nlm_srcaddr(host);\n\n\t\tclnt = rpc_create(&args);\n\t\tif (!IS_ERR(clnt))\n\t\t\thost->h_rpcclnt = clnt;\n\t\telse {\n\t\t\tprintk(\"lockd: couldn't create RPC handle for %s\\n\", host->h_name);\n\t\t\tclnt = NULL;\n\t\t}\n\t}\n\n\tmutex_unlock(&host->h_mutex);\n\treturn clnt;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NLM_HOST_REBIND\t\t(60 * HZ)"
    ],
    "globals_used": [
      "static void\t\t\tnlm_gc_hosts(struct net *net);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&host->h_mutex"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"lockd: couldn't create RPC handle for %s\\n\"",
            "host->h_name"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "clnt"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_create",
          "args": [
            "&args"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_srcaddr",
          "args": [
            "host"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_addr",
          "args": [
            "host"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: next rebind in %lu jiffies\\n\"",
            "host->h_nextrebind - jiffies"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_force_rebind",
          "args": [
            "clnt"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "host->h_nextrebind"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&host->h_mutex"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: nlm_bind_host %s (%s)\\n\"",
            "host->h_name",
            "host->h_addrbuf"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstruct rpc_clnt *\nnlm_bind_host(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\n\tdprintk(\"lockd: nlm_bind_host %s (%s)\\n\",\n\t\t\thost->h_name, host->h_addrbuf);\n\n\t/* Lock host handle */\n\tmutex_lock(&host->h_mutex);\n\n\t/* If we've already created an RPC client, check whether\n\t * RPC rebind is required\n\t */\n\tif ((clnt = host->h_rpcclnt) != NULL) {\n\t\tif (time_after_eq(jiffies, host->h_nextrebind)) {\n\t\t\trpc_force_rebind(clnt);\n\t\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t\t\tdprintk(\"lockd: next rebind in %lu jiffies\\n\",\n\t\t\t\t\thost->h_nextrebind - jiffies);\n\t\t}\n\t} else {\n\t\tunsigned long increment = nlmsvc_timeout;\n\t\tstruct rpc_timeout timeparms = {\n\t\t\t.to_initval\t= increment,\n\t\t\t.to_increment\t= increment,\n\t\t\t.to_maxval\t= increment * 6UL,\n\t\t\t.to_retries\t= 5U,\n\t\t};\n\t\tstruct rpc_create_args args = {\n\t\t\t.net\t\t= host->net,\n\t\t\t.protocol\t= host->h_proto,\n\t\t\t.address\t= nlm_addr(host),\n\t\t\t.addrsize\t= host->h_addrlen,\n\t\t\t.timeout\t= &timeparms,\n\t\t\t.servername\t= host->h_name,\n\t\t\t.program\t= &nlm_program,\n\t\t\t.version\t= host->h_version,\n\t\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING |\n\t\t\t\t\t   RPC_CLNT_CREATE_AUTOBIND),\n\t\t};\n\n\t\t/*\n\t\t * lockd retries server side blocks automatically so we want\n\t\t * those to be soft RPC calls. Client side calls need to be\n\t\t * hard RPC tasks.\n\t\t */\n\t\tif (!host->h_server)\n\t\t\targs.flags |= RPC_CLNT_CREATE_HARDRTRY;\n\t\tif (host->h_noresvport)\n\t\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\t\tif (host->h_srcaddrlen)\n\t\t\targs.saddress = nlm_srcaddr(host);\n\n\t\tclnt = rpc_create(&args);\n\t\tif (!IS_ERR(clnt))\n\t\t\thost->h_rpcclnt = clnt;\n\t\telse {\n\t\t\tprintk(\"lockd: couldn't create RPC handle for %s\\n\", host->h_name);\n\t\t\tclnt = NULL;\n\t\t}\n\t}\n\n\tmutex_unlock(&host->h_mutex);\n\treturn clnt;\n}"
  },
  {
    "function_name": "nlmsvc_release_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "403-412",
    "snippet": "void nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&host->h_count"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!host->h_server"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: release server host %s\\n\"",
            "host->h_name"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}"
  },
  {
    "function_name": "nlmsvc_lookup_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "320-395",
    "snippet": "struct nlm_host *nlmsvc_lookup_host(const struct svc_rqst *rqstp,\n\t\t\t\t    const char *hostname,\n\t\t\t\t    const size_t hostname_len)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host = NULL;\n\tstruct nsm_handle *nsm = NULL;\n\tstruct sockaddr *src_sap = svc_daddr(rqstp);\n\tsize_t src_len = rqstp->rq_daddrlen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nlm_lookup_host_info ni = {\n\t\t.server\t\t= 1,\n\t\t.sap\t\t= svc_addr(rqstp),\n\t\t.salen\t\t= rqstp->rq_addrlen,\n\t\t.protocol\t= rqstp->rq_prot,\n\t\t.version\t= rqstp->rq_vers,\n\t\t.hostname\t= hostname,\n\t\t.hostname_len\t= hostname_len,\n\t\t.net\t\t= net,\n\t};\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tdprintk(\"lockd: %s(host='%*s', vers=%u, proto=%s)\\n\", __func__,\n\t\t\t(int)hostname_len, hostname, rqstp->rq_vers,\n\t\t\t(rqstp->rq_prot == IPPROTO_UDP ? \"udp\" : \"tcp\"));\n\n\tmutex_lock(&nlm_host_mutex);\n\n\tif (time_after_eq(jiffies, ln->next_gc))\n\t\tnlm_gc_hosts(net);\n\n\tchain = &nlm_server_hosts[nlm_hash_address(ni.sap)];\n\thlist_for_each_entry(host, chain, h_hash) {\n\t\tif (host->net != net)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(host), ni.sap))\n\t\t\tcontinue;\n\n\t\t/* Same address. Share an NSM handle if we already have one */\n\t\tif (nsm == NULL)\n\t\t\tnsm = host->h_nsmhandle;\n\n\t\tif (host->h_proto != ni.protocol)\n\t\t\tcontinue;\n\t\tif (host->h_version != ni.version)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_srcaddr(host), src_sap))\n\t\t\tcontinue;\n\n\t\t/* Move to head of hash chain. */\n\t\thlist_del(&host->h_hash);\n\t\thlist_add_head(&host->h_hash, chain);\n\n\t\tnlm_get_host(host);\n\t\tdprintk(\"lockd: %s found host %s (%s)\\n\",\n\t\t\t__func__, host->h_name, host->h_addrbuf);\n\t\tgoto out;\n\t}\n\n\thost = nlm_alloc_host(&ni, nsm);\n\tif (unlikely(host == NULL))\n\t\tgoto out;\n\n\tmemcpy(nlm_srcaddr(host), src_sap, src_len);\n\thost->h_srcaddrlen = src_len;\n\thlist_add_head(&host->h_hash, chain);\n\tln->nrhosts++;\n\tnrhosts++;\n\n\tdprintk(\"lockd: %s created host %s (%s)\\n\",\n\t\t__func__, host->h_name, host->h_addrbuf);\n\nout:\n\tmutex_unlock(&nlm_host_mutex);\n\treturn host;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];",
      "static unsigned long\t\tnrhosts;",
      "static DEFINE_MUTEX(nlm_host_mutex);",
      "static void\t\t\tnlm_gc_hosts(struct net *net);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nlm_host_mutex"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: %s created host %s (%s)\\n\"",
            "__func__",
            "host->h_name",
            "host->h_addrbuf"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&host->h_hash",
            "chain"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nlm_srcaddr(host)",
            "src_sap",
            "src_len"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_srcaddr",
          "args": [
            "host"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "host == NULL"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_alloc_host",
          "args": [
            "&ni",
            "nsm"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_alloc_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "109-167",
          "snippet": "static struct nlm_host *nlm_alloc_host(struct nlm_lookup_host_info *ni,\n\t\t\t\t       struct nsm_handle *nsm)\n{\n\tstruct nlm_host *host = NULL;\n\tunsigned long now = jiffies;\n\n\tif (nsm != NULL)\n\t\tatomic_inc(&nsm->sm_count);\n\telse {\n\t\thost = NULL;\n\t\tnsm = nsm_get_handle(ni->sap, ni->salen,\n\t\t\t\t\tni->hostname, ni->hostname_len);\n\t\tif (unlikely(nsm == NULL)) {\n\t\t\tdprintk(\"lockd: %s failed; no nsm handle\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thost = kmalloc(sizeof(*host), GFP_KERNEL);\n\tif (unlikely(host == NULL)) {\n\t\tdprintk(\"lockd: %s failed; no memory\\n\", __func__);\n\t\tnsm_release(nsm);\n\t\tgoto out;\n\t}\n\n\tmemcpy(nlm_addr(host), ni->sap, ni->salen);\n\thost->h_addrlen    = ni->salen;\n\trpc_set_port(nlm_addr(host), 0);\n\thost->h_srcaddrlen = 0;\n\n\thost->h_rpcclnt    = NULL;\n\thost->h_name\t   = nsm->sm_name;\n\thost->h_version    = ni->version;\n\thost->h_proto      = ni->protocol;\n\thost->h_reclaiming = 0;\n\thost->h_server     = ni->server;\n\thost->h_noresvport = ni->noresvport;\n\thost->h_inuse      = 0;\n\tinit_waitqueue_head(&host->h_gracewait);\n\tinit_rwsem(&host->h_rwsem);\n\thost->h_state      = 0;\n\thost->h_nsmstate   = 0;\n\thost->h_pidcount   = 0;\n\tatomic_set(&host->h_count, 1);\n\tmutex_init(&host->h_mutex);\n\thost->h_nextrebind = now + NLM_HOST_REBIND;\n\thost->h_expires    = now + NLM_HOST_EXPIRE;\n\tINIT_LIST_HEAD(&host->h_lockowners);\n\tspin_lock_init(&host->h_lock);\n\tINIT_LIST_HEAD(&host->h_granted);\n\tINIT_LIST_HEAD(&host->h_reclaim);\n\thost->h_nsmhandle  = nsm;\n\thost->h_addrbuf    = nsm->sm_addrbuf;\n\thost->net\t   = ni->net;\n\nout:\n\treturn host;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_EXPIRE\t\t(300 * HZ)",
            "#define NLM_HOST_REBIND\t\t(60 * HZ)"
          ],
          "globals_used": [
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_EXPIRE\t\t(300 * HZ)\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstatic struct nlm_host *nlm_alloc_host(struct nlm_lookup_host_info *ni,\n\t\t\t\t       struct nsm_handle *nsm)\n{\n\tstruct nlm_host *host = NULL;\n\tunsigned long now = jiffies;\n\n\tif (nsm != NULL)\n\t\tatomic_inc(&nsm->sm_count);\n\telse {\n\t\thost = NULL;\n\t\tnsm = nsm_get_handle(ni->sap, ni->salen,\n\t\t\t\t\tni->hostname, ni->hostname_len);\n\t\tif (unlikely(nsm == NULL)) {\n\t\t\tdprintk(\"lockd: %s failed; no nsm handle\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thost = kmalloc(sizeof(*host), GFP_KERNEL);\n\tif (unlikely(host == NULL)) {\n\t\tdprintk(\"lockd: %s failed; no memory\\n\", __func__);\n\t\tnsm_release(nsm);\n\t\tgoto out;\n\t}\n\n\tmemcpy(nlm_addr(host), ni->sap, ni->salen);\n\thost->h_addrlen    = ni->salen;\n\trpc_set_port(nlm_addr(host), 0);\n\thost->h_srcaddrlen = 0;\n\n\thost->h_rpcclnt    = NULL;\n\thost->h_name\t   = nsm->sm_name;\n\thost->h_version    = ni->version;\n\thost->h_proto      = ni->protocol;\n\thost->h_reclaiming = 0;\n\thost->h_server     = ni->server;\n\thost->h_noresvport = ni->noresvport;\n\thost->h_inuse      = 0;\n\tinit_waitqueue_head(&host->h_gracewait);\n\tinit_rwsem(&host->h_rwsem);\n\thost->h_state      = 0;\n\thost->h_nsmstate   = 0;\n\thost->h_pidcount   = 0;\n\tatomic_set(&host->h_count, 1);\n\tmutex_init(&host->h_mutex);\n\thost->h_nextrebind = now + NLM_HOST_REBIND;\n\thost->h_expires    = now + NLM_HOST_EXPIRE;\n\tINIT_LIST_HEAD(&host->h_lockowners);\n\tspin_lock_init(&host->h_lock);\n\tINIT_LIST_HEAD(&host->h_granted);\n\tINIT_LIST_HEAD(&host->h_reclaim);\n\thost->h_nsmhandle  = nsm;\n\thost->h_addrbuf    = nsm->sm_addrbuf;\n\thost->net\t   = ni->net;\n\nout:\n\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: %s found host %s (%s)\\n\"",
            "__func__",
            "host->h_name",
            "host->h_addrbuf"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_get_host",
          "args": [
            "host"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_get_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "501-509",
          "snippet": "struct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_EXPIRE\t\t(300 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_EXPIRE\t\t(300 * HZ)\n\nstruct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&host->h_hash",
            "chain"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&host->h_hash"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_cmp_addr",
          "args": [
            "nlm_srcaddr(host)",
            "src_sap"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_srcaddr",
          "args": [
            "host"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_cmp_addr",
          "args": [
            "nlm_addr(host)",
            "ni.sap"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_addr",
          "args": [
            "host"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "host",
            "chain",
            "h_hash"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_hash_address",
          "args": [
            "ni.sap"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_hash_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "89-104",
          "snippet": "static unsigned int nlm_hash_address(const struct sockaddr *sap)\n{\n\tunsigned int hash;\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\thash = __nlm_hash_addr4(sap);\n\t\tbreak;\n\tcase AF_INET6:\n\t\thash = __nlm_hash_addr6(sap);\n\t\tbreak;\n\tdefault:\n\t\thash = 0;\n\t}\n\treturn hash & (NLM_HOST_NRHASH - 1);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_NRHASH\t\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_NRHASH\t\t32\n\nstatic unsigned int nlm_hash_address(const struct sockaddr *sap)\n{\n\tunsigned int hash;\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\thash = __nlm_hash_addr4(sap);\n\t\tbreak;\n\tcase AF_INET6:\n\t\thash = __nlm_hash_addr6(sap);\n\t\tbreak;\n\tdefault:\n\t\thash = 0;\n\t}\n\treturn hash & (NLM_HOST_NRHASH - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_gc_hosts",
          "args": [
            "net"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_gc_hosts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "639-675",
          "snippet": "static void\nnlm_gc_hosts(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct hlist_node *next;\n\tstruct nlm_host\t*host;\n\n\tdprintk(\"lockd: host garbage collection for net %p\\n\", net);\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\thost->h_inuse = 0;\n\t}\n\n\t/* Mark all hosts that hold locks, blocks or shares */\n\tnlmsvc_mark_resources(net);\n\n\tfor_each_host_safe(host, next, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\tif (atomic_read(&host->h_count) || host->h_inuse\n\t\t || time_before(jiffies, host->h_expires)) {\n\t\t\tdprintk(\"nlm_gc_hosts skipping %s \"\n\t\t\t\t\"(cnt %d use %d exp %ld net %p)\\n\",\n\t\t\t\thost->h_name, atomic_read(&host->h_count),\n\t\t\t\thost->h_inuse, host->h_expires, host->net);\n\t\t\tcontinue;\n\t\t}\n\t\tnlm_destroy_host_locked(host);\n\t}\n\n\tif (net) {\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tln->next_gc = jiffies + NLM_HOST_COLLECT;\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_COLLECT\t(120 * HZ)"
          ],
          "globals_used": [
            "static struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];",
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_COLLECT\t(120 * HZ)\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstatic void\nnlm_gc_hosts(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct hlist_node *next;\n\tstruct nlm_host\t*host;\n\n\tdprintk(\"lockd: host garbage collection for net %p\\n\", net);\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\thost->h_inuse = 0;\n\t}\n\n\t/* Mark all hosts that hold locks, blocks or shares */\n\tnlmsvc_mark_resources(net);\n\n\tfor_each_host_safe(host, next, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\tif (atomic_read(&host->h_count) || host->h_inuse\n\t\t || time_before(jiffies, host->h_expires)) {\n\t\t\tdprintk(\"nlm_gc_hosts skipping %s \"\n\t\t\t\t\"(cnt %d use %d exp %ld net %p)\\n\",\n\t\t\t\thost->h_name, atomic_read(&host->h_count),\n\t\t\t\thost->h_inuse, host->h_expires, host->net);\n\t\t\tcontinue;\n\t\t}\n\t\tnlm_destroy_host_locked(host);\n\t}\n\n\tif (net) {\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tln->next_gc = jiffies + NLM_HOST_COLLECT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "ln->next_gc"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nlm_host_mutex"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: %s(host='%*s', vers=%u, proto=%s)\\n\"",
            "__func__",
            "(int)hostname_len",
            "hostname",
            "rqstp->rq_vers",
            "(rqstp->rq_prot == IPPROTO_UDP ? \"udp\" : \"tcp\")"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "lockd_net_id"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_daddr",
          "args": [
            "rqstp"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic unsigned long\t\tnrhosts;\nstatic DEFINE_MUTEX(nlm_host_mutex);\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstruct nlm_host *nlmsvc_lookup_host(const struct svc_rqst *rqstp,\n\t\t\t\t    const char *hostname,\n\t\t\t\t    const size_t hostname_len)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host = NULL;\n\tstruct nsm_handle *nsm = NULL;\n\tstruct sockaddr *src_sap = svc_daddr(rqstp);\n\tsize_t src_len = rqstp->rq_daddrlen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nlm_lookup_host_info ni = {\n\t\t.server\t\t= 1,\n\t\t.sap\t\t= svc_addr(rqstp),\n\t\t.salen\t\t= rqstp->rq_addrlen,\n\t\t.protocol\t= rqstp->rq_prot,\n\t\t.version\t= rqstp->rq_vers,\n\t\t.hostname\t= hostname,\n\t\t.hostname_len\t= hostname_len,\n\t\t.net\t\t= net,\n\t};\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tdprintk(\"lockd: %s(host='%*s', vers=%u, proto=%s)\\n\", __func__,\n\t\t\t(int)hostname_len, hostname, rqstp->rq_vers,\n\t\t\t(rqstp->rq_prot == IPPROTO_UDP ? \"udp\" : \"tcp\"));\n\n\tmutex_lock(&nlm_host_mutex);\n\n\tif (time_after_eq(jiffies, ln->next_gc))\n\t\tnlm_gc_hosts(net);\n\n\tchain = &nlm_server_hosts[nlm_hash_address(ni.sap)];\n\thlist_for_each_entry(host, chain, h_hash) {\n\t\tif (host->net != net)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(host), ni.sap))\n\t\t\tcontinue;\n\n\t\t/* Same address. Share an NSM handle if we already have one */\n\t\tif (nsm == NULL)\n\t\t\tnsm = host->h_nsmhandle;\n\n\t\tif (host->h_proto != ni.protocol)\n\t\t\tcontinue;\n\t\tif (host->h_version != ni.version)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_srcaddr(host), src_sap))\n\t\t\tcontinue;\n\n\t\t/* Move to head of hash chain. */\n\t\thlist_del(&host->h_hash);\n\t\thlist_add_head(&host->h_hash, chain);\n\n\t\tnlm_get_host(host);\n\t\tdprintk(\"lockd: %s found host %s (%s)\\n\",\n\t\t\t__func__, host->h_name, host->h_addrbuf);\n\t\tgoto out;\n\t}\n\n\thost = nlm_alloc_host(&ni, nsm);\n\tif (unlikely(host == NULL))\n\t\tgoto out;\n\n\tmemcpy(nlm_srcaddr(host), src_sap, src_len);\n\thost->h_srcaddrlen = src_len;\n\thlist_add_head(&host->h_hash, chain);\n\tln->nrhosts++;\n\tnrhosts++;\n\n\tdprintk(\"lockd: %s created host %s (%s)\\n\",\n\t\t__func__, host->h_name, host->h_addrbuf);\n\nout:\n\tmutex_unlock(&nlm_host_mutex);\n\treturn host;\n}"
  },
  {
    "function_name": "nlmclnt_release_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "282-300",
    "snippet": "void nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nlm_host_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nlm_host_mutex"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_destroy_host_locked",
          "args": [
            "host"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_destroy_host_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "174-193",
          "snippet": "static void nlm_destroy_host_locked(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\tstruct lockd_net *ln = net_generic(host->net, lockd_net_id);\n\n\tdprintk(\"lockd: destroy host %s\\n\", host->h_name);\n\n\thlist_del_init(&host->h_hash);\n\n\tnsm_unmonitor(host);\n\tnsm_release(host->h_nsmhandle);\n\n\tclnt = host->h_rpcclnt;\n\tif (clnt != NULL)\n\t\trpc_shutdown_client(clnt);\n\tkfree(host);\n\n\tln->nrhosts--;\n\tnrhosts--;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long\t\tnrhosts;",
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic unsigned long\t\tnrhosts;\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstatic void nlm_destroy_host_locked(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\tstruct lockd_net *ln = net_generic(host->net, lockd_net_id);\n\n\tdprintk(\"lockd: destroy host %s\\n\", host->h_name);\n\n\thlist_del_init(&host->h_hash);\n\n\tnsm_unmonitor(host);\n\tnsm_release(host->h_nsmhandle);\n\n\tclnt = host->h_rpcclnt;\n\tif (clnt != NULL)\n\t\trpc_shutdown_client(clnt);\n\tkfree(host);\n\n\tln->nrhosts--;\n\tnrhosts--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nlm_host_mutex"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&host->h_reclaim)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&host->h_reclaim"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&host->h_granted)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&host->h_lockowners)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&host->h_count"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "host->h_server"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: release client host %s\\n\"",
            "host->h_name"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_host_mutex);\n\nvoid nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}"
  },
  {
    "function_name": "nlmclnt_lookup_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "209-275",
    "snippet": "struct nlm_host *nlmclnt_lookup_host(const struct sockaddr *sap,\n\t\t\t\t     const size_t salen,\n\t\t\t\t     const unsigned short protocol,\n\t\t\t\t     const u32 version,\n\t\t\t\t     const char *hostname,\n\t\t\t\t     int noresvport,\n\t\t\t\t     struct net *net)\n{\n\tstruct nlm_lookup_host_info ni = {\n\t\t.server\t\t= 0,\n\t\t.sap\t\t= sap,\n\t\t.salen\t\t= salen,\n\t\t.protocol\t= protocol,\n\t\t.version\t= version,\n\t\t.hostname\t= hostname,\n\t\t.hostname_len\t= strlen(hostname),\n\t\t.noresvport\t= noresvport,\n\t\t.net\t\t= net,\n\t};\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\tstruct nsm_handle *nsm = NULL;\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tdprintk(\"lockd: %s(host='%s', vers=%u, proto=%s)\\n\", __func__,\n\t\t\t(hostname ? hostname : \"<none>\"), version,\n\t\t\t(protocol == IPPROTO_UDP ? \"udp\" : \"tcp\"));\n\n\tmutex_lock(&nlm_host_mutex);\n\n\tchain = &nlm_client_hosts[nlm_hash_address(sap)];\n\thlist_for_each_entry(host, chain, h_hash) {\n\t\tif (host->net != net)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(host), sap))\n\t\t\tcontinue;\n\n\t\t/* Same address. Share an NSM handle if we already have one */\n\t\tif (nsm == NULL)\n\t\t\tnsm = host->h_nsmhandle;\n\n\t\tif (host->h_proto != protocol)\n\t\t\tcontinue;\n\t\tif (host->h_version != version)\n\t\t\tcontinue;\n\n\t\tnlm_get_host(host);\n\t\tdprintk(\"lockd: %s found host %s (%s)\\n\", __func__,\n\t\t\thost->h_name, host->h_addrbuf);\n\t\tgoto out;\n\t}\n\n\thost = nlm_alloc_host(&ni, nsm);\n\tif (unlikely(host == NULL))\n\t\tgoto out;\n\n\thlist_add_head(&host->h_hash, chain);\n\tln->nrhosts++;\n\tnrhosts++;\n\n\tdprintk(\"lockd: %s created host %s (%s)\\n\", __func__,\n\t\thost->h_name, host->h_addrbuf);\n\nout:\n\tmutex_unlock(&nlm_host_mutex);\n\treturn host;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head\tnlm_client_hosts[NLM_HOST_NRHASH];",
      "static unsigned long\t\tnrhosts;",
      "static DEFINE_MUTEX(nlm_host_mutex);",
      "static void\t\t\tnlm_gc_hosts(struct net *net);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nlm_host_mutex"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: %s created host %s (%s)\\n\"",
            "__func__",
            "host->h_name",
            "host->h_addrbuf"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&host->h_hash",
            "chain"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "host == NULL"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_alloc_host",
          "args": [
            "&ni",
            "nsm"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_alloc_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "109-167",
          "snippet": "static struct nlm_host *nlm_alloc_host(struct nlm_lookup_host_info *ni,\n\t\t\t\t       struct nsm_handle *nsm)\n{\n\tstruct nlm_host *host = NULL;\n\tunsigned long now = jiffies;\n\n\tif (nsm != NULL)\n\t\tatomic_inc(&nsm->sm_count);\n\telse {\n\t\thost = NULL;\n\t\tnsm = nsm_get_handle(ni->sap, ni->salen,\n\t\t\t\t\tni->hostname, ni->hostname_len);\n\t\tif (unlikely(nsm == NULL)) {\n\t\t\tdprintk(\"lockd: %s failed; no nsm handle\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thost = kmalloc(sizeof(*host), GFP_KERNEL);\n\tif (unlikely(host == NULL)) {\n\t\tdprintk(\"lockd: %s failed; no memory\\n\", __func__);\n\t\tnsm_release(nsm);\n\t\tgoto out;\n\t}\n\n\tmemcpy(nlm_addr(host), ni->sap, ni->salen);\n\thost->h_addrlen    = ni->salen;\n\trpc_set_port(nlm_addr(host), 0);\n\thost->h_srcaddrlen = 0;\n\n\thost->h_rpcclnt    = NULL;\n\thost->h_name\t   = nsm->sm_name;\n\thost->h_version    = ni->version;\n\thost->h_proto      = ni->protocol;\n\thost->h_reclaiming = 0;\n\thost->h_server     = ni->server;\n\thost->h_noresvport = ni->noresvport;\n\thost->h_inuse      = 0;\n\tinit_waitqueue_head(&host->h_gracewait);\n\tinit_rwsem(&host->h_rwsem);\n\thost->h_state      = 0;\n\thost->h_nsmstate   = 0;\n\thost->h_pidcount   = 0;\n\tatomic_set(&host->h_count, 1);\n\tmutex_init(&host->h_mutex);\n\thost->h_nextrebind = now + NLM_HOST_REBIND;\n\thost->h_expires    = now + NLM_HOST_EXPIRE;\n\tINIT_LIST_HEAD(&host->h_lockowners);\n\tspin_lock_init(&host->h_lock);\n\tINIT_LIST_HEAD(&host->h_granted);\n\tINIT_LIST_HEAD(&host->h_reclaim);\n\thost->h_nsmhandle  = nsm;\n\thost->h_addrbuf    = nsm->sm_addrbuf;\n\thost->net\t   = ni->net;\n\nout:\n\treturn host;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_EXPIRE\t\t(300 * HZ)",
            "#define NLM_HOST_REBIND\t\t(60 * HZ)"
          ],
          "globals_used": [
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_EXPIRE\t\t(300 * HZ)\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstatic struct nlm_host *nlm_alloc_host(struct nlm_lookup_host_info *ni,\n\t\t\t\t       struct nsm_handle *nsm)\n{\n\tstruct nlm_host *host = NULL;\n\tunsigned long now = jiffies;\n\n\tif (nsm != NULL)\n\t\tatomic_inc(&nsm->sm_count);\n\telse {\n\t\thost = NULL;\n\t\tnsm = nsm_get_handle(ni->sap, ni->salen,\n\t\t\t\t\tni->hostname, ni->hostname_len);\n\t\tif (unlikely(nsm == NULL)) {\n\t\t\tdprintk(\"lockd: %s failed; no nsm handle\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thost = kmalloc(sizeof(*host), GFP_KERNEL);\n\tif (unlikely(host == NULL)) {\n\t\tdprintk(\"lockd: %s failed; no memory\\n\", __func__);\n\t\tnsm_release(nsm);\n\t\tgoto out;\n\t}\n\n\tmemcpy(nlm_addr(host), ni->sap, ni->salen);\n\thost->h_addrlen    = ni->salen;\n\trpc_set_port(nlm_addr(host), 0);\n\thost->h_srcaddrlen = 0;\n\n\thost->h_rpcclnt    = NULL;\n\thost->h_name\t   = nsm->sm_name;\n\thost->h_version    = ni->version;\n\thost->h_proto      = ni->protocol;\n\thost->h_reclaiming = 0;\n\thost->h_server     = ni->server;\n\thost->h_noresvport = ni->noresvport;\n\thost->h_inuse      = 0;\n\tinit_waitqueue_head(&host->h_gracewait);\n\tinit_rwsem(&host->h_rwsem);\n\thost->h_state      = 0;\n\thost->h_nsmstate   = 0;\n\thost->h_pidcount   = 0;\n\tatomic_set(&host->h_count, 1);\n\tmutex_init(&host->h_mutex);\n\thost->h_nextrebind = now + NLM_HOST_REBIND;\n\thost->h_expires    = now + NLM_HOST_EXPIRE;\n\tINIT_LIST_HEAD(&host->h_lockowners);\n\tspin_lock_init(&host->h_lock);\n\tINIT_LIST_HEAD(&host->h_granted);\n\tINIT_LIST_HEAD(&host->h_reclaim);\n\thost->h_nsmhandle  = nsm;\n\thost->h_addrbuf    = nsm->sm_addrbuf;\n\thost->net\t   = ni->net;\n\nout:\n\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: %s found host %s (%s)\\n\"",
            "__func__",
            "host->h_name",
            "host->h_addrbuf"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_get_host",
          "args": [
            "host"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_get_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "501-509",
          "snippet": "struct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_EXPIRE\t\t(300 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_EXPIRE\t\t(300 * HZ)\n\nstruct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_cmp_addr",
          "args": [
            "nlm_addr(host)",
            "sap"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_addr",
          "args": [
            "host"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "host",
            "chain",
            "h_hash"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_hash_address",
          "args": [
            "sap"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_hash_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "89-104",
          "snippet": "static unsigned int nlm_hash_address(const struct sockaddr *sap)\n{\n\tunsigned int hash;\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\thash = __nlm_hash_addr4(sap);\n\t\tbreak;\n\tcase AF_INET6:\n\t\thash = __nlm_hash_addr6(sap);\n\t\tbreak;\n\tdefault:\n\t\thash = 0;\n\t}\n\treturn hash & (NLM_HOST_NRHASH - 1);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_NRHASH\t\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_NRHASH\t\t32\n\nstatic unsigned int nlm_hash_address(const struct sockaddr *sap)\n{\n\tunsigned int hash;\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\thash = __nlm_hash_addr4(sap);\n\t\tbreak;\n\tcase AF_INET6:\n\t\thash = __nlm_hash_addr6(sap);\n\t\tbreak;\n\tdefault:\n\t\thash = 0;\n\t}\n\treturn hash & (NLM_HOST_NRHASH - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nlm_host_mutex"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: %s(host='%s', vers=%u, proto=%s)\\n\"",
            "__func__",
            "(hostname ? hostname : \"<none>\")",
            "version",
            "(protocol == IPPROTO_UDP ? \"udp\" : \"tcp\")"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "lockd_net_id"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hostname"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct hlist_head\tnlm_client_hosts[NLM_HOST_NRHASH];\nstatic unsigned long\t\tnrhosts;\nstatic DEFINE_MUTEX(nlm_host_mutex);\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstruct nlm_host *nlmclnt_lookup_host(const struct sockaddr *sap,\n\t\t\t\t     const size_t salen,\n\t\t\t\t     const unsigned short protocol,\n\t\t\t\t     const u32 version,\n\t\t\t\t     const char *hostname,\n\t\t\t\t     int noresvport,\n\t\t\t\t     struct net *net)\n{\n\tstruct nlm_lookup_host_info ni = {\n\t\t.server\t\t= 0,\n\t\t.sap\t\t= sap,\n\t\t.salen\t\t= salen,\n\t\t.protocol\t= protocol,\n\t\t.version\t= version,\n\t\t.hostname\t= hostname,\n\t\t.hostname_len\t= strlen(hostname),\n\t\t.noresvport\t= noresvport,\n\t\t.net\t\t= net,\n\t};\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\tstruct nsm_handle *nsm = NULL;\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tdprintk(\"lockd: %s(host='%s', vers=%u, proto=%s)\\n\", __func__,\n\t\t\t(hostname ? hostname : \"<none>\"), version,\n\t\t\t(protocol == IPPROTO_UDP ? \"udp\" : \"tcp\"));\n\n\tmutex_lock(&nlm_host_mutex);\n\n\tchain = &nlm_client_hosts[nlm_hash_address(sap)];\n\thlist_for_each_entry(host, chain, h_hash) {\n\t\tif (host->net != net)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(host), sap))\n\t\t\tcontinue;\n\n\t\t/* Same address. Share an NSM handle if we already have one */\n\t\tif (nsm == NULL)\n\t\t\tnsm = host->h_nsmhandle;\n\n\t\tif (host->h_proto != protocol)\n\t\t\tcontinue;\n\t\tif (host->h_version != version)\n\t\t\tcontinue;\n\n\t\tnlm_get_host(host);\n\t\tdprintk(\"lockd: %s found host %s (%s)\\n\", __func__,\n\t\t\thost->h_name, host->h_addrbuf);\n\t\tgoto out;\n\t}\n\n\thost = nlm_alloc_host(&ni, nsm);\n\tif (unlikely(host == NULL))\n\t\tgoto out;\n\n\thlist_add_head(&host->h_hash, chain);\n\tln->nrhosts++;\n\tnrhosts++;\n\n\tdprintk(\"lockd: %s created host %s (%s)\\n\", __func__,\n\t\thost->h_name, host->h_addrbuf);\n\nout:\n\tmutex_unlock(&nlm_host_mutex);\n\treturn host;\n}"
  },
  {
    "function_name": "nlm_destroy_host_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "174-193",
    "snippet": "static void nlm_destroy_host_locked(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\tstruct lockd_net *ln = net_generic(host->net, lockd_net_id);\n\n\tdprintk(\"lockd: destroy host %s\\n\", host->h_name);\n\n\thlist_del_init(&host->h_hash);\n\n\tnsm_unmonitor(host);\n\tnsm_release(host->h_nsmhandle);\n\n\tclnt = host->h_rpcclnt;\n\tif (clnt != NULL)\n\t\trpc_shutdown_client(clnt);\n\tkfree(host);\n\n\tln->nrhosts--;\n\tnrhosts--;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long\t\tnrhosts;",
      "static void\t\t\tnlm_gc_hosts(struct net *net);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "host"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_shutdown_client",
          "args": [
            "clnt"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsm_release",
          "args": [
            "host->h_nsmhandle"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "nsm_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/mon.c",
          "lines": "454-463",
          "snippet": "void nsm_release(struct nsm_handle *nsm)\n{\n\tif (atomic_dec_and_lock(&nsm->sm_count, &nsm_lock)) {\n\t\tlist_del(&nsm->sm_link);\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: destroyed nsm_handle for %s (%s)\\n\",\n\t\t\t\tnsm->sm_name, nsm->sm_addrbuf);\n\t\tkfree(nsm);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/ktime.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static\t\t\t\tDEFINE_SPINLOCK(nsm_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <asm/unaligned.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/ktime.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic\t\t\t\tDEFINE_SPINLOCK(nsm_lock);\n\nvoid nsm_release(struct nsm_handle *nsm)\n{\n\tif (atomic_dec_and_lock(&nsm->sm_count, &nsm_lock)) {\n\t\tlist_del(&nsm->sm_link);\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: destroyed nsm_handle for %s (%s)\\n\",\n\t\t\t\tnsm->sm_name, nsm->sm_addrbuf);\n\t\tkfree(nsm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsm_unmonitor",
          "args": [
            "host"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "nsm_unmonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/mon.c",
          "lines": "242-265",
          "snippet": "void nsm_unmonitor(const struct nlm_host *host)\n{\n\tstruct nsm_handle *nsm = host->h_nsmhandle;\n\tstruct nsm_res\tres;\n\tint status;\n\n\tif (atomic_read(&nsm->sm_count) == 1\n\t && nsm->sm_monitored && !nsm->sm_sticky) {\n\t\tstruct lockd_net *ln = net_generic(host->net, lockd_net_id);\n\n\t\tdprintk(\"lockd: nsm_unmonitor(%s)\\n\", nsm->sm_name);\n\n\t\tstatus = nsm_mon_unmon(nsm, NSMPROC_UNMON, &res, ln->nsm_clnt);\n\t\tif (res.status != 0)\n\t\t\tstatus = -EIO;\n\t\tif (status < 0)\n\t\t\tprintk(KERN_NOTICE \"lockd: cannot unmonitor %s\\n\",\n\t\t\t\t\tnsm->sm_name);\n\t\telse\n\t\t\tnsm->sm_monitored = 0;\n\n\t\tnsm_client_put(host->net);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/ktime.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <asm/unaligned.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/ktime.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid nsm_unmonitor(const struct nlm_host *host)\n{\n\tstruct nsm_handle *nsm = host->h_nsmhandle;\n\tstruct nsm_res\tres;\n\tint status;\n\n\tif (atomic_read(&nsm->sm_count) == 1\n\t && nsm->sm_monitored && !nsm->sm_sticky) {\n\t\tstruct lockd_net *ln = net_generic(host->net, lockd_net_id);\n\n\t\tdprintk(\"lockd: nsm_unmonitor(%s)\\n\", nsm->sm_name);\n\n\t\tstatus = nsm_mon_unmon(nsm, NSMPROC_UNMON, &res, ln->nsm_clnt);\n\t\tif (res.status != 0)\n\t\t\tstatus = -EIO;\n\t\tif (status < 0)\n\t\t\tprintk(KERN_NOTICE \"lockd: cannot unmonitor %s\\n\",\n\t\t\t\t\tnsm->sm_name);\n\t\telse\n\t\t\tnsm->sm_monitored = 0;\n\n\t\tnsm_client_put(host->net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&host->h_hash"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: destroy host %s\\n\"",
            "host->h_name"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "host->net",
            "lockd_net_id"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic unsigned long\t\tnrhosts;\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstatic void nlm_destroy_host_locked(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\tstruct lockd_net *ln = net_generic(host->net, lockd_net_id);\n\n\tdprintk(\"lockd: destroy host %s\\n\", host->h_name);\n\n\thlist_del_init(&host->h_hash);\n\n\tnsm_unmonitor(host);\n\tnsm_release(host->h_nsmhandle);\n\n\tclnt = host->h_rpcclnt;\n\tif (clnt != NULL)\n\t\trpc_shutdown_client(clnt);\n\tkfree(host);\n\n\tln->nrhosts--;\n\tnrhosts--;\n}"
  },
  {
    "function_name": "nlm_alloc_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "109-167",
    "snippet": "static struct nlm_host *nlm_alloc_host(struct nlm_lookup_host_info *ni,\n\t\t\t\t       struct nsm_handle *nsm)\n{\n\tstruct nlm_host *host = NULL;\n\tunsigned long now = jiffies;\n\n\tif (nsm != NULL)\n\t\tatomic_inc(&nsm->sm_count);\n\telse {\n\t\thost = NULL;\n\t\tnsm = nsm_get_handle(ni->sap, ni->salen,\n\t\t\t\t\tni->hostname, ni->hostname_len);\n\t\tif (unlikely(nsm == NULL)) {\n\t\t\tdprintk(\"lockd: %s failed; no nsm handle\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thost = kmalloc(sizeof(*host), GFP_KERNEL);\n\tif (unlikely(host == NULL)) {\n\t\tdprintk(\"lockd: %s failed; no memory\\n\", __func__);\n\t\tnsm_release(nsm);\n\t\tgoto out;\n\t}\n\n\tmemcpy(nlm_addr(host), ni->sap, ni->salen);\n\thost->h_addrlen    = ni->salen;\n\trpc_set_port(nlm_addr(host), 0);\n\thost->h_srcaddrlen = 0;\n\n\thost->h_rpcclnt    = NULL;\n\thost->h_name\t   = nsm->sm_name;\n\thost->h_version    = ni->version;\n\thost->h_proto      = ni->protocol;\n\thost->h_reclaiming = 0;\n\thost->h_server     = ni->server;\n\thost->h_noresvport = ni->noresvport;\n\thost->h_inuse      = 0;\n\tinit_waitqueue_head(&host->h_gracewait);\n\tinit_rwsem(&host->h_rwsem);\n\thost->h_state      = 0;\n\thost->h_nsmstate   = 0;\n\thost->h_pidcount   = 0;\n\tatomic_set(&host->h_count, 1);\n\tmutex_init(&host->h_mutex);\n\thost->h_nextrebind = now + NLM_HOST_REBIND;\n\thost->h_expires    = now + NLM_HOST_EXPIRE;\n\tINIT_LIST_HEAD(&host->h_lockowners);\n\tspin_lock_init(&host->h_lock);\n\tINIT_LIST_HEAD(&host->h_granted);\n\tINIT_LIST_HEAD(&host->h_reclaim);\n\thost->h_nsmhandle  = nsm;\n\thost->h_addrbuf    = nsm->sm_addrbuf;\n\thost->net\t   = ni->net;\n\nout:\n\treturn host;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NLM_HOST_EXPIRE\t\t(300 * HZ)",
      "#define NLM_HOST_REBIND\t\t(60 * HZ)"
    ],
    "globals_used": [
      "static void\t\t\tnlm_gc_hosts(struct net *net);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&host->h_reclaim"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&host->h_granted"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&host->h_lock"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&host->h_lockowners"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&host->h_mutex"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&host->h_count",
            "1"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&host->h_rwsem"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&host->h_gracewait"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_set_port",
          "args": [
            "nlm_addr(host)",
            "0"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_addr",
          "args": [
            "host"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nlm_addr(host)",
            "ni->sap",
            "ni->salen"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_addr",
          "args": [
            "host"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsm_release",
          "args": [
            "nsm"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "nsm_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/mon.c",
          "lines": "454-463",
          "snippet": "void nsm_release(struct nsm_handle *nsm)\n{\n\tif (atomic_dec_and_lock(&nsm->sm_count, &nsm_lock)) {\n\t\tlist_del(&nsm->sm_link);\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: destroyed nsm_handle for %s (%s)\\n\",\n\t\t\t\tnsm->sm_name, nsm->sm_addrbuf);\n\t\tkfree(nsm);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/ktime.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static\t\t\t\tDEFINE_SPINLOCK(nsm_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <asm/unaligned.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/ktime.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic\t\t\t\tDEFINE_SPINLOCK(nsm_lock);\n\nvoid nsm_release(struct nsm_handle *nsm)\n{\n\tif (atomic_dec_and_lock(&nsm->sm_count, &nsm_lock)) {\n\t\tlist_del(&nsm->sm_link);\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: destroyed nsm_handle for %s (%s)\\n\",\n\t\t\t\tnsm->sm_name, nsm->sm_addrbuf);\n\t\tkfree(nsm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: %s failed; no memory\\n\"",
            "__func__"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "host == NULL"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*host)",
            "GFP_KERNEL"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: %s failed; no nsm handle\\n\"",
            "__func__"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nsm == NULL"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsm_get_handle",
          "args": [
            "ni->sap",
            "ni->salen",
            "ni->hostname",
            "ni->hostname_len"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "nsm_get_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/mon.c",
          "lines": "368-416",
          "snippet": "struct nsm_handle *nsm_get_handle(const struct sockaddr *sap,\n\t\t\t\t  const size_t salen, const char *hostname,\n\t\t\t\t  const size_t hostname_len)\n{\n\tstruct nsm_handle *cached, *new = NULL;\n\n\tif (hostname && memchr(hostname, '/', hostname_len) != NULL) {\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_WARNING \"Invalid hostname \\\"%.*s\\\" \"\n\t\t\t\t\t    \"in NFS lock request\\n\",\n\t\t\t\t(int)hostname_len, hostname);\n\t\t}\n\t\treturn NULL;\n\t}\n\nretry:\n\tspin_lock(&nsm_lock);\n\n\tif (nsm_use_hostnames && hostname != NULL)\n\t\tcached = nsm_lookup_hostname(hostname, hostname_len);\n\telse\n\t\tcached = nsm_lookup_addr(sap);\n\n\tif (cached != NULL) {\n\t\tatomic_inc(&cached->sm_count);\n\t\tspin_unlock(&nsm_lock);\n\t\tkfree(new);\n\t\tdprintk(\"lockd: found nsm_handle for %s (%s), \"\n\t\t\t\t\"cnt %d\\n\", cached->sm_name,\n\t\t\t\tcached->sm_addrbuf,\n\t\t\t\tatomic_read(&cached->sm_count));\n\t\treturn cached;\n\t}\n\n\tif (new != NULL) {\n\t\tlist_add(&new->sm_link, &nsm_handles);\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: created nsm_handle for %s (%s)\\n\",\n\t\t\t\tnew->sm_name, new->sm_addrbuf);\n\t\treturn new;\n\t}\n\n\tspin_unlock(&nsm_lock);\n\n\tnew = nsm_create_handle(sap, salen, hostname, hostname_len);\n\tif (unlikely(new == NULL))\n\t\treturn NULL;\n\tgoto retry;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/ktime.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static\t\t\t\tLIST_HEAD(nsm_handles);",
            "static\t\t\t\tDEFINE_SPINLOCK(nsm_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <asm/unaligned.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/ktime.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic\t\t\t\tLIST_HEAD(nsm_handles);\nstatic\t\t\t\tDEFINE_SPINLOCK(nsm_lock);\n\nstruct nsm_handle *nsm_get_handle(const struct sockaddr *sap,\n\t\t\t\t  const size_t salen, const char *hostname,\n\t\t\t\t  const size_t hostname_len)\n{\n\tstruct nsm_handle *cached, *new = NULL;\n\n\tif (hostname && memchr(hostname, '/', hostname_len) != NULL) {\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_WARNING \"Invalid hostname \\\"%.*s\\\" \"\n\t\t\t\t\t    \"in NFS lock request\\n\",\n\t\t\t\t(int)hostname_len, hostname);\n\t\t}\n\t\treturn NULL;\n\t}\n\nretry:\n\tspin_lock(&nsm_lock);\n\n\tif (nsm_use_hostnames && hostname != NULL)\n\t\tcached = nsm_lookup_hostname(hostname, hostname_len);\n\telse\n\t\tcached = nsm_lookup_addr(sap);\n\n\tif (cached != NULL) {\n\t\tatomic_inc(&cached->sm_count);\n\t\tspin_unlock(&nsm_lock);\n\t\tkfree(new);\n\t\tdprintk(\"lockd: found nsm_handle for %s (%s), \"\n\t\t\t\t\"cnt %d\\n\", cached->sm_name,\n\t\t\t\tcached->sm_addrbuf,\n\t\t\t\tatomic_read(&cached->sm_count));\n\t\treturn cached;\n\t}\n\n\tif (new != NULL) {\n\t\tlist_add(&new->sm_link, &nsm_handles);\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: created nsm_handle for %s (%s)\\n\",\n\t\t\t\tnew->sm_name, new->sm_addrbuf);\n\t\treturn new;\n\t}\n\n\tspin_unlock(&nsm_lock);\n\n\tnew = nsm_create_handle(sap, salen, hostname, hostname_len);\n\tif (unlikely(new == NULL))\n\t\treturn NULL;\n\tgoto retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&nsm->sm_count"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_EXPIRE\t\t(300 * HZ)\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstatic struct nlm_host *nlm_alloc_host(struct nlm_lookup_host_info *ni,\n\t\t\t\t       struct nsm_handle *nsm)\n{\n\tstruct nlm_host *host = NULL;\n\tunsigned long now = jiffies;\n\n\tif (nsm != NULL)\n\t\tatomic_inc(&nsm->sm_count);\n\telse {\n\t\thost = NULL;\n\t\tnsm = nsm_get_handle(ni->sap, ni->salen,\n\t\t\t\t\tni->hostname, ni->hostname_len);\n\t\tif (unlikely(nsm == NULL)) {\n\t\t\tdprintk(\"lockd: %s failed; no nsm handle\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thost = kmalloc(sizeof(*host), GFP_KERNEL);\n\tif (unlikely(host == NULL)) {\n\t\tdprintk(\"lockd: %s failed; no memory\\n\", __func__);\n\t\tnsm_release(nsm);\n\t\tgoto out;\n\t}\n\n\tmemcpy(nlm_addr(host), ni->sap, ni->salen);\n\thost->h_addrlen    = ni->salen;\n\trpc_set_port(nlm_addr(host), 0);\n\thost->h_srcaddrlen = 0;\n\n\thost->h_rpcclnt    = NULL;\n\thost->h_name\t   = nsm->sm_name;\n\thost->h_version    = ni->version;\n\thost->h_proto      = ni->protocol;\n\thost->h_reclaiming = 0;\n\thost->h_server     = ni->server;\n\thost->h_noresvport = ni->noresvport;\n\thost->h_inuse      = 0;\n\tinit_waitqueue_head(&host->h_gracewait);\n\tinit_rwsem(&host->h_rwsem);\n\thost->h_state      = 0;\n\thost->h_nsmstate   = 0;\n\thost->h_pidcount   = 0;\n\tatomic_set(&host->h_count, 1);\n\tmutex_init(&host->h_mutex);\n\thost->h_nextrebind = now + NLM_HOST_REBIND;\n\thost->h_expires    = now + NLM_HOST_EXPIRE;\n\tINIT_LIST_HEAD(&host->h_lockowners);\n\tspin_lock_init(&host->h_lock);\n\tINIT_LIST_HEAD(&host->h_granted);\n\tINIT_LIST_HEAD(&host->h_reclaim);\n\thost->h_nsmhandle  = nsm;\n\thost->h_addrbuf    = nsm->sm_addrbuf;\n\thost->net\t   = ni->net;\n\nout:\n\treturn host;\n}"
  },
  {
    "function_name": "nlm_hash_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "89-104",
    "snippet": "static unsigned int nlm_hash_address(const struct sockaddr *sap)\n{\n\tunsigned int hash;\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\thash = __nlm_hash_addr4(sap);\n\t\tbreak;\n\tcase AF_INET6:\n\t\thash = __nlm_hash_addr6(sap);\n\t\tbreak;\n\tdefault:\n\t\thash = 0;\n\t}\n\treturn hash & (NLM_HOST_NRHASH - 1);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NLM_HOST_NRHASH\t\t32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nlm_hash_addr6",
          "args": [
            "sap"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "__nlm_hash_addr6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "79-87",
          "snippet": "static unsigned int __nlm_hash_addr6(const struct sockaddr *sap)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tconst struct in6_addr addr = sin6->sin6_addr;\n\treturn __nlm_hash32(addr.s6_addr32[0]) ^\n\t       __nlm_hash32(addr.s6_addr32[1]) ^\n\t       __nlm_hash32(addr.s6_addr32[2]) ^\n\t       __nlm_hash32(addr.s6_addr32[3]);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic unsigned int __nlm_hash_addr6(const struct sockaddr *sap)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tconst struct in6_addr addr = sin6->sin6_addr;\n\treturn __nlm_hash32(addr.s6_addr32[0]) ^\n\t       __nlm_hash32(addr.s6_addr32[1]) ^\n\t       __nlm_hash32(addr.s6_addr32[2]) ^\n\t       __nlm_hash32(addr.s6_addr32[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nlm_hash_addr4",
          "args": [
            "sap"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "__nlm_hash_addr4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "73-77",
          "snippet": "static unsigned int __nlm_hash_addr4(const struct sockaddr *sap)\n{\n\tconst struct sockaddr_in *sin = (struct sockaddr_in *)sap;\n\treturn __nlm_hash32(sin->sin_addr.s_addr);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic unsigned int __nlm_hash_addr4(const struct sockaddr *sap)\n{\n\tconst struct sockaddr_in *sin = (struct sockaddr_in *)sap;\n\treturn __nlm_hash32(sin->sin_addr.s_addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_NRHASH\t\t32\n\nstatic unsigned int nlm_hash_address(const struct sockaddr *sap)\n{\n\tunsigned int hash;\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\thash = __nlm_hash_addr4(sap);\n\t\tbreak;\n\tcase AF_INET6:\n\t\thash = __nlm_hash_addr6(sap);\n\t\tbreak;\n\tdefault:\n\t\thash = 0;\n\t}\n\treturn hash & (NLM_HOST_NRHASH - 1);\n}"
  },
  {
    "function_name": "__nlm_hash_addr6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "79-87",
    "snippet": "static unsigned int __nlm_hash_addr6(const struct sockaddr *sap)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tconst struct in6_addr addr = sin6->sin6_addr;\n\treturn __nlm_hash32(addr.s6_addr32[0]) ^\n\t       __nlm_hash32(addr.s6_addr32[1]) ^\n\t       __nlm_hash32(addr.s6_addr32[2]) ^\n\t       __nlm_hash32(addr.s6_addr32[3]);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nlm_hash32",
          "args": [
            "addr.s6_addr32[3]"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "__nlm_hash32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "67-71",
          "snippet": "static unsigned int __nlm_hash32(const __be32 n)\n{\n\tunsigned int hash = (__force u32)n ^ ((__force u32)n >> 16);\n\treturn hash ^ (hash >> 8);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic unsigned int __nlm_hash32(const __be32 n)\n{\n\tunsigned int hash = (__force u32)n ^ ((__force u32)n >> 16);\n\treturn hash ^ (hash >> 8);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic unsigned int __nlm_hash_addr6(const struct sockaddr *sap)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tconst struct in6_addr addr = sin6->sin6_addr;\n\treturn __nlm_hash32(addr.s6_addr32[0]) ^\n\t       __nlm_hash32(addr.s6_addr32[1]) ^\n\t       __nlm_hash32(addr.s6_addr32[2]) ^\n\t       __nlm_hash32(addr.s6_addr32[3]);\n}"
  },
  {
    "function_name": "__nlm_hash_addr4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "73-77",
    "snippet": "static unsigned int __nlm_hash_addr4(const struct sockaddr *sap)\n{\n\tconst struct sockaddr_in *sin = (struct sockaddr_in *)sap;\n\treturn __nlm_hash32(sin->sin_addr.s_addr);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nlm_hash32",
          "args": [
            "sin->sin_addr.s_addr"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "__nlm_hash32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "67-71",
          "snippet": "static unsigned int __nlm_hash32(const __be32 n)\n{\n\tunsigned int hash = (__force u32)n ^ ((__force u32)n >> 16);\n\treturn hash ^ (hash >> 8);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic unsigned int __nlm_hash32(const __be32 n)\n{\n\tunsigned int hash = (__force u32)n ^ ((__force u32)n >> 16);\n\treturn hash ^ (hash >> 8);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic unsigned int __nlm_hash_addr4(const struct sockaddr *sap)\n{\n\tconst struct sockaddr_in *sin = (struct sockaddr_in *)sap;\n\treturn __nlm_hash32(sin->sin_addr.s_addr);\n}"
  },
  {
    "function_name": "__nlm_hash32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
    "lines": "67-71",
    "snippet": "static unsigned int __nlm_hash32(const __be32 n)\n{\n\tunsigned int hash = (__force u32)n ^ ((__force u32)n >> 16);\n\treturn hash ^ (hash >> 8);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic unsigned int __nlm_hash32(const __be32 n)\n{\n\tunsigned int hash = (__force u32)n ^ ((__force u32)n >> 16);\n\treturn hash ^ (hash >> 8);\n}"
  }
]