[
  {
    "function_name": "nfs4filelayout_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "1150-1155",
    "snippet": "static void __exit nfs4filelayout_exit(void)\n{\n\tprintk(KERN_INFO \"%s: NFSv4 File Layout Driver Unregistering...\\n\",\n\t       __func__);\n\tpnfs_unregister_layoutdriver(&filelayout_type);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pnfs_layoutdriver_type filelayout_type = {\n\t.id\t\t\t= LAYOUT_NFSV4_1_FILES,\n\t.name\t\t\t= \"LAYOUT_NFSV4_1_FILES\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.alloc_layout_hdr\t= filelayout_alloc_layout_hdr,\n\t.free_layout_hdr\t= filelayout_free_layout_hdr,\n\t.alloc_lseg\t\t= filelayout_alloc_lseg,\n\t.free_lseg\t\t= filelayout_free_lseg,\n\t.pg_read_ops\t\t= &filelayout_pg_read_ops,\n\t.pg_write_ops\t\t= &filelayout_pg_write_ops,\n\t.get_ds_info\t\t= &filelayout_get_ds_info,\n\t.mark_request_commit\t= filelayout_mark_request_commit,\n\t.clear_request_commit\t= pnfs_generic_clear_request_commit,\n\t.scan_commit_lists\t= pnfs_generic_scan_commit_lists,\n\t.recover_commit_reqs\t= pnfs_generic_recover_commit_reqs,\n\t.search_commit_reqs\t= filelayout_search_commit_reqs,\n\t.commit_pagelist\t= filelayout_commit_pagelist,\n\t.read_pagelist\t\t= filelayout_read_pagelist,\n\t.write_pagelist\t\t= filelayout_write_pagelist,\n\t.alloc_deviceid_node\t= filelayout_alloc_deviceid_node,\n\t.free_deviceid_node\t= filelayout_free_deveiceid_node,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_unregister_layoutdriver",
          "args": [
            "&filelayout_type"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_unregister_layoutdriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "184-191",
          "snippet": "void\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tdprintk(\"%s Deregistering id:%u\\n\", __func__, ld_type->id);\n\tspin_lock(&pnfs_spinlock);\n\tlist_del(&ld_type->pnfs_tblid);\n\tspin_unlock(&pnfs_spinlock);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pnfs_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\n\nvoid\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tdprintk(\"%s Deregistering id:%u\\n\", __func__, ld_type->id);\n\tspin_lock(&pnfs_spinlock);\n\tlist_del(&ld_type->pnfs_tblid);\n\tspin_unlock(&pnfs_spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: NFSv4 File Layout Driver Unregistering...\\n\"",
            "__func__"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layoutdriver_type filelayout_type = {\n\t.id\t\t\t= LAYOUT_NFSV4_1_FILES,\n\t.name\t\t\t= \"LAYOUT_NFSV4_1_FILES\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.alloc_layout_hdr\t= filelayout_alloc_layout_hdr,\n\t.free_layout_hdr\t= filelayout_free_layout_hdr,\n\t.alloc_lseg\t\t= filelayout_alloc_lseg,\n\t.free_lseg\t\t= filelayout_free_lseg,\n\t.pg_read_ops\t\t= &filelayout_pg_read_ops,\n\t.pg_write_ops\t\t= &filelayout_pg_write_ops,\n\t.get_ds_info\t\t= &filelayout_get_ds_info,\n\t.mark_request_commit\t= filelayout_mark_request_commit,\n\t.clear_request_commit\t= pnfs_generic_clear_request_commit,\n\t.scan_commit_lists\t= pnfs_generic_scan_commit_lists,\n\t.recover_commit_reqs\t= pnfs_generic_recover_commit_reqs,\n\t.search_commit_reqs\t= filelayout_search_commit_reqs,\n\t.commit_pagelist\t= filelayout_commit_pagelist,\n\t.read_pagelist\t\t= filelayout_read_pagelist,\n\t.write_pagelist\t\t= filelayout_write_pagelist,\n\t.alloc_deviceid_node\t= filelayout_alloc_deviceid_node,\n\t.free_deviceid_node\t= filelayout_free_deveiceid_node,\n};\n\nstatic void __exit nfs4filelayout_exit(void)\n{\n\tprintk(KERN_INFO \"%s: NFSv4 File Layout Driver Unregistering...\\n\",\n\t       __func__);\n\tpnfs_unregister_layoutdriver(&filelayout_type);\n}"
  },
  {
    "function_name": "nfs4filelayout_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "1143-1148",
    "snippet": "static int __init nfs4filelayout_init(void)\n{\n\tprintk(KERN_INFO \"%s: NFSv4 File Layout Driver Registering...\\n\",\n\t       __func__);\n\treturn pnfs_register_layoutdriver(&filelayout_type);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pnfs_layoutdriver_type filelayout_type = {\n\t.id\t\t\t= LAYOUT_NFSV4_1_FILES,\n\t.name\t\t\t= \"LAYOUT_NFSV4_1_FILES\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.alloc_layout_hdr\t= filelayout_alloc_layout_hdr,\n\t.free_layout_hdr\t= filelayout_free_layout_hdr,\n\t.alloc_lseg\t\t= filelayout_alloc_lseg,\n\t.free_lseg\t\t= filelayout_free_lseg,\n\t.pg_read_ops\t\t= &filelayout_pg_read_ops,\n\t.pg_write_ops\t\t= &filelayout_pg_write_ops,\n\t.get_ds_info\t\t= &filelayout_get_ds_info,\n\t.mark_request_commit\t= filelayout_mark_request_commit,\n\t.clear_request_commit\t= pnfs_generic_clear_request_commit,\n\t.scan_commit_lists\t= pnfs_generic_scan_commit_lists,\n\t.recover_commit_reqs\t= pnfs_generic_recover_commit_reqs,\n\t.search_commit_reqs\t= filelayout_search_commit_reqs,\n\t.commit_pagelist\t= filelayout_commit_pagelist,\n\t.read_pagelist\t\t= filelayout_read_pagelist,\n\t.write_pagelist\t\t= filelayout_write_pagelist,\n\t.alloc_deviceid_node\t= filelayout_alloc_deviceid_node,\n\t.free_deviceid_node\t= filelayout_free_deveiceid_node,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_register_layoutdriver",
          "args": [
            "&filelayout_type"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_register_layoutdriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "151-181",
          "snippet": "int\npnfs_register_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tint status = -EINVAL;\n\tstruct pnfs_layoutdriver_type *tmp;\n\n\tif (ld_type->id == 0) {\n\t\tprintk(KERN_ERR \"NFS: %s id 0 is reserved\\n\", __func__);\n\t\treturn status;\n\t}\n\tif (!ld_type->alloc_lseg || !ld_type->free_lseg) {\n\t\tprintk(KERN_ERR \"NFS: %s Layout driver must provide \"\n\t\t       \"alloc_lseg and free_lseg.\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tspin_lock(&pnfs_spinlock);\n\ttmp = find_pnfs_driver_locked(ld_type->id);\n\tif (!tmp) {\n\t\tlist_add(&ld_type->pnfs_tblid, &pnfs_modules_tbl);\n\t\tstatus = 0;\n\t\tdprintk(\"%s Registering id:%u name:%s\\n\", __func__, ld_type->id,\n\t\t\tld_type->name);\n\t} else {\n\t\tprintk(KERN_ERR \"NFS: %s Module with id %d already loaded!\\n\",\n\t\t\t__func__, ld_type->id);\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\n\treturn status;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pnfs_spinlock);",
            "static LIST_HEAD(pnfs_modules_tbl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\nstatic LIST_HEAD(pnfs_modules_tbl);\n\nint\npnfs_register_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tint status = -EINVAL;\n\tstruct pnfs_layoutdriver_type *tmp;\n\n\tif (ld_type->id == 0) {\n\t\tprintk(KERN_ERR \"NFS: %s id 0 is reserved\\n\", __func__);\n\t\treturn status;\n\t}\n\tif (!ld_type->alloc_lseg || !ld_type->free_lseg) {\n\t\tprintk(KERN_ERR \"NFS: %s Layout driver must provide \"\n\t\t       \"alloc_lseg and free_lseg.\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tspin_lock(&pnfs_spinlock);\n\ttmp = find_pnfs_driver_locked(ld_type->id);\n\tif (!tmp) {\n\t\tlist_add(&ld_type->pnfs_tblid, &pnfs_modules_tbl);\n\t\tstatus = 0;\n\t\tdprintk(\"%s Registering id:%u name:%s\\n\", __func__, ld_type->id,\n\t\t\tld_type->name);\n\t} else {\n\t\tprintk(KERN_ERR \"NFS: %s Module with id %d already loaded!\\n\",\n\t\t\t__func__, ld_type->id);\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: NFSv4 File Layout Driver Registering...\\n\"",
            "__func__"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layoutdriver_type filelayout_type = {\n\t.id\t\t\t= LAYOUT_NFSV4_1_FILES,\n\t.name\t\t\t= \"LAYOUT_NFSV4_1_FILES\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.alloc_layout_hdr\t= filelayout_alloc_layout_hdr,\n\t.free_layout_hdr\t= filelayout_free_layout_hdr,\n\t.alloc_lseg\t\t= filelayout_alloc_lseg,\n\t.free_lseg\t\t= filelayout_free_lseg,\n\t.pg_read_ops\t\t= &filelayout_pg_read_ops,\n\t.pg_write_ops\t\t= &filelayout_pg_write_ops,\n\t.get_ds_info\t\t= &filelayout_get_ds_info,\n\t.mark_request_commit\t= filelayout_mark_request_commit,\n\t.clear_request_commit\t= pnfs_generic_clear_request_commit,\n\t.scan_commit_lists\t= pnfs_generic_scan_commit_lists,\n\t.recover_commit_reqs\t= pnfs_generic_recover_commit_reqs,\n\t.search_commit_reqs\t= filelayout_search_commit_reqs,\n\t.commit_pagelist\t= filelayout_commit_pagelist,\n\t.read_pagelist\t\t= filelayout_read_pagelist,\n\t.write_pagelist\t\t= filelayout_write_pagelist,\n\t.alloc_deviceid_node\t= filelayout_alloc_deviceid_node,\n\t.free_deviceid_node\t= filelayout_free_deveiceid_node,\n};\n\nstatic int __init nfs4filelayout_init(void)\n{\n\tprintk(KERN_INFO \"%s: NFSv4 File Layout Driver Registering...\\n\",\n\t       __func__);\n\treturn pnfs_register_layoutdriver(&filelayout_type);\n}"
  },
  {
    "function_name": "filelayout_get_ds_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "1109-1118",
    "snippet": "static struct pnfs_ds_commit_info *\nfilelayout_get_ds_info(struct inode *inode)\n{\n\tstruct pnfs_layout_hdr *layout = NFS_I(inode)->layout;\n\n\tif (layout == NULL)\n\t\treturn NULL;\n\telse\n\t\treturn &FILELAYOUT_FROM_HDR(layout)->commit_info;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FILELAYOUT_FROM_HDR",
          "args": [
            "layout"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "74-78",
          "snippet": "static inline struct nfs4_filelayout *\nFILELAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_filelayout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout *\nFILELAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_filelayout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_ds_commit_info *\nfilelayout_get_ds_info(struct inode *inode)\n{\n\tstruct pnfs_layout_hdr *layout = NFS_I(inode)->layout;\n\n\tif (layout == NULL)\n\t\treturn NULL;\n\telse\n\t\treturn &FILELAYOUT_FROM_HDR(layout)->commit_info;\n}"
  },
  {
    "function_name": "filelayout_free_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "1103-1107",
    "snippet": "static void\nfilelayout_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tkfree(FILELAYOUT_FROM_HDR(lo));\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "FILELAYOUT_FROM_HDR(lo)"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_FROM_HDR",
          "args": [
            "lo"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "74-78",
          "snippet": "static inline struct nfs4_filelayout *\nFILELAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_filelayout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout *\nFILELAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_filelayout, generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nfilelayout_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tkfree(FILELAYOUT_FROM_HDR(lo));\n}"
  },
  {
    "function_name": "filelayout_alloc_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "1094-1101",
    "snippet": "static struct pnfs_layout_hdr *\nfilelayout_alloc_layout_hdr(struct inode *inode, gfp_t gfp_flags)\n{\n\tstruct nfs4_filelayout *flo;\n\n\tflo = kzalloc(sizeof(*flo), gfp_flags);\n\treturn flo != NULL ? &flo->generic_hdr : NULL;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*flo)",
            "gfp_flags"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_hdr *\nfilelayout_alloc_layout_hdr(struct inode *inode, gfp_t gfp_flags)\n{\n\tstruct nfs4_filelayout *flo;\n\n\tflo = kzalloc(sizeof(*flo), gfp_flags);\n\treturn flo != NULL ? &flo->generic_hdr : NULL;\n}"
  },
  {
    "function_name": "filelayout_free_deveiceid_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "1088-1092",
    "snippet": "static void\nfilelayout_free_deveiceid_node(struct nfs4_deviceid_node *d)\n{\n\tnfs4_fl_free_deviceid(container_of(d, struct nfs4_file_layout_dsaddr, id_node));\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nfilelayout_free_deveiceid_node(struct nfs4_deviceid_node *d)\n{\n\tnfs4_fl_free_deviceid(container_of(d, struct nfs4_file_layout_dsaddr, id_node));\n}"
  },
  {
    "function_name": "filelayout_alloc_deviceid_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "1076-1086",
    "snippet": "static struct nfs4_deviceid_node *\nfilelayout_alloc_deviceid_node(struct nfs_server *server,\n\t\tstruct pnfs_device *pdev, gfp_t gfp_flags)\n{\n\tstruct nfs4_file_layout_dsaddr *dsaddr;\n\n\tdsaddr = nfs4_fl_alloc_deviceid_node(server, pdev, gfp_flags);\n\tif (!dsaddr)\n\t\treturn NULL;\n\treturn &dsaddr->id_node;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_fl_alloc_deviceid_node",
          "args": [
            "server",
            "pdev",
            "gfp_flags"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_alloc_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "62-211",
          "snippet": "struct nfs4_file_layout_dsaddr *\nnfs4_fl_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\tgfp_t gfp_flags)\n{\n\tint i;\n\tu32 cnt, num;\n\tu8 *indexp;\n\t__be32 *p;\n\tu8 *stripe_indices;\n\tu8 max_stripe_index;\n\tstruct nfs4_file_layout_dsaddr *dsaddr = NULL;\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct list_head dsaddrs;\n\tstruct nfs4_pnfs_ds_addr *da;\n\n\t/* set up xdr stream */\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\tgoto out_err;\n\n\txdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* Get the stripe count (number of stripe index) */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_scratch;\n\n\tcnt = be32_to_cpup(p);\n\tdprintk(\"%s stripe count  %d\\n\", __func__, cnt);\n\tif (cnt > NFS4_PNFS_MAX_STRIPE_CNT) {\n\t\tprintk(KERN_WARNING \"NFS: %s: stripe count %d greater than \"\n\t\t       \"supported maximum %d\\n\", __func__,\n\t\t\tcnt, NFS4_PNFS_MAX_STRIPE_CNT);\n\t\tgoto out_err_free_scratch;\n\t}\n\n\t/* read stripe indices */\n\tstripe_indices = kcalloc(cnt, sizeof(u8), gfp_flags);\n\tif (!stripe_indices)\n\t\tgoto out_err_free_scratch;\n\n\tp = xdr_inline_decode(&stream, cnt << 2);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_stripe_indices;\n\n\tindexp = &stripe_indices[0];\n\tmax_stripe_index = 0;\n\tfor (i = 0; i < cnt; i++) {\n\t\t*indexp = be32_to_cpup(p++);\n\t\tmax_stripe_index = max(max_stripe_index, *indexp);\n\t\tindexp++;\n\t}\n\n\t/* Check the multipath list count */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_stripe_indices;\n\n\tnum = be32_to_cpup(p);\n\tdprintk(\"%s ds_num %u\\n\", __func__, num);\n\tif (num > NFS4_PNFS_MAX_MULTI_CNT) {\n\t\tprintk(KERN_WARNING \"NFS: %s: multipath count %d greater than \"\n\t\t\t\"supported maximum %d\\n\", __func__,\n\t\t\tnum, NFS4_PNFS_MAX_MULTI_CNT);\n\t\tgoto out_err_free_stripe_indices;\n\t}\n\n\t/* validate stripe indices are all < num */\n\tif (max_stripe_index >= num) {\n\t\tprintk(KERN_WARNING \"NFS: %s: stripe index %u >= num ds %u\\n\",\n\t\t\t__func__, max_stripe_index, num);\n\t\tgoto out_err_free_stripe_indices;\n\t}\n\n\tdsaddr = kzalloc(sizeof(*dsaddr) +\n\t\t\t(sizeof(struct nfs4_pnfs_ds *) * (num - 1)),\n\t\t\tgfp_flags);\n\tif (!dsaddr)\n\t\tgoto out_err_free_stripe_indices;\n\n\tdsaddr->stripe_count = cnt;\n\tdsaddr->stripe_indices = stripe_indices;\n\tstripe_indices = NULL;\n\tdsaddr->ds_num = num;\n\tnfs4_init_deviceid_node(&dsaddr->id_node, server, &pdev->dev_id);\n\n\tINIT_LIST_HEAD(&dsaddrs);\n\n\tfor (i = 0; i < dsaddr->ds_num; i++) {\n\t\tint j;\n\t\tu32 mp_count;\n\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free_deviceid;\n\n\t\tmp_count = be32_to_cpup(p); /* multipath count */\n\t\tfor (j = 0; j < mp_count; j++) {\n\t\t\tda = nfs4_decode_mp_ds_addr(server->nfs_client->cl_net,\n\t\t\t\t\t\t    &stream, gfp_flags);\n\t\t\tif (da)\n\t\t\t\tlist_add_tail(&da->da_node, &dsaddrs);\n\t\t}\n\t\tif (list_empty(&dsaddrs)) {\n\t\t\tdprintk(\"%s: no suitable DS addresses found\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out_err_free_deviceid;\n\t\t}\n\n\t\tdsaddr->ds_list[i] = nfs4_pnfs_ds_add(&dsaddrs, gfp_flags);\n\t\tif (!dsaddr->ds_list[i])\n\t\t\tgoto out_err_drain_dsaddrs;\n\n\t\t/* If DS was already in cache, free ds addrs */\n\t\twhile (!list_empty(&dsaddrs)) {\n\t\t\tda = list_first_entry(&dsaddrs,\n\t\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t\t      da_node);\n\t\t\tlist_del_init(&da->da_node);\n\t\t\tkfree(da->da_remotestr);\n\t\t\tkfree(da);\n\t\t}\n\t}\n\n\t__free_page(scratch);\n\treturn dsaddr;\n\nout_err_drain_dsaddrs:\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs, struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\nout_err_free_deviceid:\n\tnfs4_fl_free_deviceid(dsaddr);\n\t/* stripe_indicies was part of dsaddr */\n\tgoto out_err_free_scratch;\nout_err_free_stripe_indices:\n\tkfree(stripe_indices);\nout_err_free_scratch:\n\t__free_page(scratch);\nout_err:\n\tdprintk(\"%s ERROR: returning NULL\\n\", __func__);\n\treturn NULL;\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs4_file_layout_dsaddr *\nnfs4_fl_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\tgfp_t gfp_flags)\n{\n\tint i;\n\tu32 cnt, num;\n\tu8 *indexp;\n\t__be32 *p;\n\tu8 *stripe_indices;\n\tu8 max_stripe_index;\n\tstruct nfs4_file_layout_dsaddr *dsaddr = NULL;\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct list_head dsaddrs;\n\tstruct nfs4_pnfs_ds_addr *da;\n\n\t/* set up xdr stream */\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\tgoto out_err;\n\n\txdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* Get the stripe count (number of stripe index) */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_scratch;\n\n\tcnt = be32_to_cpup(p);\n\tdprintk(\"%s stripe count  %d\\n\", __func__, cnt);\n\tif (cnt > NFS4_PNFS_MAX_STRIPE_CNT) {\n\t\tprintk(KERN_WARNING \"NFS: %s: stripe count %d greater than \"\n\t\t       \"supported maximum %d\\n\", __func__,\n\t\t\tcnt, NFS4_PNFS_MAX_STRIPE_CNT);\n\t\tgoto out_err_free_scratch;\n\t}\n\n\t/* read stripe indices */\n\tstripe_indices = kcalloc(cnt, sizeof(u8), gfp_flags);\n\tif (!stripe_indices)\n\t\tgoto out_err_free_scratch;\n\n\tp = xdr_inline_decode(&stream, cnt << 2);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_stripe_indices;\n\n\tindexp = &stripe_indices[0];\n\tmax_stripe_index = 0;\n\tfor (i = 0; i < cnt; i++) {\n\t\t*indexp = be32_to_cpup(p++);\n\t\tmax_stripe_index = max(max_stripe_index, *indexp);\n\t\tindexp++;\n\t}\n\n\t/* Check the multipath list count */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_stripe_indices;\n\n\tnum = be32_to_cpup(p);\n\tdprintk(\"%s ds_num %u\\n\", __func__, num);\n\tif (num > NFS4_PNFS_MAX_MULTI_CNT) {\n\t\tprintk(KERN_WARNING \"NFS: %s: multipath count %d greater than \"\n\t\t\t\"supported maximum %d\\n\", __func__,\n\t\t\tnum, NFS4_PNFS_MAX_MULTI_CNT);\n\t\tgoto out_err_free_stripe_indices;\n\t}\n\n\t/* validate stripe indices are all < num */\n\tif (max_stripe_index >= num) {\n\t\tprintk(KERN_WARNING \"NFS: %s: stripe index %u >= num ds %u\\n\",\n\t\t\t__func__, max_stripe_index, num);\n\t\tgoto out_err_free_stripe_indices;\n\t}\n\n\tdsaddr = kzalloc(sizeof(*dsaddr) +\n\t\t\t(sizeof(struct nfs4_pnfs_ds *) * (num - 1)),\n\t\t\tgfp_flags);\n\tif (!dsaddr)\n\t\tgoto out_err_free_stripe_indices;\n\n\tdsaddr->stripe_count = cnt;\n\tdsaddr->stripe_indices = stripe_indices;\n\tstripe_indices = NULL;\n\tdsaddr->ds_num = num;\n\tnfs4_init_deviceid_node(&dsaddr->id_node, server, &pdev->dev_id);\n\n\tINIT_LIST_HEAD(&dsaddrs);\n\n\tfor (i = 0; i < dsaddr->ds_num; i++) {\n\t\tint j;\n\t\tu32 mp_count;\n\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free_deviceid;\n\n\t\tmp_count = be32_to_cpup(p); /* multipath count */\n\t\tfor (j = 0; j < mp_count; j++) {\n\t\t\tda = nfs4_decode_mp_ds_addr(server->nfs_client->cl_net,\n\t\t\t\t\t\t    &stream, gfp_flags);\n\t\t\tif (da)\n\t\t\t\tlist_add_tail(&da->da_node, &dsaddrs);\n\t\t}\n\t\tif (list_empty(&dsaddrs)) {\n\t\t\tdprintk(\"%s: no suitable DS addresses found\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out_err_free_deviceid;\n\t\t}\n\n\t\tdsaddr->ds_list[i] = nfs4_pnfs_ds_add(&dsaddrs, gfp_flags);\n\t\tif (!dsaddr->ds_list[i])\n\t\t\tgoto out_err_drain_dsaddrs;\n\n\t\t/* If DS was already in cache, free ds addrs */\n\t\twhile (!list_empty(&dsaddrs)) {\n\t\t\tda = list_first_entry(&dsaddrs,\n\t\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t\t      da_node);\n\t\t\tlist_del_init(&da->da_node);\n\t\t\tkfree(da->da_remotestr);\n\t\t\tkfree(da);\n\t\t}\n\t}\n\n\t__free_page(scratch);\n\treturn dsaddr;\n\nout_err_drain_dsaddrs:\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs, struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\nout_err_free_deviceid:\n\tnfs4_fl_free_deviceid(dsaddr);\n\t/* stripe_indicies was part of dsaddr */\n\tgoto out_err_free_scratch;\nout_err_free_stripe_indices:\n\tkfree(stripe_indices);\nout_err_free_scratch:\n\t__free_page(scratch);\nout_err:\n\tdprintk(\"%s ERROR: returning NULL\\n\", __func__);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs4_deviceid_node *\nfilelayout_alloc_deviceid_node(struct nfs_server *server,\n\t\tstruct pnfs_device *pdev, gfp_t gfp_flags)\n{\n\tstruct nfs4_file_layout_dsaddr *dsaddr;\n\n\tdsaddr = nfs4_fl_alloc_deviceid_node(server, pdev, gfp_flags);\n\tif (!dsaddr)\n\t\treturn NULL;\n\treturn &dsaddr->id_node;\n}"
  },
  {
    "function_name": "filelayout_commit_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "1068-1074",
    "snippet": "static int\nfilelayout_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\n\t\t\t   int how, struct nfs_commit_info *cinfo)\n{\n\treturn pnfs_generic_commit_pagelist(inode, mds_pages, how, cinfo,\n\t\t\t\t\t    filelayout_initiate_commit);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_generic_commit_pagelist",
          "args": [
            "inode",
            "mds_pages",
            "how",
            "cinfo",
            "filelayout_initiate_commit"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_commit_pagelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "233-287",
          "snippet": "int\npnfs_generic_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\n\t\t\t     int how, struct nfs_commit_info *cinfo,\n\t\t\t     int (*initiate_commit)(struct nfs_commit_data *data,\n\t\t\t\t\t\t    int how))\n{\n\tstruct nfs_commit_data *data, *tmp;\n\tLIST_HEAD(list);\n\tunsigned int nreq = 0;\n\n\tif (!list_empty(mds_pages)) {\n\t\tdata = nfs_commitdata_alloc();\n\t\tif (data != NULL) {\n\t\t\tdata->lseg = NULL;\n\t\t\tlist_add(&data->pages, &list);\n\t\t\tnreq++;\n\t\t} else {\n\t\t\tnfs_retry_commit(mds_pages, NULL, cinfo, 0);\n\t\t\tpnfs_generic_retry_commit(cinfo, 0);\n\t\t\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tnreq += pnfs_generic_alloc_ds_commits(cinfo, &list);\n\n\tif (nreq == 0) {\n\t\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\t\tgoto out;\n\t}\n\n\tatomic_add(nreq, &cinfo->mds->rpcs_out);\n\n\tlist_for_each_entry_safe(data, tmp, &list, pages) {\n\t\tlist_del_init(&data->pages);\n\t\tif (!data->lseg) {\n\t\t\tnfs_init_commit(data, mds_pages, NULL, cinfo);\n\t\t\tnfs_initiate_commit(NFS_CLIENT(inode), data,\n\t\t\t\t\t    NFS_PROTO(data->inode),\n\t\t\t\t\t    data->mds_ops, how, 0);\n\t\t} else {\n\t\t\tstruct pnfs_commit_bucket *buckets;\n\n\t\t\tbuckets = cinfo->ds->buckets;\n\t\t\tnfs_init_commit(data,\n\t\t\t\t\t&buckets[data->ds_commit_index].committing,\n\t\t\t\t\tdata->lseg,\n\t\t\t\t\tcinfo);\n\t\t\tinitiate_commit(data, how);\n\t\t}\n\t}\nout:\n\tcinfo->ds->ncommitting = 0;\n\treturn PNFS_ATTEMPTED;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_generic_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\n\t\t\t     int how, struct nfs_commit_info *cinfo,\n\t\t\t     int (*initiate_commit)(struct nfs_commit_data *data,\n\t\t\t\t\t\t    int how))\n{\n\tstruct nfs_commit_data *data, *tmp;\n\tLIST_HEAD(list);\n\tunsigned int nreq = 0;\n\n\tif (!list_empty(mds_pages)) {\n\t\tdata = nfs_commitdata_alloc();\n\t\tif (data != NULL) {\n\t\t\tdata->lseg = NULL;\n\t\t\tlist_add(&data->pages, &list);\n\t\t\tnreq++;\n\t\t} else {\n\t\t\tnfs_retry_commit(mds_pages, NULL, cinfo, 0);\n\t\t\tpnfs_generic_retry_commit(cinfo, 0);\n\t\t\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tnreq += pnfs_generic_alloc_ds_commits(cinfo, &list);\n\n\tif (nreq == 0) {\n\t\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\t\tgoto out;\n\t}\n\n\tatomic_add(nreq, &cinfo->mds->rpcs_out);\n\n\tlist_for_each_entry_safe(data, tmp, &list, pages) {\n\t\tlist_del_init(&data->pages);\n\t\tif (!data->lseg) {\n\t\t\tnfs_init_commit(data, mds_pages, NULL, cinfo);\n\t\t\tnfs_initiate_commit(NFS_CLIENT(inode), data,\n\t\t\t\t\t    NFS_PROTO(data->inode),\n\t\t\t\t\t    data->mds_ops, how, 0);\n\t\t} else {\n\t\t\tstruct pnfs_commit_bucket *buckets;\n\n\t\t\tbuckets = cinfo->ds->buckets;\n\t\t\tnfs_init_commit(data,\n\t\t\t\t\t&buckets[data->ds_commit_index].committing,\n\t\t\t\t\tdata->lseg,\n\t\t\t\t\tcinfo);\n\t\t\tinitiate_commit(data, how);\n\t\t}\n\t}\nout:\n\tcinfo->ds->ncommitting = 0;\n\treturn PNFS_ATTEMPTED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\nfilelayout_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\n\t\t\t   int how, struct nfs_commit_info *cinfo)\n{\n\treturn pnfs_generic_commit_pagelist(inode, mds_pages, how, cinfo,\n\t\t\t\t\t    filelayout_initiate_commit);\n}"
  },
  {
    "function_name": "filelayout_search_commit_reqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "1045-1066",
    "snippet": "static struct nfs_page *\nfilelayout_search_commit_reqs(struct nfs_commit_info *cinfo, struct page *page)\n{\n\tstruct nfs_page *freq, *t;\n\tstruct pnfs_commit_bucket *b;\n\tint i;\n\n\t/* Linearly search the commit lists for each bucket until a matching\n\t * request is found */\n\tfor (i = 0, b = cinfo->ds->buckets; i < cinfo->ds->nbuckets; i++, b++) {\n\t\tlist_for_each_entry_safe(freq, t, &b->written, wb_list) {\n\t\t\tif (freq->wb_page == page)\n\t\t\t\treturn freq->wb_head;\n\t\t}\n\t\tlist_for_each_entry_safe(freq, t, &b->committing, wb_list) {\n\t\t\tif (freq->wb_page == page)\n\t\t\t\treturn freq->wb_head;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "freq",
            "t",
            "&b->committing",
            "wb_list"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "freq",
            "t",
            "&b->written",
            "wb_list"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs_page *\nfilelayout_search_commit_reqs(struct nfs_commit_info *cinfo, struct page *page)\n{\n\tstruct nfs_page *freq, *t;\n\tstruct pnfs_commit_bucket *b;\n\tint i;\n\n\t/* Linearly search the commit lists for each bucket until a matching\n\t * request is found */\n\tfor (i = 0, b = cinfo->ds->buckets; i < cinfo->ds->nbuckets; i++, b++) {\n\t\tlist_for_each_entry_safe(freq, t, &b->written, wb_list) {\n\t\t\tif (freq->wb_page == page)\n\t\t\t\treturn freq->wb_head;\n\t\t}\n\t\tlist_for_each_entry_safe(freq, t, &b->committing, wb_list) {\n\t\t\tif (freq->wb_page == page)\n\t\t\t\treturn freq->wb_head;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "filelayout_initiate_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "1004-1036",
    "snippet": "static int filelayout_initiate_commit(struct nfs_commit_data *data, int how)\n{\n\tstruct pnfs_layout_segment *lseg = data->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tu32 idx;\n\tstruct nfs_fh *fh;\n\n\tidx = calc_ds_index_from_commit(lseg, data->ds_commit_index);\n\tds = nfs4_fl_prepare_ds(lseg, idx);\n\tif (!ds)\n\t\tgoto out_err;\n\n\tds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, data->inode);\n\tif (IS_ERR(ds_clnt))\n\t\tgoto out_err;\n\n\tdprintk(\"%s ino %lu, how %d cl_count %d\\n\", __func__,\n\t\tdata->inode->i_ino, how, atomic_read(&ds->ds_clp->cl_count));\n\tdata->commit_done_cb = filelayout_commit_done_cb;\n\tatomic_inc(&ds->ds_clp->cl_count);\n\tdata->ds_clp = ds->ds_clp;\n\tfh = select_ds_fh_from_commit(lseg, data->ds_commit_index);\n\tif (fh)\n\t\tdata->args.fh = fh;\n\treturn nfs_initiate_commit(ds_clnt, data, NFS_PROTO(data->inode),\n\t\t\t\t   &filelayout_commit_call_ops, how,\n\t\t\t\t   RPC_TASK_SOFTCONN);\nout_err:\n\tpnfs_generic_prepare_to_resend_writes(data);\n\tpnfs_generic_commit_release(data);\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_call_ops filelayout_commit_call_ops = {\n\t.rpc_call_prepare = filelayout_commit_prepare,\n\t.rpc_call_done = pnfs_generic_write_commit_done,\n\t.rpc_count_stats = filelayout_commit_count_stats,\n\t.rpc_release = pnfs_generic_commit_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_generic_commit_release",
          "args": [
            "data"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_commit_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "51-59",
          "snippet": "void pnfs_generic_commit_release(void *calldata)\n{\n\tstruct nfs_commit_data *data = calldata;\n\n\tdata->completion_ops->completion(data);\n\tpnfs_put_lseg(data->lseg);\n\tnfs_put_client(data->ds_clp);\n\tnfs_commitdata_release(data);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_generic_commit_release(void *calldata)\n{\n\tstruct nfs_commit_data *data = calldata;\n\n\tdata->completion_ops->completion(data);\n\tpnfs_put_lseg(data->lseg);\n\tnfs_put_client(data->ds_clp);\n\tnfs_commitdata_release(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_generic_prepare_to_resend_writes",
          "args": [
            "data"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_prepare_to_resend_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "31-39",
          "snippet": "void pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data)\n{\n\tstruct nfs_page *first = nfs_list_entry(data->pages.next);\n\n\tdata->task.tk_status = 0;\n\tmemcpy(&data->verf.verifier, &first->wb_verf,\n\t       sizeof(data->verf.verifier));\n\tdata->verf.verifier.data[0]++; /* ensure verifier mismatch */\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data)\n{\n\tstruct nfs_page *first = nfs_list_entry(data->pages.next);\n\n\tdata->task.tk_status = 0;\n\tmemcpy(&data->verf.verifier, &first->wb_verf,\n\t       sizeof(data->verf.verifier));\n\tdata->verf.verifier.data[0]++; /* ensure verifier mismatch */\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_initiate_commit",
          "args": [
            "ds_clnt",
            "data",
            "NFS_PROTO(data->inode)",
            "&filelayout_commit_call_ops",
            "how",
            "RPC_TASK_SOFTCONN"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_initiate_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1533-1570",
          "snippet": "int nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct nfs_rpc_ops *nfs_ops,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\t/* Set up the initial task struct.  */\n\tnfs_ops->commit_setup(data, &msg);\n\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\n\tnfs4_state_protect(NFS_SERVER(data->inode)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_COMMIT, &task_setup_data.rpc_client, &msg);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct nfs_rpc_ops *nfs_ops,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\t/* Set up the initial task struct.  */\n\tnfs_ops->commit_setup(data, &msg);\n\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\n\tnfs4_state_protect(NFS_SERVER(data->inode)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_COMMIT, &task_setup_data.rpc_client, &msg);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "data->inode"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_ds_fh_from_commit",
          "args": [
            "lseg",
            "data->ds_commit_index"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "select_ds_fh_from_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "989-1002",
          "snippet": "static struct nfs_fh *\nselect_ds_fh_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tif (flseg->stripe_type == STRIPE_SPARSE) {\n\t\tif (flseg->num_fh == 1)\n\t\t\ti = 0;\n\t\telse if (flseg->num_fh == 0)\n\t\t\t/* Use the MDS OPEN fh set in nfs_read_rpcsetup */\n\t\t\treturn NULL;\n\t}\n\treturn flseg->fh_array[i];\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs_fh *\nselect_ds_fh_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tif (flseg->stripe_type == STRIPE_SPARSE) {\n\t\tif (flseg->num_fh == 1)\n\t\t\ti = 0;\n\t\telse if (flseg->num_fh == 0)\n\t\t\t/* Use the MDS OPEN fh set in nfs_read_rpcsetup */\n\t\t\treturn NULL;\n\t}\n\treturn flseg->fh_array[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ds->ds_clp->cl_count"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s ino %lu, how %d cl_count %d\\n\"",
            "__func__",
            "data->inode->i_ino",
            "how",
            "atomic_read(&ds->ds_clp->cl_count)"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ds->ds_clp->cl_count"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ds_clnt"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_find_or_create_ds_client",
          "args": [
            "ds->ds_clp",
            "data->inode"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_find_or_create_ds_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4client.c",
          "lines": "124-141",
          "snippet": "struct rpc_clnt *\nnfs4_find_or_create_ds_client(struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ds_server *dss, *new;\n\trpc_authflavor_t flavor = NFS_SERVER(inode)->client->cl_auth->au_flavor;\n\n\tdss = nfs4_find_ds_client(ds_clp, flavor);\n\tif (dss != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_ds_server(ds_clp, flavor);\n\tif (IS_ERR(new))\n\t\treturn ERR_CAST(new);\n\tdss = nfs4_add_ds_client(ds_clp, flavor, new);\n\tif (dss != new)\n\t\tnfs4_free_ds_server(new);\nout:\n\treturn dss->rpc_clnt;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"internal.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/auth.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"internal.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n\nstruct rpc_clnt *\nnfs4_find_or_create_ds_client(struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ds_server *dss, *new;\n\trpc_authflavor_t flavor = NFS_SERVER(inode)->client->cl_auth->au_flavor;\n\n\tdss = nfs4_find_ds_client(ds_clp, flavor);\n\tif (dss != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_ds_server(ds_clp, flavor);\n\tif (IS_ERR(new))\n\t\treturn ERR_CAST(new);\n\tdss = nfs4_add_ds_client(ds_clp, flavor, new);\n\tif (dss != new)\n\t\tnfs4_free_ds_server(new);\nout:\n\treturn dss->rpc_clnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_fl_prepare_ds",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_prepare_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "261-290",
          "snippet": "struct nfs4_pnfs_ds *\nnfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\tstruct nfs4_file_layout_dsaddr *dsaddr = FILELAYOUT_LSEG(lseg)->dsaddr;\n\tstruct nfs4_pnfs_ds *ds = dsaddr->ds_list[ds_idx];\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs4_pnfs_ds *ret = ds;\n\tstruct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);\n\n\tif (ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\tgoto out;\n\t}\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out_test_devid;\n\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans, 4,\n\t\t\t     s->nfs_client->cl_minorversion,\n\t\t\t     s->nfs_client->cl_rpcclient->cl_auth->au_flavor);\n\nout_test_devid:\n\tif (filelayout_test_devid_unavailable(devid))\n\t\tret = NULL;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;",
            "static unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;\nstatic unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;\n\nstruct nfs4_pnfs_ds *\nnfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\tstruct nfs4_file_layout_dsaddr *dsaddr = FILELAYOUT_LSEG(lseg)->dsaddr;\n\tstruct nfs4_pnfs_ds *ds = dsaddr->ds_list[ds_idx];\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs4_pnfs_ds *ret = ds;\n\tstruct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);\n\n\tif (ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\tgoto out;\n\t}\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out_test_devid;\n\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans, 4,\n\t\t\t     s->nfs_client->cl_minorversion,\n\t\t\t     s->nfs_client->cl_rpcclient->cl_auth->au_flavor);\n\nout_test_devid:\n\tif (filelayout_test_devid_unavailable(devid))\n\t\tret = NULL;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_ds_index_from_commit",
          "args": [
            "lseg",
            "data->ds_commit_index"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "calc_ds_index_from_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "979-987",
          "snippet": "static u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tif (flseg->stripe_type == STRIPE_SPARSE)\n\t\treturn i;\n\telse\n\t\treturn nfs4_fl_calc_ds_index(lseg, i);\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tif (flseg->stripe_type == STRIPE_SPARSE)\n\t\treturn i;\n\telse\n\t\treturn nfs4_fl_calc_ds_index(lseg, i);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic const struct rpc_call_ops filelayout_commit_call_ops = {\n\t.rpc_call_prepare = filelayout_commit_prepare,\n\t.rpc_call_done = pnfs_generic_write_commit_done,\n\t.rpc_count_stats = filelayout_commit_count_stats,\n\t.rpc_release = pnfs_generic_commit_release,\n};\n\nstatic int filelayout_initiate_commit(struct nfs_commit_data *data, int how)\n{\n\tstruct pnfs_layout_segment *lseg = data->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tu32 idx;\n\tstruct nfs_fh *fh;\n\n\tidx = calc_ds_index_from_commit(lseg, data->ds_commit_index);\n\tds = nfs4_fl_prepare_ds(lseg, idx);\n\tif (!ds)\n\t\tgoto out_err;\n\n\tds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, data->inode);\n\tif (IS_ERR(ds_clnt))\n\t\tgoto out_err;\n\n\tdprintk(\"%s ino %lu, how %d cl_count %d\\n\", __func__,\n\t\tdata->inode->i_ino, how, atomic_read(&ds->ds_clp->cl_count));\n\tdata->commit_done_cb = filelayout_commit_done_cb;\n\tatomic_inc(&ds->ds_clp->cl_count);\n\tdata->ds_clp = ds->ds_clp;\n\tfh = select_ds_fh_from_commit(lseg, data->ds_commit_index);\n\tif (fh)\n\t\tdata->args.fh = fh;\n\treturn nfs_initiate_commit(ds_clnt, data, NFS_PROTO(data->inode),\n\t\t\t\t   &filelayout_commit_call_ops, how,\n\t\t\t\t   RPC_TASK_SOFTCONN);\nout_err:\n\tpnfs_generic_prepare_to_resend_writes(data);\n\tpnfs_generic_commit_release(data);\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "select_ds_fh_from_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "989-1002",
    "snippet": "static struct nfs_fh *\nselect_ds_fh_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tif (flseg->stripe_type == STRIPE_SPARSE) {\n\t\tif (flseg->num_fh == 1)\n\t\t\ti = 0;\n\t\telse if (flseg->num_fh == 0)\n\t\t\t/* Use the MDS OPEN fh set in nfs_read_rpcsetup */\n\t\t\treturn NULL;\n\t}\n\treturn flseg->fh_array[i];\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FILELAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "80-86",
          "snippet": "static inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs_fh *\nselect_ds_fh_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tif (flseg->stripe_type == STRIPE_SPARSE) {\n\t\tif (flseg->num_fh == 1)\n\t\t\ti = 0;\n\t\telse if (flseg->num_fh == 0)\n\t\t\t/* Use the MDS OPEN fh set in nfs_read_rpcsetup */\n\t\t\treturn NULL;\n\t}\n\treturn flseg->fh_array[i];\n}"
  },
  {
    "function_name": "calc_ds_index_from_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "979-987",
    "snippet": "static u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tif (flseg->stripe_type == STRIPE_SPARSE)\n\t\treturn i;\n\telse\n\t\treturn nfs4_fl_calc_ds_index(lseg, i);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_fl_calc_ds_index",
          "args": [
            "lseg",
            "i"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_calc_ds_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "235-239",
          "snippet": "u32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nu32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "80-86",
          "snippet": "static inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tif (flseg->stripe_type == STRIPE_SPARSE)\n\t\treturn i;\n\telse\n\t\treturn nfs4_fl_calc_ds_index(lseg, i);\n}"
  },
  {
    "function_name": "filelayout_mark_request_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "954-977",
    "snippet": "static void\nfilelayout_mark_request_commit(struct nfs_page *req,\n\t\t\t       struct pnfs_layout_segment *lseg,\n\t\t\t       struct nfs_commit_info *cinfo,\n\t\t\t       u32 ds_commit_idx)\n\n{\n\tstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\n\tu32 i, j;\n\n\tif (fl->commit_through_mds) {\n\t\tnfs_request_add_commit_list(req, &cinfo->mds->list, cinfo);\n\t} else {\n\t\t/* Note that we are calling nfs4_fl_calc_j_index on each page\n\t\t * that ends up being committed to a data server.  An attractive\n\t\t * alternative is to add a field to nfs_write_data and nfs_page\n\t\t * to store the value calculated in filelayout_write_pagelist\n\t\t * and just use that here.\n\t\t */\n\t\tj = nfs4_fl_calc_j_index(lseg, req_offset(req));\n\t\ti = select_bucket_index(fl, j);\n\t\tpnfs_layout_mark_request_commit(req, lseg, cinfo, i);\n\t}\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_layout_mark_request_commit",
          "args": [
            "req",
            "lseg",
            "cinfo",
            "i"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_mark_request_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "842-869",
          "snippet": "void\npnfs_layout_mark_request_commit(struct nfs_page *req,\n\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\tstruct nfs_commit_info *cinfo,\n\t\t\t\tu32 ds_commit_idx)\n{\n\tstruct list_head *list;\n\tstruct pnfs_commit_bucket *buckets;\n\n\tspin_lock(cinfo->lock);\n\tbuckets = cinfo->ds->buckets;\n\tlist = &buckets[ds_commit_idx].written;\n\tif (list_empty(list)) {\n\t\t/* Non-empty buckets hold a reference on the lseg.  That ref\n\t\t * is normally transferred to the COMMIT call and released\n\t\t * there.  It could also be released if the last req is pulled\n\t\t * off due to a rewrite, in which case it will be done in\n\t\t * pnfs_common_clear_request_commit\n\t\t */\n\t\tWARN_ON_ONCE(buckets[ds_commit_idx].wlseg != NULL);\n\t\tbuckets[ds_commit_idx].wlseg = pnfs_get_lseg(lseg);\n\t}\n\tset_bit(PG_COMMIT_TO_DS, &req->wb_flags);\n\tcinfo->ds->nwritten++;\n\tspin_unlock(cinfo->lock);\n\n\tnfs_request_add_commit_list(req, list, cinfo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_layout_mark_request_commit(struct nfs_page *req,\n\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\tstruct nfs_commit_info *cinfo,\n\t\t\t\tu32 ds_commit_idx)\n{\n\tstruct list_head *list;\n\tstruct pnfs_commit_bucket *buckets;\n\n\tspin_lock(cinfo->lock);\n\tbuckets = cinfo->ds->buckets;\n\tlist = &buckets[ds_commit_idx].written;\n\tif (list_empty(list)) {\n\t\t/* Non-empty buckets hold a reference on the lseg.  That ref\n\t\t * is normally transferred to the COMMIT call and released\n\t\t * there.  It could also be released if the last req is pulled\n\t\t * off due to a rewrite, in which case it will be done in\n\t\t * pnfs_common_clear_request_commit\n\t\t */\n\t\tWARN_ON_ONCE(buckets[ds_commit_idx].wlseg != NULL);\n\t\tbuckets[ds_commit_idx].wlseg = pnfs_get_lseg(lseg);\n\t}\n\tset_bit(PG_COMMIT_TO_DS, &req->wb_flags);\n\tcinfo->ds->nwritten++;\n\tspin_unlock(cinfo->lock);\n\n\tnfs_request_add_commit_list(req, list, cinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_bucket_index",
          "args": [
            "fl",
            "j"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "select_bucket_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "946-952",
          "snippet": "static u32 select_bucket_index(struct nfs4_filelayout_segment *fl, u32 j)\n{\n\tif (fl->stripe_type == STRIPE_SPARSE)\n\t\treturn nfs4_fl_calc_ds_index(&fl->generic_hdr, j);\n\telse\n\t\treturn j;\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic u32 select_bucket_index(struct nfs4_filelayout_segment *fl, u32 j)\n{\n\tif (fl->stripe_type == STRIPE_SPARSE)\n\t\treturn nfs4_fl_calc_ds_index(&fl->generic_hdr, j);\n\telse\n\t\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_fl_calc_j_index",
          "args": [
            "lseg",
            "req_offset(req)"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_calc_j_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "223-233",
          "snippet": "u32\nnfs4_fl_calc_j_index(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu64 tmp;\n\n\ttmp = offset - flseg->pattern_offset;\n\tdo_div(tmp, flseg->stripe_unit);\n\ttmp += flseg->first_stripe_index;\n\treturn do_div(tmp, flseg->dsaddr->stripe_count);\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nu32\nnfs4_fl_calc_j_index(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu64 tmp;\n\n\ttmp = offset - flseg->pattern_offset;\n\tdo_div(tmp, flseg->stripe_unit);\n\ttmp += flseg->first_stripe_index;\n\treturn do_div(tmp, flseg->dsaddr->stripe_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_request_add_commit_list",
          "args": [
            "req",
            "&cinfo->mds->list",
            "cinfo"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_request_add_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "783-794",
          "snippet": "void\nnfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,\n\t\t\t    struct nfs_commit_info *cinfo)\n{\n\tset_bit(PG_CLEAN, &(req)->wb_flags);\n\tspin_lock(cinfo->lock);\n\tnfs_list_add_request(req, dst);\n\tcinfo->mds->ncommit++;\n\tspin_unlock(cinfo->lock);\n\tif (!cinfo->dreq)\n\t\tnfs_mark_page_unstable(req->wb_page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid\nnfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,\n\t\t\t    struct nfs_commit_info *cinfo)\n{\n\tset_bit(PG_CLEAN, &(req)->wb_flags);\n\tspin_lock(cinfo->lock);\n\tnfs_list_add_request(req, dst);\n\tcinfo->mds->ncommit++;\n\tspin_unlock(cinfo->lock);\n\tif (!cinfo->dreq)\n\t\tnfs_mark_page_unstable(req->wb_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "80-86",
          "snippet": "static inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nfilelayout_mark_request_commit(struct nfs_page *req,\n\t\t\t       struct pnfs_layout_segment *lseg,\n\t\t\t       struct nfs_commit_info *cinfo,\n\t\t\t       u32 ds_commit_idx)\n\n{\n\tstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\n\tu32 i, j;\n\n\tif (fl->commit_through_mds) {\n\t\tnfs_request_add_commit_list(req, &cinfo->mds->list, cinfo);\n\t} else {\n\t\t/* Note that we are calling nfs4_fl_calc_j_index on each page\n\t\t * that ends up being committed to a data server.  An attractive\n\t\t * alternative is to add a field to nfs_write_data and nfs_page\n\t\t * to store the value calculated in filelayout_write_pagelist\n\t\t * and just use that here.\n\t\t */\n\t\tj = nfs4_fl_calc_j_index(lseg, req_offset(req));\n\t\ti = select_bucket_index(fl, j);\n\t\tpnfs_layout_mark_request_commit(req, lseg, cinfo, i);\n\t}\n}"
  },
  {
    "function_name": "select_bucket_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "946-952",
    "snippet": "static u32 select_bucket_index(struct nfs4_filelayout_segment *fl, u32 j)\n{\n\tif (fl->stripe_type == STRIPE_SPARSE)\n\t\treturn nfs4_fl_calc_ds_index(&fl->generic_hdr, j);\n\telse\n\t\treturn j;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_fl_calc_ds_index",
          "args": [
            "&fl->generic_hdr",
            "j"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_calc_ds_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "235-239",
          "snippet": "u32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nu32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic u32 select_bucket_index(struct nfs4_filelayout_segment *fl, u32 j)\n{\n\tif (fl->stripe_type == STRIPE_SPARSE)\n\t\treturn nfs4_fl_calc_ds_index(&fl->generic_hdr, j);\n\telse\n\t\treturn j;\n}"
  },
  {
    "function_name": "filelayout_pg_init_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "903-930",
    "snippet": "static void\nfilelayout_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t struct nfs_page *req)\n{\n\tstruct nfs_commit_info cinfo;\n\tint status;\n\n\tif (!pgio->pg_lseg)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t   0,\n\t\t\t\t\t   NFS4_MAX_UINT64,\n\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t   GFP_NOFS);\n\t/* If no lseg, fall back to write through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tgoto out_mds;\n\tnfs_init_cinfo(&cinfo, pgio->pg_inode, pgio->pg_dreq);\n\tstatus = filelayout_alloc_commit_info(pgio->pg_lseg, &cinfo, GFP_NOFS);\n\tif (status < 0) {\n\t\tpnfs_put_lseg(pgio->pg_lseg);\n\t\tpgio->pg_lseg = NULL;\n\t\tgoto out_mds;\n\t}\n\treturn;\nout_mds:\n\tnfs_pageio_reset_write_mds(pgio);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_reset_write_mds",
          "args": [
            "pgio"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_reset_write_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1329-1339",
          "snippet": "void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_put_lseg",
          "args": [
            "pgio->pg_lseg"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "545-547",
          "snippet": "static inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "filelayout_alloc_commit_info",
          "args": [
            "pgio->pg_lseg",
            "&cinfo",
            "GFP_NOFS"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_alloc_commit_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "766-821",
          "snippet": "static int\nfilelayout_alloc_commit_info(struct pnfs_layout_segment *lseg,\n\t\t\t     struct nfs_commit_info *cinfo,\n\t\t\t     gfp_t gfp_flags)\n{\n\tstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\n\tstruct pnfs_commit_bucket *buckets;\n\tint size, i;\n\n\tif (fl->commit_through_mds)\n\t\treturn 0;\n\n\tsize = (fl->stripe_type == STRIPE_SPARSE) ?\n\t\tfl->dsaddr->ds_num : fl->dsaddr->stripe_count;\n\n\tif (cinfo->ds->nbuckets >= size) {\n\t\t/* This assumes there is only one IOMODE_RW lseg.  What\n\t\t * we really want to do is have a layout_hdr level\n\t\t * dictionary of <multipath_list4, fh> keys, each\n\t\t * associated with a struct list_head, populated by calls\n\t\t * to filelayout_write_pagelist().\n\t\t * */\n\t\treturn 0;\n\t}\n\n\tbuckets = kcalloc(size, sizeof(struct pnfs_commit_bucket),\n\t\t\t  gfp_flags);\n\tif (!buckets)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < size; i++) {\n\t\tINIT_LIST_HEAD(&buckets[i].written);\n\t\tINIT_LIST_HEAD(&buckets[i].committing);\n\t\t/* mark direct verifier as unset */\n\t\tbuckets[i].direct_verf.committed = NFS_INVALID_STABLE_HOW;\n\t}\n\n\tspin_lock(cinfo->lock);\n\tif (cinfo->ds->nbuckets >= size)\n\t\tgoto out;\n\tfor (i = 0; i < cinfo->ds->nbuckets; i++) {\n\t\tlist_splice(&cinfo->ds->buckets[i].written,\n\t\t\t    &buckets[i].written);\n\t\tlist_splice(&cinfo->ds->buckets[i].committing,\n\t\t\t    &buckets[i].committing);\n\t\tbuckets[i].direct_verf.committed =\n\t\t\tcinfo->ds->buckets[i].direct_verf.committed;\n\t\tbuckets[i].wlseg = cinfo->ds->buckets[i].wlseg;\n\t\tbuckets[i].clseg = cinfo->ds->buckets[i].clseg;\n\t}\n\tswap(cinfo->ds->buckets, buckets);\n\tcinfo->ds->nbuckets = size;\nout:\n\tspin_unlock(cinfo->lock);\n\tkfree(buckets);\n\treturn 0;\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\nfilelayout_alloc_commit_info(struct pnfs_layout_segment *lseg,\n\t\t\t     struct nfs_commit_info *cinfo,\n\t\t\t     gfp_t gfp_flags)\n{\n\tstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\n\tstruct pnfs_commit_bucket *buckets;\n\tint size, i;\n\n\tif (fl->commit_through_mds)\n\t\treturn 0;\n\n\tsize = (fl->stripe_type == STRIPE_SPARSE) ?\n\t\tfl->dsaddr->ds_num : fl->dsaddr->stripe_count;\n\n\tif (cinfo->ds->nbuckets >= size) {\n\t\t/* This assumes there is only one IOMODE_RW lseg.  What\n\t\t * we really want to do is have a layout_hdr level\n\t\t * dictionary of <multipath_list4, fh> keys, each\n\t\t * associated with a struct list_head, populated by calls\n\t\t * to filelayout_write_pagelist().\n\t\t * */\n\t\treturn 0;\n\t}\n\n\tbuckets = kcalloc(size, sizeof(struct pnfs_commit_bucket),\n\t\t\t  gfp_flags);\n\tif (!buckets)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < size; i++) {\n\t\tINIT_LIST_HEAD(&buckets[i].written);\n\t\tINIT_LIST_HEAD(&buckets[i].committing);\n\t\t/* mark direct verifier as unset */\n\t\tbuckets[i].direct_verf.committed = NFS_INVALID_STABLE_HOW;\n\t}\n\n\tspin_lock(cinfo->lock);\n\tif (cinfo->ds->nbuckets >= size)\n\t\tgoto out;\n\tfor (i = 0; i < cinfo->ds->nbuckets; i++) {\n\t\tlist_splice(&cinfo->ds->buckets[i].written,\n\t\t\t    &buckets[i].written);\n\t\tlist_splice(&cinfo->ds->buckets[i].committing,\n\t\t\t    &buckets[i].committing);\n\t\tbuckets[i].direct_verf.committed =\n\t\t\tcinfo->ds->buckets[i].direct_verf.committed;\n\t\tbuckets[i].wlseg = cinfo->ds->buckets[i].wlseg;\n\t\tbuckets[i].clseg = cinfo->ds->buckets[i].clseg;\n\t}\n\tswap(cinfo->ds->buckets, buckets);\n\tcinfo->ds->nbuckets = size;\nout:\n\tspin_unlock(cinfo->lock);\n\tkfree(buckets);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_init_cinfo",
          "args": [
            "&cinfo",
            "pgio->pg_inode",
            "pgio->pg_dreq"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_init_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "829-837",
          "snippet": "void nfs_init_cinfo(struct nfs_commit_info *cinfo,\n\t\t    struct inode *inode,\n\t\t    struct nfs_direct_req *dreq)\n{\n\tif (dreq)\n\t\tnfs_init_cinfo_from_dreq(cinfo, dreq);\n\telse\n\t\tnfs_init_cinfo_from_inode(cinfo, inode);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nvoid nfs_init_cinfo(struct nfs_commit_info *cinfo,\n\t\t    struct inode *inode,\n\t\t    struct nfs_direct_req *dreq)\n{\n\tif (dreq)\n\t\tnfs_init_cinfo_from_dreq(cinfo, dreq);\n\telse\n\t\tnfs_init_cinfo_from_inode(cinfo, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_update_layout",
          "args": [
            "pgio->pg_inode",
            "req->wb_context",
            "0",
            "NFS4_MAX_UINT64",
            "IOMODE_RW",
            "GFP_NOFS"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_update_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1445-1574",
          "snippet": "struct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nfilelayout_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t struct nfs_page *req)\n{\n\tstruct nfs_commit_info cinfo;\n\tint status;\n\n\tif (!pgio->pg_lseg)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t   0,\n\t\t\t\t\t   NFS4_MAX_UINT64,\n\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t   GFP_NOFS);\n\t/* If no lseg, fall back to write through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tgoto out_mds;\n\tnfs_init_cinfo(&cinfo, pgio->pg_inode, pgio->pg_dreq);\n\tstatus = filelayout_alloc_commit_info(pgio->pg_lseg, &cinfo, GFP_NOFS);\n\tif (status < 0) {\n\t\tpnfs_put_lseg(pgio->pg_lseg);\n\t\tpgio->pg_lseg = NULL;\n\t\tgoto out_mds;\n\t}\n\treturn;\nout_mds:\n\tnfs_pageio_reset_write_mds(pgio);\n}"
  },
  {
    "function_name": "filelayout_pg_init_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "887-901",
    "snippet": "static void\nfilelayout_pg_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\tstruct nfs_page *req)\n{\n\tif (!pgio->pg_lseg)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t   0,\n\t\t\t\t\t   NFS4_MAX_UINT64,\n\t\t\t\t\t   IOMODE_READ,\n\t\t\t\t\t   GFP_KERNEL);\n\t/* If no lseg, fall back to read through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_read_mds(pgio);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_reset_read_mds",
          "args": [
            "pgio"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_reset_read_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "71-82",
          "snippet": "void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\t/* read path should never have more than one mirror */\n\tWARN_ON_ONCE(pgio->pg_mirror_count != 1);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nvoid nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\t/* read path should never have more than one mirror */\n\tWARN_ON_ONCE(pgio->pg_mirror_count != 1);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_update_layout",
          "args": [
            "pgio->pg_inode",
            "req->wb_context",
            "0",
            "NFS4_MAX_UINT64",
            "IOMODE_READ",
            "GFP_KERNEL"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_update_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1445-1574",
          "snippet": "struct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nfilelayout_pg_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\tstruct nfs_page *req)\n{\n\tif (!pgio->pg_lseg)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t   0,\n\t\t\t\t\t   NFS4_MAX_UINT64,\n\t\t\t\t\t   IOMODE_READ,\n\t\t\t\t\t   GFP_KERNEL);\n\t/* If no lseg, fall back to read through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_read_mds(pgio);\n}"
  },
  {
    "function_name": "filelayout_pg_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "851-885",
    "snippet": "static size_t\nfilelayout_pg_test(struct nfs_pageio_descriptor *pgio, struct nfs_page *prev,\n\t\t   struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 p_stripe, r_stripe;\n\tu32 stripe_offset;\n\tu64 segment_offset = pgio->pg_lseg->pls_range.offset;\n\tu32 stripe_unit = FILELAYOUT_LSEG(pgio->pg_lseg)->stripe_unit;\n\n\t/* calls nfs_generic_pg_test */\n\tsize = pnfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/* see if req and prev are in the same stripe */\n\tif (prev) {\n\t\tp_stripe = (u64)req_offset(prev) - segment_offset;\n\t\tr_stripe = (u64)req_offset(req) - segment_offset;\n\t\tdo_div(p_stripe, stripe_unit);\n\t\tdo_div(r_stripe, stripe_unit);\n\n\t\tif (p_stripe != r_stripe)\n\t\t\treturn 0;\n\t}\n\n\t/* calculate remaining bytes in the current stripe */\n\tdiv_u64_rem((u64)req_offset(req) - segment_offset,\n\t\t\tstripe_unit,\n\t\t\t&stripe_offset);\n\tWARN_ON_ONCE(stripe_offset > stripe_unit);\n\tif (stripe_offset >= stripe_unit)\n\t\treturn 0;\n\treturn min(stripe_unit - (unsigned int)stripe_offset, size);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "stripe_unit - (unsigned int)stripe_offset",
            "size"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "stripe_offset > stripe_unit"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64_rem",
          "args": [
            "(u64)req_offset(req) - segment_offset",
            "stripe_unit",
            "&stripe_offset"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "r_stripe",
            "stripe_unit"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "p_stripe",
            "stripe_unit"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "prev"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_generic_pg_test",
          "args": [
            "pgio",
            "prev",
            "req"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_pg_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1766-1811",
          "snippet": "size_t\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t     struct nfs_page *prev, struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 seg_end, req_start, seg_left;\n\n\tsize = nfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/*\n\t * 'size' contains the number of bytes left in the current page (up\n\t * to the original size asked for in @req->wb_bytes).\n\t *\n\t * Calculate how many bytes are left in the layout segment\n\t * and if there are less bytes than 'size', return that instead.\n\t *\n\t * Please also note that 'end_offset' is actually the offset of the\n\t * first byte that lies outside the pnfs_layout_range. FIXME?\n\t *\n\t */\n\tif (pgio->pg_lseg) {\n\t\tseg_end = end_offset(pgio->pg_lseg->pls_range.offset,\n\t\t\t\t     pgio->pg_lseg->pls_range.length);\n\t\treq_start = req_offset(req);\n\t\tWARN_ON_ONCE(req_start >= seg_end);\n\t\t/* start of request is past the last byte of this segment */\n\t\tif (req_start >= seg_end) {\n\t\t\t/* reference the new lseg */\n\t\t\tif (pgio->pg_ops->pg_cleanup)\n\t\t\t\tpgio->pg_ops->pg_cleanup(pgio);\n\t\t\tif (pgio->pg_ops->pg_init)\n\t\t\t\tpgio->pg_ops->pg_init(pgio, req);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* adjust 'size' iff there are fewer bytes left in the\n\t\t * segment than what nfs_generic_pg_test returned */\n\t\tseg_left = seg_end - req_start;\n\t\tif (seg_left < size)\n\t\t\tsize = (unsigned int)seg_left;\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nsize_t\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t     struct nfs_page *prev, struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 seg_end, req_start, seg_left;\n\n\tsize = nfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/*\n\t * 'size' contains the number of bytes left in the current page (up\n\t * to the original size asked for in @req->wb_bytes).\n\t *\n\t * Calculate how many bytes are left in the layout segment\n\t * and if there are less bytes than 'size', return that instead.\n\t *\n\t * Please also note that 'end_offset' is actually the offset of the\n\t * first byte that lies outside the pnfs_layout_range. FIXME?\n\t *\n\t */\n\tif (pgio->pg_lseg) {\n\t\tseg_end = end_offset(pgio->pg_lseg->pls_range.offset,\n\t\t\t\t     pgio->pg_lseg->pls_range.length);\n\t\treq_start = req_offset(req);\n\t\tWARN_ON_ONCE(req_start >= seg_end);\n\t\t/* start of request is past the last byte of this segment */\n\t\tif (req_start >= seg_end) {\n\t\t\t/* reference the new lseg */\n\t\t\tif (pgio->pg_ops->pg_cleanup)\n\t\t\t\tpgio->pg_ops->pg_cleanup(pgio);\n\t\t\tif (pgio->pg_ops->pg_init)\n\t\t\t\tpgio->pg_ops->pg_init(pgio, req);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* adjust 'size' iff there are fewer bytes left in the\n\t\t * segment than what nfs_generic_pg_test returned */\n\t\tseg_left = seg_end - req_start;\n\t\tif (seg_left < size)\n\t\t\tsize = (unsigned int)seg_left;\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_LSEG",
          "args": [
            "pgio->pg_lseg"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "80-86",
          "snippet": "static inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic size_t\nfilelayout_pg_test(struct nfs_pageio_descriptor *pgio, struct nfs_page *prev,\n\t\t   struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 p_stripe, r_stripe;\n\tu32 stripe_offset;\n\tu64 segment_offset = pgio->pg_lseg->pls_range.offset;\n\tu32 stripe_unit = FILELAYOUT_LSEG(pgio->pg_lseg)->stripe_unit;\n\n\t/* calls nfs_generic_pg_test */\n\tsize = pnfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/* see if req and prev are in the same stripe */\n\tif (prev) {\n\t\tp_stripe = (u64)req_offset(prev) - segment_offset;\n\t\tr_stripe = (u64)req_offset(req) - segment_offset;\n\t\tdo_div(p_stripe, stripe_unit);\n\t\tdo_div(r_stripe, stripe_unit);\n\n\t\tif (p_stripe != r_stripe)\n\t\t\treturn 0;\n\t}\n\n\t/* calculate remaining bytes in the current stripe */\n\tdiv_u64_rem((u64)req_offset(req) - segment_offset,\n\t\t\tstripe_unit,\n\t\t\t&stripe_offset);\n\tWARN_ON_ONCE(stripe_offset > stripe_unit);\n\tif (stripe_offset >= stripe_unit)\n\t\treturn 0;\n\treturn min(stripe_unit - (unsigned int)stripe_offset, size);\n}"
  },
  {
    "function_name": "filelayout_alloc_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "823-843",
    "snippet": "static struct pnfs_layout_segment *\nfilelayout_alloc_lseg(struct pnfs_layout_hdr *layoutid,\n\t\t      struct nfs4_layoutget_res *lgr,\n\t\t      gfp_t gfp_flags)\n{\n\tstruct nfs4_filelayout_segment *fl;\n\tint rc;\n\tstruct nfs4_deviceid id;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tfl = kzalloc(sizeof(*fl), gfp_flags);\n\tif (!fl)\n\t\treturn NULL;\n\n\trc = filelayout_decode_layout(layoutid, fl, lgr, &id, gfp_flags);\n\tif (rc != 0 || filelayout_check_layout(layoutid, fl, lgr, &id, gfp_flags)) {\n\t\t_filelayout_free_lseg(fl);\n\t\treturn NULL;\n\t}\n\treturn &fl->generic_hdr;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_filelayout_free_lseg",
          "args": [
            "fl"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "_filelayout_free_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "643-648",
          "snippet": "static void\n_filelayout_free_lseg(struct nfs4_filelayout_segment *fl)\n{\n\tfilelayout_free_fh_array(fl);\n\tkfree(fl);\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\n_filelayout_free_lseg(struct nfs4_filelayout_segment *fl)\n{\n\tfilelayout_free_fh_array(fl);\n\tkfree(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filelayout_check_layout",
          "args": [
            "layoutid",
            "fl",
            "lgr",
            "&id",
            "gfp_flags"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_check_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "560-628",
          "snippet": "static int\nfilelayout_check_layout(struct pnfs_layout_hdr *lo,\n\t\t\tstruct nfs4_filelayout_segment *fl,\n\t\t\tstruct nfs4_layoutget_res *lgr,\n\t\t\tstruct nfs4_deviceid *id,\n\t\t\tgfp_t gfp_flags)\n{\n\tstruct nfs4_deviceid_node *d;\n\tstruct nfs4_file_layout_dsaddr *dsaddr;\n\tint status = -EINVAL;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\t/* FIXME: remove this check when layout segment support is added */\n\tif (lgr->range.offset != 0 ||\n\t    lgr->range.length != NFS4_MAX_UINT64) {\n\t\tdprintk(\"%s Only whole file layouts supported. Use MDS i/o\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tif (fl->pattern_offset > lgr->range.offset) {\n\t\tdprintk(\"%s pattern_offset %lld too large\\n\",\n\t\t\t\t__func__, fl->pattern_offset);\n\t\tgoto out;\n\t}\n\n\tif (!fl->stripe_unit) {\n\t\tdprintk(\"%s Invalid stripe unit (%u)\\n\",\n\t\t\t__func__, fl->stripe_unit);\n\t\tgoto out;\n\t}\n\n\t/* find and reference the deviceid */\n\td = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode), id,\n\t\t\tlo->plh_lc_cred, gfp_flags);\n\tif (d == NULL)\n\t\tgoto out;\n\n\tdsaddr = container_of(d, struct nfs4_file_layout_dsaddr, id_node);\n\t/* Found deviceid is unavailable */\n\tif (filelayout_test_devid_unavailable(&dsaddr->id_node))\n\t\tgoto out_put;\n\n\tfl->dsaddr = dsaddr;\n\n\tif (fl->first_stripe_index >= dsaddr->stripe_count) {\n\t\tdprintk(\"%s Bad first_stripe_index %u\\n\",\n\t\t\t\t__func__, fl->first_stripe_index);\n\t\tgoto out_put;\n\t}\n\n\tif ((fl->stripe_type == STRIPE_SPARSE &&\n\t    fl->num_fh > 1 && fl->num_fh != dsaddr->ds_num) ||\n\t    (fl->stripe_type == STRIPE_DENSE &&\n\t    fl->num_fh != dsaddr->stripe_count)) {\n\t\tdprintk(\"%s num_fh %u not valid for given packing\\n\",\n\t\t\t__func__, fl->num_fh);\n\t\tgoto out_put;\n\t}\n\n\tstatus = 0;\nout:\n\tdprintk(\"--> %s returns %d\\n\", __func__, status);\n\treturn status;\nout_put:\n\tnfs4_fl_put_deviceid(dsaddr);\n\tgoto out;\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\nfilelayout_check_layout(struct pnfs_layout_hdr *lo,\n\t\t\tstruct nfs4_filelayout_segment *fl,\n\t\t\tstruct nfs4_layoutget_res *lgr,\n\t\t\tstruct nfs4_deviceid *id,\n\t\t\tgfp_t gfp_flags)\n{\n\tstruct nfs4_deviceid_node *d;\n\tstruct nfs4_file_layout_dsaddr *dsaddr;\n\tint status = -EINVAL;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\t/* FIXME: remove this check when layout segment support is added */\n\tif (lgr->range.offset != 0 ||\n\t    lgr->range.length != NFS4_MAX_UINT64) {\n\t\tdprintk(\"%s Only whole file layouts supported. Use MDS i/o\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tif (fl->pattern_offset > lgr->range.offset) {\n\t\tdprintk(\"%s pattern_offset %lld too large\\n\",\n\t\t\t\t__func__, fl->pattern_offset);\n\t\tgoto out;\n\t}\n\n\tif (!fl->stripe_unit) {\n\t\tdprintk(\"%s Invalid stripe unit (%u)\\n\",\n\t\t\t__func__, fl->stripe_unit);\n\t\tgoto out;\n\t}\n\n\t/* find and reference the deviceid */\n\td = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode), id,\n\t\t\tlo->plh_lc_cred, gfp_flags);\n\tif (d == NULL)\n\t\tgoto out;\n\n\tdsaddr = container_of(d, struct nfs4_file_layout_dsaddr, id_node);\n\t/* Found deviceid is unavailable */\n\tif (filelayout_test_devid_unavailable(&dsaddr->id_node))\n\t\tgoto out_put;\n\n\tfl->dsaddr = dsaddr;\n\n\tif (fl->first_stripe_index >= dsaddr->stripe_count) {\n\t\tdprintk(\"%s Bad first_stripe_index %u\\n\",\n\t\t\t\t__func__, fl->first_stripe_index);\n\t\tgoto out_put;\n\t}\n\n\tif ((fl->stripe_type == STRIPE_SPARSE &&\n\t    fl->num_fh > 1 && fl->num_fh != dsaddr->ds_num) ||\n\t    (fl->stripe_type == STRIPE_DENSE &&\n\t    fl->num_fh != dsaddr->stripe_count)) {\n\t\tdprintk(\"%s num_fh %u not valid for given packing\\n\",\n\t\t\t__func__, fl->num_fh);\n\t\tgoto out_put;\n\t}\n\n\tstatus = 0;\nout:\n\tdprintk(\"--> %s returns %d\\n\", __func__, status);\n\treturn status;\nout_put:\n\tnfs4_fl_put_deviceid(dsaddr);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filelayout_decode_layout",
          "args": [
            "layoutid",
            "fl",
            "lgr",
            "&id",
            "gfp_flags"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_decode_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "650-745",
          "snippet": "static int\nfilelayout_decode_layout(struct pnfs_layout_hdr *flo,\n\t\t\t struct nfs4_filelayout_segment *fl,\n\t\t\t struct nfs4_layoutget_res *lgr,\n\t\t\t struct nfs4_deviceid *id,\n\t\t\t gfp_t gfp_flags)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\t__be32 *p;\n\tuint32_t nfl_util;\n\tint i;\n\n\tdprintk(\"%s: set_layout_map Begin\\n\", __func__);\n\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\txdr_init_decode_pages(&stream, &buf, lgr->layoutp->pages, lgr->layoutp->len);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* 20 = ufl_util (4), first_stripe_index (4), pattern_offset (8),\n\t * num_fh (4) */\n\tp = xdr_inline_decode(&stream, NFS4_DEVICEID4_SIZE + 20);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\n\tmemcpy(id, p, sizeof(*id));\n\tp += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\n\tnfs4_print_deviceid(id);\n\n\tnfl_util = be32_to_cpup(p++);\n\tif (nfl_util & NFL4_UFLG_COMMIT_THRU_MDS)\n\t\tfl->commit_through_mds = 1;\n\tif (nfl_util & NFL4_UFLG_DENSE)\n\t\tfl->stripe_type = STRIPE_DENSE;\n\telse\n\t\tfl->stripe_type = STRIPE_SPARSE;\n\tfl->stripe_unit = nfl_util & ~NFL4_UFLG_MASK;\n\n\tfl->first_stripe_index = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &fl->pattern_offset);\n\tfl->num_fh = be32_to_cpup(p++);\n\n\tdprintk(\"%s: nfl_util 0x%X num_fh %u fsi %u po %llu\\n\",\n\t\t__func__, nfl_util, fl->num_fh, fl->first_stripe_index,\n\t\tfl->pattern_offset);\n\n\t/* Note that a zero value for num_fh is legal for STRIPE_SPARSE.\n\t * Futher checking is done in filelayout_check_layout */\n\tif (fl->num_fh >\n\t    max(NFS4_PNFS_MAX_STRIPE_CNT, NFS4_PNFS_MAX_MULTI_CNT))\n\t\tgoto out_err;\n\n\tif (fl->num_fh > 0) {\n\t\tfl->fh_array = kcalloc(fl->num_fh, sizeof(fl->fh_array[0]),\n\t\t\t\t       gfp_flags);\n\t\tif (!fl->fh_array)\n\t\t\tgoto out_err;\n\t}\n\n\tfor (i = 0; i < fl->num_fh; i++) {\n\t\t/* Do we want to use a mempool here? */\n\t\tfl->fh_array[i] = kmalloc(sizeof(struct nfs_fh), gfp_flags);\n\t\tif (!fl->fh_array[i])\n\t\t\tgoto out_err_free;\n\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free;\n\t\tfl->fh_array[i]->size = be32_to_cpup(p++);\n\t\tif (sizeof(struct nfs_fh) < fl->fh_array[i]->size) {\n\t\t\tprintk(KERN_ERR \"NFS: Too big fh %d received %d\\n\",\n\t\t\t       i, fl->fh_array[i]->size);\n\t\t\tgoto out_err_free;\n\t\t}\n\n\t\tp = xdr_inline_decode(&stream, fl->fh_array[i]->size);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free;\n\t\tmemcpy(fl->fh_array[i]->data, p, fl->fh_array[i]->size);\n\t\tdprintk(\"DEBUG: %s: fh len %d\\n\", __func__,\n\t\t\tfl->fh_array[i]->size);\n\t}\n\n\t__free_page(scratch);\n\treturn 0;\n\nout_err_free:\n\tfilelayout_free_fh_array(fl);\nout_err:\n\t__free_page(scratch);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\nfilelayout_decode_layout(struct pnfs_layout_hdr *flo,\n\t\t\t struct nfs4_filelayout_segment *fl,\n\t\t\t struct nfs4_layoutget_res *lgr,\n\t\t\t struct nfs4_deviceid *id,\n\t\t\t gfp_t gfp_flags)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\t__be32 *p;\n\tuint32_t nfl_util;\n\tint i;\n\n\tdprintk(\"%s: set_layout_map Begin\\n\", __func__);\n\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\txdr_init_decode_pages(&stream, &buf, lgr->layoutp->pages, lgr->layoutp->len);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* 20 = ufl_util (4), first_stripe_index (4), pattern_offset (8),\n\t * num_fh (4) */\n\tp = xdr_inline_decode(&stream, NFS4_DEVICEID4_SIZE + 20);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\n\tmemcpy(id, p, sizeof(*id));\n\tp += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\n\tnfs4_print_deviceid(id);\n\n\tnfl_util = be32_to_cpup(p++);\n\tif (nfl_util & NFL4_UFLG_COMMIT_THRU_MDS)\n\t\tfl->commit_through_mds = 1;\n\tif (nfl_util & NFL4_UFLG_DENSE)\n\t\tfl->stripe_type = STRIPE_DENSE;\n\telse\n\t\tfl->stripe_type = STRIPE_SPARSE;\n\tfl->stripe_unit = nfl_util & ~NFL4_UFLG_MASK;\n\n\tfl->first_stripe_index = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &fl->pattern_offset);\n\tfl->num_fh = be32_to_cpup(p++);\n\n\tdprintk(\"%s: nfl_util 0x%X num_fh %u fsi %u po %llu\\n\",\n\t\t__func__, nfl_util, fl->num_fh, fl->first_stripe_index,\n\t\tfl->pattern_offset);\n\n\t/* Note that a zero value for num_fh is legal for STRIPE_SPARSE.\n\t * Futher checking is done in filelayout_check_layout */\n\tif (fl->num_fh >\n\t    max(NFS4_PNFS_MAX_STRIPE_CNT, NFS4_PNFS_MAX_MULTI_CNT))\n\t\tgoto out_err;\n\n\tif (fl->num_fh > 0) {\n\t\tfl->fh_array = kcalloc(fl->num_fh, sizeof(fl->fh_array[0]),\n\t\t\t\t       gfp_flags);\n\t\tif (!fl->fh_array)\n\t\t\tgoto out_err;\n\t}\n\n\tfor (i = 0; i < fl->num_fh; i++) {\n\t\t/* Do we want to use a mempool here? */\n\t\tfl->fh_array[i] = kmalloc(sizeof(struct nfs_fh), gfp_flags);\n\t\tif (!fl->fh_array[i])\n\t\t\tgoto out_err_free;\n\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free;\n\t\tfl->fh_array[i]->size = be32_to_cpup(p++);\n\t\tif (sizeof(struct nfs_fh) < fl->fh_array[i]->size) {\n\t\t\tprintk(KERN_ERR \"NFS: Too big fh %d received %d\\n\",\n\t\t\t       i, fl->fh_array[i]->size);\n\t\t\tgoto out_err_free;\n\t\t}\n\n\t\tp = xdr_inline_decode(&stream, fl->fh_array[i]->size);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free;\n\t\tmemcpy(fl->fh_array[i]->data, p, fl->fh_array[i]->size);\n\t\tdprintk(\"DEBUG: %s: fh len %d\\n\", __func__,\n\t\t\tfl->fh_array[i]->size);\n\t}\n\n\t__free_page(scratch);\n\treturn 0;\n\nout_err_free:\n\tfilelayout_free_fh_array(fl);\nout_err:\n\t__free_page(scratch);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*fl)",
            "gfp_flags"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s\\n\"",
            "__func__"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_segment *\nfilelayout_alloc_lseg(struct pnfs_layout_hdr *layoutid,\n\t\t      struct nfs4_layoutget_res *lgr,\n\t\t      gfp_t gfp_flags)\n{\n\tstruct nfs4_filelayout_segment *fl;\n\tint rc;\n\tstruct nfs4_deviceid id;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tfl = kzalloc(sizeof(*fl), gfp_flags);\n\tif (!fl)\n\t\treturn NULL;\n\n\trc = filelayout_decode_layout(layoutid, fl, lgr, &id, gfp_flags);\n\tif (rc != 0 || filelayout_check_layout(layoutid, fl, lgr, &id, gfp_flags)) {\n\t\t_filelayout_free_lseg(fl);\n\t\treturn NULL;\n\t}\n\treturn &fl->generic_hdr;\n}"
  },
  {
    "function_name": "filelayout_alloc_commit_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "766-821",
    "snippet": "static int\nfilelayout_alloc_commit_info(struct pnfs_layout_segment *lseg,\n\t\t\t     struct nfs_commit_info *cinfo,\n\t\t\t     gfp_t gfp_flags)\n{\n\tstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\n\tstruct pnfs_commit_bucket *buckets;\n\tint size, i;\n\n\tif (fl->commit_through_mds)\n\t\treturn 0;\n\n\tsize = (fl->stripe_type == STRIPE_SPARSE) ?\n\t\tfl->dsaddr->ds_num : fl->dsaddr->stripe_count;\n\n\tif (cinfo->ds->nbuckets >= size) {\n\t\t/* This assumes there is only one IOMODE_RW lseg.  What\n\t\t * we really want to do is have a layout_hdr level\n\t\t * dictionary of <multipath_list4, fh> keys, each\n\t\t * associated with a struct list_head, populated by calls\n\t\t * to filelayout_write_pagelist().\n\t\t * */\n\t\treturn 0;\n\t}\n\n\tbuckets = kcalloc(size, sizeof(struct pnfs_commit_bucket),\n\t\t\t  gfp_flags);\n\tif (!buckets)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < size; i++) {\n\t\tINIT_LIST_HEAD(&buckets[i].written);\n\t\tINIT_LIST_HEAD(&buckets[i].committing);\n\t\t/* mark direct verifier as unset */\n\t\tbuckets[i].direct_verf.committed = NFS_INVALID_STABLE_HOW;\n\t}\n\n\tspin_lock(cinfo->lock);\n\tif (cinfo->ds->nbuckets >= size)\n\t\tgoto out;\n\tfor (i = 0; i < cinfo->ds->nbuckets; i++) {\n\t\tlist_splice(&cinfo->ds->buckets[i].written,\n\t\t\t    &buckets[i].written);\n\t\tlist_splice(&cinfo->ds->buckets[i].committing,\n\t\t\t    &buckets[i].committing);\n\t\tbuckets[i].direct_verf.committed =\n\t\t\tcinfo->ds->buckets[i].direct_verf.committed;\n\t\tbuckets[i].wlseg = cinfo->ds->buckets[i].wlseg;\n\t\tbuckets[i].clseg = cinfo->ds->buckets[i].clseg;\n\t}\n\tswap(cinfo->ds->buckets, buckets);\n\tcinfo->ds->nbuckets = size;\nout:\n\tspin_unlock(cinfo->lock);\n\tkfree(buckets);\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buckets"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "cinfo->lock"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "cinfo->ds->buckets",
            "buckets"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2438-2481",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&cinfo->ds->buckets[i].committing",
            "&buckets[i].committing"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&cinfo->ds->buckets[i].written",
            "&buckets[i].written"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "cinfo->lock"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&buckets[i].committing"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&buckets[i].written"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "size",
            "sizeof(struct pnfs_commit_bucket)",
            "gfp_flags"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "80-86",
          "snippet": "static inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\nfilelayout_alloc_commit_info(struct pnfs_layout_segment *lseg,\n\t\t\t     struct nfs_commit_info *cinfo,\n\t\t\t     gfp_t gfp_flags)\n{\n\tstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\n\tstruct pnfs_commit_bucket *buckets;\n\tint size, i;\n\n\tif (fl->commit_through_mds)\n\t\treturn 0;\n\n\tsize = (fl->stripe_type == STRIPE_SPARSE) ?\n\t\tfl->dsaddr->ds_num : fl->dsaddr->stripe_count;\n\n\tif (cinfo->ds->nbuckets >= size) {\n\t\t/* This assumes there is only one IOMODE_RW lseg.  What\n\t\t * we really want to do is have a layout_hdr level\n\t\t * dictionary of <multipath_list4, fh> keys, each\n\t\t * associated with a struct list_head, populated by calls\n\t\t * to filelayout_write_pagelist().\n\t\t * */\n\t\treturn 0;\n\t}\n\n\tbuckets = kcalloc(size, sizeof(struct pnfs_commit_bucket),\n\t\t\t  gfp_flags);\n\tif (!buckets)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < size; i++) {\n\t\tINIT_LIST_HEAD(&buckets[i].written);\n\t\tINIT_LIST_HEAD(&buckets[i].committing);\n\t\t/* mark direct verifier as unset */\n\t\tbuckets[i].direct_verf.committed = NFS_INVALID_STABLE_HOW;\n\t}\n\n\tspin_lock(cinfo->lock);\n\tif (cinfo->ds->nbuckets >= size)\n\t\tgoto out;\n\tfor (i = 0; i < cinfo->ds->nbuckets; i++) {\n\t\tlist_splice(&cinfo->ds->buckets[i].written,\n\t\t\t    &buckets[i].written);\n\t\tlist_splice(&cinfo->ds->buckets[i].committing,\n\t\t\t    &buckets[i].committing);\n\t\tbuckets[i].direct_verf.committed =\n\t\t\tcinfo->ds->buckets[i].direct_verf.committed;\n\t\tbuckets[i].wlseg = cinfo->ds->buckets[i].wlseg;\n\t\tbuckets[i].clseg = cinfo->ds->buckets[i].clseg;\n\t}\n\tswap(cinfo->ds->buckets, buckets);\n\tcinfo->ds->nbuckets = size;\nout:\n\tspin_unlock(cinfo->lock);\n\tkfree(buckets);\n\treturn 0;\n}"
  },
  {
    "function_name": "filelayout_free_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "747-764",
    "snippet": "static void\nfilelayout_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tnfs4_fl_put_deviceid(fl->dsaddr);\n\t/* This assumes a single RW lseg */\n\tif (lseg->pls_range.iomode == IOMODE_RW) {\n\t\tstruct nfs4_filelayout *flo;\n\n\t\tflo = FILELAYOUT_FROM_HDR(lseg->pls_layout);\n\t\tflo->commit_info.nbuckets = 0;\n\t\tkfree(flo->commit_info.buckets);\n\t\tflo->commit_info.buckets = NULL;\n\t}\n\t_filelayout_free_lseg(fl);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_filelayout_free_lseg",
          "args": [
            "fl"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "_filelayout_free_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "643-648",
          "snippet": "static void\n_filelayout_free_lseg(struct nfs4_filelayout_segment *fl)\n{\n\tfilelayout_free_fh_array(fl);\n\tkfree(fl);\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\n_filelayout_free_lseg(struct nfs4_filelayout_segment *fl)\n{\n\tfilelayout_free_fh_array(fl);\n\tkfree(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "flo->commit_info.buckets"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_FROM_HDR",
          "args": [
            "lseg->pls_layout"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "74-78",
          "snippet": "static inline struct nfs4_filelayout *\nFILELAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_filelayout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout *\nFILELAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_filelayout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_fl_put_deviceid",
          "args": [
            "fl->dsaddr"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_put_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "213-217",
          "snippet": "void\nnfs4_fl_put_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\n{\n\tnfs4_put_deviceid_node(&dsaddr->id_node);\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nvoid\nnfs4_fl_put_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\n{\n\tnfs4_put_deviceid_node(&dsaddr->id_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s\\n\"",
            "__func__"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "80-86",
          "snippet": "static inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nfilelayout_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tnfs4_fl_put_deviceid(fl->dsaddr);\n\t/* This assumes a single RW lseg */\n\tif (lseg->pls_range.iomode == IOMODE_RW) {\n\t\tstruct nfs4_filelayout *flo;\n\n\t\tflo = FILELAYOUT_FROM_HDR(lseg->pls_layout);\n\t\tflo->commit_info.nbuckets = 0;\n\t\tkfree(flo->commit_info.buckets);\n\t\tflo->commit_info.buckets = NULL;\n\t}\n\t_filelayout_free_lseg(fl);\n}"
  },
  {
    "function_name": "filelayout_decode_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "650-745",
    "snippet": "static int\nfilelayout_decode_layout(struct pnfs_layout_hdr *flo,\n\t\t\t struct nfs4_filelayout_segment *fl,\n\t\t\t struct nfs4_layoutget_res *lgr,\n\t\t\t struct nfs4_deviceid *id,\n\t\t\t gfp_t gfp_flags)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\t__be32 *p;\n\tuint32_t nfl_util;\n\tint i;\n\n\tdprintk(\"%s: set_layout_map Begin\\n\", __func__);\n\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\txdr_init_decode_pages(&stream, &buf, lgr->layoutp->pages, lgr->layoutp->len);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* 20 = ufl_util (4), first_stripe_index (4), pattern_offset (8),\n\t * num_fh (4) */\n\tp = xdr_inline_decode(&stream, NFS4_DEVICEID4_SIZE + 20);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\n\tmemcpy(id, p, sizeof(*id));\n\tp += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\n\tnfs4_print_deviceid(id);\n\n\tnfl_util = be32_to_cpup(p++);\n\tif (nfl_util & NFL4_UFLG_COMMIT_THRU_MDS)\n\t\tfl->commit_through_mds = 1;\n\tif (nfl_util & NFL4_UFLG_DENSE)\n\t\tfl->stripe_type = STRIPE_DENSE;\n\telse\n\t\tfl->stripe_type = STRIPE_SPARSE;\n\tfl->stripe_unit = nfl_util & ~NFL4_UFLG_MASK;\n\n\tfl->first_stripe_index = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &fl->pattern_offset);\n\tfl->num_fh = be32_to_cpup(p++);\n\n\tdprintk(\"%s: nfl_util 0x%X num_fh %u fsi %u po %llu\\n\",\n\t\t__func__, nfl_util, fl->num_fh, fl->first_stripe_index,\n\t\tfl->pattern_offset);\n\n\t/* Note that a zero value for num_fh is legal for STRIPE_SPARSE.\n\t * Futher checking is done in filelayout_check_layout */\n\tif (fl->num_fh >\n\t    max(NFS4_PNFS_MAX_STRIPE_CNT, NFS4_PNFS_MAX_MULTI_CNT))\n\t\tgoto out_err;\n\n\tif (fl->num_fh > 0) {\n\t\tfl->fh_array = kcalloc(fl->num_fh, sizeof(fl->fh_array[0]),\n\t\t\t\t       gfp_flags);\n\t\tif (!fl->fh_array)\n\t\t\tgoto out_err;\n\t}\n\n\tfor (i = 0; i < fl->num_fh; i++) {\n\t\t/* Do we want to use a mempool here? */\n\t\tfl->fh_array[i] = kmalloc(sizeof(struct nfs_fh), gfp_flags);\n\t\tif (!fl->fh_array[i])\n\t\t\tgoto out_err_free;\n\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free;\n\t\tfl->fh_array[i]->size = be32_to_cpup(p++);\n\t\tif (sizeof(struct nfs_fh) < fl->fh_array[i]->size) {\n\t\t\tprintk(KERN_ERR \"NFS: Too big fh %d received %d\\n\",\n\t\t\t       i, fl->fh_array[i]->size);\n\t\t\tgoto out_err_free;\n\t\t}\n\n\t\tp = xdr_inline_decode(&stream, fl->fh_array[i]->size);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free;\n\t\tmemcpy(fl->fh_array[i]->data, p, fl->fh_array[i]->size);\n\t\tdprintk(\"DEBUG: %s: fh len %d\\n\", __func__,\n\t\t\tfl->fh_array[i]->size);\n\t}\n\n\t__free_page(scratch);\n\treturn 0;\n\nout_err_free:\n\tfilelayout_free_fh_array(fl);\nout_err:\n\t__free_page(scratch);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "scratch"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filelayout_free_fh_array",
          "args": [
            "fl"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_free_fh_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "630-641",
          "snippet": "static void filelayout_free_fh_array(struct nfs4_filelayout_segment *fl)\n{\n\tint i;\n\n\tfor (i = 0; i < fl->num_fh; i++) {\n\t\tif (!fl->fh_array[i])\n\t\t\tbreak;\n\t\tkfree(fl->fh_array[i]);\n\t}\n\tkfree(fl->fh_array);\n\tfl->fh_array = NULL;\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_free_fh_array(struct nfs4_filelayout_segment *fl)\n{\n\tint i;\n\n\tfor (i = 0; i < fl->num_fh; i++) {\n\t\tif (!fl->fh_array[i])\n\t\t\tbreak;\n\t\tkfree(fl->fh_array[i]);\n\t}\n\tkfree(fl->fh_array);\n\tfl->fh_array = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "scratch"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"DEBUG: %s: fh len %d\\n\"",
            "__func__",
            "fl->fh_array[i]->size"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fl->fh_array[i]->data",
            "p",
            "fl->fh_array[i]->size"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "fl->fh_array[i]->size"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFS: Too big fh %d received %d\\n\"",
            "i",
            "fl->fh_array[i]->size"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "4"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct nfs_fh)",
            "gfp_flags"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "fl->num_fh",
            "sizeof(fl->fh_array[0])",
            "gfp_flags"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "NFS4_PNFS_MAX_STRIPE_CNT",
            "NFS4_PNFS_MAX_MULTI_CNT"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: nfl_util 0x%X num_fh %u fsi %u po %llu\\n\"",
            "__func__",
            "nfl_util",
            "fl->num_fh",
            "fl->first_stripe_index",
            "fl->pattern_offset"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&fl->pattern_offset"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_print_deviceid",
          "args": [
            "id"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_print_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "520-522",
          "snippet": "static inline void nfs4_print_deviceid(const struct nfs4_deviceid *dev_id)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void nfs4_print_deviceid(const struct nfs4_deviceid *dev_id)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "NFS4_DEVICEID4_SIZE"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "id",
            "p",
            "sizeof(*id)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "NFS4_DEVICEID4_SIZE + 20"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_set_scratch_buffer",
          "args": [
            "&stream",
            "page_address(scratch)",
            "PAGE_SIZE"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "scratch"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_init_decode_pages",
          "args": [
            "&stream",
            "&buf",
            "lgr->layoutp->pages",
            "lgr->layoutp->len"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "gfp_flags"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: set_layout_map Begin\\n\"",
            "__func__"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\nfilelayout_decode_layout(struct pnfs_layout_hdr *flo,\n\t\t\t struct nfs4_filelayout_segment *fl,\n\t\t\t struct nfs4_layoutget_res *lgr,\n\t\t\t struct nfs4_deviceid *id,\n\t\t\t gfp_t gfp_flags)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\t__be32 *p;\n\tuint32_t nfl_util;\n\tint i;\n\n\tdprintk(\"%s: set_layout_map Begin\\n\", __func__);\n\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\txdr_init_decode_pages(&stream, &buf, lgr->layoutp->pages, lgr->layoutp->len);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* 20 = ufl_util (4), first_stripe_index (4), pattern_offset (8),\n\t * num_fh (4) */\n\tp = xdr_inline_decode(&stream, NFS4_DEVICEID4_SIZE + 20);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\n\tmemcpy(id, p, sizeof(*id));\n\tp += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\n\tnfs4_print_deviceid(id);\n\n\tnfl_util = be32_to_cpup(p++);\n\tif (nfl_util & NFL4_UFLG_COMMIT_THRU_MDS)\n\t\tfl->commit_through_mds = 1;\n\tif (nfl_util & NFL4_UFLG_DENSE)\n\t\tfl->stripe_type = STRIPE_DENSE;\n\telse\n\t\tfl->stripe_type = STRIPE_SPARSE;\n\tfl->stripe_unit = nfl_util & ~NFL4_UFLG_MASK;\n\n\tfl->first_stripe_index = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &fl->pattern_offset);\n\tfl->num_fh = be32_to_cpup(p++);\n\n\tdprintk(\"%s: nfl_util 0x%X num_fh %u fsi %u po %llu\\n\",\n\t\t__func__, nfl_util, fl->num_fh, fl->first_stripe_index,\n\t\tfl->pattern_offset);\n\n\t/* Note that a zero value for num_fh is legal for STRIPE_SPARSE.\n\t * Futher checking is done in filelayout_check_layout */\n\tif (fl->num_fh >\n\t    max(NFS4_PNFS_MAX_STRIPE_CNT, NFS4_PNFS_MAX_MULTI_CNT))\n\t\tgoto out_err;\n\n\tif (fl->num_fh > 0) {\n\t\tfl->fh_array = kcalloc(fl->num_fh, sizeof(fl->fh_array[0]),\n\t\t\t\t       gfp_flags);\n\t\tif (!fl->fh_array)\n\t\t\tgoto out_err;\n\t}\n\n\tfor (i = 0; i < fl->num_fh; i++) {\n\t\t/* Do we want to use a mempool here? */\n\t\tfl->fh_array[i] = kmalloc(sizeof(struct nfs_fh), gfp_flags);\n\t\tif (!fl->fh_array[i])\n\t\t\tgoto out_err_free;\n\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free;\n\t\tfl->fh_array[i]->size = be32_to_cpup(p++);\n\t\tif (sizeof(struct nfs_fh) < fl->fh_array[i]->size) {\n\t\t\tprintk(KERN_ERR \"NFS: Too big fh %d received %d\\n\",\n\t\t\t       i, fl->fh_array[i]->size);\n\t\t\tgoto out_err_free;\n\t\t}\n\n\t\tp = xdr_inline_decode(&stream, fl->fh_array[i]->size);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free;\n\t\tmemcpy(fl->fh_array[i]->data, p, fl->fh_array[i]->size);\n\t\tdprintk(\"DEBUG: %s: fh len %d\\n\", __func__,\n\t\t\tfl->fh_array[i]->size);\n\t}\n\n\t__free_page(scratch);\n\treturn 0;\n\nout_err_free:\n\tfilelayout_free_fh_array(fl);\nout_err:\n\t__free_page(scratch);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "_filelayout_free_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "643-648",
    "snippet": "static void\n_filelayout_free_lseg(struct nfs4_filelayout_segment *fl)\n{\n\tfilelayout_free_fh_array(fl);\n\tkfree(fl);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fl"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filelayout_free_fh_array",
          "args": [
            "fl"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_free_fh_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "630-641",
          "snippet": "static void filelayout_free_fh_array(struct nfs4_filelayout_segment *fl)\n{\n\tint i;\n\n\tfor (i = 0; i < fl->num_fh; i++) {\n\t\tif (!fl->fh_array[i])\n\t\t\tbreak;\n\t\tkfree(fl->fh_array[i]);\n\t}\n\tkfree(fl->fh_array);\n\tfl->fh_array = NULL;\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_free_fh_array(struct nfs4_filelayout_segment *fl)\n{\n\tint i;\n\n\tfor (i = 0; i < fl->num_fh; i++) {\n\t\tif (!fl->fh_array[i])\n\t\t\tbreak;\n\t\tkfree(fl->fh_array[i]);\n\t}\n\tkfree(fl->fh_array);\n\tfl->fh_array = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\n_filelayout_free_lseg(struct nfs4_filelayout_segment *fl)\n{\n\tfilelayout_free_fh_array(fl);\n\tkfree(fl);\n}"
  },
  {
    "function_name": "filelayout_free_fh_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "630-641",
    "snippet": "static void filelayout_free_fh_array(struct nfs4_filelayout_segment *fl)\n{\n\tint i;\n\n\tfor (i = 0; i < fl->num_fh; i++) {\n\t\tif (!fl->fh_array[i])\n\t\t\tbreak;\n\t\tkfree(fl->fh_array[i]);\n\t}\n\tkfree(fl->fh_array);\n\tfl->fh_array = NULL;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fl->fh_array"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fl->fh_array[i]"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_free_fh_array(struct nfs4_filelayout_segment *fl)\n{\n\tint i;\n\n\tfor (i = 0; i < fl->num_fh; i++) {\n\t\tif (!fl->fh_array[i])\n\t\t\tbreak;\n\t\tkfree(fl->fh_array[i]);\n\t}\n\tkfree(fl->fh_array);\n\tfl->fh_array = NULL;\n}"
  },
  {
    "function_name": "filelayout_check_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "560-628",
    "snippet": "static int\nfilelayout_check_layout(struct pnfs_layout_hdr *lo,\n\t\t\tstruct nfs4_filelayout_segment *fl,\n\t\t\tstruct nfs4_layoutget_res *lgr,\n\t\t\tstruct nfs4_deviceid *id,\n\t\t\tgfp_t gfp_flags)\n{\n\tstruct nfs4_deviceid_node *d;\n\tstruct nfs4_file_layout_dsaddr *dsaddr;\n\tint status = -EINVAL;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\t/* FIXME: remove this check when layout segment support is added */\n\tif (lgr->range.offset != 0 ||\n\t    lgr->range.length != NFS4_MAX_UINT64) {\n\t\tdprintk(\"%s Only whole file layouts supported. Use MDS i/o\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tif (fl->pattern_offset > lgr->range.offset) {\n\t\tdprintk(\"%s pattern_offset %lld too large\\n\",\n\t\t\t\t__func__, fl->pattern_offset);\n\t\tgoto out;\n\t}\n\n\tif (!fl->stripe_unit) {\n\t\tdprintk(\"%s Invalid stripe unit (%u)\\n\",\n\t\t\t__func__, fl->stripe_unit);\n\t\tgoto out;\n\t}\n\n\t/* find and reference the deviceid */\n\td = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode), id,\n\t\t\tlo->plh_lc_cred, gfp_flags);\n\tif (d == NULL)\n\t\tgoto out;\n\n\tdsaddr = container_of(d, struct nfs4_file_layout_dsaddr, id_node);\n\t/* Found deviceid is unavailable */\n\tif (filelayout_test_devid_unavailable(&dsaddr->id_node))\n\t\tgoto out_put;\n\n\tfl->dsaddr = dsaddr;\n\n\tif (fl->first_stripe_index >= dsaddr->stripe_count) {\n\t\tdprintk(\"%s Bad first_stripe_index %u\\n\",\n\t\t\t\t__func__, fl->first_stripe_index);\n\t\tgoto out_put;\n\t}\n\n\tif ((fl->stripe_type == STRIPE_SPARSE &&\n\t    fl->num_fh > 1 && fl->num_fh != dsaddr->ds_num) ||\n\t    (fl->stripe_type == STRIPE_DENSE &&\n\t    fl->num_fh != dsaddr->stripe_count)) {\n\t\tdprintk(\"%s num_fh %u not valid for given packing\\n\",\n\t\t\t__func__, fl->num_fh);\n\t\tgoto out_put;\n\t}\n\n\tstatus = 0;\nout:\n\tdprintk(\"--> %s returns %d\\n\", __func__, status);\n\treturn status;\nout_put:\n\tnfs4_fl_put_deviceid(dsaddr);\n\tgoto out;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_fl_put_deviceid",
          "args": [
            "dsaddr"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_put_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "213-217",
          "snippet": "void\nnfs4_fl_put_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\n{\n\tnfs4_put_deviceid_node(&dsaddr->id_node);\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nvoid\nnfs4_fl_put_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\n{\n\tnfs4_put_deviceid_node(&dsaddr->id_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s returns %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s num_fh %u not valid for given packing\\n\"",
            "__func__",
            "fl->num_fh"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Bad first_stripe_index %u\\n\"",
            "__func__",
            "fl->first_stripe_index"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filelayout_test_devid_unavailable",
          "args": [
            "&dsaddr->id_node"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_test_devid_unavailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "266-271",
          "snippet": "bool\nfilelayout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn filelayout_test_devid_invalid(node) ||\n\t\tnfs4_test_deviceid_unavailable(node);\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nbool\nfilelayout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn filelayout_test_devid_invalid(node) ||\n\t\tnfs4_test_deviceid_unavailable(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "d",
            "structnfs4_file_layout_dsaddr",
            "id_node"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_find_get_deviceid",
          "args": [
            "NFS_SERVER(lo->plh_inode)",
            "id",
            "lo->plh_lc_cred",
            "gfp_flags"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_find_get_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "184-212",
          "snippet": "struct nfs4_deviceid_node *\nnfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, struct rpc_cred *cred,\n\t\tgfp_t gfp_mask)\n{\n\tlong hash = nfs4_deviceid_hash(id);\n\tstruct nfs4_deviceid_node *d, *new;\n\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d)\n\t\treturn d;\n\n\tnew = nfs4_get_device_info(server, id, cred, gfp_mask);\n\tif (!new)\n\t\treturn new;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\tserver->pnfs_curr_ld->free_deviceid_node(new);\n\t\treturn d;\n\t}\n\thlist_add_head_rcu(&new->node, &nfs4_deviceid_cache[hash]);\n\tatomic_inc(&new->ref);\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\treturn new;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];",
            "static DEFINE_SPINLOCK(nfs4_deviceid_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfs4_deviceid_lock);\n\nstruct nfs4_deviceid_node *\nnfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, struct rpc_cred *cred,\n\t\tgfp_t gfp_mask)\n{\n\tlong hash = nfs4_deviceid_hash(id);\n\tstruct nfs4_deviceid_node *d, *new;\n\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d)\n\t\treturn d;\n\n\tnew = nfs4_get_device_info(server, id, cred, gfp_mask);\n\tif (!new)\n\t\treturn new;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\tserver->pnfs_curr_ld->free_deviceid_node(new);\n\t\treturn d;\n\t}\n\thlist_add_head_rcu(&new->node, &nfs4_deviceid_cache[hash]);\n\tatomic_inc(&new->ref);\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "lo->plh_inode"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Invalid stripe unit (%u)\\n\"",
            "__func__",
            "fl->stripe_unit"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s pattern_offset %lld too large\\n\"",
            "__func__",
            "fl->pattern_offset"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Only whole file layouts supported. Use MDS i/o\\n\"",
            "__func__"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s\\n\"",
            "__func__"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\nfilelayout_check_layout(struct pnfs_layout_hdr *lo,\n\t\t\tstruct nfs4_filelayout_segment *fl,\n\t\t\tstruct nfs4_layoutget_res *lgr,\n\t\t\tstruct nfs4_deviceid *id,\n\t\t\tgfp_t gfp_flags)\n{\n\tstruct nfs4_deviceid_node *d;\n\tstruct nfs4_file_layout_dsaddr *dsaddr;\n\tint status = -EINVAL;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\t/* FIXME: remove this check when layout segment support is added */\n\tif (lgr->range.offset != 0 ||\n\t    lgr->range.length != NFS4_MAX_UINT64) {\n\t\tdprintk(\"%s Only whole file layouts supported. Use MDS i/o\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tif (fl->pattern_offset > lgr->range.offset) {\n\t\tdprintk(\"%s pattern_offset %lld too large\\n\",\n\t\t\t\t__func__, fl->pattern_offset);\n\t\tgoto out;\n\t}\n\n\tif (!fl->stripe_unit) {\n\t\tdprintk(\"%s Invalid stripe unit (%u)\\n\",\n\t\t\t__func__, fl->stripe_unit);\n\t\tgoto out;\n\t}\n\n\t/* find and reference the deviceid */\n\td = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode), id,\n\t\t\tlo->plh_lc_cred, gfp_flags);\n\tif (d == NULL)\n\t\tgoto out;\n\n\tdsaddr = container_of(d, struct nfs4_file_layout_dsaddr, id_node);\n\t/* Found deviceid is unavailable */\n\tif (filelayout_test_devid_unavailable(&dsaddr->id_node))\n\t\tgoto out_put;\n\n\tfl->dsaddr = dsaddr;\n\n\tif (fl->first_stripe_index >= dsaddr->stripe_count) {\n\t\tdprintk(\"%s Bad first_stripe_index %u\\n\",\n\t\t\t\t__func__, fl->first_stripe_index);\n\t\tgoto out_put;\n\t}\n\n\tif ((fl->stripe_type == STRIPE_SPARSE &&\n\t    fl->num_fh > 1 && fl->num_fh != dsaddr->ds_num) ||\n\t    (fl->stripe_type == STRIPE_DENSE &&\n\t    fl->num_fh != dsaddr->stripe_count)) {\n\t\tdprintk(\"%s num_fh %u not valid for given packing\\n\",\n\t\t\t__func__, fl->num_fh);\n\t\tgoto out_put;\n\t}\n\n\tstatus = 0;\nout:\n\tdprintk(\"--> %s returns %d\\n\", __func__, status);\n\treturn status;\nout_put:\n\tnfs4_fl_put_deviceid(dsaddr);\n\tgoto out;\n}"
  },
  {
    "function_name": "filelayout_write_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "511-550",
    "snippet": "static enum pnfs_try_status\nfilelayout_write_pagelist(struct nfs_pgio_header *hdr, int sync)\n{\n\tstruct pnfs_layout_segment *lseg = hdr->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tloff_t offset = hdr->args.offset;\n\tu32 j, idx;\n\tstruct nfs_fh *fh;\n\n\t/* Retrieve the correct rpc_client for the byte range */\n\tj = nfs4_fl_calc_j_index(lseg, offset);\n\tidx = nfs4_fl_calc_ds_index(lseg, j);\n\tds = nfs4_fl_prepare_ds(lseg, idx);\n\tif (!ds)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, hdr->inode);\n\tif (IS_ERR(ds_clnt))\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tdprintk(\"%s ino %lu sync %d req %Zu@%llu DS: %s cl_count %d\\n\",\n\t\t__func__, hdr->inode->i_ino, sync, (size_t) hdr->args.count,\n\t\toffset, ds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count));\n\n\thdr->pgio_done_cb = filelayout_write_done_cb;\n\tatomic_inc(&ds->ds_clp->cl_count);\n\thdr->ds_clp = ds->ds_clp;\n\thdr->ds_commit_idx = idx;\n\tfh = nfs4_fl_select_ds_fh(lseg, j);\n\tif (fh)\n\t\thdr->args.fh = fh;\n\thdr->args.offset = filelayout_get_dserver_offset(lseg, offset);\n\n\t/* Perform an asynchronous write */\n\tnfs_initiate_pgio(ds_clnt, hdr, hdr->cred,\n\t\t\t  NFS_PROTO(hdr->inode), &filelayout_write_call_ops,\n\t\t\t  sync, RPC_TASK_SOFTCONN);\n\treturn PNFS_ATTEMPTED;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_call_ops filelayout_write_call_ops = {\n\t.rpc_call_prepare = filelayout_write_prepare,\n\t.rpc_call_done = filelayout_write_call_done,\n\t.rpc_count_stats = filelayout_write_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_initiate_pgio",
          "args": [
            "ds_clnt",
            "hdr",
            "hdr->cred",
            "NFS_PROTO(hdr->inode)",
            "&filelayout_write_call_ops",
            "sync",
            "RPC_TASK_SOFTCONN"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_initiate_pgio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "616-660",
          "snippet": "int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &hdr->args,\n\t\t.rpc_resp = &hdr->res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.task = &hdr->task,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = hdr,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t};\n\tint ret = 0;\n\n\thdr->rw_ops->rw_initiate(hdr, &msg, rpc_ops, &task_setup_data, how);\n\n\tdprintk(\"NFS: %5u initiated pgio call \"\n\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\",\n\t\thdr->task.tk_pid,\n\t\thdr->inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\thdr->args.count,\n\t\t(unsigned long long)hdr->args.offset);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tif (how & FLUSH_SYNC) {\n\t\tret = rpc_wait_for_completion_task(task);\n\t\tif (ret == 0)\n\t\t\tret = task->tk_status;\n\t}\n\trpc_put_task(task);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &hdr->args,\n\t\t.rpc_resp = &hdr->res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.task = &hdr->task,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = hdr,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t};\n\tint ret = 0;\n\n\thdr->rw_ops->rw_initiate(hdr, &msg, rpc_ops, &task_setup_data, how);\n\n\tdprintk(\"NFS: %5u initiated pgio call \"\n\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\",\n\t\thdr->task.tk_pid,\n\t\thdr->inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\thdr->args.count,\n\t\t(unsigned long long)hdr->args.offset);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tif (how & FLUSH_SYNC) {\n\t\tret = rpc_wait_for_completion_task(task);\n\t\tif (ret == 0)\n\t\t\tret = task->tk_status;\n\t}\n\trpc_put_task(task);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "hdr->inode"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filelayout_get_dserver_offset",
          "args": [
            "lseg",
            "offset"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_get_dserver_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "71-85",
          "snippet": "static loff_t\nfilelayout_get_dserver_offset(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tswitch (flseg->stripe_type) {\n\tcase STRIPE_SPARSE:\n\t\treturn offset;\n\n\tcase STRIPE_DENSE:\n\t\treturn filelayout_get_dense_offset(flseg, offset);\n\t}\n\n\tBUG();\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic loff_t\nfilelayout_get_dserver_offset(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tswitch (flseg->stripe_type) {\n\tcase STRIPE_SPARSE:\n\t\treturn offset;\n\n\tcase STRIPE_DENSE:\n\t\treturn filelayout_get_dense_offset(flseg, offset);\n\t}\n\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_fl_select_ds_fh",
          "args": [
            "lseg",
            "j"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_select_ds_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "241-258",
          "snippet": "struct nfs_fh *\nnfs4_fl_select_ds_fh(struct pnfs_layout_segment *lseg, u32 j)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu32 i;\n\n\tif (flseg->stripe_type == STRIPE_SPARSE) {\n\t\tif (flseg->num_fh == 1)\n\t\t\ti = 0;\n\t\telse if (flseg->num_fh == 0)\n\t\t\t/* Use the MDS OPEN fh set in nfs_read_rpcsetup */\n\t\t\treturn NULL;\n\t\telse\n\t\t\ti = nfs4_fl_calc_ds_index(lseg, j);\n\t} else\n\t\ti = j;\n\treturn flseg->fh_array[i];\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs_fh *\nnfs4_fl_select_ds_fh(struct pnfs_layout_segment *lseg, u32 j)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu32 i;\n\n\tif (flseg->stripe_type == STRIPE_SPARSE) {\n\t\tif (flseg->num_fh == 1)\n\t\t\ti = 0;\n\t\telse if (flseg->num_fh == 0)\n\t\t\t/* Use the MDS OPEN fh set in nfs_read_rpcsetup */\n\t\t\treturn NULL;\n\t\telse\n\t\t\ti = nfs4_fl_calc_ds_index(lseg, j);\n\t} else\n\t\ti = j;\n\treturn flseg->fh_array[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ds->ds_clp->cl_count"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s ino %lu sync %d req %Zu@%llu DS: %s cl_count %d\\n\"",
            "__func__",
            "hdr->inode->i_ino",
            "sync",
            "(size_t) hdr->args.count",
            "offset",
            "ds->ds_remotestr",
            "atomic_read(&ds->ds_clp->cl_count)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ds->ds_clp->cl_count"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ds_clnt"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_find_or_create_ds_client",
          "args": [
            "ds->ds_clp",
            "hdr->inode"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_find_or_create_ds_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4client.c",
          "lines": "124-141",
          "snippet": "struct rpc_clnt *\nnfs4_find_or_create_ds_client(struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ds_server *dss, *new;\n\trpc_authflavor_t flavor = NFS_SERVER(inode)->client->cl_auth->au_flavor;\n\n\tdss = nfs4_find_ds_client(ds_clp, flavor);\n\tif (dss != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_ds_server(ds_clp, flavor);\n\tif (IS_ERR(new))\n\t\treturn ERR_CAST(new);\n\tdss = nfs4_add_ds_client(ds_clp, flavor, new);\n\tif (dss != new)\n\t\tnfs4_free_ds_server(new);\nout:\n\treturn dss->rpc_clnt;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"internal.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/auth.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"internal.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n\nstruct rpc_clnt *\nnfs4_find_or_create_ds_client(struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ds_server *dss, *new;\n\trpc_authflavor_t flavor = NFS_SERVER(inode)->client->cl_auth->au_flavor;\n\n\tdss = nfs4_find_ds_client(ds_clp, flavor);\n\tif (dss != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_ds_server(ds_clp, flavor);\n\tif (IS_ERR(new))\n\t\treturn ERR_CAST(new);\n\tdss = nfs4_add_ds_client(ds_clp, flavor, new);\n\tif (dss != new)\n\t\tnfs4_free_ds_server(new);\nout:\n\treturn dss->rpc_clnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_fl_prepare_ds",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_prepare_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "261-290",
          "snippet": "struct nfs4_pnfs_ds *\nnfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\tstruct nfs4_file_layout_dsaddr *dsaddr = FILELAYOUT_LSEG(lseg)->dsaddr;\n\tstruct nfs4_pnfs_ds *ds = dsaddr->ds_list[ds_idx];\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs4_pnfs_ds *ret = ds;\n\tstruct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);\n\n\tif (ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\tgoto out;\n\t}\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out_test_devid;\n\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans, 4,\n\t\t\t     s->nfs_client->cl_minorversion,\n\t\t\t     s->nfs_client->cl_rpcclient->cl_auth->au_flavor);\n\nout_test_devid:\n\tif (filelayout_test_devid_unavailable(devid))\n\t\tret = NULL;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;",
            "static unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;\nstatic unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;\n\nstruct nfs4_pnfs_ds *\nnfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\tstruct nfs4_file_layout_dsaddr *dsaddr = FILELAYOUT_LSEG(lseg)->dsaddr;\n\tstruct nfs4_pnfs_ds *ds = dsaddr->ds_list[ds_idx];\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs4_pnfs_ds *ret = ds;\n\tstruct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);\n\n\tif (ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\tgoto out;\n\t}\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out_test_devid;\n\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans, 4,\n\t\t\t     s->nfs_client->cl_minorversion,\n\t\t\t     s->nfs_client->cl_rpcclient->cl_auth->au_flavor);\n\nout_test_devid:\n\tif (filelayout_test_devid_unavailable(devid))\n\t\tret = NULL;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_fl_calc_ds_index",
          "args": [
            "lseg",
            "j"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_calc_ds_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "235-239",
          "snippet": "u32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nu32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_fl_calc_j_index",
          "args": [
            "lseg",
            "offset"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_calc_j_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "223-233",
          "snippet": "u32\nnfs4_fl_calc_j_index(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu64 tmp;\n\n\ttmp = offset - flseg->pattern_offset;\n\tdo_div(tmp, flseg->stripe_unit);\n\ttmp += flseg->first_stripe_index;\n\treturn do_div(tmp, flseg->dsaddr->stripe_count);\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nu32\nnfs4_fl_calc_j_index(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu64 tmp;\n\n\ttmp = offset - flseg->pattern_offset;\n\tdo_div(tmp, flseg->stripe_unit);\n\ttmp += flseg->first_stripe_index;\n\treturn do_div(tmp, flseg->dsaddr->stripe_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic const struct rpc_call_ops filelayout_write_call_ops = {\n\t.rpc_call_prepare = filelayout_write_prepare,\n\t.rpc_call_done = filelayout_write_call_done,\n\t.rpc_count_stats = filelayout_write_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};\n\nstatic enum pnfs_try_status\nfilelayout_write_pagelist(struct nfs_pgio_header *hdr, int sync)\n{\n\tstruct pnfs_layout_segment *lseg = hdr->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tloff_t offset = hdr->args.offset;\n\tu32 j, idx;\n\tstruct nfs_fh *fh;\n\n\t/* Retrieve the correct rpc_client for the byte range */\n\tj = nfs4_fl_calc_j_index(lseg, offset);\n\tidx = nfs4_fl_calc_ds_index(lseg, j);\n\tds = nfs4_fl_prepare_ds(lseg, idx);\n\tif (!ds)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, hdr->inode);\n\tif (IS_ERR(ds_clnt))\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tdprintk(\"%s ino %lu sync %d req %Zu@%llu DS: %s cl_count %d\\n\",\n\t\t__func__, hdr->inode->i_ino, sync, (size_t) hdr->args.count,\n\t\toffset, ds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count));\n\n\thdr->pgio_done_cb = filelayout_write_done_cb;\n\tatomic_inc(&ds->ds_clp->cl_count);\n\thdr->ds_clp = ds->ds_clp;\n\thdr->ds_commit_idx = idx;\n\tfh = nfs4_fl_select_ds_fh(lseg, j);\n\tif (fh)\n\t\thdr->args.fh = fh;\n\thdr->args.offset = filelayout_get_dserver_offset(lseg, offset);\n\n\t/* Perform an asynchronous write */\n\tnfs_initiate_pgio(ds_clnt, hdr, hdr->cred,\n\t\t\t  NFS_PROTO(hdr->inode), &filelayout_write_call_ops,\n\t\t\t  sync, RPC_TASK_SOFTCONN);\n\treturn PNFS_ATTEMPTED;\n}"
  },
  {
    "function_name": "filelayout_read_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "464-508",
    "snippet": "static enum pnfs_try_status\nfilelayout_read_pagelist(struct nfs_pgio_header *hdr)\n{\n\tstruct pnfs_layout_segment *lseg = hdr->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tloff_t offset = hdr->args.offset;\n\tu32 j, idx;\n\tstruct nfs_fh *fh;\n\n\tdprintk(\"--> %s ino %lu pgbase %u req %Zu@%llu\\n\",\n\t\t__func__, hdr->inode->i_ino,\n\t\thdr->args.pgbase, (size_t)hdr->args.count, offset);\n\n\t/* Retrieve the correct rpc_client for the byte range */\n\tj = nfs4_fl_calc_j_index(lseg, offset);\n\tidx = nfs4_fl_calc_ds_index(lseg, j);\n\tds = nfs4_fl_prepare_ds(lseg, idx);\n\tif (!ds)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, hdr->inode);\n\tif (IS_ERR(ds_clnt))\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tdprintk(\"%s USE DS: %s cl_count %d\\n\", __func__,\n\t\tds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count));\n\n\t/* No multipath support. Use first DS */\n\tatomic_inc(&ds->ds_clp->cl_count);\n\thdr->ds_clp = ds->ds_clp;\n\thdr->ds_commit_idx = idx;\n\tfh = nfs4_fl_select_ds_fh(lseg, j);\n\tif (fh)\n\t\thdr->args.fh = fh;\n\n\thdr->args.offset = filelayout_get_dserver_offset(lseg, offset);\n\thdr->mds_offset = offset;\n\n\t/* Perform an asynchronous read to ds */\n\tnfs_initiate_pgio(ds_clnt, hdr, hdr->cred,\n\t\t\t  NFS_PROTO(hdr->inode), &filelayout_read_call_ops,\n\t\t\t  0, RPC_TASK_SOFTCONN);\n\treturn PNFS_ATTEMPTED;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_call_ops filelayout_read_call_ops = {\n\t.rpc_call_prepare = filelayout_read_prepare,\n\t.rpc_call_done = filelayout_read_call_done,\n\t.rpc_count_stats = filelayout_read_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_initiate_pgio",
          "args": [
            "ds_clnt",
            "hdr",
            "hdr->cred",
            "NFS_PROTO(hdr->inode)",
            "&filelayout_read_call_ops",
            "0",
            "RPC_TASK_SOFTCONN"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_initiate_pgio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "616-660",
          "snippet": "int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &hdr->args,\n\t\t.rpc_resp = &hdr->res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.task = &hdr->task,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = hdr,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t};\n\tint ret = 0;\n\n\thdr->rw_ops->rw_initiate(hdr, &msg, rpc_ops, &task_setup_data, how);\n\n\tdprintk(\"NFS: %5u initiated pgio call \"\n\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\",\n\t\thdr->task.tk_pid,\n\t\thdr->inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\thdr->args.count,\n\t\t(unsigned long long)hdr->args.offset);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tif (how & FLUSH_SYNC) {\n\t\tret = rpc_wait_for_completion_task(task);\n\t\tif (ret == 0)\n\t\t\tret = task->tk_status;\n\t}\n\trpc_put_task(task);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &hdr->args,\n\t\t.rpc_resp = &hdr->res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.task = &hdr->task,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = hdr,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t};\n\tint ret = 0;\n\n\thdr->rw_ops->rw_initiate(hdr, &msg, rpc_ops, &task_setup_data, how);\n\n\tdprintk(\"NFS: %5u initiated pgio call \"\n\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\",\n\t\thdr->task.tk_pid,\n\t\thdr->inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\thdr->args.count,\n\t\t(unsigned long long)hdr->args.offset);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tif (how & FLUSH_SYNC) {\n\t\tret = rpc_wait_for_completion_task(task);\n\t\tif (ret == 0)\n\t\t\tret = task->tk_status;\n\t}\n\trpc_put_task(task);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "hdr->inode"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filelayout_get_dserver_offset",
          "args": [
            "lseg",
            "offset"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_get_dserver_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "71-85",
          "snippet": "static loff_t\nfilelayout_get_dserver_offset(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tswitch (flseg->stripe_type) {\n\tcase STRIPE_SPARSE:\n\t\treturn offset;\n\n\tcase STRIPE_DENSE:\n\t\treturn filelayout_get_dense_offset(flseg, offset);\n\t}\n\n\tBUG();\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic loff_t\nfilelayout_get_dserver_offset(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tswitch (flseg->stripe_type) {\n\tcase STRIPE_SPARSE:\n\t\treturn offset;\n\n\tcase STRIPE_DENSE:\n\t\treturn filelayout_get_dense_offset(flseg, offset);\n\t}\n\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_fl_select_ds_fh",
          "args": [
            "lseg",
            "j"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_select_ds_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "241-258",
          "snippet": "struct nfs_fh *\nnfs4_fl_select_ds_fh(struct pnfs_layout_segment *lseg, u32 j)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu32 i;\n\n\tif (flseg->stripe_type == STRIPE_SPARSE) {\n\t\tif (flseg->num_fh == 1)\n\t\t\ti = 0;\n\t\telse if (flseg->num_fh == 0)\n\t\t\t/* Use the MDS OPEN fh set in nfs_read_rpcsetup */\n\t\t\treturn NULL;\n\t\telse\n\t\t\ti = nfs4_fl_calc_ds_index(lseg, j);\n\t} else\n\t\ti = j;\n\treturn flseg->fh_array[i];\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs_fh *\nnfs4_fl_select_ds_fh(struct pnfs_layout_segment *lseg, u32 j)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu32 i;\n\n\tif (flseg->stripe_type == STRIPE_SPARSE) {\n\t\tif (flseg->num_fh == 1)\n\t\t\ti = 0;\n\t\telse if (flseg->num_fh == 0)\n\t\t\t/* Use the MDS OPEN fh set in nfs_read_rpcsetup */\n\t\t\treturn NULL;\n\t\telse\n\t\t\ti = nfs4_fl_calc_ds_index(lseg, j);\n\t} else\n\t\ti = j;\n\treturn flseg->fh_array[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ds->ds_clp->cl_count"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s USE DS: %s cl_count %d\\n\"",
            "__func__",
            "ds->ds_remotestr",
            "atomic_read(&ds->ds_clp->cl_count)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ds->ds_clp->cl_count"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ds_clnt"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_find_or_create_ds_client",
          "args": [
            "ds->ds_clp",
            "hdr->inode"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_find_or_create_ds_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4client.c",
          "lines": "124-141",
          "snippet": "struct rpc_clnt *\nnfs4_find_or_create_ds_client(struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ds_server *dss, *new;\n\trpc_authflavor_t flavor = NFS_SERVER(inode)->client->cl_auth->au_flavor;\n\n\tdss = nfs4_find_ds_client(ds_clp, flavor);\n\tif (dss != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_ds_server(ds_clp, flavor);\n\tif (IS_ERR(new))\n\t\treturn ERR_CAST(new);\n\tdss = nfs4_add_ds_client(ds_clp, flavor, new);\n\tif (dss != new)\n\t\tnfs4_free_ds_server(new);\nout:\n\treturn dss->rpc_clnt;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"internal.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/auth.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"internal.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n\nstruct rpc_clnt *\nnfs4_find_or_create_ds_client(struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ds_server *dss, *new;\n\trpc_authflavor_t flavor = NFS_SERVER(inode)->client->cl_auth->au_flavor;\n\n\tdss = nfs4_find_ds_client(ds_clp, flavor);\n\tif (dss != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_ds_server(ds_clp, flavor);\n\tif (IS_ERR(new))\n\t\treturn ERR_CAST(new);\n\tdss = nfs4_add_ds_client(ds_clp, flavor, new);\n\tif (dss != new)\n\t\tnfs4_free_ds_server(new);\nout:\n\treturn dss->rpc_clnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_fl_prepare_ds",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_prepare_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "261-290",
          "snippet": "struct nfs4_pnfs_ds *\nnfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\tstruct nfs4_file_layout_dsaddr *dsaddr = FILELAYOUT_LSEG(lseg)->dsaddr;\n\tstruct nfs4_pnfs_ds *ds = dsaddr->ds_list[ds_idx];\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs4_pnfs_ds *ret = ds;\n\tstruct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);\n\n\tif (ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\tgoto out;\n\t}\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out_test_devid;\n\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans, 4,\n\t\t\t     s->nfs_client->cl_minorversion,\n\t\t\t     s->nfs_client->cl_rpcclient->cl_auth->au_flavor);\n\nout_test_devid:\n\tif (filelayout_test_devid_unavailable(devid))\n\t\tret = NULL;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;",
            "static unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;\nstatic unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;\n\nstruct nfs4_pnfs_ds *\nnfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\tstruct nfs4_file_layout_dsaddr *dsaddr = FILELAYOUT_LSEG(lseg)->dsaddr;\n\tstruct nfs4_pnfs_ds *ds = dsaddr->ds_list[ds_idx];\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs4_pnfs_ds *ret = ds;\n\tstruct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);\n\n\tif (ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\tgoto out;\n\t}\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out_test_devid;\n\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans, 4,\n\t\t\t     s->nfs_client->cl_minorversion,\n\t\t\t     s->nfs_client->cl_rpcclient->cl_auth->au_flavor);\n\nout_test_devid:\n\tif (filelayout_test_devid_unavailable(devid))\n\t\tret = NULL;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_fl_calc_ds_index",
          "args": [
            "lseg",
            "j"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_calc_ds_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "235-239",
          "snippet": "u32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nu32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_fl_calc_j_index",
          "args": [
            "lseg",
            "offset"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_calc_j_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "223-233",
          "snippet": "u32\nnfs4_fl_calc_j_index(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu64 tmp;\n\n\ttmp = offset - flseg->pattern_offset;\n\tdo_div(tmp, flseg->stripe_unit);\n\ttmp += flseg->first_stripe_index;\n\treturn do_div(tmp, flseg->dsaddr->stripe_count);\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nu32\nnfs4_fl_calc_j_index(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu64 tmp;\n\n\ttmp = offset - flseg->pattern_offset;\n\tdo_div(tmp, flseg->stripe_unit);\n\ttmp += flseg->first_stripe_index;\n\treturn do_div(tmp, flseg->dsaddr->stripe_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s ino %lu pgbase %u req %Zu@%llu\\n\"",
            "__func__",
            "hdr->inode->i_ino",
            "hdr->args.pgbase",
            "(size_t)hdr->args.count",
            "offset"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic const struct rpc_call_ops filelayout_read_call_ops = {\n\t.rpc_call_prepare = filelayout_read_prepare,\n\t.rpc_call_done = filelayout_read_call_done,\n\t.rpc_count_stats = filelayout_read_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};\n\nstatic enum pnfs_try_status\nfilelayout_read_pagelist(struct nfs_pgio_header *hdr)\n{\n\tstruct pnfs_layout_segment *lseg = hdr->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tloff_t offset = hdr->args.offset;\n\tu32 j, idx;\n\tstruct nfs_fh *fh;\n\n\tdprintk(\"--> %s ino %lu pgbase %u req %Zu@%llu\\n\",\n\t\t__func__, hdr->inode->i_ino,\n\t\thdr->args.pgbase, (size_t)hdr->args.count, offset);\n\n\t/* Retrieve the correct rpc_client for the byte range */\n\tj = nfs4_fl_calc_j_index(lseg, offset);\n\tidx = nfs4_fl_calc_ds_index(lseg, j);\n\tds = nfs4_fl_prepare_ds(lseg, idx);\n\tif (!ds)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, hdr->inode);\n\tif (IS_ERR(ds_clnt))\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tdprintk(\"%s USE DS: %s cl_count %d\\n\", __func__,\n\t\tds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count));\n\n\t/* No multipath support. Use first DS */\n\tatomic_inc(&ds->ds_clp->cl_count);\n\thdr->ds_clp = ds->ds_clp;\n\thdr->ds_commit_idx = idx;\n\tfh = nfs4_fl_select_ds_fh(lseg, j);\n\tif (fh)\n\t\thdr->args.fh = fh;\n\n\thdr->args.offset = filelayout_get_dserver_offset(lseg, offset);\n\thdr->mds_offset = offset;\n\n\t/* Perform an asynchronous read to ds */\n\tnfs_initiate_pgio(ds_clnt, hdr, hdr->cred,\n\t\t\t  NFS_PROTO(hdr->inode), &filelayout_read_call_ops,\n\t\t\t  0, RPC_TASK_SOFTCONN);\n\treturn PNFS_ATTEMPTED;\n}"
  },
  {
    "function_name": "filelayout_commit_count_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "436-441",
    "snippet": "static void filelayout_commit_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *cdata = data;\n\n\trpc_count_iostats(task, NFS_SERVER(cdata->inode)->client->cl_metrics);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_count_iostats",
          "args": [
            "task",
            "NFS_SERVER(cdata->inode)->client->cl_metrics"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "cdata->inode"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_commit_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *cdata = data;\n\n\trpc_count_iostats(task, NFS_SERVER(cdata->inode)->client->cl_metrics);\n}"
  },
  {
    "function_name": "filelayout_commit_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "426-434",
    "snippet": "static void filelayout_commit_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *wdata = data;\n\n\tnfs41_setup_sequence(wdata->ds_clp->cl_session,\n\t\t\t&wdata->args.seq_args,\n\t\t\t&wdata->res.seq_res,\n\t\t\ttask);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs41_setup_sequence",
          "args": [
            "wdata->ds_clp->cl_session",
            "&wdata->args.seq_args",
            "&wdata->res.seq_res",
            "task"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_setup_sequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "707-768",
          "snippet": "int nfs41_setup_sequence(struct nfs4_session *session,\n\t\t\t\tstruct nfs4_sequence_args *args,\n\t\t\t\tstruct nfs4_sequence_res *res,\n\t\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_slot *slot;\n\tstruct nfs4_slot_table *tbl;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\tgoto out_success;\n\n\ttbl = &session->fc_slot_table;\n\n\ttask->tk_timeout = 0;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state) &&\n\t    !args->sa_privileged) {\n\t\t/* The state manager will wait until the slot table is empty */\n\t\tdprintk(\"%s session is draining\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\n\tslot = nfs4_alloc_slot(tbl);\n\tif (IS_ERR(slot)) {\n\t\t/* If out of memory, try again in 1/4 second */\n\t\tif (slot == ERR_PTR(-ENOMEM))\n\t\t\ttask->tk_timeout = HZ >> 2;\n\t\tdprintk(\"<-- %s: no free slots\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\targs->sa_slot = slot;\n\n\tdprintk(\"<-- %s slotid=%u seqid=%u\\n\", __func__,\n\t\t\tslot->slot_nr, slot->seq_nr);\n\n\tres->sr_slot = slot;\n\tres->sr_timestamp = jiffies;\n\tres->sr_status_flags = 0;\n\t/*\n\t * sr_status is only set in decode_sequence, and so will remain\n\t * set to 1 if an rpc level failure occurs.\n\t */\n\tres->sr_status = 1;\n\ttrace_nfs4_setup_sequence(session, args);\nout_success:\n\trpc_call_start(task);\n\treturn 0;\nout_sleep:\n\t/* Privileged tasks are queued with top priority */\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,\n\t\t\t\tNULL, RPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs41_setup_sequence(struct nfs4_session *session,\n\t\t\t\tstruct nfs4_sequence_args *args,\n\t\t\t\tstruct nfs4_sequence_res *res,\n\t\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_slot *slot;\n\tstruct nfs4_slot_table *tbl;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\tgoto out_success;\n\n\ttbl = &session->fc_slot_table;\n\n\ttask->tk_timeout = 0;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state) &&\n\t    !args->sa_privileged) {\n\t\t/* The state manager will wait until the slot table is empty */\n\t\tdprintk(\"%s session is draining\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\n\tslot = nfs4_alloc_slot(tbl);\n\tif (IS_ERR(slot)) {\n\t\t/* If out of memory, try again in 1/4 second */\n\t\tif (slot == ERR_PTR(-ENOMEM))\n\t\t\ttask->tk_timeout = HZ >> 2;\n\t\tdprintk(\"<-- %s: no free slots\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\targs->sa_slot = slot;\n\n\tdprintk(\"<-- %s slotid=%u seqid=%u\\n\", __func__,\n\t\t\tslot->slot_nr, slot->seq_nr);\n\n\tres->sr_slot = slot;\n\tres->sr_timestamp = jiffies;\n\tres->sr_status_flags = 0;\n\t/*\n\t * sr_status is only set in decode_sequence, and so will remain\n\t * set to 1 if an rpc level failure occurs.\n\t */\n\tres->sr_status = 1;\n\ttrace_nfs4_setup_sequence(session, args);\nout_success:\n\trpc_call_start(task);\n\treturn 0;\nout_sleep:\n\t/* Privileged tasks are queued with top priority */\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,\n\t\t\t\tNULL, RPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_commit_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *wdata = data;\n\n\tnfs41_setup_sequence(wdata->ds_clp->cl_session,\n\t\t\t&wdata->args.seq_args,\n\t\t\t&wdata->res.seq_res,\n\t\t\ttask);\n}"
  },
  {
    "function_name": "filelayout_write_count_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "419-424",
    "snippet": "static void filelayout_write_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\trpc_count_iostats(task, NFS_SERVER(hdr->inode)->client->cl_metrics);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_count_iostats",
          "args": [
            "task",
            "NFS_SERVER(hdr->inode)->client->cl_metrics"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "hdr->inode"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_write_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\trpc_count_iostats(task, NFS_SERVER(hdr->inode)->client->cl_metrics);\n}"
  },
  {
    "function_name": "filelayout_write_call_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "405-417",
    "snippet": "static void filelayout_write_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&\n\t    task->tk_status == 0) {\n\t\tnfs41_sequence_done(task, &hdr->res.seq_res);\n\t\treturn;\n\t}\n\n\t/* Note this may cause RPC to be resent */\n\thdr->mds_ops->rpc_call_done(task, data);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hdr->mds_ops->rpc_call_done",
          "args": [
            "task",
            "data"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs41_sequence_done",
          "args": [
            "task",
            "&hdr->res.seq_res"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_sequence_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "593-694",
          "snippet": "int nfs41_sequence_done(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot *slot = res->sr_slot;\n\tstruct nfs_client *clp;\n\tbool interrupted = false;\n\tint ret = 1;\n\n\tif (slot == NULL)\n\t\tgoto out_noaction;\n\t/* don't increment the sequence number if the task wasn't sent */\n\tif (!RPC_WAS_SENT(task))\n\t\tgoto out;\n\n\tsession = slot->table->session;\n\n\tif (slot->interrupted) {\n\t\tslot->interrupted = 0;\n\t\tinterrupted = true;\n\t}\n\n\ttrace_nfs4_sequence_done(session, res);\n\t/* Check the SEQUENCE operation status */\n\tswitch (res->sr_status) {\n\tcase 0:\n\t\t/* Update the slot's sequence and clientid lease timer */\n\t\t++slot->seq_nr;\n\t\tclp = session->clp;\n\t\tdo_renew_lease(clp, res->sr_timestamp);\n\t\t/* Check sequence flags */\n\t\tif (res->sr_status_flags != 0)\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\tnfs41_update_target_slotid(slot->table, slot, res);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * sr_status remains 1 if an RPC level error occurred.\n\t\t * The server may or may not have processed the sequence\n\t\t * operation..\n\t\t * Mark the slot as having hosted an interrupted RPC call.\n\t\t */\n\t\tslot->interrupted = 1;\n\t\tgoto out;\n\tcase -NFS4ERR_DELAY:\n\t\t/* The server detected a resend of the RPC call and\n\t\t * returned NFS4ERR_DELAY as per Section 2.10.6.2\n\t\t * of RFC5661.\n\t\t */\n\t\tdprintk(\"%s: slot=%u seq=%u: Operation in progress\\n\",\n\t\t\t__func__,\n\t\t\tslot->slot_nr,\n\t\t\tslot->seq_nr);\n\t\tgoto out_retry;\n\tcase -NFS4ERR_BADSLOT:\n\t\t/*\n\t\t * The slot id we used was probably retired. Try again\n\t\t * using a different slot id.\n\t\t */\n\t\tgoto retry_nowait;\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t/*\n\t\t * Was the last operation on this sequence interrupted?\n\t\t * If so, retry after bumping the sequence number.\n\t\t */\n\t\tif (interrupted) {\n\t\t\t++slot->seq_nr;\n\t\t\tgoto retry_nowait;\n\t\t}\n\t\t/*\n\t\t * Could this slot have been previously retired?\n\t\t * If so, then the server may be expecting seq_nr = 1!\n\t\t */\n\t\tif (slot->seq_nr != 1) {\n\t\t\tslot->seq_nr = 1;\n\t\t\tgoto retry_nowait;\n\t\t}\n\t\tbreak;\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\t++slot->seq_nr;\n\t\tgoto retry_nowait;\n\tdefault:\n\t\t/* Just update the slot sequence no. */\n\t\t++slot->seq_nr;\n\t}\nout:\n\t/* The session may be reset by one of the error handlers. */\n\tdprintk(\"%s: Error %d free the slot \\n\", __func__, res->sr_status);\n\tnfs41_sequence_free_slot(res);\nout_noaction:\n\treturn ret;\nretry_nowait:\n\tif (rpc_restart_call_prepare(task)) {\n\t\ttask->tk_status = 0;\n\t\tret = 0;\n\t}\n\tgoto out;\nout_retry:\n\tif (!rpc_restart_call(task))\n\t\tgoto out;\n\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define NFS4_POLL_RETRY_MAX\t(15*HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\n#define NFS4_POLL_RETRY_MAX\t(15*HZ)\n\nint nfs41_sequence_done(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot *slot = res->sr_slot;\n\tstruct nfs_client *clp;\n\tbool interrupted = false;\n\tint ret = 1;\n\n\tif (slot == NULL)\n\t\tgoto out_noaction;\n\t/* don't increment the sequence number if the task wasn't sent */\n\tif (!RPC_WAS_SENT(task))\n\t\tgoto out;\n\n\tsession = slot->table->session;\n\n\tif (slot->interrupted) {\n\t\tslot->interrupted = 0;\n\t\tinterrupted = true;\n\t}\n\n\ttrace_nfs4_sequence_done(session, res);\n\t/* Check the SEQUENCE operation status */\n\tswitch (res->sr_status) {\n\tcase 0:\n\t\t/* Update the slot's sequence and clientid lease timer */\n\t\t++slot->seq_nr;\n\t\tclp = session->clp;\n\t\tdo_renew_lease(clp, res->sr_timestamp);\n\t\t/* Check sequence flags */\n\t\tif (res->sr_status_flags != 0)\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\tnfs41_update_target_slotid(slot->table, slot, res);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * sr_status remains 1 if an RPC level error occurred.\n\t\t * The server may or may not have processed the sequence\n\t\t * operation..\n\t\t * Mark the slot as having hosted an interrupted RPC call.\n\t\t */\n\t\tslot->interrupted = 1;\n\t\tgoto out;\n\tcase -NFS4ERR_DELAY:\n\t\t/* The server detected a resend of the RPC call and\n\t\t * returned NFS4ERR_DELAY as per Section 2.10.6.2\n\t\t * of RFC5661.\n\t\t */\n\t\tdprintk(\"%s: slot=%u seq=%u: Operation in progress\\n\",\n\t\t\t__func__,\n\t\t\tslot->slot_nr,\n\t\t\tslot->seq_nr);\n\t\tgoto out_retry;\n\tcase -NFS4ERR_BADSLOT:\n\t\t/*\n\t\t * The slot id we used was probably retired. Try again\n\t\t * using a different slot id.\n\t\t */\n\t\tgoto retry_nowait;\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t/*\n\t\t * Was the last operation on this sequence interrupted?\n\t\t * If so, retry after bumping the sequence number.\n\t\t */\n\t\tif (interrupted) {\n\t\t\t++slot->seq_nr;\n\t\t\tgoto retry_nowait;\n\t\t}\n\t\t/*\n\t\t * Could this slot have been previously retired?\n\t\t * If so, then the server may be expecting seq_nr = 1!\n\t\t */\n\t\tif (slot->seq_nr != 1) {\n\t\t\tslot->seq_nr = 1;\n\t\t\tgoto retry_nowait;\n\t\t}\n\t\tbreak;\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\t++slot->seq_nr;\n\t\tgoto retry_nowait;\n\tdefault:\n\t\t/* Just update the slot sequence no. */\n\t\t++slot->seq_nr;\n\t}\nout:\n\t/* The session may be reset by one of the error handlers. */\n\tdprintk(\"%s: Error %d free the slot \\n\", __func__, res->sr_status);\n\tnfs41_sequence_free_slot(res);\nout_noaction:\n\treturn ret;\nretry_nowait:\n\tif (rpc_restart_call_prepare(task)) {\n\t\ttask->tk_status = 0;\n\t\tret = 0;\n\t}\n\tgoto out;\nout_retry:\n\tif (!rpc_restart_call(task))\n\t\tgoto out;\n\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_IOHDR_REDO",
            "&hdr->flags"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_write_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&\n\t    task->tk_status == 0) {\n\t\tnfs41_sequence_done(task, &hdr->res.seq_res);\n\t\treturn;\n\t}\n\n\t/* Note this may cause RPC to be resent */\n\thdr->mds_ops->rpc_call_done(task, data);\n}"
  },
  {
    "function_name": "filelayout_write_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "381-403",
    "snippet": "static void filelayout_write_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn;\n\t}\n\tif (filelayout_reset_to_mds(hdr->lseg)) {\n\t\tdprintk(\"%s task %u reset io to MDS\\n\", __func__, task->tk_pid);\n\t\tfilelayout_reset_write(hdr);\n\t\trpc_exit(task, 0);\n\t\treturn;\n\t}\n\tif (nfs41_setup_sequence(hdr->ds_clp->cl_session,\n\t\t\t&hdr->args.seq_args,\n\t\t\t&hdr->res.seq_res,\n\t\t\ttask))\n\t\treturn;\n\tif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\n\t\t\thdr->args.lock_context, FMODE_WRITE) == -EIO)\n\t\trpc_exit(task, -EIO); /* lost lock, terminate I/O */\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_exit",
          "args": [
            "task",
            "-EIO"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_set_rw_stateid",
          "args": [
            "&hdr->args.stateid",
            "hdr->args.context",
            "hdr->args.lock_context",
            "FMODE_WRITE"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_rw_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "4110-4120",
          "snippet": "int nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\tconst struct nfs_lockowner *lockowner = NULL;\n\n\tif (l_ctx != NULL)\n\t\tlockowner = &l_ctx->lockowner;\n\treturn nfs4_select_rw_stateid(stateid, ctx->state, fmode, lockowner);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\tconst struct nfs_lockowner *lockowner = NULL;\n\n\tif (l_ctx != NULL)\n\t\tlockowner = &l_ctx->lockowner;\n\treturn nfs4_select_rw_stateid(stateid, ctx->state, fmode, lockowner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_setup_sequence",
          "args": [
            "hdr->ds_clp->cl_session",
            "&hdr->args.seq_args",
            "&hdr->res.seq_res",
            "task"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_setup_sequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "707-768",
          "snippet": "int nfs41_setup_sequence(struct nfs4_session *session,\n\t\t\t\tstruct nfs4_sequence_args *args,\n\t\t\t\tstruct nfs4_sequence_res *res,\n\t\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_slot *slot;\n\tstruct nfs4_slot_table *tbl;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\tgoto out_success;\n\n\ttbl = &session->fc_slot_table;\n\n\ttask->tk_timeout = 0;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state) &&\n\t    !args->sa_privileged) {\n\t\t/* The state manager will wait until the slot table is empty */\n\t\tdprintk(\"%s session is draining\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\n\tslot = nfs4_alloc_slot(tbl);\n\tif (IS_ERR(slot)) {\n\t\t/* If out of memory, try again in 1/4 second */\n\t\tif (slot == ERR_PTR(-ENOMEM))\n\t\t\ttask->tk_timeout = HZ >> 2;\n\t\tdprintk(\"<-- %s: no free slots\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\targs->sa_slot = slot;\n\n\tdprintk(\"<-- %s slotid=%u seqid=%u\\n\", __func__,\n\t\t\tslot->slot_nr, slot->seq_nr);\n\n\tres->sr_slot = slot;\n\tres->sr_timestamp = jiffies;\n\tres->sr_status_flags = 0;\n\t/*\n\t * sr_status is only set in decode_sequence, and so will remain\n\t * set to 1 if an rpc level failure occurs.\n\t */\n\tres->sr_status = 1;\n\ttrace_nfs4_setup_sequence(session, args);\nout_success:\n\trpc_call_start(task);\n\treturn 0;\nout_sleep:\n\t/* Privileged tasks are queued with top priority */\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,\n\t\t\t\tNULL, RPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs41_setup_sequence(struct nfs4_session *session,\n\t\t\t\tstruct nfs4_sequence_args *args,\n\t\t\t\tstruct nfs4_sequence_res *res,\n\t\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_slot *slot;\n\tstruct nfs4_slot_table *tbl;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\tgoto out_success;\n\n\ttbl = &session->fc_slot_table;\n\n\ttask->tk_timeout = 0;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state) &&\n\t    !args->sa_privileged) {\n\t\t/* The state manager will wait until the slot table is empty */\n\t\tdprintk(\"%s session is draining\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\n\tslot = nfs4_alloc_slot(tbl);\n\tif (IS_ERR(slot)) {\n\t\t/* If out of memory, try again in 1/4 second */\n\t\tif (slot == ERR_PTR(-ENOMEM))\n\t\t\ttask->tk_timeout = HZ >> 2;\n\t\tdprintk(\"<-- %s: no free slots\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\targs->sa_slot = slot;\n\n\tdprintk(\"<-- %s slotid=%u seqid=%u\\n\", __func__,\n\t\t\tslot->slot_nr, slot->seq_nr);\n\n\tres->sr_slot = slot;\n\tres->sr_timestamp = jiffies;\n\tres->sr_status_flags = 0;\n\t/*\n\t * sr_status is only set in decode_sequence, and so will remain\n\t * set to 1 if an rpc level failure occurs.\n\t */\n\tres->sr_status = 1;\n\ttrace_nfs4_setup_sequence(session, args);\nout_success:\n\trpc_call_start(task);\n\treturn 0;\nout_sleep:\n\t/* Privileged tasks are queued with top priority */\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,\n\t\t\t\tNULL, RPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_exit",
          "args": [
            "task",
            "0"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filelayout_reset_write",
          "args": [
            "hdr"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_reset_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "87-102",
          "snippet": "static void filelayout_reset_write(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_reset_write(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s task %u reset io to MDS\\n\"",
            "__func__",
            "task->tk_pid"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filelayout_reset_to_mds",
          "args": [
            "hdr->lseg"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_reset_to_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "273-279",
          "snippet": "static bool\nfilelayout_reset_to_mds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_deviceid_node *node = FILELAYOUT_DEVID_NODE(lseg);\n\n\treturn filelayout_test_devid_unavailable(node);\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nfilelayout_reset_to_mds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_deviceid_node *node = FILELAYOUT_DEVID_NODE(lseg);\n\n\treturn filelayout_test_devid_unavailable(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_exit",
          "args": [
            "task",
            "-EIO"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_CONTEXT_BAD",
            "&hdr->args.context->flags"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_write_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn;\n\t}\n\tif (filelayout_reset_to_mds(hdr->lseg)) {\n\t\tdprintk(\"%s task %u reset io to MDS\\n\", __func__, task->tk_pid);\n\t\tfilelayout_reset_write(hdr);\n\t\trpc_exit(task, 0);\n\t\treturn;\n\t}\n\tif (nfs41_setup_sequence(hdr->ds_clp->cl_session,\n\t\t\t&hdr->args.seq_args,\n\t\t\t&hdr->res.seq_res,\n\t\t\ttask))\n\t\treturn;\n\tif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\n\t\t\thdr->args.lock_context, FMODE_WRITE) == -EIO)\n\t\trpc_exit(task, -EIO); /* lost lock, terminate I/O */\n}"
  },
  {
    "function_name": "filelayout_commit_done_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "357-379",
    "snippet": "static int filelayout_commit_done_cb(struct rpc_task *task,\n\t\t\t\t     struct nfs_commit_data *data)\n{\n\tint err;\n\n\ttrace_nfs4_pnfs_commit_ds(data, task->tk_status);\n\terr = filelayout_async_handle_error(task, NULL, data->ds_clp,\n\t\t\t\t\t    data->lseg);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tpnfs_generic_prepare_to_resend_writes(data);\n\t\treturn -EAGAIN;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (data->verf.committed == NFS_UNSTABLE)\n\t\tpnfs_commit_set_layoutcommit(data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_commit_set_layoutcommit",
          "args": [
            "data"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_commit_set_layoutcommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2132-2158",
          "snippet": "void pnfs_commit_set_layoutcommit(struct nfs_commit_data *data)\n{\n\tstruct inode *inode = data->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &data->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(data->lseg);\n\t}\n\tif (data->lwb > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = data->lwb;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, data->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_commit_set_layoutcommit(struct nfs_commit_data *data)\n{\n\tstruct inode *inode = data->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &data->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(data->lseg);\n\t}\n\tif (data->lwb > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = data->lwb;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, data->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_restart_call_prepare",
          "args": [
            "task"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_generic_prepare_to_resend_writes",
          "args": [
            "data"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_prepare_to_resend_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "31-39",
          "snippet": "void pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data)\n{\n\tstruct nfs_page *first = nfs_list_entry(data->pages.next);\n\n\tdata->task.tk_status = 0;\n\tmemcpy(&data->verf.verifier, &first->wb_verf,\n\t       sizeof(data->verf.verifier));\n\tdata->verf.verifier.data[0]++; /* ensure verifier mismatch */\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data)\n{\n\tstruct nfs_page *first = nfs_list_entry(data->pages.next);\n\n\tdata->task.tk_status = 0;\n\tmemcpy(&data->verf.verifier, &first->wb_verf,\n\t       sizeof(data->verf.verifier));\n\tdata->verf.verifier.data[0]++; /* ensure verifier mismatch */\n}"
        }
      },
      {
        "call_info": {
          "callee": "filelayout_async_handle_error",
          "args": [
            "task",
            "NULL",
            "data->ds_clp",
            "data->lseg"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_async_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "121-223",
          "snippet": "static int filelayout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\t struct nfs4_state *state,\n\t\t\t\t\t struct nfs_client *clp,\n\t\t\t\t\t struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs_server *mds_server = NFS_SERVER(inode);\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs_client *mds_client = mds_server->nfs_client;\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t/* MDS state errors */\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_OPENMODE:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\tgoto out_bad_stateid;\n\t\tgoto wait_on_recovery;\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (state != NULL) {\n\t\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\t\tgoto out_bad_stateid;\n\t\t}\n\t\tnfs4_schedule_lease_recovery(mds_client);\n\t\tgoto wait_on_recovery;\n\t/* DS session errors */\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FILELAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t/* Invalidate Layout errors */\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           /* mapped NFS4ERR_STALE */\n\tcase -EBADHANDLE:       /* mapped NFS4ERR_BADHANDLE */\n\tcase -EISDIR:           /* mapped NFS4ERR_ISDIR */\n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t/*\n\t\t * Destroy layout so new i/o will get a new layout.\n\t\t * Layout will not be destroyed until all current lseg\n\t\t * references are put. Mark layout as invalid to resend failed\n\t\t * i/o and all i/o waiting on the slot table to the MDS until\n\t\t * layout is destroyed and a new valid layout is obtained.\n\t\t */\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t/* RPC connection errors */\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tpnfs_error_mark_layout_for_return(inode, lseg);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\t/* fall through */\n\tdefault:\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\nout:\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\nout_bad_stateid:\n\ttask->tk_status = -EIO;\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\n\tgoto out;\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [
            "#define FILELAYOUT_POLL_RETRY_MAX     (15*HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\n#define FILELAYOUT_POLL_RETRY_MAX     (15*HZ)\n\nstatic int filelayout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\t struct nfs4_state *state,\n\t\t\t\t\t struct nfs_client *clp,\n\t\t\t\t\t struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs_server *mds_server = NFS_SERVER(inode);\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs_client *mds_client = mds_server->nfs_client;\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t/* MDS state errors */\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_OPENMODE:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\tgoto out_bad_stateid;\n\t\tgoto wait_on_recovery;\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (state != NULL) {\n\t\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\t\tgoto out_bad_stateid;\n\t\t}\n\t\tnfs4_schedule_lease_recovery(mds_client);\n\t\tgoto wait_on_recovery;\n\t/* DS session errors */\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FILELAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t/* Invalidate Layout errors */\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           /* mapped NFS4ERR_STALE */\n\tcase -EBADHANDLE:       /* mapped NFS4ERR_BADHANDLE */\n\tcase -EISDIR:           /* mapped NFS4ERR_ISDIR */\n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t/*\n\t\t * Destroy layout so new i/o will get a new layout.\n\t\t * Layout will not be destroyed until all current lseg\n\t\t * references are put. Mark layout as invalid to resend failed\n\t\t * i/o and all i/o waiting on the slot table to the MDS until\n\t\t * layout is destroyed and a new valid layout is obtained.\n\t\t */\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t/* RPC connection errors */\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tpnfs_error_mark_layout_for_return(inode, lseg);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\t/* fall through */\n\tdefault:\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\nout:\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\nout_bad_stateid:\n\ttask->tk_status = -EIO;\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs4_pnfs_commit_ds",
          "args": [
            "data",
            "task->tk_status"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int filelayout_commit_done_cb(struct rpc_task *task,\n\t\t\t\t     struct nfs_commit_data *data)\n{\n\tint err;\n\n\ttrace_nfs4_pnfs_commit_ds(data, task->tk_status);\n\terr = filelayout_async_handle_error(task, NULL, data->ds_clp,\n\t\t\t\t\t    data->lseg);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tpnfs_generic_prepare_to_resend_writes(data);\n\t\treturn -EAGAIN;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (data->verf.committed == NFS_UNSTABLE)\n\t\tpnfs_commit_set_layoutcommit(data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "filelayout_write_done_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "335-355",
    "snippet": "static int filelayout_write_done_cb(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tint err;\n\n\ttrace_nfs4_pnfs_write(hdr, task->tk_status);\n\terr = filelayout_async_handle_error(task, hdr->args.context->state,\n\t\t\t\t\t    hdr->ds_clp, hdr->lseg);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tfilelayout_reset_write(hdr);\n\t\treturn task->tk_status;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\tfilelayout_set_layoutcommit(hdr);\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filelayout_set_layoutcommit",
          "args": [
            "hdr"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_set_layoutcommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "253-264",
          "snippet": "static void\nfilelayout_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\n\tif (FILELAYOUT_LSEG(hdr->lseg)->commit_through_mds ||\n\t    hdr->res.verf->committed != NFS_DATA_SYNC)\n\t\treturn;\n\n\tpnfs_set_layoutcommit(hdr);\n\tdprintk(\"%s inode %lu pls_end_pos %lu\\n\", __func__, hdr->inode->i_ino,\n\t\t(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb);\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nfilelayout_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\n\tif (FILELAYOUT_LSEG(hdr->lseg)->commit_through_mds ||\n\t    hdr->res.verf->committed != NFS_DATA_SYNC)\n\t\treturn;\n\n\tpnfs_set_layoutcommit(hdr);\n\tdprintk(\"%s inode %lu pls_end_pos %lu\\n\", __func__, hdr->inode->i_ino,\n\t\t(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_restart_call_prepare",
          "args": [
            "task"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filelayout_reset_write",
          "args": [
            "hdr"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_reset_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "87-102",
          "snippet": "static void filelayout_reset_write(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_reset_write(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filelayout_async_handle_error",
          "args": [
            "task",
            "hdr->args.context->state",
            "hdr->ds_clp",
            "hdr->lseg"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_async_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "121-223",
          "snippet": "static int filelayout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\t struct nfs4_state *state,\n\t\t\t\t\t struct nfs_client *clp,\n\t\t\t\t\t struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs_server *mds_server = NFS_SERVER(inode);\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs_client *mds_client = mds_server->nfs_client;\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t/* MDS state errors */\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_OPENMODE:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\tgoto out_bad_stateid;\n\t\tgoto wait_on_recovery;\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (state != NULL) {\n\t\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\t\tgoto out_bad_stateid;\n\t\t}\n\t\tnfs4_schedule_lease_recovery(mds_client);\n\t\tgoto wait_on_recovery;\n\t/* DS session errors */\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FILELAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t/* Invalidate Layout errors */\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           /* mapped NFS4ERR_STALE */\n\tcase -EBADHANDLE:       /* mapped NFS4ERR_BADHANDLE */\n\tcase -EISDIR:           /* mapped NFS4ERR_ISDIR */\n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t/*\n\t\t * Destroy layout so new i/o will get a new layout.\n\t\t * Layout will not be destroyed until all current lseg\n\t\t * references are put. Mark layout as invalid to resend failed\n\t\t * i/o and all i/o waiting on the slot table to the MDS until\n\t\t * layout is destroyed and a new valid layout is obtained.\n\t\t */\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t/* RPC connection errors */\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tpnfs_error_mark_layout_for_return(inode, lseg);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\t/* fall through */\n\tdefault:\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\nout:\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\nout_bad_stateid:\n\ttask->tk_status = -EIO;\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\n\tgoto out;\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [
            "#define FILELAYOUT_POLL_RETRY_MAX     (15*HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\n#define FILELAYOUT_POLL_RETRY_MAX     (15*HZ)\n\nstatic int filelayout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\t struct nfs4_state *state,\n\t\t\t\t\t struct nfs_client *clp,\n\t\t\t\t\t struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs_server *mds_server = NFS_SERVER(inode);\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs_client *mds_client = mds_server->nfs_client;\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t/* MDS state errors */\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_OPENMODE:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\tgoto out_bad_stateid;\n\t\tgoto wait_on_recovery;\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (state != NULL) {\n\t\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\t\tgoto out_bad_stateid;\n\t\t}\n\t\tnfs4_schedule_lease_recovery(mds_client);\n\t\tgoto wait_on_recovery;\n\t/* DS session errors */\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FILELAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t/* Invalidate Layout errors */\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           /* mapped NFS4ERR_STALE */\n\tcase -EBADHANDLE:       /* mapped NFS4ERR_BADHANDLE */\n\tcase -EISDIR:           /* mapped NFS4ERR_ISDIR */\n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t/*\n\t\t * Destroy layout so new i/o will get a new layout.\n\t\t * Layout will not be destroyed until all current lseg\n\t\t * references are put. Mark layout as invalid to resend failed\n\t\t * i/o and all i/o waiting on the slot table to the MDS until\n\t\t * layout is destroyed and a new valid layout is obtained.\n\t\t */\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t/* RPC connection errors */\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tpnfs_error_mark_layout_for_return(inode, lseg);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\t/* fall through */\n\tdefault:\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\nout:\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\nout_bad_stateid:\n\ttask->tk_status = -EIO;\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs4_pnfs_write",
          "args": [
            "hdr",
            "task->tk_status"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int filelayout_write_done_cb(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tint err;\n\n\ttrace_nfs4_pnfs_write(hdr, task->tk_status);\n\terr = filelayout_async_handle_error(task, hdr->args.context->state,\n\t\t\t\t\t    hdr->ds_clp, hdr->lseg);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tfilelayout_reset_write(hdr);\n\t\treturn task->tk_status;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\tfilelayout_set_layoutcommit(hdr);\n\treturn 0;\n}"
  },
  {
    "function_name": "filelayout_read_count_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "328-333",
    "snippet": "static void filelayout_read_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\trpc_count_iostats(task, NFS_SERVER(hdr->inode)->client->cl_metrics);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_count_iostats",
          "args": [
            "task",
            "NFS_SERVER(hdr->inode)->client->cl_metrics"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "hdr->inode"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_read_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\trpc_count_iostats(task, NFS_SERVER(hdr->inode)->client->cl_metrics);\n}"
  },
  {
    "function_name": "filelayout_read_call_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "312-326",
    "snippet": "static void filelayout_read_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tdprintk(\"--> %s task->tk_status %d\\n\", __func__, task->tk_status);\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&\n\t    task->tk_status == 0) {\n\t\tnfs41_sequence_done(task, &hdr->res.seq_res);\n\t\treturn;\n\t}\n\n\t/* Note this may cause RPC to be resent */\n\thdr->mds_ops->rpc_call_done(task, data);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hdr->mds_ops->rpc_call_done",
          "args": [
            "task",
            "data"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs41_sequence_done",
          "args": [
            "task",
            "&hdr->res.seq_res"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_sequence_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "593-694",
          "snippet": "int nfs41_sequence_done(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot *slot = res->sr_slot;\n\tstruct nfs_client *clp;\n\tbool interrupted = false;\n\tint ret = 1;\n\n\tif (slot == NULL)\n\t\tgoto out_noaction;\n\t/* don't increment the sequence number if the task wasn't sent */\n\tif (!RPC_WAS_SENT(task))\n\t\tgoto out;\n\n\tsession = slot->table->session;\n\n\tif (slot->interrupted) {\n\t\tslot->interrupted = 0;\n\t\tinterrupted = true;\n\t}\n\n\ttrace_nfs4_sequence_done(session, res);\n\t/* Check the SEQUENCE operation status */\n\tswitch (res->sr_status) {\n\tcase 0:\n\t\t/* Update the slot's sequence and clientid lease timer */\n\t\t++slot->seq_nr;\n\t\tclp = session->clp;\n\t\tdo_renew_lease(clp, res->sr_timestamp);\n\t\t/* Check sequence flags */\n\t\tif (res->sr_status_flags != 0)\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\tnfs41_update_target_slotid(slot->table, slot, res);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * sr_status remains 1 if an RPC level error occurred.\n\t\t * The server may or may not have processed the sequence\n\t\t * operation..\n\t\t * Mark the slot as having hosted an interrupted RPC call.\n\t\t */\n\t\tslot->interrupted = 1;\n\t\tgoto out;\n\tcase -NFS4ERR_DELAY:\n\t\t/* The server detected a resend of the RPC call and\n\t\t * returned NFS4ERR_DELAY as per Section 2.10.6.2\n\t\t * of RFC5661.\n\t\t */\n\t\tdprintk(\"%s: slot=%u seq=%u: Operation in progress\\n\",\n\t\t\t__func__,\n\t\t\tslot->slot_nr,\n\t\t\tslot->seq_nr);\n\t\tgoto out_retry;\n\tcase -NFS4ERR_BADSLOT:\n\t\t/*\n\t\t * The slot id we used was probably retired. Try again\n\t\t * using a different slot id.\n\t\t */\n\t\tgoto retry_nowait;\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t/*\n\t\t * Was the last operation on this sequence interrupted?\n\t\t * If so, retry after bumping the sequence number.\n\t\t */\n\t\tif (interrupted) {\n\t\t\t++slot->seq_nr;\n\t\t\tgoto retry_nowait;\n\t\t}\n\t\t/*\n\t\t * Could this slot have been previously retired?\n\t\t * If so, then the server may be expecting seq_nr = 1!\n\t\t */\n\t\tif (slot->seq_nr != 1) {\n\t\t\tslot->seq_nr = 1;\n\t\t\tgoto retry_nowait;\n\t\t}\n\t\tbreak;\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\t++slot->seq_nr;\n\t\tgoto retry_nowait;\n\tdefault:\n\t\t/* Just update the slot sequence no. */\n\t\t++slot->seq_nr;\n\t}\nout:\n\t/* The session may be reset by one of the error handlers. */\n\tdprintk(\"%s: Error %d free the slot \\n\", __func__, res->sr_status);\n\tnfs41_sequence_free_slot(res);\nout_noaction:\n\treturn ret;\nretry_nowait:\n\tif (rpc_restart_call_prepare(task)) {\n\t\ttask->tk_status = 0;\n\t\tret = 0;\n\t}\n\tgoto out;\nout_retry:\n\tif (!rpc_restart_call(task))\n\t\tgoto out;\n\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define NFS4_POLL_RETRY_MAX\t(15*HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\n#define NFS4_POLL_RETRY_MAX\t(15*HZ)\n\nint nfs41_sequence_done(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot *slot = res->sr_slot;\n\tstruct nfs_client *clp;\n\tbool interrupted = false;\n\tint ret = 1;\n\n\tif (slot == NULL)\n\t\tgoto out_noaction;\n\t/* don't increment the sequence number if the task wasn't sent */\n\tif (!RPC_WAS_SENT(task))\n\t\tgoto out;\n\n\tsession = slot->table->session;\n\n\tif (slot->interrupted) {\n\t\tslot->interrupted = 0;\n\t\tinterrupted = true;\n\t}\n\n\ttrace_nfs4_sequence_done(session, res);\n\t/* Check the SEQUENCE operation status */\n\tswitch (res->sr_status) {\n\tcase 0:\n\t\t/* Update the slot's sequence and clientid lease timer */\n\t\t++slot->seq_nr;\n\t\tclp = session->clp;\n\t\tdo_renew_lease(clp, res->sr_timestamp);\n\t\t/* Check sequence flags */\n\t\tif (res->sr_status_flags != 0)\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\tnfs41_update_target_slotid(slot->table, slot, res);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * sr_status remains 1 if an RPC level error occurred.\n\t\t * The server may or may not have processed the sequence\n\t\t * operation..\n\t\t * Mark the slot as having hosted an interrupted RPC call.\n\t\t */\n\t\tslot->interrupted = 1;\n\t\tgoto out;\n\tcase -NFS4ERR_DELAY:\n\t\t/* The server detected a resend of the RPC call and\n\t\t * returned NFS4ERR_DELAY as per Section 2.10.6.2\n\t\t * of RFC5661.\n\t\t */\n\t\tdprintk(\"%s: slot=%u seq=%u: Operation in progress\\n\",\n\t\t\t__func__,\n\t\t\tslot->slot_nr,\n\t\t\tslot->seq_nr);\n\t\tgoto out_retry;\n\tcase -NFS4ERR_BADSLOT:\n\t\t/*\n\t\t * The slot id we used was probably retired. Try again\n\t\t * using a different slot id.\n\t\t */\n\t\tgoto retry_nowait;\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t/*\n\t\t * Was the last operation on this sequence interrupted?\n\t\t * If so, retry after bumping the sequence number.\n\t\t */\n\t\tif (interrupted) {\n\t\t\t++slot->seq_nr;\n\t\t\tgoto retry_nowait;\n\t\t}\n\t\t/*\n\t\t * Could this slot have been previously retired?\n\t\t * If so, then the server may be expecting seq_nr = 1!\n\t\t */\n\t\tif (slot->seq_nr != 1) {\n\t\t\tslot->seq_nr = 1;\n\t\t\tgoto retry_nowait;\n\t\t}\n\t\tbreak;\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\t++slot->seq_nr;\n\t\tgoto retry_nowait;\n\tdefault:\n\t\t/* Just update the slot sequence no. */\n\t\t++slot->seq_nr;\n\t}\nout:\n\t/* The session may be reset by one of the error handlers. */\n\tdprintk(\"%s: Error %d free the slot \\n\", __func__, res->sr_status);\n\tnfs41_sequence_free_slot(res);\nout_noaction:\n\treturn ret;\nretry_nowait:\n\tif (rpc_restart_call_prepare(task)) {\n\t\ttask->tk_status = 0;\n\t\tret = 0;\n\t}\n\tgoto out;\nout_retry:\n\tif (!rpc_restart_call(task))\n\t\tgoto out;\n\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_IOHDR_REDO",
            "&hdr->flags"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s task->tk_status %d\\n\"",
            "__func__",
            "task->tk_status"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_read_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tdprintk(\"--> %s task->tk_status %d\\n\", __func__, task->tk_status);\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&\n\t    task->tk_status == 0) {\n\t\tnfs41_sequence_done(task, &hdr->res.seq_res);\n\t\treturn;\n\t}\n\n\t/* Note this may cause RPC to be resent */\n\thdr->mds_ops->rpc_call_done(task, data);\n}"
  },
  {
    "function_name": "filelayout_read_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "286-310",
    "snippet": "static void filelayout_read_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn;\n\t}\n\tif (filelayout_reset_to_mds(hdr->lseg)) {\n\t\tdprintk(\"%s task %u reset io to MDS\\n\", __func__, task->tk_pid);\n\t\tfilelayout_reset_read(hdr);\n\t\trpc_exit(task, 0);\n\t\treturn;\n\t}\n\thdr->pgio_done_cb = filelayout_read_done_cb;\n\n\tif (nfs41_setup_sequence(hdr->ds_clp->cl_session,\n\t\t\t&hdr->args.seq_args,\n\t\t\t&hdr->res.seq_res,\n\t\t\ttask))\n\t\treturn;\n\tif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\n\t\t\thdr->args.lock_context, FMODE_READ) == -EIO)\n\t\trpc_exit(task, -EIO); /* lost lock, terminate I/O */\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_exit",
          "args": [
            "task",
            "-EIO"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_set_rw_stateid",
          "args": [
            "&hdr->args.stateid",
            "hdr->args.context",
            "hdr->args.lock_context",
            "FMODE_READ"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_rw_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "4110-4120",
          "snippet": "int nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\tconst struct nfs_lockowner *lockowner = NULL;\n\n\tif (l_ctx != NULL)\n\t\tlockowner = &l_ctx->lockowner;\n\treturn nfs4_select_rw_stateid(stateid, ctx->state, fmode, lockowner);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\tconst struct nfs_lockowner *lockowner = NULL;\n\n\tif (l_ctx != NULL)\n\t\tlockowner = &l_ctx->lockowner;\n\treturn nfs4_select_rw_stateid(stateid, ctx->state, fmode, lockowner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_setup_sequence",
          "args": [
            "hdr->ds_clp->cl_session",
            "&hdr->args.seq_args",
            "&hdr->res.seq_res",
            "task"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_setup_sequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "707-768",
          "snippet": "int nfs41_setup_sequence(struct nfs4_session *session,\n\t\t\t\tstruct nfs4_sequence_args *args,\n\t\t\t\tstruct nfs4_sequence_res *res,\n\t\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_slot *slot;\n\tstruct nfs4_slot_table *tbl;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\tgoto out_success;\n\n\ttbl = &session->fc_slot_table;\n\n\ttask->tk_timeout = 0;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state) &&\n\t    !args->sa_privileged) {\n\t\t/* The state manager will wait until the slot table is empty */\n\t\tdprintk(\"%s session is draining\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\n\tslot = nfs4_alloc_slot(tbl);\n\tif (IS_ERR(slot)) {\n\t\t/* If out of memory, try again in 1/4 second */\n\t\tif (slot == ERR_PTR(-ENOMEM))\n\t\t\ttask->tk_timeout = HZ >> 2;\n\t\tdprintk(\"<-- %s: no free slots\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\targs->sa_slot = slot;\n\n\tdprintk(\"<-- %s slotid=%u seqid=%u\\n\", __func__,\n\t\t\tslot->slot_nr, slot->seq_nr);\n\n\tres->sr_slot = slot;\n\tres->sr_timestamp = jiffies;\n\tres->sr_status_flags = 0;\n\t/*\n\t * sr_status is only set in decode_sequence, and so will remain\n\t * set to 1 if an rpc level failure occurs.\n\t */\n\tres->sr_status = 1;\n\ttrace_nfs4_setup_sequence(session, args);\nout_success:\n\trpc_call_start(task);\n\treturn 0;\nout_sleep:\n\t/* Privileged tasks are queued with top priority */\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,\n\t\t\t\tNULL, RPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs41_setup_sequence(struct nfs4_session *session,\n\t\t\t\tstruct nfs4_sequence_args *args,\n\t\t\t\tstruct nfs4_sequence_res *res,\n\t\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_slot *slot;\n\tstruct nfs4_slot_table *tbl;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\tgoto out_success;\n\n\ttbl = &session->fc_slot_table;\n\n\ttask->tk_timeout = 0;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state) &&\n\t    !args->sa_privileged) {\n\t\t/* The state manager will wait until the slot table is empty */\n\t\tdprintk(\"%s session is draining\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\n\tslot = nfs4_alloc_slot(tbl);\n\tif (IS_ERR(slot)) {\n\t\t/* If out of memory, try again in 1/4 second */\n\t\tif (slot == ERR_PTR(-ENOMEM))\n\t\t\ttask->tk_timeout = HZ >> 2;\n\t\tdprintk(\"<-- %s: no free slots\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\targs->sa_slot = slot;\n\n\tdprintk(\"<-- %s slotid=%u seqid=%u\\n\", __func__,\n\t\t\tslot->slot_nr, slot->seq_nr);\n\n\tres->sr_slot = slot;\n\tres->sr_timestamp = jiffies;\n\tres->sr_status_flags = 0;\n\t/*\n\t * sr_status is only set in decode_sequence, and so will remain\n\t * set to 1 if an rpc level failure occurs.\n\t */\n\tres->sr_status = 1;\n\ttrace_nfs4_setup_sequence(session, args);\nout_success:\n\trpc_call_start(task);\n\treturn 0;\nout_sleep:\n\t/* Privileged tasks are queued with top priority */\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,\n\t\t\t\tNULL, RPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_exit",
          "args": [
            "task",
            "0"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filelayout_reset_read",
          "args": [
            "hdr"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_reset_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "104-119",
          "snippet": "static void filelayout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s task %u reset io to MDS\\n\"",
            "__func__",
            "task->tk_pid"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filelayout_reset_to_mds",
          "args": [
            "hdr->lseg"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_reset_to_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "273-279",
          "snippet": "static bool\nfilelayout_reset_to_mds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_deviceid_node *node = FILELAYOUT_DEVID_NODE(lseg);\n\n\treturn filelayout_test_devid_unavailable(node);\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nfilelayout_reset_to_mds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_deviceid_node *node = FILELAYOUT_DEVID_NODE(lseg);\n\n\treturn filelayout_test_devid_unavailable(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_exit",
          "args": [
            "task",
            "-EIO"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_CONTEXT_BAD",
            "&hdr->args.context->flags"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_read_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn;\n\t}\n\tif (filelayout_reset_to_mds(hdr->lseg)) {\n\t\tdprintk(\"%s task %u reset io to MDS\\n\", __func__, task->tk_pid);\n\t\tfilelayout_reset_read(hdr);\n\t\trpc_exit(task, 0);\n\t\treturn;\n\t}\n\thdr->pgio_done_cb = filelayout_read_done_cb;\n\n\tif (nfs41_setup_sequence(hdr->ds_clp->cl_session,\n\t\t\t&hdr->args.seq_args,\n\t\t\t&hdr->res.seq_res,\n\t\t\ttask))\n\t\treturn;\n\tif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\n\t\t\thdr->args.lock_context, FMODE_READ) == -EIO)\n\t\trpc_exit(task, -EIO); /* lost lock, terminate I/O */\n}"
  },
  {
    "function_name": "filelayout_reset_to_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "273-279",
    "snippet": "static bool\nfilelayout_reset_to_mds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_deviceid_node *node = FILELAYOUT_DEVID_NODE(lseg);\n\n\treturn filelayout_test_devid_unavailable(node);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filelayout_test_devid_unavailable",
          "args": [
            "node"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_test_devid_unavailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "266-271",
          "snippet": "bool\nfilelayout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn filelayout_test_devid_invalid(node) ||\n\t\tnfs4_test_deviceid_unavailable(node);\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nbool\nfilelayout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn filelayout_test_devid_invalid(node) ||\n\t\tnfs4_test_deviceid_unavailable(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_DEVID_NODE",
          "args": [
            "lseg"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_DEVID_NODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "88-92",
          "snippet": "static inline struct nfs4_deviceid_node *\nFILELAYOUT_DEVID_NODE(struct pnfs_layout_segment *lseg)\n{\n\treturn &FILELAYOUT_LSEG(lseg)->dsaddr->id_node;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_deviceid_node *\nFILELAYOUT_DEVID_NODE(struct pnfs_layout_segment *lseg)\n{\n\treturn &FILELAYOUT_LSEG(lseg)->dsaddr->id_node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nfilelayout_reset_to_mds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_deviceid_node *node = FILELAYOUT_DEVID_NODE(lseg);\n\n\treturn filelayout_test_devid_unavailable(node);\n}"
  },
  {
    "function_name": "filelayout_test_devid_unavailable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "266-271",
    "snippet": "bool\nfilelayout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn filelayout_test_devid_invalid(node) ||\n\t\tnfs4_test_deviceid_unavailable(node);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_test_deviceid_unavailable",
          "args": [
            "node"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_test_deviceid_unavailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "289-302",
          "snippet": "bool\nnfs4_test_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tif (test_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags)) {\n\t\tunsigned long start, end;\n\n\t\tend = jiffies;\n\t\tstart = end - PNFS_DEVICE_RETRY_TIMEOUT;\n\t\tif (time_in_range(node->timestamp_unavailable, start, end))\n\t\t\treturn true;\n\t\tclear_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define PNFS_DEVICE_RETRY_TIMEOUT (120*HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\n#define PNFS_DEVICE_RETRY_TIMEOUT (120*HZ)\n\nbool\nnfs4_test_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tif (test_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags)) {\n\t\tunsigned long start, end;\n\n\t\tend = jiffies;\n\t\tstart = end - PNFS_DEVICE_RETRY_TIMEOUT;\n\t\tif (time_in_range(node->timestamp_unavailable, start, end))\n\t\t\treturn true;\n\t\tclear_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filelayout_test_devid_invalid",
          "args": [
            "node"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_test_devid_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "94-98",
          "snippet": "static inline bool\nfilelayout_test_devid_invalid(struct nfs4_deviceid_node *node)\n{\n\treturn test_bit(NFS_DEVICEID_INVALID, &node->flags);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline bool\nfilelayout_test_devid_invalid(struct nfs4_deviceid_node *node)\n{\n\treturn test_bit(NFS_DEVICEID_INVALID, &node->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nbool\nfilelayout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn filelayout_test_devid_invalid(node) ||\n\t\tnfs4_test_deviceid_unavailable(node);\n}"
  },
  {
    "function_name": "filelayout_set_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "253-264",
    "snippet": "static void\nfilelayout_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\n\tif (FILELAYOUT_LSEG(hdr->lseg)->commit_through_mds ||\n\t    hdr->res.verf->committed != NFS_DATA_SYNC)\n\t\treturn;\n\n\tpnfs_set_layoutcommit(hdr);\n\tdprintk(\"%s inode %lu pls_end_pos %lu\\n\", __func__, hdr->inode->i_ino,\n\t\t(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb);\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s inode %lu pls_end_pos %lu\\n\"",
            "__func__",
            "hdr->inode->i_ino",
            "(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "hdr->inode"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_set_layoutcommit",
          "args": [
            "hdr"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_set_layoutcommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2101-2129",
          "snippet": "void\npnfs_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos = hdr->mds_offset + hdr->res.count;\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &hdr->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(hdr->lseg);\n\t}\n\tif (end_pos > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = end_pos;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, hdr->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos = hdr->mds_offset + hdr->res.count;\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &hdr->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(hdr->lseg);\n\t}\n\tif (end_pos > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = end_pos;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, hdr->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_LSEG",
          "args": [
            "hdr->lseg"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "80-86",
          "snippet": "static inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nfilelayout_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\n\tif (FILELAYOUT_LSEG(hdr->lseg)->commit_through_mds ||\n\t    hdr->res.verf->committed != NFS_DATA_SYNC)\n\t\treturn;\n\n\tpnfs_set_layoutcommit(hdr);\n\tdprintk(\"%s inode %lu pls_end_pos %lu\\n\", __func__, hdr->inode->i_ino,\n\t\t(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb);\n}"
  },
  {
    "function_name": "filelayout_read_done_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "227-246",
    "snippet": "static int filelayout_read_done_cb(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tint err;\n\n\ttrace_nfs4_pnfs_read(hdr, task->tk_status);\n\terr = filelayout_async_handle_error(task, hdr->args.context->state,\n\t\t\t\t\t    hdr->ds_clp, hdr->lseg);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tfilelayout_reset_read(hdr);\n\t\treturn task->tk_status;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_restart_call_prepare",
          "args": [
            "task"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filelayout_reset_read",
          "args": [
            "hdr"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_reset_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "104-119",
          "snippet": "static void filelayout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filelayout_async_handle_error",
          "args": [
            "task",
            "hdr->args.context->state",
            "hdr->ds_clp",
            "hdr->lseg"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_async_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "121-223",
          "snippet": "static int filelayout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\t struct nfs4_state *state,\n\t\t\t\t\t struct nfs_client *clp,\n\t\t\t\t\t struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs_server *mds_server = NFS_SERVER(inode);\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs_client *mds_client = mds_server->nfs_client;\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t/* MDS state errors */\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_OPENMODE:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\tgoto out_bad_stateid;\n\t\tgoto wait_on_recovery;\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (state != NULL) {\n\t\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\t\tgoto out_bad_stateid;\n\t\t}\n\t\tnfs4_schedule_lease_recovery(mds_client);\n\t\tgoto wait_on_recovery;\n\t/* DS session errors */\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FILELAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t/* Invalidate Layout errors */\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           /* mapped NFS4ERR_STALE */\n\tcase -EBADHANDLE:       /* mapped NFS4ERR_BADHANDLE */\n\tcase -EISDIR:           /* mapped NFS4ERR_ISDIR */\n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t/*\n\t\t * Destroy layout so new i/o will get a new layout.\n\t\t * Layout will not be destroyed until all current lseg\n\t\t * references are put. Mark layout as invalid to resend failed\n\t\t * i/o and all i/o waiting on the slot table to the MDS until\n\t\t * layout is destroyed and a new valid layout is obtained.\n\t\t */\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t/* RPC connection errors */\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tpnfs_error_mark_layout_for_return(inode, lseg);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\t/* fall through */\n\tdefault:\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\nout:\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\nout_bad_stateid:\n\ttask->tk_status = -EIO;\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\n\tgoto out;\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [
            "#define FILELAYOUT_POLL_RETRY_MAX     (15*HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\n#define FILELAYOUT_POLL_RETRY_MAX     (15*HZ)\n\nstatic int filelayout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\t struct nfs4_state *state,\n\t\t\t\t\t struct nfs_client *clp,\n\t\t\t\t\t struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs_server *mds_server = NFS_SERVER(inode);\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs_client *mds_client = mds_server->nfs_client;\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t/* MDS state errors */\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_OPENMODE:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\tgoto out_bad_stateid;\n\t\tgoto wait_on_recovery;\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (state != NULL) {\n\t\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\t\tgoto out_bad_stateid;\n\t\t}\n\t\tnfs4_schedule_lease_recovery(mds_client);\n\t\tgoto wait_on_recovery;\n\t/* DS session errors */\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FILELAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t/* Invalidate Layout errors */\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           /* mapped NFS4ERR_STALE */\n\tcase -EBADHANDLE:       /* mapped NFS4ERR_BADHANDLE */\n\tcase -EISDIR:           /* mapped NFS4ERR_ISDIR */\n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t/*\n\t\t * Destroy layout so new i/o will get a new layout.\n\t\t * Layout will not be destroyed until all current lseg\n\t\t * references are put. Mark layout as invalid to resend failed\n\t\t * i/o and all i/o waiting on the slot table to the MDS until\n\t\t * layout is destroyed and a new valid layout is obtained.\n\t\t */\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t/* RPC connection errors */\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tpnfs_error_mark_layout_for_return(inode, lseg);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\t/* fall through */\n\tdefault:\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\nout:\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\nout_bad_stateid:\n\ttask->tk_status = -EIO;\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs4_pnfs_read",
          "args": [
            "hdr",
            "task->tk_status"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int filelayout_read_done_cb(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tint err;\n\n\ttrace_nfs4_pnfs_read(hdr, task->tk_status);\n\terr = filelayout_async_handle_error(task, hdr->args.context->state,\n\t\t\t\t\t    hdr->ds_clp, hdr->lseg);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tfilelayout_reset_read(hdr);\n\t\treturn task->tk_status;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "filelayout_async_handle_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "121-223",
    "snippet": "static int filelayout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\t struct nfs4_state *state,\n\t\t\t\t\t struct nfs_client *clp,\n\t\t\t\t\t struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs_server *mds_server = NFS_SERVER(inode);\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs_client *mds_client = mds_server->nfs_client;\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t/* MDS state errors */\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_OPENMODE:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\tgoto out_bad_stateid;\n\t\tgoto wait_on_recovery;\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (state != NULL) {\n\t\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\t\tgoto out_bad_stateid;\n\t\t}\n\t\tnfs4_schedule_lease_recovery(mds_client);\n\t\tgoto wait_on_recovery;\n\t/* DS session errors */\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FILELAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t/* Invalidate Layout errors */\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           /* mapped NFS4ERR_STALE */\n\tcase -EBADHANDLE:       /* mapped NFS4ERR_BADHANDLE */\n\tcase -EISDIR:           /* mapped NFS4ERR_ISDIR */\n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t/*\n\t\t * Destroy layout so new i/o will get a new layout.\n\t\t * Layout will not be destroyed until all current lseg\n\t\t * references are put. Mark layout as invalid to resend failed\n\t\t * i/o and all i/o waiting on the slot table to the MDS until\n\t\t * layout is destroyed and a new valid layout is obtained.\n\t\t */\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t/* RPC connection errors */\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tpnfs_error_mark_layout_for_return(inode, lseg);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\t/* fall through */\n\tdefault:\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\nout:\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\nout_bad_stateid:\n\ttask->tk_status = -EIO;\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\n\tgoto out;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [
      "#define FILELAYOUT_POLL_RETRY_MAX     (15*HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_wake_up_queued_task",
          "args": [
            "&mds_client->cl_rpcwaitq",
            "task"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS4CLNT_MANAGER_RUNNING",
            "&mds_client->cl_state"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_sleep_on",
          "args": [
            "&mds_client->cl_rpcwaitq",
            "task",
            "NULL"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Retry through MDS. Error %d\\n\"",
            "__func__",
            "task->tk_status"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_wake_up",
          "args": [
            "&tbl->slot_tbl_waitq"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_error_mark_layout_for_return",
          "args": [
            "inode",
            "lseg"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_error_mark_layout_for_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1679-1707",
          "snippet": "void pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\n\tint iomode = pnfs_iomode_to_fail_bit(lseg->pls_range.iomode);\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = lseg->pls_range.iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(free_me);\n\n\tspin_lock(&inode->i_lock);\n\t/* set failure bit so that pnfs path will be retried later */\n\tpnfs_layout_set_fail_bit(lo, iomode);\n\tset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tif (lo->plh_return_iomode == 0)\n\t\tlo->plh_return_iomode = range.iomode;\n\telse if (lo->plh_return_iomode != range.iomode)\n\t\tlo->plh_return_iomode = IOMODE_ANY;\n\t/*\n\t * mark all matching lsegs so that we are sure to have no live\n\t * segments at hand when sending layoutreturn. See pnfs_put_lseg()\n\t * for how it works.\n\t */\n\tpnfs_mark_matching_lsegs_return(lo, &free_me, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\n\tint iomode = pnfs_iomode_to_fail_bit(lseg->pls_range.iomode);\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = lseg->pls_range.iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(free_me);\n\n\tspin_lock(&inode->i_lock);\n\t/* set failure bit so that pnfs path will be retried later */\n\tpnfs_layout_set_fail_bit(lo, iomode);\n\tset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tif (lo->plh_return_iomode == 0)\n\t\tlo->plh_return_iomode = range.iomode;\n\telse if (lo->plh_return_iomode != range.iomode)\n\t\tlo->plh_return_iomode = IOMODE_ANY;\n\t/*\n\t * mark all matching lsegs so that we are sure to have no live\n\t * segments at hand when sending layoutreturn. See pnfs_put_lseg()\n\t * for how it works.\n\t */\n\tpnfs_mark_matching_lsegs_return(lo, &free_me, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_mark_deviceid_unavailable",
          "args": [
            "devid"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_mark_deviceid_unavailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "281-286",
          "snippet": "void\nnfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tnode->timestamp_unavailable = jiffies;\n\tset_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nvoid\nnfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tnode->timestamp_unavailable = jiffies;\n\tset_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s DS connection error %d\\n\"",
            "__func__",
            "task->tk_status"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_wake_up",
          "args": [
            "&tbl->slot_tbl_waitq"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_destroy_layout",
          "args": [
            "NFS_I(inode)"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_destroy_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "535-537",
          "snippet": "static inline void pnfs_destroy_layout(struct nfs_inode *nfsi)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_destroy_layout(struct nfs_inode *nfsi)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Invalid layout error %d\\n\"",
            "__func__",
            "task->tk_status"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_delay",
          "args": [
            "task",
            "FILELAYOUT_POLL_RETRY_MAX"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_schedule_session_recovery",
          "args": [
            "clp->cl_session",
            "task->tk_status"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_session_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2138-2150",
          "snippet": "void nfs4_schedule_session_recovery(struct nfs4_session *session, int err)\n{\n\tstruct nfs_client *clp = session->clp;\n\n\tswitch (err) {\n\tdefault:\n\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t}\n\tnfs4_schedule_lease_recovery(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_schedule_session_recovery(struct nfs4_session *session, int err)\n{\n\tstruct nfs_client *clp = session->clp;\n\n\tswitch (err) {\n\tdefault:\n\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t}\n\tnfs4_schedule_lease_recovery(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\"",
            "__func__",
            "task->tk_status",
            "clp->cl_exchange_flags"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_schedule_lease_recovery",
          "args": [
            "mds_client"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_lease_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1177-1186",
          "snippet": "void nfs4_schedule_lease_recovery(struct nfs_client *clp)\n{\n\tif (!clp)\n\t\treturn;\n\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tdprintk(\"%s: scheduling lease recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_schedule_lease_recovery(struct nfs_client *clp)\n{\n\tif (!clp)\n\t\treturn;\n\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tdprintk(\"%s: scheduling lease recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_schedule_stateid_recovery",
          "args": [
            "mds_server",
            "state"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_stateid_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1322-1333",
          "snippet": "int nfs4_schedule_stateid_recovery(const struct nfs_server *server, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!nfs4_valid_open_stateid(state))\n\t\treturn -EBADF;\n\tnfs4_state_mark_reclaim_nograce(clp, state);\n\tdprintk(\"%s: scheduling stateid recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_schedule_stateid_recovery(const struct nfs_server *server, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!nfs4_valid_open_stateid(state))\n\t\treturn -EBADF;\n\tnfs4_state_mark_reclaim_nograce(clp, state);\n\tdprintk(\"%s: scheduling stateid recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_DEVID_NODE",
          "args": [
            "lseg"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_DEVID_NODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "88-92",
          "snippet": "static inline struct nfs4_deviceid_node *\nFILELAYOUT_DEVID_NODE(struct pnfs_layout_segment *lseg)\n{\n\treturn &FILELAYOUT_LSEG(lseg)->dsaddr->id_node;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_deviceid_node *\nFILELAYOUT_DEVID_NODE(struct pnfs_layout_segment *lseg)\n{\n\treturn &FILELAYOUT_LSEG(lseg)->dsaddr->id_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\n#define FILELAYOUT_POLL_RETRY_MAX     (15*HZ)\n\nstatic int filelayout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\t struct nfs4_state *state,\n\t\t\t\t\t struct nfs_client *clp,\n\t\t\t\t\t struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs_server *mds_server = NFS_SERVER(inode);\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs_client *mds_client = mds_server->nfs_client;\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t/* MDS state errors */\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_OPENMODE:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\tgoto out_bad_stateid;\n\t\tgoto wait_on_recovery;\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (state != NULL) {\n\t\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\t\tgoto out_bad_stateid;\n\t\t}\n\t\tnfs4_schedule_lease_recovery(mds_client);\n\t\tgoto wait_on_recovery;\n\t/* DS session errors */\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FILELAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t/* Invalidate Layout errors */\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           /* mapped NFS4ERR_STALE */\n\tcase -EBADHANDLE:       /* mapped NFS4ERR_BADHANDLE */\n\tcase -EISDIR:           /* mapped NFS4ERR_ISDIR */\n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t/*\n\t\t * Destroy layout so new i/o will get a new layout.\n\t\t * Layout will not be destroyed until all current lseg\n\t\t * references are put. Mark layout as invalid to resend failed\n\t\t * i/o and all i/o waiting on the slot table to the MDS until\n\t\t * layout is destroyed and a new valid layout is obtained.\n\t\t */\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t/* RPC connection errors */\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tpnfs_error_mark_layout_for_return(inode, lseg);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\t/* fall through */\n\tdefault:\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\nout:\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\nout_bad_stateid:\n\ttask->tk_status = -EIO;\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\n\tgoto out;\n}"
  },
  {
    "function_name": "filelayout_reset_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "104-119",
    "snippet": "static void filelayout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_read_done_resend_to_mds",
          "args": [
            "hdr"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_read_done_resend_to_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1931-1938",
          "snippet": "int pnfs_read_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_read(&pgio, hdr->inode, true, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_read_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_read(&pgio, hdr->inode, true, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\"",
            "__func__",
            "hdr->task.tk_pid",
            "hdr->inode->i_sb->s_id",
            "(unsigned long long)NFS_FILEID(hdr->inode)",
            "hdr->args.count",
            "(unsigned long long)hdr->args.offset"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FILEID",
          "args": [
            "hdr->inode"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_IOHDR_REDO",
            "&hdr->flags"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}"
  },
  {
    "function_name": "filelayout_reset_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "87-102",
    "snippet": "static void filelayout_reset_write(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_write_done_resend_to_mds",
          "args": [
            "hdr"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_write_done_resend_to_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1814-1822",
          "snippet": "int pnfs_write_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_write(&pgio, hdr->inode, FLUSH_STABLE, true,\n\t\t\t      hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_write_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_write(&pgio, hdr->inode, FLUSH_STABLE, true,\n\t\t\t      hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\"",
            "__func__",
            "hdr->task.tk_pid",
            "hdr->inode->i_sb->s_id",
            "(unsigned long long)NFS_FILEID(hdr->inode)",
            "hdr->args.count",
            "(unsigned long long)hdr->args.offset"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FILEID",
          "args": [
            "hdr->inode"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_IOHDR_REDO",
            "&hdr->flags"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void filelayout_reset_write(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}"
  },
  {
    "function_name": "filelayout_get_dserver_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "71-85",
    "snippet": "static loff_t\nfilelayout_get_dserver_offset(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tswitch (flseg->stripe_type) {\n\tcase STRIPE_SPARSE:\n\t\treturn offset;\n\n\tcase STRIPE_DENSE:\n\t\treturn filelayout_get_dense_offset(flseg, offset);\n\t}\n\n\tBUG();\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filelayout_get_dense_offset",
          "args": [
            "flseg",
            "offset"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_get_dense_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "52-65",
          "snippet": "static loff_t\nfilelayout_get_dense_offset(struct nfs4_filelayout_segment *flseg,\n\t\t\t    loff_t offset)\n{\n\tu32 stripe_width = flseg->stripe_unit * flseg->dsaddr->stripe_count;\n\tu64 stripe_no;\n\tu32 rem;\n\n\toffset -= flseg->pattern_offset;\n\tstripe_no = div_u64(offset, stripe_width);\n\tdiv_u64_rem(offset, flseg->stripe_unit, &rem);\n\n\treturn stripe_no * flseg->stripe_unit + rem;\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic loff_t\nfilelayout_get_dense_offset(struct nfs4_filelayout_segment *flseg,\n\t\t\t    loff_t offset)\n{\n\tu32 stripe_width = flseg->stripe_unit * flseg->dsaddr->stripe_count;\n\tu64 stripe_no;\n\tu32 rem;\n\n\toffset -= flseg->pattern_offset;\n\tstripe_no = div_u64(offset, stripe_width);\n\tdiv_u64_rem(offset, flseg->stripe_unit, &rem);\n\n\treturn stripe_no * flseg->stripe_unit + rem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "80-86",
          "snippet": "static inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic loff_t\nfilelayout_get_dserver_offset(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tswitch (flseg->stripe_type) {\n\tcase STRIPE_SPARSE:\n\t\treturn offset;\n\n\tcase STRIPE_DENSE:\n\t\treturn filelayout_get_dense_offset(flseg, offset);\n\t}\n\n\tBUG();\n}"
  },
  {
    "function_name": "filelayout_get_dense_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
    "lines": "52-65",
    "snippet": "static loff_t\nfilelayout_get_dense_offset(struct nfs4_filelayout_segment *flseg,\n\t\t\t    loff_t offset)\n{\n\tu32 stripe_width = flseg->stripe_unit * flseg->dsaddr->stripe_count;\n\tu64 stripe_no;\n\tu32 rem;\n\n\toffset -= flseg->pattern_offset;\n\tstripe_no = div_u64(offset, stripe_width);\n\tdiv_u64_rem(offset, flseg->stripe_unit, &rem);\n\n\treturn stripe_no * flseg->stripe_unit + rem;\n}",
    "includes": [
      "#include \"../nfs4trace.h\"",
      "#include \"filelayout.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64_rem",
          "args": [
            "offset",
            "flseg->stripe_unit",
            "&rem"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "offset",
            "stripe_width"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic loff_t\nfilelayout_get_dense_offset(struct nfs4_filelayout_segment *flseg,\n\t\t\t    loff_t offset)\n{\n\tu32 stripe_width = flseg->stripe_unit * flseg->dsaddr->stripe_count;\n\tu64 stripe_no;\n\tu32 rem;\n\n\toffset -= flseg->pattern_offset;\n\tstripe_no = div_u64(offset, stripe_width);\n\tdiv_u64_rem(offset, flseg->stripe_unit, &rem);\n\n\treturn stripe_no * flseg->stripe_unit + rem;\n}"
  }
]