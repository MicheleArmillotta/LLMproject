[
  {
    "function_name": "ntfs_mark_quotas_out_of_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/quota.c",
    "lines": "37-115",
    "snippet": "bool ntfs_mark_quotas_out_of_date(ntfs_volume *vol)\n{\n\tntfs_index_context *ictx;\n\tQUOTA_CONTROL_ENTRY *qce;\n\tconst le32 qid = QUOTA_DEFAULTS_ID;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\tif (NVolQuotaOutOfDate(vol))\n\t\tgoto done;\n\tif (!vol->quota_ino || !vol->quota_q_ino) {\n\t\tntfs_error(vol->sb, \"Quota inodes are not open.\");\n\t\treturn false;\n\t}\n\tmutex_lock(&vol->quota_q_ino->i_mutex);\n\tictx = ntfs_index_ctx_get(NTFS_I(vol->quota_q_ino));\n\tif (!ictx) {\n\t\tntfs_error(vol->sb, \"Failed to get index context.\");\n\t\tgoto err_out;\n\t}\n\terr = ntfs_index_lookup(&qid, sizeof(qid), ictx);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vol->sb, \"Quota defaults entry is not \"\n\t\t\t\t\t\"present.\");\n\t\telse\n\t\t\tntfs_error(vol->sb, \"Lookup of quota defaults entry \"\n\t\t\t\t\t\"failed.\");\n\t\tgoto err_out;\n\t}\n\tif (ictx->data_len < offsetof(QUOTA_CONTROL_ENTRY, sid)) {\n\t\tntfs_error(vol->sb, \"Quota defaults entry size is invalid.  \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tgoto err_out;\n\t}\n\tqce = (QUOTA_CONTROL_ENTRY*)ictx->data;\n\tif (le32_to_cpu(qce->version) != QUOTA_VERSION) {\n\t\tntfs_error(vol->sb, \"Quota defaults entry version 0x%x is not \"\n\t\t\t\t\"supported.\", le32_to_cpu(qce->version));\n\t\tgoto err_out;\n\t}\n\tntfs_debug(\"Quota defaults flags = 0x%x.\", le32_to_cpu(qce->flags));\n\t/* If quotas are already marked out of date, no need to do anything. */\n\tif (qce->flags & QUOTA_FLAG_OUT_OF_DATE)\n\t\tgoto set_done;\n\t/*\n\t * If quota tracking is neither requested, nor enabled and there are no\n\t * pending deletes, no need to mark the quotas out of date.\n\t */\n\tif (!(qce->flags & (QUOTA_FLAG_TRACKING_ENABLED |\n\t\t\tQUOTA_FLAG_TRACKING_REQUESTED |\n\t\t\tQUOTA_FLAG_PENDING_DELETES)))\n\t\tgoto set_done;\n\t/*\n\t * Set the QUOTA_FLAG_OUT_OF_DATE bit thus marking quotas out of date.\n\t * This is verified on WinXP to be sufficient to cause windows to\n\t * rescan the volume on boot and update all quota entries.\n\t */\n\tqce->flags |= QUOTA_FLAG_OUT_OF_DATE;\n\t/* Ensure the modified flags are written to disk. */\n\tntfs_index_entry_flush_dcache_page(ictx);\n\tntfs_index_entry_mark_dirty(ictx);\nset_done:\n\tntfs_index_ctx_put(ictx);\n\tmutex_unlock(&vol->quota_q_ino->i_mutex);\n\t/*\n\t * We set the flag so we do not try to mark the quotas out of date\n\t * again on remount.\n\t */\n\tNVolSetQuotaOutOfDate(vol);\ndone:\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tif (ictx)\n\t\tntfs_index_ctx_put(ictx);\n\tmutex_unlock(&vol->quota_q_ino->i_mutex);\n\treturn false;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"quota.h\"",
      "#include \"index.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vol->quota_q_ino->i_mutex"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_index_ctx_put",
          "args": [
            "ictx"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_ctx_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.c",
          "lines": "57-76",
          "snippet": "void ntfs_index_ctx_put(ntfs_index_context *ictx)\n{\n\tif (ictx->entry) {\n\t\tif (ictx->is_in_root) {\n\t\t\tif (ictx->actx)\n\t\t\t\tntfs_attr_put_search_ctx(ictx->actx);\n\t\t\tif (ictx->base_ni)\n\t\t\t\tunmap_mft_record(ictx->base_ni);\n\t\t} else {\n\t\t\tstruct page *page = ictx->page;\n\t\t\tif (page) {\n\t\t\t\tBUG_ON(!PageLocked(page));\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t}\n\t\t}\n\t}\n\tkmem_cache_free(ntfs_index_ctx_cache, ictx);\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"collate.h\"",
            "#include \"aops.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"collate.h\"\n#include \"aops.h\"\n#include <linux/slab.h>\n\nvoid ntfs_index_ctx_put(ntfs_index_context *ictx)\n{\n\tif (ictx->entry) {\n\t\tif (ictx->is_in_root) {\n\t\t\tif (ictx->actx)\n\t\t\t\tntfs_attr_put_search_ctx(ictx->actx);\n\t\t\tif (ictx->base_ni)\n\t\t\t\tunmap_mft_record(ictx->base_ni);\n\t\t} else {\n\t\t\tstruct page *page = ictx->page;\n\t\t\tif (page) {\n\t\t\t\tBUG_ON(!PageLocked(page));\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t}\n\t\t}\n\t}\n\tkmem_cache_free(ntfs_index_ctx_cache, ictx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetQuotaOutOfDate",
          "args": [
            "vol"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vol->quota_q_ino->i_mutex"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_index_entry_mark_dirty",
          "args": [
            "ictx"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "137-144",
          "snippet": "static inline void ntfs_index_entry_mark_dirty(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tmark_mft_record_dirty(ictx->actx->ntfs_ino);\n\telse\n\t\tmark_ntfs_record_dirty(ictx->page,\n\t\t\t\t(u8*)ictx->ia - (u8*)page_address(ictx->page));\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_mark_dirty(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tmark_mft_record_dirty(ictx->actx->ntfs_ino);\n\telse\n\t\tmark_ntfs_record_dirty(ictx->page,\n\t\t\t\t(u8*)ictx->ia - (u8*)page_address(ictx->page));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_index_entry_flush_dcache_page",
          "args": [
            "ictx"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Quota defaults flags = 0x%x.\"",
            "le32_to_cpu(qce->flags)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "qce->flags"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Quota defaults entry version 0x%x is not \"\n\t\t\t\t\"supported.\"",
            "le32_to_cpu(qce->version)"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Quota defaults entry size is invalid.  \"\n\t\t\t\t\"Run chkdsk.\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Lookup of quota defaults entry \"\n\t\t\t\t\t\"failed.\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Quota defaults entry is not \"\n\t\t\t\t\t\"present.\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_index_lookup",
          "args": [
            "&qid",
            "sizeof(qid)",
            "ictx"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.c",
          "lines": "119-454",
          "snippet": "int ntfs_index_lookup(const void *key, const int key_len,\n\t\tntfs_index_context *ictx)\n{\n\tVCN vcn, old_vcn;\n\tntfs_inode *idx_ni = ictx->idx_ni;\n\tntfs_volume *vol = idx_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tntfs_inode *base_ni = idx_ni->ext.base_ntfs_ino;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end, *kaddr;\n\tntfs_attr_search_ctx *actx;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tint rc, err = 0;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(!NInoAttr(idx_ni));\n\tBUG_ON(idx_ni->type != AT_INDEX_ALLOCATION);\n\tBUG_ON(idx_ni->nr_extents != -1);\n\tBUG_ON(!base_ni);\n\tBUG_ON(!key);\n\tBUG_ON(key_len <= 0);\n\tif (!ntfs_is_collation_rule_supported(\n\t\t\tidx_ni->itype.index.collation_rule)) {\n\t\tntfs_error(sb, \"Index uses unsupported collation rule 0x%x.  \"\n\t\t\t\t\"Aborting lookup.\", le32_to_cpu(\n\t\t\t\tidx_ni->itype.index.collation_rule));\n\t\treturn -EOPNOTSUPP;\n\t}\n\t/* Get hold of the mft record for the index inode. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn PTR_ERR(m);\n\t}\n\tactx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!actx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, idx_ni->name, idx_ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, actx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it has been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)actx->attr +\n\t\t\tle16_to_cpu(actx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)actx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->length) > index_end)\n\t\t\tgoto idx_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a key.  It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/* Further bounds checks. */\n\t\tif ((u32)sizeof(INDEX_ENTRY_HEADER) +\n\t\t\t\tle16_to_cpu(ie->key_length) >\n\t\t\t\tle16_to_cpu(ie->data.vi.data_offset) ||\n\t\t\t\t(u32)le16_to_cpu(ie->data.vi.data_offset) +\n\t\t\t\tle16_to_cpu(ie->data.vi.data_length) >\n\t\t\t\tle16_to_cpu(ie->length))\n\t\t\tgoto idx_err_out;\n\t\t/* If the keys match perfectly, we setup @ictx and return 0. */\n\t\tif ((key_len == le16_to_cpu(ie->key_length)) && !memcmp(key,\n\t\t\t\t&ie->key, key_len)) {\nir_done:\n\t\t\tictx->is_in_root = true;\n\t\t\tictx->ir = ir;\n\t\t\tictx->actx = actx;\n\t\t\tictx->base_ni = base_ni;\n\t\t\tictx->ia = NULL;\n\t\t\tictx->page = NULL;\ndone:\n\t\t\tictx->entry = ie;\n\t\t\tictx->data = (u8*)ie +\n\t\t\t\t\tle16_to_cpu(ie->data.vi.data_offset);\n\t\t\tictx->data_len = le16_to_cpu(ie->data.vi.data_length);\n\t\t\tntfs_debug(\"Done.\");\n\t\t\treturn err;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate(vol, idx_ni->itype.index.collation_rule, key,\n\t\t\t\tkey_len, &ie->key, le16_to_cpu(ie->key_length));\n\t\t/*\n\t\t * If @key collates before the key of the current entry, there\n\t\t * is definitely no such key in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/*\n\t\t * A match should never happen as the memcmp() call should have\n\t\t * cought it, but we still treat it correctly.\n\t\t */\n\t\tif (!rc)\n\t\t\tgoto ir_done;\n\t\t/* The keys are not equal, continue the search. */\n\t}\n\t/*\n\t * We have finished with this index without success.  Check for the\n\t * presence of a child node and if not present setup @ictx and return\n\t * -ENOENT.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto ir_done;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(idx_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one.  Inode 0x%lx is corrupt or \"\n\t\t\t\t\"driver bug.\", idx_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(idx_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record.  Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(actx);\n\tunmap_mft_record(base_ni);\n\tm = NULL;\n\tactx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tidx_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tidx_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed.  Corrupt inode \"\n\t\t\t\t\"0x%lx or driver bug.\", idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Index record with vcn 0x%llx is corrupt.  \"\n\t\t\t\t\"Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx).  Inode \"\n\t\t\t\t\"0x%lx is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tidx_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of inode 0x%lx has \"\n\t\t\t\t\"a size (%u) differing from the index \"\n\t\t\t\t\"specified size (%u).  Inode is corrupt or \"\n\t\t\t\t\"driver bug.\", (unsigned long long)vcn,\n\t\t\t\tidx_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tidx_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + idx_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of inode 0x%lx \"\n\t\t\t\t\"crosses page boundary.  Impossible!  Cannot \"\n\t\t\t\t\"access!  This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tidx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + idx_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of inode \"\n\t\t\t\t\"0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->length) > index_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a key.  It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/* Further bounds checks. */\n\t\tif ((u32)sizeof(INDEX_ENTRY_HEADER) +\n\t\t\t\tle16_to_cpu(ie->key_length) >\n\t\t\t\tle16_to_cpu(ie->data.vi.data_offset) ||\n\t\t\t\t(u32)le16_to_cpu(ie->data.vi.data_offset) +\n\t\t\t\tle16_to_cpu(ie->data.vi.data_length) >\n\t\t\t\tle16_to_cpu(ie->length)) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* If the keys match perfectly, we setup @ictx and return 0. */\n\t\tif ((key_len == le16_to_cpu(ie->key_length)) && !memcmp(key,\n\t\t\t\t&ie->key, key_len)) {\nia_done:\n\t\t\tictx->is_in_root = false;\n\t\t\tictx->actx = NULL;\n\t\t\tictx->base_ni = NULL;\n\t\t\tictx->ia = ia;\n\t\t\tictx->page = page;\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate(vol, idx_ni->itype.index.collation_rule, key,\n\t\t\t\tkey_len, &ie->key, le16_to_cpu(ie->key_length));\n\t\t/*\n\t\t * If @key collates before the key of the current entry, there\n\t\t * is definitely no such key in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/*\n\t\t * A match should never happen as the memcmp() call should have\n\t\t * cought it, but we still treat it correctly.\n\t\t */\n\t\tif (!rc)\n\t\t\tgoto ia_done;\n\t\t/* The keys are not equal, continue the search. */\n\t}\n\t/*\n\t * We have finished with this index buffer without success.  Check for\n\t * the presence of a child node and if not present return -ENOENT.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto ia_done;\n\t}\n\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\tntfs_error(sb, \"Index entry with child node found in a leaf \"\n\t\t\t\t\"node in inode 0x%lx.\", idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Child node present, descend into it. */\n\told_vcn = vcn;\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tif (vcn >= 0) {\n\t\t/*\n\t\t * If vcn is in the same page cache page as old_vcn we recycle\n\t\t * the mapped page.\n\t\t */\n\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\tgoto fast_descend_into_child_node;\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\tgoto descend_into_child_node;\n\t}\n\tntfs_error(sb, \"Negative child node vcn in inode 0x%lx.\",\n\t\t\tidx_ni->mft_no);\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (actx)\n\t\tntfs_attr_put_search_ctx(actx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\nidx_err_out:\n\tntfs_error(sb, \"Corrupt index.  Aborting lookup.\");\n\tgoto err_out;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"collate.h\"",
            "#include \"aops.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"collate.h\"\n#include \"aops.h\"\n#include <linux/slab.h>\n\nint ntfs_index_lookup(const void *key, const int key_len,\n\t\tntfs_index_context *ictx)\n{\n\tVCN vcn, old_vcn;\n\tntfs_inode *idx_ni = ictx->idx_ni;\n\tntfs_volume *vol = idx_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tntfs_inode *base_ni = idx_ni->ext.base_ntfs_ino;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end, *kaddr;\n\tntfs_attr_search_ctx *actx;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tint rc, err = 0;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(!NInoAttr(idx_ni));\n\tBUG_ON(idx_ni->type != AT_INDEX_ALLOCATION);\n\tBUG_ON(idx_ni->nr_extents != -1);\n\tBUG_ON(!base_ni);\n\tBUG_ON(!key);\n\tBUG_ON(key_len <= 0);\n\tif (!ntfs_is_collation_rule_supported(\n\t\t\tidx_ni->itype.index.collation_rule)) {\n\t\tntfs_error(sb, \"Index uses unsupported collation rule 0x%x.  \"\n\t\t\t\t\"Aborting lookup.\", le32_to_cpu(\n\t\t\t\tidx_ni->itype.index.collation_rule));\n\t\treturn -EOPNOTSUPP;\n\t}\n\t/* Get hold of the mft record for the index inode. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn PTR_ERR(m);\n\t}\n\tactx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!actx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, idx_ni->name, idx_ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, actx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it has been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)actx->attr +\n\t\t\tle16_to_cpu(actx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)actx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->length) > index_end)\n\t\t\tgoto idx_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a key.  It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/* Further bounds checks. */\n\t\tif ((u32)sizeof(INDEX_ENTRY_HEADER) +\n\t\t\t\tle16_to_cpu(ie->key_length) >\n\t\t\t\tle16_to_cpu(ie->data.vi.data_offset) ||\n\t\t\t\t(u32)le16_to_cpu(ie->data.vi.data_offset) +\n\t\t\t\tle16_to_cpu(ie->data.vi.data_length) >\n\t\t\t\tle16_to_cpu(ie->length))\n\t\t\tgoto idx_err_out;\n\t\t/* If the keys match perfectly, we setup @ictx and return 0. */\n\t\tif ((key_len == le16_to_cpu(ie->key_length)) && !memcmp(key,\n\t\t\t\t&ie->key, key_len)) {\nir_done:\n\t\t\tictx->is_in_root = true;\n\t\t\tictx->ir = ir;\n\t\t\tictx->actx = actx;\n\t\t\tictx->base_ni = base_ni;\n\t\t\tictx->ia = NULL;\n\t\t\tictx->page = NULL;\ndone:\n\t\t\tictx->entry = ie;\n\t\t\tictx->data = (u8*)ie +\n\t\t\t\t\tle16_to_cpu(ie->data.vi.data_offset);\n\t\t\tictx->data_len = le16_to_cpu(ie->data.vi.data_length);\n\t\t\tntfs_debug(\"Done.\");\n\t\t\treturn err;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate(vol, idx_ni->itype.index.collation_rule, key,\n\t\t\t\tkey_len, &ie->key, le16_to_cpu(ie->key_length));\n\t\t/*\n\t\t * If @key collates before the key of the current entry, there\n\t\t * is definitely no such key in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/*\n\t\t * A match should never happen as the memcmp() call should have\n\t\t * cought it, but we still treat it correctly.\n\t\t */\n\t\tif (!rc)\n\t\t\tgoto ir_done;\n\t\t/* The keys are not equal, continue the search. */\n\t}\n\t/*\n\t * We have finished with this index without success.  Check for the\n\t * presence of a child node and if not present setup @ictx and return\n\t * -ENOENT.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto ir_done;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(idx_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one.  Inode 0x%lx is corrupt or \"\n\t\t\t\t\"driver bug.\", idx_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(idx_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record.  Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(actx);\n\tunmap_mft_record(base_ni);\n\tm = NULL;\n\tactx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tidx_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tidx_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed.  Corrupt inode \"\n\t\t\t\t\"0x%lx or driver bug.\", idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Index record with vcn 0x%llx is corrupt.  \"\n\t\t\t\t\"Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx).  Inode \"\n\t\t\t\t\"0x%lx is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tidx_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of inode 0x%lx has \"\n\t\t\t\t\"a size (%u) differing from the index \"\n\t\t\t\t\"specified size (%u).  Inode is corrupt or \"\n\t\t\t\t\"driver bug.\", (unsigned long long)vcn,\n\t\t\t\tidx_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tidx_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + idx_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of inode 0x%lx \"\n\t\t\t\t\"crosses page boundary.  Impossible!  Cannot \"\n\t\t\t\t\"access!  This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tidx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + idx_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of inode \"\n\t\t\t\t\"0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->length) > index_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a key.  It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/* Further bounds checks. */\n\t\tif ((u32)sizeof(INDEX_ENTRY_HEADER) +\n\t\t\t\tle16_to_cpu(ie->key_length) >\n\t\t\t\tle16_to_cpu(ie->data.vi.data_offset) ||\n\t\t\t\t(u32)le16_to_cpu(ie->data.vi.data_offset) +\n\t\t\t\tle16_to_cpu(ie->data.vi.data_length) >\n\t\t\t\tle16_to_cpu(ie->length)) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* If the keys match perfectly, we setup @ictx and return 0. */\n\t\tif ((key_len == le16_to_cpu(ie->key_length)) && !memcmp(key,\n\t\t\t\t&ie->key, key_len)) {\nia_done:\n\t\t\tictx->is_in_root = false;\n\t\t\tictx->actx = NULL;\n\t\t\tictx->base_ni = NULL;\n\t\t\tictx->ia = ia;\n\t\t\tictx->page = page;\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate(vol, idx_ni->itype.index.collation_rule, key,\n\t\t\t\tkey_len, &ie->key, le16_to_cpu(ie->key_length));\n\t\t/*\n\t\t * If @key collates before the key of the current entry, there\n\t\t * is definitely no such key in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/*\n\t\t * A match should never happen as the memcmp() call should have\n\t\t * cought it, but we still treat it correctly.\n\t\t */\n\t\tif (!rc)\n\t\t\tgoto ia_done;\n\t\t/* The keys are not equal, continue the search. */\n\t}\n\t/*\n\t * We have finished with this index buffer without success.  Check for\n\t * the presence of a child node and if not present return -ENOENT.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto ia_done;\n\t}\n\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\tntfs_error(sb, \"Index entry with child node found in a leaf \"\n\t\t\t\t\"node in inode 0x%lx.\", idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Child node present, descend into it. */\n\told_vcn = vcn;\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tif (vcn >= 0) {\n\t\t/*\n\t\t * If vcn is in the same page cache page as old_vcn we recycle\n\t\t * the mapped page.\n\t\t */\n\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\tgoto fast_descend_into_child_node;\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\tgoto descend_into_child_node;\n\t}\n\tntfs_error(sb, \"Negative child node vcn in inode 0x%lx.\",\n\t\t\tidx_ni->mft_no);\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (actx)\n\t\tntfs_attr_put_search_ctx(actx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\nidx_err_out:\n\tntfs_error(sb, \"Corrupt index.  Aborting lookup.\");\n\tgoto err_out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to get index context.\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_index_ctx_get",
          "args": [
            "NTFS_I(vol->quota_q_ino)"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_ctx_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.c",
          "lines": "39-47",
          "snippet": "ntfs_index_context *ntfs_index_ctx_get(ntfs_inode *idx_ni)\n{\n\tntfs_index_context *ictx;\n\n\tictx = kmem_cache_alloc(ntfs_index_ctx_cache, GFP_NOFS);\n\tif (ictx)\n\t\t*ictx = (ntfs_index_context){ .idx_ni = idx_ni };\n\treturn ictx;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"collate.h\"",
            "#include \"aops.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"collate.h\"\n#include \"aops.h\"\n#include <linux/slab.h>\n\nntfs_index_context *ntfs_index_ctx_get(ntfs_inode *idx_ni)\n{\n\tntfs_index_context *ictx;\n\n\tictx = kmem_cache_alloc(ntfs_index_ctx_cache, GFP_NOFS);\n\tif (ictx)\n\t\t*ictx = (ntfs_index_context){ .idx_ni = idx_ni };\n\treturn ictx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vol->quota_q_ino"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vol->quota_q_ino->i_mutex"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Quota inodes are not open.\""
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolQuotaOutOfDate",
          "args": [
            "vol"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"quota.h\"\n#include \"index.h\"\n\nbool ntfs_mark_quotas_out_of_date(ntfs_volume *vol)\n{\n\tntfs_index_context *ictx;\n\tQUOTA_CONTROL_ENTRY *qce;\n\tconst le32 qid = QUOTA_DEFAULTS_ID;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\tif (NVolQuotaOutOfDate(vol))\n\t\tgoto done;\n\tif (!vol->quota_ino || !vol->quota_q_ino) {\n\t\tntfs_error(vol->sb, \"Quota inodes are not open.\");\n\t\treturn false;\n\t}\n\tmutex_lock(&vol->quota_q_ino->i_mutex);\n\tictx = ntfs_index_ctx_get(NTFS_I(vol->quota_q_ino));\n\tif (!ictx) {\n\t\tntfs_error(vol->sb, \"Failed to get index context.\");\n\t\tgoto err_out;\n\t}\n\terr = ntfs_index_lookup(&qid, sizeof(qid), ictx);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vol->sb, \"Quota defaults entry is not \"\n\t\t\t\t\t\"present.\");\n\t\telse\n\t\t\tntfs_error(vol->sb, \"Lookup of quota defaults entry \"\n\t\t\t\t\t\"failed.\");\n\t\tgoto err_out;\n\t}\n\tif (ictx->data_len < offsetof(QUOTA_CONTROL_ENTRY, sid)) {\n\t\tntfs_error(vol->sb, \"Quota defaults entry size is invalid.  \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tgoto err_out;\n\t}\n\tqce = (QUOTA_CONTROL_ENTRY*)ictx->data;\n\tif (le32_to_cpu(qce->version) != QUOTA_VERSION) {\n\t\tntfs_error(vol->sb, \"Quota defaults entry version 0x%x is not \"\n\t\t\t\t\"supported.\", le32_to_cpu(qce->version));\n\t\tgoto err_out;\n\t}\n\tntfs_debug(\"Quota defaults flags = 0x%x.\", le32_to_cpu(qce->flags));\n\t/* If quotas are already marked out of date, no need to do anything. */\n\tif (qce->flags & QUOTA_FLAG_OUT_OF_DATE)\n\t\tgoto set_done;\n\t/*\n\t * If quota tracking is neither requested, nor enabled and there are no\n\t * pending deletes, no need to mark the quotas out of date.\n\t */\n\tif (!(qce->flags & (QUOTA_FLAG_TRACKING_ENABLED |\n\t\t\tQUOTA_FLAG_TRACKING_REQUESTED |\n\t\t\tQUOTA_FLAG_PENDING_DELETES)))\n\t\tgoto set_done;\n\t/*\n\t * Set the QUOTA_FLAG_OUT_OF_DATE bit thus marking quotas out of date.\n\t * This is verified on WinXP to be sufficient to cause windows to\n\t * rescan the volume on boot and update all quota entries.\n\t */\n\tqce->flags |= QUOTA_FLAG_OUT_OF_DATE;\n\t/* Ensure the modified flags are written to disk. */\n\tntfs_index_entry_flush_dcache_page(ictx);\n\tntfs_index_entry_mark_dirty(ictx);\nset_done:\n\tntfs_index_ctx_put(ictx);\n\tmutex_unlock(&vol->quota_q_ino->i_mutex);\n\t/*\n\t * We set the flag so we do not try to mark the quotas out of date\n\t * again on remount.\n\t */\n\tNVolSetQuotaOutOfDate(vol);\ndone:\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tif (ictx)\n\t\tntfs_index_ctx_put(ictx);\n\tmutex_unlock(&vol->quota_q_ino->i_mutex);\n\treturn false;\n}"
  }
]