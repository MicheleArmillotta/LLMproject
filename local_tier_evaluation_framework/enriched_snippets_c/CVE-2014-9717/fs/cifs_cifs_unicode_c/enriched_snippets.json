[
  {
    "function_name": "cifs_strndup_to_utf16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "503-520",
    "snippet": "__le16 *\ncifs_strndup_to_utf16(const char *src, const int maxlen, int *utf16_len,\n\t\t      const struct nls_table *cp, int remap)\n{\n\tint len;\n\t__le16 *dst;\n\n\tlen = cifs_local_to_utf16_bytes(src, maxlen, cp);\n\tlen += 2; /* NULL */\n\tdst = kmalloc(len, GFP_KERNEL);\n\tif (!dst) {\n\t\t*utf16_len = 0;\n\t\treturn NULL;\n\t}\n\tcifsConvertToUTF16(dst, src, strlen(src), cp, remap);\n\t*utf16_len = len;\n\treturn dst;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "dst",
            "src",
            "strlen(src)",
            "cp",
            "remap"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "src"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_local_to_utf16_bytes",
          "args": [
            "src",
            "maxlen",
            "cp"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_local_to_utf16_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "474-489",
          "snippet": "static int\ncifs_local_to_utf16_bytes(const char *from, int len,\n\t\t\t  const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to;\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\t/* Failed conversion defaults to a question mark */\n\t\tif (charlen < 1)\n\t\t\tcharlen = 1;\n\t}\n\treturn 2 * i; /* UTF16 characters are two bytes */\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_local_to_utf16_bytes(const char *from, int len,\n\t\t\t  const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to;\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\t/* Failed conversion defaults to a question mark */\n\t\tif (charlen < 1)\n\t\t\tcharlen = 1;\n\t}\n\treturn 2 * i; /* UTF16 characters are two bytes */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\n__le16 *\ncifs_strndup_to_utf16(const char *src, const int maxlen, int *utf16_len,\n\t\t      const struct nls_table *cp, int remap)\n{\n\tint len;\n\t__le16 *dst;\n\n\tlen = cifs_local_to_utf16_bytes(src, maxlen, cp);\n\tlen += 2; /* NULL */\n\tdst = kmalloc(len, GFP_KERNEL);\n\tif (!dst) {\n\t\t*utf16_len = 0;\n\t\treturn NULL;\n\t}\n\tcifsConvertToUTF16(dst, src, strlen(src), cp, remap);\n\t*utf16_len = len;\n\treturn dst;\n}"
  },
  {
    "function_name": "cifs_local_to_utf16_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "474-489",
    "snippet": "static int\ncifs_local_to_utf16_bytes(const char *from, int len,\n\t\t\t  const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to;\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\t/* Failed conversion defaults to a question mark */\n\t\tif (charlen < 1)\n\t\t\tcharlen = 1;\n\t}\n\treturn 2 * i; /* UTF16 characters are two bytes */\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "codepage->char2uni",
          "args": [
            "from",
            "len",
            "&wchar_to"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "char2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7877-7908",
          "snippet": "static int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};\n\nstatic int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_local_to_utf16_bytes(const char *from, int len,\n\t\t\t  const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to;\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\t/* Failed conversion defaults to a question mark */\n\t\tif (charlen < 1)\n\t\t\tcharlen = 1;\n\t}\n\treturn 2 * i; /* UTF16 characters are two bytes */\n}"
  },
  {
    "function_name": "cifsConvertToUTF16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "403-460",
    "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unaligned",
          "args": [
            "0",
            "&target[j]"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "put_unaligned_le8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/struct-funcs.c",
          "lines": "29-32",
          "snippet": "static inline void put_unaligned_le8(u8 val, void *p)\n{\n       *(u8 *)p = val;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/highmem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/highmem.h>\n\nstatic inline void put_unaligned_le8(u8 val, void *p)\n{\n       *(u8 *)p = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0x003f"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "tmp"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cp->char2uni",
          "args": [
            "source + i",
            "srclen - i",
            "&tmp"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "char2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7877-7908",
          "snippet": "static int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};\n\nstatic int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_to_sfm_char",
          "args": [
            "src_char"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "convert_to_sfm_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "367-395",
          "snippet": "static __le16 convert_to_sfm_char(char src_char)\n{\n\t__le16 dest_char;\n\n\tswitch (src_char) {\n\tcase ':':\n\t\tdest_char = cpu_to_le16(SFM_COLON);\n\t\tbreak;\n\tcase '*':\n\t\tdest_char = cpu_to_le16(SFM_ASTERISK);\n\t\tbreak;\n\tcase '?':\n\t\tdest_char = cpu_to_le16(SFM_QUESTION);\n\t\tbreak;\n\tcase '<':\n\t\tdest_char = cpu_to_le16(SFM_LESSTHAN);\n\t\tbreak;\n\tcase '>':\n\t\tdest_char = cpu_to_le16(SFM_GRTRTHAN);\n\t\tbreak;\n\tcase '|':\n\t\tdest_char = cpu_to_le16(SFM_PIPE);\n\t\tbreak;\n\tdefault:\n\t\tdest_char = 0;\n\t}\n\n\treturn dest_char;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic __le16 convert_to_sfm_char(char src_char)\n{\n\t__le16 dest_char;\n\n\tswitch (src_char) {\n\tcase ':':\n\t\tdest_char = cpu_to_le16(SFM_COLON);\n\t\tbreak;\n\tcase '*':\n\t\tdest_char = cpu_to_le16(SFM_ASTERISK);\n\t\tbreak;\n\tcase '?':\n\t\tdest_char = cpu_to_le16(SFM_QUESTION);\n\t\tbreak;\n\tcase '<':\n\t\tdest_char = cpu_to_le16(SFM_LESSTHAN);\n\t\tbreak;\n\tcase '>':\n\t\tdest_char = cpu_to_le16(SFM_GRTRTHAN);\n\t\tbreak;\n\tcase '|':\n\t\tdest_char = cpu_to_le16(SFM_PIPE);\n\t\tbreak;\n\tdefault:\n\t\tdest_char = 0;\n\t}\n\n\treturn dest_char;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_to_sfu_char",
          "args": [
            "src_char"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "convert_to_sfu_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "337-365",
          "snippet": "static __le16 convert_to_sfu_char(char src_char)\n{\n\t__le16 dest_char;\n\n\tswitch (src_char) {\n\tcase ':':\n\t\tdest_char = cpu_to_le16(UNI_COLON);\n\t\tbreak;\n\tcase '*':\n\t\tdest_char = cpu_to_le16(UNI_ASTERISK);\n\t\tbreak;\n\tcase '?':\n\t\tdest_char = cpu_to_le16(UNI_QUESTION);\n\t\tbreak;\n\tcase '<':\n\t\tdest_char = cpu_to_le16(UNI_LESSTHAN);\n\t\tbreak;\n\tcase '>':\n\t\tdest_char = cpu_to_le16(UNI_GRTRTHAN);\n\t\tbreak;\n\tcase '|':\n\t\tdest_char = cpu_to_le16(UNI_PIPE);\n\t\tbreak;\n\tdefault:\n\t\tdest_char = 0;\n\t}\n\n\treturn dest_char;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic __le16 convert_to_sfu_char(char src_char)\n{\n\t__le16 dest_char;\n\n\tswitch (src_char) {\n\tcase ':':\n\t\tdest_char = cpu_to_le16(UNI_COLON);\n\t\tbreak;\n\tcase '*':\n\t\tdest_char = cpu_to_le16(UNI_ASTERISK);\n\t\tbreak;\n\tcase '?':\n\t\tdest_char = cpu_to_le16(UNI_QUESTION);\n\t\tbreak;\n\tcase '<':\n\t\tdest_char = cpu_to_le16(UNI_LESSTHAN);\n\t\tbreak;\n\tcase '>':\n\t\tdest_char = cpu_to_le16(UNI_GRTRTHAN);\n\t\tbreak;\n\tcase '|':\n\t\tdest_char = cpu_to_le16(UNI_PIPE);\n\t\tbreak;\n\tdefault:\n\t\tdest_char = 0;\n\t}\n\n\treturn dest_char;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_strtoUTF16",
          "args": [
            "target",
            "source",
            "PATH_MAX",
            "cp"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strtoUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "252-296",
          "snippet": "int\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
  },
  {
    "function_name": "convert_to_sfm_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "367-395",
    "snippet": "static __le16 convert_to_sfm_char(char src_char)\n{\n\t__le16 dest_char;\n\n\tswitch (src_char) {\n\tcase ':':\n\t\tdest_char = cpu_to_le16(SFM_COLON);\n\t\tbreak;\n\tcase '*':\n\t\tdest_char = cpu_to_le16(SFM_ASTERISK);\n\t\tbreak;\n\tcase '?':\n\t\tdest_char = cpu_to_le16(SFM_QUESTION);\n\t\tbreak;\n\tcase '<':\n\t\tdest_char = cpu_to_le16(SFM_LESSTHAN);\n\t\tbreak;\n\tcase '>':\n\t\tdest_char = cpu_to_le16(SFM_GRTRTHAN);\n\t\tbreak;\n\tcase '|':\n\t\tdest_char = cpu_to_le16(SFM_PIPE);\n\t\tbreak;\n\tdefault:\n\t\tdest_char = 0;\n\t}\n\n\treturn dest_char;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SFM_PIPE"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SFM_GRTRTHAN"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SFM_LESSTHAN"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SFM_QUESTION"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SFM_ASTERISK"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SFM_COLON"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic __le16 convert_to_sfm_char(char src_char)\n{\n\t__le16 dest_char;\n\n\tswitch (src_char) {\n\tcase ':':\n\t\tdest_char = cpu_to_le16(SFM_COLON);\n\t\tbreak;\n\tcase '*':\n\t\tdest_char = cpu_to_le16(SFM_ASTERISK);\n\t\tbreak;\n\tcase '?':\n\t\tdest_char = cpu_to_le16(SFM_QUESTION);\n\t\tbreak;\n\tcase '<':\n\t\tdest_char = cpu_to_le16(SFM_LESSTHAN);\n\t\tbreak;\n\tcase '>':\n\t\tdest_char = cpu_to_le16(SFM_GRTRTHAN);\n\t\tbreak;\n\tcase '|':\n\t\tdest_char = cpu_to_le16(SFM_PIPE);\n\t\tbreak;\n\tdefault:\n\t\tdest_char = 0;\n\t}\n\n\treturn dest_char;\n}"
  },
  {
    "function_name": "convert_to_sfu_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "337-365",
    "snippet": "static __le16 convert_to_sfu_char(char src_char)\n{\n\t__le16 dest_char;\n\n\tswitch (src_char) {\n\tcase ':':\n\t\tdest_char = cpu_to_le16(UNI_COLON);\n\t\tbreak;\n\tcase '*':\n\t\tdest_char = cpu_to_le16(UNI_ASTERISK);\n\t\tbreak;\n\tcase '?':\n\t\tdest_char = cpu_to_le16(UNI_QUESTION);\n\t\tbreak;\n\tcase '<':\n\t\tdest_char = cpu_to_le16(UNI_LESSTHAN);\n\t\tbreak;\n\tcase '>':\n\t\tdest_char = cpu_to_le16(UNI_GRTRTHAN);\n\t\tbreak;\n\tcase '|':\n\t\tdest_char = cpu_to_le16(UNI_PIPE);\n\t\tbreak;\n\tdefault:\n\t\tdest_char = 0;\n\t}\n\n\treturn dest_char;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "UNI_PIPE"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "UNI_GRTRTHAN"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "UNI_LESSTHAN"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "UNI_QUESTION"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "UNI_ASTERISK"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "UNI_COLON"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic __le16 convert_to_sfu_char(char src_char)\n{\n\t__le16 dest_char;\n\n\tswitch (src_char) {\n\tcase ':':\n\t\tdest_char = cpu_to_le16(UNI_COLON);\n\t\tbreak;\n\tcase '*':\n\t\tdest_char = cpu_to_le16(UNI_ASTERISK);\n\t\tbreak;\n\tcase '?':\n\t\tdest_char = cpu_to_le16(UNI_QUESTION);\n\t\tbreak;\n\tcase '<':\n\t\tdest_char = cpu_to_le16(UNI_LESSTHAN);\n\t\tbreak;\n\tcase '>':\n\t\tdest_char = cpu_to_le16(UNI_GRTRTHAN);\n\t\tbreak;\n\tcase '|':\n\t\tdest_char = cpu_to_le16(UNI_PIPE);\n\t\tbreak;\n\tdefault:\n\t\tdest_char = 0;\n\t}\n\n\treturn dest_char;\n}"
  },
  {
    "function_name": "cifs_strndup_from_utf16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "310-335",
    "snippet": "char *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "dst",
            "src",
            "len"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "src",
            "maxlen"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_from_utf16",
          "args": [
            "dst",
            "(__le16 *) src",
            "len",
            "maxlen",
            "codepage",
            "NO_MAP_UNI_RSVD"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_from_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "200-244",
          "snippet": "int\ncifs_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,\n\t\tconst struct nls_table *codepage, int map_type)\n{\n\tint i, charlen, safelen;\n\tint outlen = 0;\n\tint nullsize = nls_nullsize(codepage);\n\tint fromwords = fromlen / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\t/*\n\t * because the chars can be of varying widths, we need to take care\n\t * not to overflow the destination buffer when we get close to the\n\t * end of it. Until we get to this offset, we don't need to check\n\t * for overflow however.\n\t */\n\tsafelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);\n\n\tfor (i = 0; i < fromwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * check to see if converting this character might make the\n\t\t * conversion bleed into the null terminator\n\t\t */\n\t\tif (outlen >= safelen) {\n\t\t\tcharlen = cifs_mapchar(tmp, ftmp, codepage, map_type);\n\t\t\tif ((outlen + charlen) > (tolen - nullsize))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* put converted char into 'to' buffer */\n\t\tcharlen = cifs_mapchar(&to[outlen], ftmp, codepage, map_type);\n\t\toutlen += charlen;\n\t}\n\n\t/* properly null-terminate string */\n\tfor (i = 0; i < nullsize; i++)\n\t\tto[outlen++] = 0;\n\n\treturn outlen;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,\n\t\tconst struct nls_table *codepage, int map_type)\n{\n\tint i, charlen, safelen;\n\tint outlen = 0;\n\tint nullsize = nls_nullsize(codepage);\n\tint fromwords = fromlen / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\t/*\n\t * because the chars can be of varying widths, we need to take care\n\t * not to overflow the destination buffer when we get close to the\n\t * end of it. Until we get to this offset, we don't need to check\n\t * for overflow however.\n\t */\n\tsafelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);\n\n\tfor (i = 0; i < fromwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * check to see if converting this character might make the\n\t\t * conversion bleed into the null terminator\n\t\t */\n\t\tif (outlen >= safelen) {\n\t\t\tcharlen = cifs_mapchar(tmp, ftmp, codepage, map_type);\n\t\t\tif ((outlen + charlen) > (tolen - nullsize))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* put converted char into 'to' buffer */\n\t\tcharlen = cifs_mapchar(&to[outlen], ftmp, codepage, map_type);\n\t\toutlen += charlen;\n\t}\n\n\t/* properly null-terminate string */\n\tfor (i = 0; i < nullsize; i++)\n\t\tto[outlen++] = 0;\n\n\treturn outlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nls_nullsize",
          "args": [
            "codepage"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_utf16_bytes",
          "args": [
            "(__le16 *) src",
            "maxlen",
            "codepage"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_utf16_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "40-63",
          "snippet": "int\ncifs_utf16_bytes(const __le16 *from, int maxbytes,\n\t\tconst struct nls_table *codepage)\n{\n\tint i;\n\tint charlen, outlen = 0;\n\tint maxwords = maxbytes / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\tfor (i = 0; i < maxwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\tcharlen = codepage->uni2char(ftmp, tmp, NLS_MAX_CHARSET_SIZE);\n\t\tif (charlen > 0)\n\t\t\toutlen += charlen;\n\t\telse\n\t\t\toutlen++;\n\t}\n\n\treturn outlen;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_utf16_bytes(const __le16 *from, int maxbytes,\n\t\tconst struct nls_table *codepage)\n{\n\tint i;\n\tint charlen, outlen = 0;\n\tint maxwords = maxbytes / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\tfor (i = 0; i < maxwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\tcharlen = codepage->uni2char(ftmp, tmp, NLS_MAX_CHARSET_SIZE);\n\t\tif (charlen > 0)\n\t\t\toutlen += charlen;\n\t\telse\n\t\t\toutlen++;\n\t}\n\n\treturn outlen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nchar *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}"
  },
  {
    "function_name": "cifs_strtoUTF16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "252-296",
    "snippet": "int\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unaligned_le16",
          "args": [
            "0",
            "&to[i]"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unaligned_le16",
          "args": [
            "wchar_to",
            "&to[i]"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"strtoUTF16: char2uni of 0x%x returned %d\\n\"",
            "*from",
            "charlen"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "codepage->char2uni",
          "args": [
            "from",
            "len",
            "&wchar_to"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "char2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7877-7908",
          "snippet": "static int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};\n\nstatic int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "utf8s_to_utf16s",
          "args": [
            "from",
            "len",
            "UTF16_LITTLE_ENDIAN",
            "(wchar_t *) to",
            "len"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "utf8s_to_utf16s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "132-171",
          "snippet": "int utf8s_to_utf16s(const u8 *s, int inlen, enum utf16_endian endian,\n\t\twchar_t *pwcs, int maxout)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (inlen > 0 && maxout > 0 && *s) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, inlen, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\ts += size;\n\t\t\tinlen -= size;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tif (maxout < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tmaxout -= 2;\n\t\t\t} else {\n\t\t\t\tput_utf16(op++, u, endian);\n\t\t\t\tmaxout--;\n\t\t\t}\n\t\t} else {\n\t\t\tput_utf16(op++, *s++, endian);\n\t\t\tinlen--;\n\t\t\tmaxout--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SURROGATE_BITS\t0x000003ff",
            "#define SURROGATE_LOW\t0x00000400",
            "#define SURROGATE_PAIR\t0x0000d800",
            "#define PLANE_SIZE\t0x00010000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#define SURROGATE_BITS\t0x000003ff\n#define SURROGATE_LOW\t0x00000400\n#define SURROGATE_PAIR\t0x0000d800\n#define PLANE_SIZE\t0x00010000\n\nint utf8s_to_utf16s(const u8 *s, int inlen, enum utf16_endian endian,\n\t\twchar_t *pwcs, int maxout)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (inlen > 0 && maxout > 0 && *s) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, inlen, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\ts += size;\n\t\t\tinlen -= size;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tif (maxout < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tmaxout -= 2;\n\t\t\t} else {\n\t\t\t\tput_utf16(op++, u, endian);\n\t\t\t\tmaxout--;\n\t\t\t}\n\t\t} else {\n\t\t\tput_utf16(op++, *s++, endian);\n\t\t\tinlen--;\n\t\t\tmaxout--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "codepage->charset",
            "\"utf8\""
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}"
  },
  {
    "function_name": "cifs_from_utf16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "200-244",
    "snippet": "int\ncifs_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,\n\t\tconst struct nls_table *codepage, int map_type)\n{\n\tint i, charlen, safelen;\n\tint outlen = 0;\n\tint nullsize = nls_nullsize(codepage);\n\tint fromwords = fromlen / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\t/*\n\t * because the chars can be of varying widths, we need to take care\n\t * not to overflow the destination buffer when we get close to the\n\t * end of it. Until we get to this offset, we don't need to check\n\t * for overflow however.\n\t */\n\tsafelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);\n\n\tfor (i = 0; i < fromwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * check to see if converting this character might make the\n\t\t * conversion bleed into the null terminator\n\t\t */\n\t\tif (outlen >= safelen) {\n\t\t\tcharlen = cifs_mapchar(tmp, ftmp, codepage, map_type);\n\t\t\tif ((outlen + charlen) > (tolen - nullsize))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* put converted char into 'to' buffer */\n\t\tcharlen = cifs_mapchar(&to[outlen], ftmp, codepage, map_type);\n\t\toutlen += charlen;\n\t}\n\n\t/* properly null-terminate string */\n\tfor (i = 0; i < nullsize; i++)\n\t\tto[outlen++] = 0;\n\n\treturn outlen;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_mapchar",
          "args": [
            "&to[outlen]",
            "ftmp",
            "codepage",
            "map_type"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_mapchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "157-176",
          "snippet": "static int\ncifs_mapchar(char *target, const __u16 src_char, const struct nls_table *cp,\n\t     int maptype)\n{\n\tint len = 1;\n\n\tif ((maptype == SFM_MAP_UNI_RSVD) && convert_sfm_char(src_char, target))\n\t\treturn len;\n\telse if ((maptype == SFU_MAP_UNI_RSVD) &&\n\t\t  convert_sfu_char(src_char, target))\n\t\treturn len;\n\n\t/* if character not one of seven in special remap set */\n\tlen = cp->uni2char(src_char, target, NLS_MAX_CHARSET_SIZE);\n\tif (len <= 0) {\n\t\t*target = '?';\n\t\tlen = 1;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_mapchar(char *target, const __u16 src_char, const struct nls_table *cp,\n\t     int maptype)\n{\n\tint len = 1;\n\n\tif ((maptype == SFM_MAP_UNI_RSVD) && convert_sfm_char(src_char, target))\n\t\treturn len;\n\telse if ((maptype == SFU_MAP_UNI_RSVD) &&\n\t\t  convert_sfu_char(src_char, target))\n\t\treturn len;\n\n\t/* if character not one of seven in special remap set */\n\tlen = cp->uni2char(src_char, target, NLS_MAX_CHARSET_SIZE);\n\tif (len <= 0) {\n\t\t*target = '?';\n\t\tlen = 1;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&from[i]"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nls_nullsize",
          "args": [
            "codepage"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,\n\t\tconst struct nls_table *codepage, int map_type)\n{\n\tint i, charlen, safelen;\n\tint outlen = 0;\n\tint nullsize = nls_nullsize(codepage);\n\tint fromwords = fromlen / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\t/*\n\t * because the chars can be of varying widths, we need to take care\n\t * not to overflow the destination buffer when we get close to the\n\t * end of it. Until we get to this offset, we don't need to check\n\t * for overflow however.\n\t */\n\tsafelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);\n\n\tfor (i = 0; i < fromwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * check to see if converting this character might make the\n\t\t * conversion bleed into the null terminator\n\t\t */\n\t\tif (outlen >= safelen) {\n\t\t\tcharlen = cifs_mapchar(tmp, ftmp, codepage, map_type);\n\t\t\tif ((outlen + charlen) > (tolen - nullsize))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* put converted char into 'to' buffer */\n\t\tcharlen = cifs_mapchar(&to[outlen], ftmp, codepage, map_type);\n\t\toutlen += charlen;\n\t}\n\n\t/* properly null-terminate string */\n\tfor (i = 0; i < nullsize; i++)\n\t\tto[outlen++] = 0;\n\n\treturn outlen;\n}"
  },
  {
    "function_name": "cifs_mapchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "157-176",
    "snippet": "static int\ncifs_mapchar(char *target, const __u16 src_char, const struct nls_table *cp,\n\t     int maptype)\n{\n\tint len = 1;\n\n\tif ((maptype == SFM_MAP_UNI_RSVD) && convert_sfm_char(src_char, target))\n\t\treturn len;\n\telse if ((maptype == SFU_MAP_UNI_RSVD) &&\n\t\t  convert_sfu_char(src_char, target))\n\t\treturn len;\n\n\t/* if character not one of seven in special remap set */\n\tlen = cp->uni2char(src_char, target, NLS_MAX_CHARSET_SIZE);\n\tif (len <= 0) {\n\t\t*target = '?';\n\t\tlen = 1;\n\t}\n\treturn len;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cp->uni2char",
          "args": [
            "src_char",
            "target",
            "NLS_MAX_CHARSET_SIZE"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "uni2char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7837-7875",
          "snippet": "static int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};",
            "static const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};\nstatic const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };\n\nstatic int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_sfu_char",
          "args": [
            "src_char",
            "target"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "convert_sfu_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "80-111",
          "snippet": "static bool\nconvert_sfu_char(const __u16 src_char, char *target)\n{\n\t/*\n\t * BB: Cannot handle remapping UNI_SLASH until all the calls to\n\t *     build_path_from_dentry are modified, as they use slash as\n\t *     separator.\n\t */\n\tswitch (src_char) {\n\tcase UNI_COLON:\n\t\t*target = ':';\n\t\tbreak;\n\tcase UNI_ASTERISK:\n\t\t*target = '*';\n\t\tbreak;\n\tcase UNI_QUESTION:\n\t\t*target = '?';\n\t\tbreak;\n\tcase UNI_PIPE:\n\t\t*target = '|';\n\t\tbreak;\n\tcase UNI_GRTRTHAN:\n\t\t*target = '>';\n\t\tbreak;\n\tcase UNI_LESSTHAN:\n\t\t*target = '<';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool\nconvert_sfu_char(const __u16 src_char, char *target)\n{\n\t/*\n\t * BB: Cannot handle remapping UNI_SLASH until all the calls to\n\t *     build_path_from_dentry are modified, as they use slash as\n\t *     separator.\n\t */\n\tswitch (src_char) {\n\tcase UNI_COLON:\n\t\t*target = ':';\n\t\tbreak;\n\tcase UNI_ASTERISK:\n\t\t*target = '*';\n\t\tbreak;\n\tcase UNI_QUESTION:\n\t\t*target = '?';\n\t\tbreak;\n\tcase UNI_PIPE:\n\t\t*target = '|';\n\t\tbreak;\n\tcase UNI_GRTRTHAN:\n\t\t*target = '>';\n\t\tbreak;\n\tcase UNI_LESSTHAN:\n\t\t*target = '<';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_sfm_char",
          "args": [
            "src_char",
            "target"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "convert_sfm_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "114-143",
          "snippet": "static bool\nconvert_sfm_char(const __u16 src_char, char *target)\n{\n\tswitch (src_char) {\n\tcase SFM_COLON:\n\t\t*target = ':';\n\t\tbreak;\n\tcase SFM_ASTERISK:\n\t\t*target = '*';\n\t\tbreak;\n\tcase SFM_QUESTION:\n\t\t*target = '?';\n\t\tbreak;\n\tcase SFM_PIPE:\n\t\t*target = '|';\n\t\tbreak;\n\tcase SFM_GRTRTHAN:\n\t\t*target = '>';\n\t\tbreak;\n\tcase SFM_LESSTHAN:\n\t\t*target = '<';\n\t\tbreak;\n\tcase SFM_SLASH:\n\t\t*target = '\\\\';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool\nconvert_sfm_char(const __u16 src_char, char *target)\n{\n\tswitch (src_char) {\n\tcase SFM_COLON:\n\t\t*target = ':';\n\t\tbreak;\n\tcase SFM_ASTERISK:\n\t\t*target = '*';\n\t\tbreak;\n\tcase SFM_QUESTION:\n\t\t*target = '?';\n\t\tbreak;\n\tcase SFM_PIPE:\n\t\t*target = '|';\n\t\tbreak;\n\tcase SFM_GRTRTHAN:\n\t\t*target = '>';\n\t\tbreak;\n\tcase SFM_LESSTHAN:\n\t\t*target = '<';\n\t\tbreak;\n\tcase SFM_SLASH:\n\t\t*target = '\\\\';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_mapchar(char *target, const __u16 src_char, const struct nls_table *cp,\n\t     int maptype)\n{\n\tint len = 1;\n\n\tif ((maptype == SFM_MAP_UNI_RSVD) && convert_sfm_char(src_char, target))\n\t\treturn len;\n\telse if ((maptype == SFU_MAP_UNI_RSVD) &&\n\t\t  convert_sfu_char(src_char, target))\n\t\treturn len;\n\n\t/* if character not one of seven in special remap set */\n\tlen = cp->uni2char(src_char, target, NLS_MAX_CHARSET_SIZE);\n\tif (len <= 0) {\n\t\t*target = '?';\n\t\tlen = 1;\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "convert_sfm_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "114-143",
    "snippet": "static bool\nconvert_sfm_char(const __u16 src_char, char *target)\n{\n\tswitch (src_char) {\n\tcase SFM_COLON:\n\t\t*target = ':';\n\t\tbreak;\n\tcase SFM_ASTERISK:\n\t\t*target = '*';\n\t\tbreak;\n\tcase SFM_QUESTION:\n\t\t*target = '?';\n\t\tbreak;\n\tcase SFM_PIPE:\n\t\t*target = '|';\n\t\tbreak;\n\tcase SFM_GRTRTHAN:\n\t\t*target = '>';\n\t\tbreak;\n\tcase SFM_LESSTHAN:\n\t\t*target = '<';\n\t\tbreak;\n\tcase SFM_SLASH:\n\t\t*target = '\\\\';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool\nconvert_sfm_char(const __u16 src_char, char *target)\n{\n\tswitch (src_char) {\n\tcase SFM_COLON:\n\t\t*target = ':';\n\t\tbreak;\n\tcase SFM_ASTERISK:\n\t\t*target = '*';\n\t\tbreak;\n\tcase SFM_QUESTION:\n\t\t*target = '?';\n\t\tbreak;\n\tcase SFM_PIPE:\n\t\t*target = '|';\n\t\tbreak;\n\tcase SFM_GRTRTHAN:\n\t\t*target = '>';\n\t\tbreak;\n\tcase SFM_LESSTHAN:\n\t\t*target = '<';\n\t\tbreak;\n\tcase SFM_SLASH:\n\t\t*target = '\\\\';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "convert_sfu_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "80-111",
    "snippet": "static bool\nconvert_sfu_char(const __u16 src_char, char *target)\n{\n\t/*\n\t * BB: Cannot handle remapping UNI_SLASH until all the calls to\n\t *     build_path_from_dentry are modified, as they use slash as\n\t *     separator.\n\t */\n\tswitch (src_char) {\n\tcase UNI_COLON:\n\t\t*target = ':';\n\t\tbreak;\n\tcase UNI_ASTERISK:\n\t\t*target = '*';\n\t\tbreak;\n\tcase UNI_QUESTION:\n\t\t*target = '?';\n\t\tbreak;\n\tcase UNI_PIPE:\n\t\t*target = '|';\n\t\tbreak;\n\tcase UNI_GRTRTHAN:\n\t\t*target = '>';\n\t\tbreak;\n\tcase UNI_LESSTHAN:\n\t\t*target = '<';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool\nconvert_sfu_char(const __u16 src_char, char *target)\n{\n\t/*\n\t * BB: Cannot handle remapping UNI_SLASH until all the calls to\n\t *     build_path_from_dentry are modified, as they use slash as\n\t *     separator.\n\t */\n\tswitch (src_char) {\n\tcase UNI_COLON:\n\t\t*target = ':';\n\t\tbreak;\n\tcase UNI_ASTERISK:\n\t\t*target = '*';\n\t\tbreak;\n\tcase UNI_QUESTION:\n\t\t*target = '?';\n\t\tbreak;\n\tcase UNI_PIPE:\n\t\t*target = '|';\n\t\tbreak;\n\tcase UNI_GRTRTHAN:\n\t\t*target = '>';\n\t\tbreak;\n\tcase UNI_LESSTHAN:\n\t\t*target = '<';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "cifs_remap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "65-77",
    "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
  },
  {
    "function_name": "cifs_utf16_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
    "lines": "40-63",
    "snippet": "int\ncifs_utf16_bytes(const __le16 *from, int maxbytes,\n\t\tconst struct nls_table *codepage)\n{\n\tint i;\n\tint charlen, outlen = 0;\n\tint maxwords = maxbytes / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\tfor (i = 0; i < maxwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\tcharlen = codepage->uni2char(ftmp, tmp, NLS_MAX_CHARSET_SIZE);\n\t\tif (charlen > 0)\n\t\t\toutlen += charlen;\n\t\telse\n\t\t\toutlen++;\n\t}\n\n\treturn outlen;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_uniupr.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "codepage->uni2char",
          "args": [
            "ftmp",
            "tmp",
            "NLS_MAX_CHARSET_SIZE"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "uni2char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7837-7875",
          "snippet": "static int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};",
            "static const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};\nstatic const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };\n\nstatic int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&from[i]"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_utf16_bytes(const __le16 *from, int maxbytes,\n\t\tconst struct nls_table *codepage)\n{\n\tint i;\n\tint charlen, outlen = 0;\n\tint maxwords = maxbytes / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\tfor (i = 0; i < maxwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\tcharlen = codepage->uni2char(ftmp, tmp, NLS_MAX_CHARSET_SIZE);\n\t\tif (charlen > 0)\n\t\t\toutlen += charlen;\n\t\telse\n\t\t\toutlen++;\n\t}\n\n\treturn outlen;\n}"
  }
]