[
  {
    "function_name": "ext4_inode_resume_unlocked_dio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "2830-2834",
    "snippet": "static inline void ext4_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb();\n\text4_clear_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_DIOREAD_LOCK"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb();\n\text4_clear_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n}"
  },
  {
    "function_name": "ext4_inode_block_unlocked_dio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "2825-2829",
    "snippet": "static inline void ext4_inode_block_unlocked_dio(struct inode *inode)\n{\n\text4_set_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n\tsmp_mb();\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_DIOREAD_LOCK"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_block_unlocked_dio(struct inode *inode)\n{\n\text4_set_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n\tsmp_mb();\n}"
  },
  {
    "function_name": "set_bitmap_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "2816-2819",
    "snippet": "static inline void set_bitmap_uptodate(struct buffer_head *bh)\n{\n\tset_bit(BH_BITMAP_UPTODATE, &(bh)->b_state);\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define BH_BITMAP_UPTODATE BH_JBDPrivateStart"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BH_BITMAP_UPTODATE",
            "&(bh)->b_state"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "396-400",
          "snippet": "static inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define BH_BITMAP_UPTODATE BH_JBDPrivateStart\n\nstatic inline void set_bitmap_uptodate(struct buffer_head *bh)\n{\n\tset_bit(BH_BITMAP_UPTODATE, &(bh)->b_state);\n}"
  },
  {
    "function_name": "bitmap_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "2811-2815",
    "snippet": "static inline int bitmap_uptodate(struct buffer_head *bh)\n{\n\treturn (buffer_uptodate(bh) &&\n\t\t\ttest_bit(BH_BITMAP_UPTODATE, &(bh)->b_state));\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define BH_BITMAP_UPTODATE BH_JBDPrivateStart"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BH_BITMAP_UPTODATE",
            "&(bh)->b_state"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2813
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define BH_BITMAP_UPTODATE BH_JBDPrivateStart\n\nstatic inline int bitmap_uptodate(struct buffer_head *bh)\n{\n\treturn (buffer_uptodate(bh) &&\n\t\t\ttest_bit(BH_BITMAP_UPTODATE, &(bh)->b_state));\n}"
  },
  {
    "function_name": "ext4_set_de_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "2695-2700",
    "snippet": "static inline void ext4_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext4_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define S_SHIFT 12",
      "#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_FILETYPE"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define S_SHIFT 12\n#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n\nstatic inline void ext4_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext4_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}"
  },
  {
    "function_name": "ext4_has_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "2665-2669",
    "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_INLINE_DATA"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
  },
  {
    "function_name": "ext4_unlock_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "2567-2571",
    "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ext4_group_lock_ptr(sb, group)"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_lock_ptr",
          "args": [
            "sb",
            "group"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_lock_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2211-2536",
          "snippet": "extern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400",
            "#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n\nextern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
  },
  {
    "function_name": "ext4_lock_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "2547-2565",
    "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "lock"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add_unless",
          "args": [
            "&EXT4_SB(sb)->s_lock_busy",
            "1",
            "EXT4_MAX_CONTENTION"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add_unless",
          "args": [
            "&EXT4_SB(sb)->s_lock_busy",
            "-1",
            "0"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "lock"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_lock_ptr",
          "args": [
            "sb",
            "group"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_lock_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2211-2536",
          "snippet": "extern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400",
            "#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n\nextern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
  },
  {
    "function_name": "ext4_fs_is_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "2542-2545",
    "snippet": "static inline int ext4_fs_is_busy(struct ext4_sb_info *sbi)\n{\n\treturn (atomic_read(&sbi->s_lock_busy) > EXT4_CONTENTION_THRESHOLD);\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_lock_busy"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_fs_is_busy(struct ext4_sb_info *sbi)\n{\n\treturn (atomic_read(&sbi->s_lock_busy) > EXT4_CONTENTION_THRESHOLD);\n}"
  },
  {
    "function_name": "ext4_group_lock_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "2211-2536",
    "snippet": "extern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400",
      "#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bgl_lock_ptr",
          "args": [
            "EXT4_SB(sb)->s_blockgroup_lock",
            "group"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2535
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_CLEAR_TRIMMED",
          "args": [
            "grp"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_SET_TRIMMED",
          "args": [
            "grp"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ext4_error_file",
          "args": [
            "file",
            "\"\",0",
            "block",
            "\" \");\t\t\t\\\n} while (0)\n#defineext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "fmt",
            "...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize){\n\t\text4_update_i_disksize(inode",
            "newsize"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "407-424",
          "snippet": "void __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext4_error",
          "args": [
            "sb",
            "\"\",0",
            "\" \");\t\t\t\t\t\\\n} while (0)\n#defineext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_abort",
          "args": [
            "sb",
            "fmt",
            "...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size){\n\t\ti_size_write(inode",
            "newsize"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "563-591",
          "snippet": "void __ext4_abort(struct super_block *sb, const char *function,\n\t\tunsigned int line, const char *fmt, ...)\n{\n\tva_list args;\n\n\tsave_error_info(sb, function, line);\n\tva_start(args, fmt);\n\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \", sb->s_id,\n\t       function, line);\n\tvprintk(fmt, args);\n\tprintk(\"\\n\");\n\tva_end(args);\n\n\tif ((sb->s_flags & MS_RDONLY) == 0) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tif (EXT4_SB(sb)->s_journal)\n\t\t\tjbd2_journal_abort(EXT4_SB(sb)->s_journal, -EIO);\n\t\tsave_error_info(sb, function, line);\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs panic from previous error\\n\");\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_abort(struct super_block *sb, const char *function,\n\t\tunsigned int line, const char *fmt, ...)\n{\n\tva_list args;\n\n\tsave_error_info(sb, function, line);\n\tva_start(args, fmt);\n\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \", sb->s_id,\n\t       function, line);\n\tvprintk(fmt, args);\n\tprintk(\"\\n\");\n\tva_end(args);\n\n\tif ((sb->s_flags & MS_RDONLY) == 0) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tif (EXT4_SB(sb)->s_journal)\n\t\t\tjbd2_journal_abort(EXT4_SB(sb)->s_journal, -EIO);\n\t\tsave_error_info(sb, function, line);\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs panic from previous error\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext4_abort",
          "args": [
            "sb",
            "\"\",0",
            "\" \");\t\t\t\t\t\\\n} while (0)\n#defineext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "fmt",
            "...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode",
            "loff_tnewsize"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext4_warning",
          "args": [
            "sb",
            "\"\",0",
            "\" \");\t\t\t\t\t\\\n} while (0)\n#defineext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "level",
            "fmt",
            "...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)EXT4_I(inode"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext4_msg",
          "args": [
            "sb",
            "\"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dump_mmp_msg",
          "args": [
            "sb",
            "mmp",
            "\"\",0",
            "\"\")\n#defineext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_grp_locked_error",
          "args": [
            "sb",
            "grp",
            "ino",
            "block",
            "fmt",
            "...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);__ext4_grp_locked_error(\"\"",
            "0",
            "sb",
            "grp",
            "ino",
            "block",
            "\" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturnEXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv",
            "indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info =EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex)"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_grp_locked_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "627-677",
          "snippet": "void __ext4_grp_locked_error(const char *function, unsigned int line,\n\t\t\t     struct super_block *sb, ext4_group_t grp,\n\t\t\t     unsigned long ino, ext4_fsblk_t block,\n\t\t\t     const char *fmt, ...)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb);\n\t/*\n\t * We only get here in the ERRORS_RO case; relocking the group\n\t * may be dangerous, but nothing bad will happen since the\n\t * filesystem will have already been marked read/only and the\n\t * journal has been aborted.  We return 1 as a hint to callers\n\t * who might what to use the return value from\n\t * ext4_grp_locked_error() to distinguish between the\n\t * ERRORS_CONT and ERRORS_RO case, and perhaps return more\n\t * aggressively from the ext4 function in question, with a\n\t * more appropriate error code.\n\t */\n\text4_lock_group(sb, grp);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_grp_locked_error(const char *function, unsigned int line,\n\t\t\t     struct super_block *sb, ext4_group_t grp,\n\t\t\t     unsigned long ino, ext4_fsblk_t block,\n\t\t\t     const char *fmt, ...)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb);\n\t/*\n\t * We only get here in the ERRORS_RO case; relocking the group\n\t * may be dangerous, but nothing bad will happen since the\n\t * filesystem will have already been marked read/only and the\n\t * journal has been aborted.  We return 1 as a hint to callers\n\t * who might what to use the return value from\n\t * ext4_grp_locked_error() to distinguish between the\n\t * ERRORS_CONT and ERRORS_RO case, and perhaps return more\n\t * aggressively from the ext4 function in question, with a\n\t * more appropriate error code.\n\t */\n\text4_lock_group(sb, grp);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_update_i_disksize",
          "args": [
            "struct inode *inode",
            "loff_tnewsize"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_FREECLUSTERS_WATERMARK",
          "args": [
            "4 * (percpu_counter_batch * nr_cpu_ids)"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ext4_std_error",
          "args": [
            "(sb)",
            "__func__",
            "__LINE__",
            "(errno)"
          ],
          "line": 2452
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_std_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "530-551",
          "snippet": "void __ext4_std_error(struct super_block *sb, const char *function,\n\t\t      unsigned int line, int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\t/* Special case: if the error is EROFS, and we're not already\n\t * inside a transaction, then there's really no point in logging\n\t * an error. */\n\tif (errno == -EROFS && journal_current_handle() == NULL &&\n\t    (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\terrstr = ext4_decode_error(sb, errno, nbuf);\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s) in %s:%d: %s\\n\",\n\t\t       sb->s_id, function, line, errstr);\n\t}\n\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_std_error(struct super_block *sb, const char *function,\n\t\t      unsigned int line, int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\t/* Special case: if the error is EROFS, and we're not already\n\t * inside a transaction, then there's really no point in logging\n\t * an error. */\n\tif (errno == -EROFS && journal_current_handle() == NULL &&\n\t    (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\terrstr = ext4_decode_error(sb, errno, nbuf);\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s) in %s:%d: %s\\n\",\n\t\t       sb->s_id, function, line, errstr);\n\t}\n\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "errno"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_flex_bg_size",
          "args": [
            "structext4_sb_info *sbi"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_flex_group",
          "args": [
            "structext4_sb_info *sbi",
            "ext4_group_tblock_group"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "structsuper_block *sb"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "group >= EXT4_SB(sb)->s_groups_count"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "structsuper_block *sb",
            "ext4_group_tgroup"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_size >> 32"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_size"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_isize_set",
          "args": [
            "structext4_inode *raw_inode",
            "loff_ti_size"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_inode->i_size_lo"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "return",
          "args": [
            "(loff_t)le32_to_cpu(raw_inode->i_size_high) << 32"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "le16_to_cpu(raw_inode->i_mode)"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "raw_inode->i_mode"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_isize",
          "args": [
            "structext4_inode *raw_inode"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "blk >> 32"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)blk"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_r_blocks_count_set",
          "args": [
            "structext4_super_block *es",
            "ext4_fsblk_tblk"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "blk >> 32"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)blk"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks_count_set",
          "args": [
            "structext4_super_block *es",
            "ext4_fsblk_tblk"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "blk >> 32"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)blk"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count_set",
          "args": [
            "structext4_super_block *es",
            "ext4_fsblk_tblk"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks_count",
          "args": [
            "structext4_super_block *es"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_r_blocks_count",
          "args": [
            "structext4_super_block *es"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "structext4_super_block *es"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_METADATA_CSUM"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "structsuper_block *sb"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_GDT_CSUM"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_group_desc_csum",
          "args": [
            "structsuper_block *sb"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_register_li_request",
          "args": [
            "structsuper_block *sb",
            "ext4_group_tfirst_not_zeroed"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_register_li_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3137-3194",
          "snippet": "int ext4_register_li_request(struct super_block *sb,\n\t\t\t     ext4_group_t first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr = NULL;\n\text4_group_t ngroups = EXT4_SB(sb)->s_groups_count;\n\tint ret = 0;\n\n\tmutex_lock(&ext4_li_mtx);\n\tif (sbi->s_li_request != NULL) {\n\t\t/*\n\t\t * Reset timeout so it can be computed again, because\n\t\t * s_li_wait_mult might have changed.\n\t\t */\n\t\tsbi->s_li_request->lr_timeout = 0;\n\t\tgoto out;\n\t}\n\n\tif (first_not_zeroed == ngroups ||\n\t    (sb->s_flags & MS_RDONLY) ||\n\t    !test_opt(sb, INIT_INODE_TABLE))\n\t\tgoto out;\n\n\telr = ext4_li_request_new(sb, first_not_zeroed);\n\tif (!elr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (NULL == ext4_li_info) {\n\t\tret = ext4_li_info_new();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_add(&elr->lr_request, &ext4_li_info->li_request_list);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\n\tsbi->s_li_request = elr;\n\t/*\n\t * set elr to NULL here since it has been inserted to\n\t * the request_list and the removal and free of it is\n\t * handled by ext4_clear_request_list from now on.\n\t */\n\telr = NULL;\n\n\tif (!(ext4_li_info->li_state & EXT4_LAZYINIT_RUNNING)) {\n\t\tret = ext4_run_lazyinit_thread();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ext4_li_mtx);\n\tif (ret)\n\t\tkfree(elr);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_lazy_init *ext4_li_info;",
            "static struct mutex ext4_li_mtx;",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static void ext4_clear_request_list(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic struct mutex ext4_li_mtx;\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic void ext4_clear_request_list(void);\n\nint ext4_register_li_request(struct super_block *sb,\n\t\t\t     ext4_group_t first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr = NULL;\n\text4_group_t ngroups = EXT4_SB(sb)->s_groups_count;\n\tint ret = 0;\n\n\tmutex_lock(&ext4_li_mtx);\n\tif (sbi->s_li_request != NULL) {\n\t\t/*\n\t\t * Reset timeout so it can be computed again, because\n\t\t * s_li_wait_mult might have changed.\n\t\t */\n\t\tsbi->s_li_request->lr_timeout = 0;\n\t\tgoto out;\n\t}\n\n\tif (first_not_zeroed == ngroups ||\n\t    (sb->s_flags & MS_RDONLY) ||\n\t    !test_opt(sb, INIT_INODE_TABLE))\n\t\tgoto out;\n\n\telr = ext4_li_request_new(sb, first_not_zeroed);\n\tif (!elr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (NULL == ext4_li_info) {\n\t\tret = ext4_li_info_new();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_add(&elr->lr_request, &ext4_li_info->li_request_list);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\n\tsbi->s_li_request = elr;\n\t/*\n\t * set elr to NULL here since it has been inserted to\n\t * the request_list and the removal and free of it is\n\t * handled by ext4_clear_request_list from now on.\n\t */\n\telr = NULL;\n\n\tif (!(ext4_li_info->li_state & EXT4_LAZYINIT_RUNNING)) {\n\t\tret = ext4_run_lazyinit_thread();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ext4_li_mtx);\n\tif (ret)\n\t\tkfree(elr);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_desc_csum_set",
          "args": [
            "structsuper_block *sb",
            "__u32group",
            "structext4_group_desc *gdp"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2050-2056",
          "snippet": "void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_desc_csum_verify",
          "args": [
            "structsuper_block *sb",
            "__u32group",
            "structext4_group_desc *gdp"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2039-2048",
          "snippet": "int ext4_group_desc_csum_verify(struct super_block *sb, __u32 block_group,\n\t\t\t\tstruct ext4_group_desc *gdp)\n{\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_checksum != ext4_group_desc_csum(EXT4_SB(sb),\n\t\t\t\t\t\t      block_group, gdp)))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nint ext4_group_desc_csum_verify(struct super_block *sb, __u32 block_group,\n\t\t\t\tstruct ext4_group_desc *gdp)\n{\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_checksum != ext4_group_desc_csum(EXT4_SB(sb),\n\t\t\t\t\t\t      block_group, gdp)))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_itable_unused_set",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg",
            "__u32count"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_itable_unused_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "283-289",
          "snippet": "void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_itable_unused_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_itable_unused_hi = cpu_to_le16(count >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_itable_unused_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_itable_unused_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_itable_unused_hi = cpu_to_le16(count >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_used_dirs_set",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg",
            "__u32count"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_used_dirs_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "275-281",
          "snippet": "void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_used_dirs_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_used_dirs_count_hi = cpu_to_le16(count >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_used_dirs_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_used_dirs_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_used_dirs_count_hi = cpu_to_le16(count >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_inodes_set",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg",
            "__u32count"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_inodes_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "267-273",
          "snippet": "void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_inodes_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_inodes_count_hi = cpu_to_le16(count >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_free_inodes_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_inodes_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_inodes_count_hi = cpu_to_le16(count >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_group_clusters_set",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg",
            "__u32count"
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_group_clusters_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "259-265",
          "snippet": "void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_table_set",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg",
            "ext4_fsblk_tblk"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_table_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "251-257",
          "snippet": "void ext4_inode_table_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_table_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_table_hi = cpu_to_le32(blk >> 32);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid ext4_inode_table_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_table_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_table_hi = cpu_to_le32(blk >> 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap_set",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg",
            "ext4_fsblk_tblk"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "243-249",
          "snippet": "void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_bitmap_lo  = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_bitmap_hi = cpu_to_le32(blk >> 32);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_bitmap_lo  = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_bitmap_hi = cpu_to_le32(blk >> 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap_set",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg",
            "ext4_fsblk_tblk"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "235-241",
          "snippet": "void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_block_bitmap_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_block_bitmap_hi = cpu_to_le32(blk >> 32);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_block_bitmap_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_block_bitmap_hi = cpu_to_le32(blk >> 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_itable_unused_count",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_itable_unused_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "227-233",
          "snippet": "__u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_itable_unused_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_itable_unused_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_itable_unused_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_itable_unused_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_used_dirs_count",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_used_dirs_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "219-225",
          "snippet": "__u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_used_dirs_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_used_dirs_count_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_used_dirs_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_used_dirs_count_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_inodes_count",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_inodes_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "211-217",
          "snippet": "__u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_inodes_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_inodes_count_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_inodes_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_inodes_count_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_group_clusters",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_group_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "203-209",
          "snippet": "__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_table",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "195-201",
          "snippet": "ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "187-193",
          "snippet": "ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap",
          "args": [
            "structsuper_block *sb",
            "structext4_group_desc *bg"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "179-185",
          "snippet": "ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_incompat_feature",
          "args": [
            "handle_t *handle",
            "structsuper_block *sb",
            "__u32incompat"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_update_rocompat_feature",
          "args": [
            "handle_t *handle",
            "structsuper_block *sb",
            "__u32rocompat"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_update_compat_feature",
          "args": [
            "handle_t *handle",
            "structsuper_block *sb",
            "__u32compat"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_update_dynamic_rev",
          "args": [
            "structsuper_block *sb"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_dynamic_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "679-702",
          "snippet": "void ext4_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)\n\t\treturn;\n\n\text4_warning(sb,\n\t\t     \"updating to rev %d because of new feature flag, \"\n\t\t     \"running e2fsck is recommended\",\n\t\t     EXT4_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT4_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT4_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT4_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)\n\t\treturn;\n\n\text4_warning(sb,\n\t\t     \"updating to rev %d because of new feature flag, \"\n\t\t     \"running e2fsck is recommended\",\n\t\t     EXT4_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT4_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT4_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT4_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_printk",
          "args": [
            "fmt",
            "##__VA_ARGS__"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_mmp_msg",
          "args": [
            "sb",
            "mmp",
            "msg"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no_printk",
          "args": [
            "fmt",
            "##__VA_ARGS__"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no_printk",
          "args": [
            "fmt",
            "##__VA_ARGS__"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no_printk",
          "args": [
            "fmt",
            "##__VA_ARGS__"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no_printk",
          "args": [
            "fmt",
            "##__VA_ARGS__"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n\nextern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}"
  },
  {
    "function_name": "get_dtype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "2036-2043",
    "snippet": "static inline  unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT4_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn ext4_filetype_table[filetype];\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define EXT4_FT_MAX\t\t8",
      "#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_FILETYPE"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FT_MAX\t\t8\n#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n\nstatic inline  unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT4_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn ext4_filetype_table[filetype];\n}"
  },
  {
    "function_name": "ext4_update_dx_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "2026-2031",
    "snippet": "static inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_clear_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_INDEX"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "inode->i_sb",
            "EXT4_FEATURE_COMPAT_DIR_INDEX"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n\nstatic inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}"
  },
  {
    "function_name": "ext4_group_first_block_no",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1831-1836",
    "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_first_data_block"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
  },
  {
    "function_name": "ext4_raw_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1810-1813",
    "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
  },
  {
    "function_name": "ext4_chksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1756-1775",
    "snippet": "static inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&desc.shash",
            "address",
            "length"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx)"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_descsize",
          "args": [
            "sbi->s_chksum_driver"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}"
  },
  {
    "function_name": "ext4_rec_len_to_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1717-1734",
    "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(len & 65532) | ((len >> 16) & 3)"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_MAX_REC_LEN"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
  },
  {
    "function_name": "ext4_rec_len_from_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1703-1715",
    "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dlen"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
  },
  {
    "function_name": "ext4_clear_state_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1457-1460",
    "snippet": "static inline void ext4_clear_state_flags(struct ext4_inode_info *ei)\n{\n\t/* We depend on the fact that callers will set i_flags */\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_clear_state_flags(struct ext4_inode_info *ei)\n{\n\t/* We depend on the fact that callers will set i_flags */\n}"
  },
  {
    "function_name": "ext4_clear_state_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1450-1453",
    "snippet": "static inline void ext4_clear_state_flags(struct ext4_inode_info *ei)\n{\n\t(ei)->i_state_flags = 0;\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_clear_state_flags(struct ext4_inode_info *ei)\n{\n\t(ei)->i_state_flags = 0;\n}"
  },
  {
    "function_name": "ext4_inode_aio_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1397-1400",
    "snippet": "static inline void ext4_inode_aio_set(struct inode *inode, ext4_io_end_t *io)\n{\n\tinode->i_private = io;\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_aio_set(struct inode *inode, ext4_io_end_t *io)\n{\n\tinode->i_private = io;\n}"
  },
  {
    "function_name": "ext4_inode_aio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1392-1395",
    "snippet": "static inline ext4_io_end_t *ext4_inode_aio(struct inode *inode)\n{\n\treturn inode->i_private;\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_io_end_t *ext4_inode_aio(struct inode *inode)\n{\n\treturn inode->i_private;\n}"
  },
  {
    "function_name": "ext4_set_io_unwritten_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1383-1390",
    "snippet": "static inline void ext4_set_io_unwritten_flag(struct inode *inode,\n\t\t\t\t\t      struct ext4_io_end *io_end)\n{\n\tif (!(io_end->flag & EXT4_IO_END_UNWRITTEN)) {\n\t\tio_end->flag |= EXT4_IO_END_UNWRITTEN;\n\t\tatomic_inc(&EXT4_I(inode)->i_unwritten);\n\t}\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define\tEXT4_IO_END_UNWRITTEN\t0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&EXT4_I(inode)->i_unwritten"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define\tEXT4_IO_END_UNWRITTEN\t0x0001\n\nstatic inline void ext4_set_io_unwritten_flag(struct inode *inode,\n\t\t\t\t\t      struct ext4_io_end *io_end)\n{\n\tif (!(io_end->flag & EXT4_IO_END_UNWRITTEN)) {\n\t\tio_end->flag |= EXT4_IO_END_UNWRITTEN;\n\t\tatomic_inc(&EXT4_I(inode)->i_unwritten);\n\t}\n}"
  },
  {
    "function_name": "ext4_valid_inum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1371-1381",
    "snippet": "static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\tino == EXT4_USR_QUOTA_INO ||\n\t\tino == EXT4_GRP_QUOTA_INO ||\n\t\tino == EXT4_BOOT_LOADER_INO ||\n\t\tino == EXT4_JOURNAL_INO ||\n\t\tino == EXT4_RESIZE_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define EXT4_JOURNAL_INO\t 8\t/* Journal inode */",
      "#define EXT4_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */",
      "#define EXT4_BOOT_LOADER_INO\t 5\t/* Boot loader inode */",
      "#define EXT4_GRP_QUOTA_INO\t 4\t/* Group quota inode */",
      "#define EXT4_USR_QUOTA_INO\t 3\t/* User quota inode */",
      "#define EXT4_ROOT_INO\t\t 2\t/* Root inode */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_inodes_count"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_FIRST_INO",
          "args": [
            "sb"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_JOURNAL_INO\t 8\t/* Journal inode */\n#define EXT4_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */\n#define EXT4_BOOT_LOADER_INO\t 5\t/* Boot loader inode */\n#define EXT4_GRP_QUOTA_INO\t 4\t/* Group quota inode */\n#define EXT4_USR_QUOTA_INO\t 3\t/* User quota inode */\n#define EXT4_ROOT_INO\t\t 2\t/* Root inode */\n\nstatic inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\tino == EXT4_USR_QUOTA_INO ||\n\t\tino == EXT4_GRP_QUOTA_INO ||\n\t\tino == EXT4_BOOT_LOADER_INO ||\n\t\tino == EXT4_JOURNAL_INO ||\n\t\tino == EXT4_RESIZE_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}"
  },
  {
    "function_name": "ext4_current_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1365-1369",
    "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
  },
  {
    "function_name": "EXT4_I",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1360-1363",
    "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "inode",
            "structext4_inode_info",
            "vfs_inode"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
  },
  {
    "function_name": "EXT4_SB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "1356-1359",
    "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
  },
  {
    "function_name": "ext4_decode_extra_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "725-731",
    "snippet": "static inline void ext4_decode_extra_time(struct timespec *time, __le32 extra)\n{\n       if (sizeof(time->tv_sec) > 4)\n\t       time->tv_sec |= (__u64)(le32_to_cpu(extra) & EXT4_EPOCH_MASK)\n\t\t\t       << 32;\n       time->tv_nsec = (le32_to_cpu(extra) & EXT4_NSEC_MASK) >> EXT4_EPOCH_BITS;\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define EXT4_NSEC_MASK  (~0UL << EXT4_EPOCH_BITS)",
      "#define EXT4_EPOCH_MASK ((1 << EXT4_EPOCH_BITS) - 1)",
      "#define EXT4_EPOCH_BITS 2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "extra"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "le32_to_cpu(extra) & EXT4_EPOCH_MASK"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_NSEC_MASK  (~0UL << EXT4_EPOCH_BITS)\n#define EXT4_EPOCH_MASK ((1 << EXT4_EPOCH_BITS) - 1)\n#define EXT4_EPOCH_BITS 2\n\nstatic inline void ext4_decode_extra_time(struct timespec *time, __le32 extra)\n{\n       if (sizeof(time->tv_sec) > 4)\n\t       time->tv_sec |= (__u64)(le32_to_cpu(extra) & EXT4_EPOCH_MASK)\n\t\t\t       << 32;\n       time->tv_nsec = (le32_to_cpu(extra) & EXT4_NSEC_MASK) >> EXT4_EPOCH_BITS;\n}"
  },
  {
    "function_name": "ext4_encode_extra_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "718-723",
    "snippet": "static inline __le32 ext4_encode_extra_time(struct timespec *time)\n{\n       return cpu_to_le32((sizeof(time->tv_sec) > 4 ?\n\t\t\t   (time->tv_sec >> 32) & EXT4_EPOCH_MASK : 0) |\n                          ((time->tv_nsec << EXT4_EPOCH_BITS) & EXT4_NSEC_MASK));\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define EXT4_NSEC_MASK  (~0UL << EXT4_EPOCH_BITS)",
      "#define EXT4_EPOCH_MASK ((1 << EXT4_EPOCH_BITS) - 1)",
      "#define EXT4_EPOCH_BITS 2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(sizeof(time->tv_sec) > 4 ?\n\t\t\t   (time->tv_sec >> 32) & EXT4_EPOCH_MASK : 0) |\n                          ((time->tv_nsec << EXT4_EPOCH_BITS) & EXT4_NSEC_MASK)"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_NSEC_MASK  (~0UL << EXT4_EPOCH_BITS)\n#define EXT4_EPOCH_MASK ((1 << EXT4_EPOCH_BITS) - 1)\n#define EXT4_EPOCH_BITS 2\n\nstatic inline __le32 ext4_encode_extra_time(struct timespec *time)\n{\n       return cpu_to_le32((sizeof(time->tv_sec) > 4 ?\n\t\t\t   (time->tv_sec >> 32) & EXT4_EPOCH_MASK : 0) |\n                          ((time->tv_nsec << EXT4_EPOCH_BITS) & EXT4_NSEC_MASK));\n}"
  },
  {
    "function_name": "ext4_check_flag_values",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "457-483",
    "snippet": "static inline void ext4_check_flag_values(void)\n{\n\tCHECK_FLAG_VALUE(SECRM);\n\tCHECK_FLAG_VALUE(UNRM);\n\tCHECK_FLAG_VALUE(COMPR);\n\tCHECK_FLAG_VALUE(SYNC);\n\tCHECK_FLAG_VALUE(IMMUTABLE);\n\tCHECK_FLAG_VALUE(APPEND);\n\tCHECK_FLAG_VALUE(NODUMP);\n\tCHECK_FLAG_VALUE(NOATIME);\n\tCHECK_FLAG_VALUE(DIRTY);\n\tCHECK_FLAG_VALUE(COMPRBLK);\n\tCHECK_FLAG_VALUE(NOCOMPR);\n\tCHECK_FLAG_VALUE(ENCRYPT);\n\tCHECK_FLAG_VALUE(INDEX);\n\tCHECK_FLAG_VALUE(IMAGIC);\n\tCHECK_FLAG_VALUE(JOURNAL_DATA);\n\tCHECK_FLAG_VALUE(NOTAIL);\n\tCHECK_FLAG_VALUE(DIRSYNC);\n\tCHECK_FLAG_VALUE(TOPDIR);\n\tCHECK_FLAG_VALUE(HUGE_FILE);\n\tCHECK_FLAG_VALUE(EXTENTS);\n\tCHECK_FLAG_VALUE(EA_INODE);\n\tCHECK_FLAG_VALUE(EOFBLOCKS);\n\tCHECK_FLAG_VALUE(INLINE_DATA);\n\tCHECK_FLAG_VALUE(RESERVED);\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "RESERVED"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "INLINE_DATA"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "EOFBLOCKS"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "EA_INODE"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "EXTENTS"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "HUGE_FILE"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "TOPDIR"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "DIRSYNC"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "NOTAIL"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "JOURNAL_DATA"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "IMAGIC"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "INDEX"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "ENCRYPT"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "NOCOMPR"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "COMPRBLK"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "DIRTY"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "NOATIME"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "NODUMP"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "APPEND"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "IMMUTABLE"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "SYNC"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "COMPR"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "UNRM"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FLAG_VALUE",
          "args": [
            "SECRM"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_check_flag_values(void)\n{\n\tCHECK_FLAG_VALUE(SECRM);\n\tCHECK_FLAG_VALUE(UNRM);\n\tCHECK_FLAG_VALUE(COMPR);\n\tCHECK_FLAG_VALUE(SYNC);\n\tCHECK_FLAG_VALUE(IMMUTABLE);\n\tCHECK_FLAG_VALUE(APPEND);\n\tCHECK_FLAG_VALUE(NODUMP);\n\tCHECK_FLAG_VALUE(NOATIME);\n\tCHECK_FLAG_VALUE(DIRTY);\n\tCHECK_FLAG_VALUE(COMPRBLK);\n\tCHECK_FLAG_VALUE(NOCOMPR);\n\tCHECK_FLAG_VALUE(ENCRYPT);\n\tCHECK_FLAG_VALUE(INDEX);\n\tCHECK_FLAG_VALUE(IMAGIC);\n\tCHECK_FLAG_VALUE(JOURNAL_DATA);\n\tCHECK_FLAG_VALUE(NOTAIL);\n\tCHECK_FLAG_VALUE(DIRSYNC);\n\tCHECK_FLAG_VALUE(TOPDIR);\n\tCHECK_FLAG_VALUE(HUGE_FILE);\n\tCHECK_FLAG_VALUE(EXTENTS);\n\tCHECK_FLAG_VALUE(EA_INODE);\n\tCHECK_FLAG_VALUE(EOFBLOCKS);\n\tCHECK_FLAG_VALUE(INLINE_DATA);\n\tCHECK_FLAG_VALUE(RESERVED);\n}"
  },
  {
    "function_name": "ext4_mask_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
    "lines": "399-407",
    "snippet": "static inline __u32 ext4_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT4_REG_FLMASK;\n\telse\n\t\treturn flags & EXT4_OTHER_FLMASK;\n}",
    "includes": [
      "#include \"extents_status.h\"",
      "#include <linux/compat.h>",
      "#include <linux/falloc.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/wait.h>",
      "#include <linux/timer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quota.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define EXT4_OTHER_FLMASK (EXT4_NODUMP_FL | EXT4_NOATIME_FL)",
      "#define EXT4_REG_FLMASK (~(EXT4_DIRSYNC_FL | EXT4_TOPDIR_FL))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_OTHER_FLMASK (EXT4_NODUMP_FL | EXT4_NOATIME_FL)\n#define EXT4_REG_FLMASK (~(EXT4_DIRSYNC_FL | EXT4_TOPDIR_FL))\n\nstatic inline __u32 ext4_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT4_REG_FLMASK;\n\telse\n\t\treturn flags & EXT4_OTHER_FLMASK;\n}"
  }
]