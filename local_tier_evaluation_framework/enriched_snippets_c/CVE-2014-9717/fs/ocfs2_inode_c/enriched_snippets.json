[
  {
    "function_name": "ocfs2_inode_cache_io_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1445-1450",
    "snippet": "static void ocfs2_inode_cache_io_unlock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\tmutex_unlock(&oi->ip_io_mutex);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&oi->ip_io_mutex"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "ci"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "185-188",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_inode_cache_io_unlock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\tmutex_unlock(&oi->ip_io_mutex);\n}"
  },
  {
    "function_name": "ocfs2_inode_cache_io_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1438-1443",
    "snippet": "static void ocfs2_inode_cache_io_lock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\tmutex_lock(&oi->ip_io_mutex);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&oi->ip_io_mutex"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "ci"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "185-188",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_inode_cache_io_lock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\tmutex_lock(&oi->ip_io_mutex);\n}"
  },
  {
    "function_name": "ocfs2_inode_cache_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1431-1436",
    "snippet": "static void ocfs2_inode_cache_unlock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\tspin_unlock(&oi->ip_lock);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "ci"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "185-188",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_inode_cache_unlock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\tspin_unlock(&oi->ip_lock);\n}"
  },
  {
    "function_name": "ocfs2_inode_cache_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1424-1429",
    "snippet": "static void ocfs2_inode_cache_lock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\tspin_lock(&oi->ip_lock);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "ci"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "185-188",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_inode_cache_lock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\tspin_lock(&oi->ip_lock);\n}"
  },
  {
    "function_name": "ocfs2_inode_cache_get_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1417-1422",
    "snippet": "static struct super_block *ocfs2_inode_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\treturn oi->vfs_inode.i_sb;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "ci"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "185-188",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct super_block *ocfs2_inode_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\treturn oi->vfs_inode.i_sb;\n}"
  },
  {
    "function_name": "ocfs2_inode_cache_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1410-1415",
    "snippet": "static u64 ocfs2_inode_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\treturn oi->ip_blkno;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "ci"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "185-188",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_inode_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\treturn oi->ip_blkno;\n}"
  },
  {
    "function_name": "ocfs2_read_inode_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1404-1407",
    "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block_full",
          "args": [
            "inode",
            "bh",
            "0"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1388-1402",
          "snippet": "int ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t/* If ocfs2_read_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t/* If ocfs2_read_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
  },
  {
    "function_name": "ocfs2_read_inode_block_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1388-1402",
    "snippet": "int ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t/* If ocfs2_read_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_read_blocks",
          "args": [
            "INODE_CACHE(inode)",
            "OCFS2_I(inode)->ip_blkno",
            "1",
            "&tmp",
            "flags",
            "ocfs2_validate_inode_block"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "176-366",
          "snippet": "int ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t/* If ocfs2_read_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_validate_inode_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1324-1386",
    "snippet": "int ocfs2_validate_inode_block(struct super_block *sb,\n\t\t\t       struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\ttrace_ocfs2_validate_inode_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &di->i_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for dinode %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Errors after here are fatal.\n\t */\n\n\trc = -EINVAL;\n\n\tif (!OCFS2_IS_VALID_DINODE(di)) {\n\t\tocfs2_error(sb, \"Invalid dinode #%llu: signature = %.*s\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    di->i_signature);\n\t\tgoto bail;\n\t}\n\n\tif (le64_to_cpu(di->i_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb, \"Invalid dinode #%llu: i_blkno is %llu\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(di->i_blkno));\n\t\tgoto bail;\n\t}\n\n\tif (!(di->i_flags & cpu_to_le32(OCFS2_VALID_FL))) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid dinode #%llu: OCFS2_VALID_FL not set\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr);\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(di->i_fs_generation) !=\n\t    OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid dinode #%llu: fs_generation is %u\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(di->i_fs_generation));\n\t\tgoto bail;\n\t}\n\n\trc = 0;\n\nbail:\n\treturn rc;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Invalid dinode #%llu: fs_generation is %u\\n\"",
            "(unsigned long long)bh->b_blocknr",
            "le32_to_cpu(di->i_fs_generation)"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->i_fs_generation"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_VALID_FL"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_blkno"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "di"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Checksum failed for dinode %llu\\n\"",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_meta_ecc",
          "args": [
            "sb",
            "bh->b_data",
            "&di->i_check"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "613-624",
          "snippet": "int ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_validate_inode_block",
          "args": [
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_validate_inode_block(struct super_block *sb,\n\t\t\t       struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\ttrace_ocfs2_validate_inode_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &di->i_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for dinode %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Errors after here are fatal.\n\t */\n\n\trc = -EINVAL;\n\n\tif (!OCFS2_IS_VALID_DINODE(di)) {\n\t\tocfs2_error(sb, \"Invalid dinode #%llu: signature = %.*s\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    di->i_signature);\n\t\tgoto bail;\n\t}\n\n\tif (le64_to_cpu(di->i_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb, \"Invalid dinode #%llu: i_blkno is %llu\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(di->i_blkno));\n\t\tgoto bail;\n\t}\n\n\tif (!(di->i_flags & cpu_to_le32(OCFS2_VALID_FL))) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid dinode #%llu: OCFS2_VALID_FL not set\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr);\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(di->i_fs_generation) !=\n\t    OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid dinode #%llu: fs_generation is %u\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(di->i_fs_generation));\n\t\tgoto bail;\n\t}\n\n\trc = 0;\n\nbail:\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_refresh_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1296-1322",
    "snippet": "void ocfs2_refresh_inode(struct inode *inode,\n\t\t\t struct ocfs2_dinode *fe)\n{\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tOCFS2_I(inode)->ip_attr = le32_to_cpu(fe->i_attr);\n\tOCFS2_I(inode)->ip_dyn_features = le16_to_cpu(fe->i_dyn_features);\n\tocfs2_set_inode_flags(inode);\n\ti_size_write(inode, le64_to_cpu(fe->i_size));\n\tset_nlink(inode, ocfs2_read_links_count(fe));\n\ti_uid_write(inode, le32_to_cpu(fe->i_uid));\n\ti_gid_write(inode, le32_to_cpu(fe->i_gid));\n\tinode->i_mode = le16_to_cpu(fe->i_mode);\n\tif (S_ISLNK(inode->i_mode) && le32_to_cpu(fe->i_clusters) == 0)\n\t\tinode->i_blocks = 0;\n\telse\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);\n\tinode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);\n\tinode->i_ctime.tv_sec = le64_to_cpu(fe->i_ctime);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(fe->i_ctime_nsec);\n\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(inode)->ip_lock"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->i_ctime_nsec"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_ctime"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "inode"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fe->i_mode"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "le32_to_cpu(fe->i_gid)"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "le32_to_cpu(fe->i_uid)"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "ocfs2_read_links_count(fe)"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_links_count",
          "args": [
            "fe"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "553-562",
          "snippet": "static inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "le64_to_cpu(fe->i_size)"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "77-95",
          "snippet": "void ocfs2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = OCFS2_I(inode)->ip_attr;\n\n\tinode->i_flags &= ~(S_IMMUTABLE |\n\t\tS_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);\n\n\tif (flags & OCFS2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\n\tif (flags & OCFS2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & OCFS2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & OCFS2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & OCFS2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = OCFS2_I(inode)->ip_attr;\n\n\tinode->i_flags &= ~(S_IMMUTABLE |\n\t\tS_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);\n\n\tif (flags & OCFS2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\n\tif (flags & OCFS2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & OCFS2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & OCFS2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & OCFS2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(inode)->ip_lock"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_refresh_inode(struct inode *inode,\n\t\t\t struct ocfs2_dinode *fe)\n{\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tOCFS2_I(inode)->ip_attr = le32_to_cpu(fe->i_attr);\n\tOCFS2_I(inode)->ip_dyn_features = le16_to_cpu(fe->i_dyn_features);\n\tocfs2_set_inode_flags(inode);\n\ti_size_write(inode, le64_to_cpu(fe->i_size));\n\tset_nlink(inode, ocfs2_read_links_count(fe));\n\ti_uid_write(inode, le32_to_cpu(fe->i_uid));\n\ti_gid_write(inode, le32_to_cpu(fe->i_gid));\n\tinode->i_mode = le16_to_cpu(fe->i_mode);\n\tif (S_ISLNK(inode->i_mode) && le32_to_cpu(fe->i_clusters) == 0)\n\t\tinode->i_blocks = 0;\n\telse\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);\n\tinode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);\n\tinode->i_ctime.tv_sec = le64_to_cpu(fe->i_ctime);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(fe->i_ctime_nsec);\n\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n}"
  },
  {
    "function_name": "ocfs2_mark_inode_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1250-1289",
    "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_mtime.tv_nsec"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_mtime.tv_sec"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_nsec"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_atime.tv_nsec"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_atime.tv_sec"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_mode"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_gid_read(inode)"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_uid_read(inode)"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_links_count",
          "args": [
            "fe",
            "inode->i_nlink"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "564-573",
          "snippet": "static inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "i_size_read(inode)"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(inode)->ip_lock"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "OCFS2_I(inode)->ip_dyn_features"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_I(inode)->ip_attr"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_inode_flags",
          "args": [
            "OCFS2_I(inode)"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "98-114",
          "snippet": "void ocfs2_get_inode_flags(struct ocfs2_inode_info *oi)\n{\n\tunsigned int flags = oi->vfs_inode.i_flags;\n\n\toi->ip_attr &= ~(OCFS2_SYNC_FL|OCFS2_APPEND_FL|\n\t\t\tOCFS2_IMMUTABLE_FL|OCFS2_NOATIME_FL|OCFS2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\toi->ip_attr |= OCFS2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\toi->ip_attr |= OCFS2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\toi->ip_attr |= OCFS2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\toi->ip_attr |= OCFS2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\toi->ip_attr |= OCFS2_DIRSYNC_FL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_get_inode_flags(struct ocfs2_inode_info *oi)\n{\n\tunsigned int flags = oi->vfs_inode.i_flags;\n\n\toi->ip_attr &= ~(OCFS2_SYNC_FL|OCFS2_APPEND_FL|\n\t\t\tOCFS2_IMMUTABLE_FL|OCFS2_NOATIME_FL|OCFS2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\toi->ip_attr |= OCFS2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\toi->ip_attr |= OCFS2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\toi->ip_attr |= OCFS2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\toi->ip_attr |= OCFS2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\toi->ip_attr |= OCFS2_DIRSYNC_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_I(inode)->ip_clusters"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(inode)->ip_lock"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_mark_inode_dirty",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_inode_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1210-1243",
    "snippet": "int ocfs2_inode_revalidate(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint status = 0;\n\n\ttrace_ocfs2_inode_revalidate(inode,\n\t\tinode ? (unsigned long long)OCFS2_I(inode)->ip_blkno : 0ULL,\n\t\tinode ? (unsigned long long)OCFS2_I(inode)->ip_flags : 0);\n\n\tif (!inode) {\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED) {\n\t\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\t/* Let ocfs2_inode_lock do the work of updating our struct\n\t * inode for us. */\n\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_inode_unlock(inode, 0);\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "0"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "NULL",
            "0"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(inode)->ip_lock"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(inode)->ip_lock"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_inode_revalidate",
          "args": [
            "inode",
            "inode ? (unsigned long long)OCFS2_I(inode)->ip_blkno : 0ULL",
            "inode ? (unsigned long long)OCFS2_I(inode)->ip_flags : 0"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_inode_revalidate(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint status = 0;\n\n\ttrace_ocfs2_inode_revalidate(inode,\n\t\tinode ? (unsigned long long)OCFS2_I(inode)->ip_blkno : 0ULL,\n\t\tinode ? (unsigned long long)OCFS2_I(inode)->ip_flags : 0);\n\n\tif (!inode) {\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED) {\n\t\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\t/* Let ocfs2_inode_lock do the work of updating our struct\n\t * inode for us. */\n\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_inode_unlock(inode, 0);\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_drop_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1191-1205",
    "snippet": "int ocfs2_drop_inode(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tint res;\n\n\ttrace_ocfs2_drop_inode((unsigned long long)oi->ip_blkno,\n\t\t\t\tinode->i_nlink, oi->ip_flags);\n\n\tif (oi->ip_flags & OCFS2_INODE_MAYBE_ORPHANED)\n\t\tres = 1;\n\telse\n\t\tres = generic_drop_inode(inode);\n\n\treturn res;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_drop_inode",
          "args": [
            "inode"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_drop_inode",
          "args": [
            "(unsigned long long)oi->ip_blkno",
            "inode->i_nlink",
            "oi->ip_flags"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_drop_inode(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tint res;\n\n\ttrace_ocfs2_drop_inode((unsigned long long)oi->ip_blkno,\n\t\t\t\tinode->i_nlink, oi->ip_flags);\n\n\tif (oi->ip_flags & OCFS2_INODE_MAYBE_ORPHANED)\n\t\tres = 1;\n\telse\n\t\tres = generic_drop_inode(inode);\n\n\treturn res;\n}"
  },
  {
    "function_name": "ocfs2_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1177-1186",
    "snippet": "void ocfs2_evict_inode(struct inode *inode)\n{\n\tif (!inode->i_nlink ||\n\t    (OCFS2_I(inode)->ip_flags & OCFS2_INODE_MAYBE_ORPHANED)) {\n\t\tocfs2_delete_inode(inode);\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tocfs2_clear_inode(inode);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clear_inode",
          "args": [
            "inode"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1078-1175",
          "snippet": "static void ocfs2_clear_inode(struct inode *inode)\n{\n\tint status;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tclear_inode(inode);\n\ttrace_ocfs2_clear_inode((unsigned long long)oi->ip_blkno,\n\t\t\t\tinode->i_nlink);\n\n\tmlog_bug_on_msg(OCFS2_SB(inode->i_sb) == NULL,\n\t\t\t\"Inode=%lu\\n\", inode->i_ino);\n\n\tdquot_drop(inode);\n\n\t/* To preven remote deletes we hold open lock before, now it\n\t * is time to unlock PR and EX open locks. */\n\tocfs2_open_unlock(inode);\n\n\t/* Do these before all the other work so that we don't bounce\n\t * the downconvert thread while waiting to destroy the locks. */\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_rw_lockres);\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_inode_lockres);\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_open_lockres);\n\n\tocfs2_resv_discard(&OCFS2_SB(inode->i_sb)->osb_la_resmap,\n\t\t\t   &oi->ip_la_data_resv);\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\t/* We very well may get a clear_inode before all an inodes\n\t * metadata has hit disk. Of course, we can't drop any cluster\n\t * locks until the journal has finished with it. The only\n\t * exception here are successfully wiped inodes - their\n\t * metadata can now be considered to be part of the system\n\t * inodes from which it came. */\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED))\n\t\tocfs2_checkpoint_inode(inode);\n\n\tmlog_bug_on_msg(!list_empty(&oi->ip_io_markers),\n\t\t\t\"Clear inode of %llu, inode has io markers\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tocfs2_extent_map_trunc(inode, 0);\n\n\tstatus = ocfs2_drop_inode_locks(inode);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_lock_res_free(&oi->ip_rw_lockres);\n\tocfs2_lock_res_free(&oi->ip_inode_lockres);\n\tocfs2_lock_res_free(&oi->ip_open_lockres);\n\n\tocfs2_metadata_cache_exit(INODE_CACHE(inode));\n\n\tmlog_bug_on_msg(INODE_CACHE(inode)->ci_num_cached,\n\t\t\t\"Clear inode of %llu, inode has %u cache items\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\tINODE_CACHE(inode)->ci_num_cached);\n\n\tmlog_bug_on_msg(!(INODE_CACHE(inode)->ci_flags & OCFS2_CACHE_FL_INLINE),\n\t\t\t\"Clear inode of %llu, inode has a bad flag\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tmlog_bug_on_msg(spin_is_locked(&oi->ip_lock),\n\t\t\t\"Clear inode of %llu, inode is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tmlog_bug_on_msg(!mutex_trylock(&oi->ip_io_mutex),\n\t\t\t\"Clear inode of %llu, io_mutex is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tmutex_unlock(&oi->ip_io_mutex);\n\n\t/*\n\t * down_trylock() returns 0, down_write_trylock() returns 1\n\t * kernel 1, world 0\n\t */\n\tmlog_bug_on_msg(!down_write_trylock(&oi->ip_alloc_sem),\n\t\t\t\"Clear inode of %llu, alloc_sem is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tup_write(&oi->ip_alloc_sem);\n\n\tmlog_bug_on_msg(oi->ip_open_count,\n\t\t\t\"Clear inode of %llu has open count %d\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno, oi->ip_open_count);\n\n\t/* Clear all other flags. */\n\toi->ip_flags = 0;\n\toi->ip_dir_start_lookup = 0;\n\toi->ip_blkno = 0ULL;\n\n\t/*\n\t * ip_jinode is used to track txns against this inode. We ensure that\n\t * the journal is flushed before journal shutdown. Thus it is safe to\n\t * have inodes get cleaned up after journal shutdown.\n\t */\n\tjbd2_journal_release_jbd_inode(OCFS2_SB(inode->i_sb)->journal->j_journal,\n\t\t\t\t       &oi->ip_jinode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_clear_inode(struct inode *inode)\n{\n\tint status;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tclear_inode(inode);\n\ttrace_ocfs2_clear_inode((unsigned long long)oi->ip_blkno,\n\t\t\t\tinode->i_nlink);\n\n\tmlog_bug_on_msg(OCFS2_SB(inode->i_sb) == NULL,\n\t\t\t\"Inode=%lu\\n\", inode->i_ino);\n\n\tdquot_drop(inode);\n\n\t/* To preven remote deletes we hold open lock before, now it\n\t * is time to unlock PR and EX open locks. */\n\tocfs2_open_unlock(inode);\n\n\t/* Do these before all the other work so that we don't bounce\n\t * the downconvert thread while waiting to destroy the locks. */\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_rw_lockres);\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_inode_lockres);\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_open_lockres);\n\n\tocfs2_resv_discard(&OCFS2_SB(inode->i_sb)->osb_la_resmap,\n\t\t\t   &oi->ip_la_data_resv);\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\t/* We very well may get a clear_inode before all an inodes\n\t * metadata has hit disk. Of course, we can't drop any cluster\n\t * locks until the journal has finished with it. The only\n\t * exception here are successfully wiped inodes - their\n\t * metadata can now be considered to be part of the system\n\t * inodes from which it came. */\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED))\n\t\tocfs2_checkpoint_inode(inode);\n\n\tmlog_bug_on_msg(!list_empty(&oi->ip_io_markers),\n\t\t\t\"Clear inode of %llu, inode has io markers\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tocfs2_extent_map_trunc(inode, 0);\n\n\tstatus = ocfs2_drop_inode_locks(inode);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_lock_res_free(&oi->ip_rw_lockres);\n\tocfs2_lock_res_free(&oi->ip_inode_lockres);\n\tocfs2_lock_res_free(&oi->ip_open_lockres);\n\n\tocfs2_metadata_cache_exit(INODE_CACHE(inode));\n\n\tmlog_bug_on_msg(INODE_CACHE(inode)->ci_num_cached,\n\t\t\t\"Clear inode of %llu, inode has %u cache items\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\tINODE_CACHE(inode)->ci_num_cached);\n\n\tmlog_bug_on_msg(!(INODE_CACHE(inode)->ci_flags & OCFS2_CACHE_FL_INLINE),\n\t\t\t\"Clear inode of %llu, inode has a bad flag\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tmlog_bug_on_msg(spin_is_locked(&oi->ip_lock),\n\t\t\t\"Clear inode of %llu, inode is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tmlog_bug_on_msg(!mutex_trylock(&oi->ip_io_mutex),\n\t\t\t\"Clear inode of %llu, io_mutex is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tmutex_unlock(&oi->ip_io_mutex);\n\n\t/*\n\t * down_trylock() returns 0, down_write_trylock() returns 1\n\t * kernel 1, world 0\n\t */\n\tmlog_bug_on_msg(!down_write_trylock(&oi->ip_alloc_sem),\n\t\t\t\"Clear inode of %llu, alloc_sem is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tup_write(&oi->ip_alloc_sem);\n\n\tmlog_bug_on_msg(oi->ip_open_count,\n\t\t\t\"Clear inode of %llu has open count %d\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno, oi->ip_open_count);\n\n\t/* Clear all other flags. */\n\toi->ip_flags = 0;\n\toi->ip_dir_start_lookup = 0;\n\toi->ip_blkno = 0ULL;\n\n\t/*\n\t * ip_jinode is used to track txns against this inode. We ensure that\n\t * the journal is flushed before journal shutdown. Thus it is safe to\n\t * have inodes get cleaned up after journal shutdown.\n\t */\n\tjbd2_journal_release_jbd_inode(OCFS2_SB(inode->i_sb)->journal->j_journal,\n\t\t\t\t       &oi->ip_jinode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_delete_inode",
          "args": [
            "inode"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "969-1076",
          "snippet": "static void ocfs2_delete_inode(struct inode *inode)\n{\n\tint wipe, status;\n\tsigset_t oldset;\n\tstruct buffer_head *di_bh = NULL;\n\n\ttrace_ocfs2_delete_inode(inode->i_ino,\n\t\t\t\t (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t is_bad_inode(inode));\n\n\t/* When we fail in read_inode() we mark inode as bad. The second test\n\t * catches the case when inode allocation fails before allocating\n\t * a block for inode. */\n\tif (is_bad_inode(inode) || !OCFS2_I(inode)->ip_blkno)\n\t\tgoto bail;\n\n\tif (!ocfs2_inode_is_valid_to_delete(inode)) {\n\t\t/* It's probably not necessary to truncate_inode_pages\n\t\t * here but we do it for safety anyway (it will most\n\t\t * likely be a no-op anyway) */\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail;\n\t}\n\n\tdquot_initialize(inode);\n\n\t/* We want to block signals in delete_inode as the lock and\n\t * messaging paths may return us -ERESTARTSYS. Which would\n\t * cause us to exit early, resulting in inodes being orphaned\n\t * forever. */\n\tocfs2_block_signals(&oldset);\n\n\t/*\n\t * Synchronize us against ocfs2_get_dentry. We take this in\n\t * shared mode so that all nodes can still concurrently\n\t * process deletes.\n\t */\n\tstatus = ocfs2_nfs_sync_lock(OCFS2_SB(inode->i_sb), 0);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(PR) failed %d\\n\", status);\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail_unblock;\n\t}\n\t/* Lock down the inode. This gives us an up to date view of\n\t * it's metadata (for verification), and allows us to\n\t * serialize delete_inode on multiple nodes.\n\t *\n\t * Even though we might be doing a truncate, we don't take the\n\t * allocation lock here as it won't be needed - nobody will\n\t * have the file open.\n\t */\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail_unlock_nfs_sync;\n\t}\n\n\t/* Query the cluster. This will be the final decision made\n\t * before we go ahead and wipe the inode. */\n\tstatus = ocfs2_query_inode_wipe(inode, di_bh, &wipe);\n\tif (!wipe || status < 0) {\n\t\t/* Error and remote inode busy both mean we won't be\n\t\t * removing the inode, so they take almost the same\n\t\t * path. */\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\n\t\t/* Someone in the cluster has disallowed a wipe of\n\t\t * this inode, or it was never completely\n\t\t * orphaned. Write out the pages and exit now. */\n\t\tocfs2_cleanup_delete_inode(inode, 1);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\tocfs2_cleanup_delete_inode(inode, 0);\n\n\tstatus = ocfs2_wipe_inode(inode, di_bh);\n\tif (status < 0) {\n\t\tif (status != -EDEADLK)\n\t\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\t/*\n\t * Mark the inode as successfully deleted.\n\t *\n\t * This is important for ocfs2_clear_inode() as it will check\n\t * this flag and skip any checkpointing work\n\t *\n\t * ocfs2_stuff_meta_lvb() also uses this flag to invalidate\n\t * the LVB for other nodes.\n\t */\n\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_DELETED;\n\nbail_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\nbail_unlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(OCFS2_SB(inode->i_sb), 0);\n\nbail_unblock:\n\tocfs2_unblock_signals(&oldset);\nbail:\n\treturn;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_delete_inode(struct inode *inode)\n{\n\tint wipe, status;\n\tsigset_t oldset;\n\tstruct buffer_head *di_bh = NULL;\n\n\ttrace_ocfs2_delete_inode(inode->i_ino,\n\t\t\t\t (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t is_bad_inode(inode));\n\n\t/* When we fail in read_inode() we mark inode as bad. The second test\n\t * catches the case when inode allocation fails before allocating\n\t * a block for inode. */\n\tif (is_bad_inode(inode) || !OCFS2_I(inode)->ip_blkno)\n\t\tgoto bail;\n\n\tif (!ocfs2_inode_is_valid_to_delete(inode)) {\n\t\t/* It's probably not necessary to truncate_inode_pages\n\t\t * here but we do it for safety anyway (it will most\n\t\t * likely be a no-op anyway) */\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail;\n\t}\n\n\tdquot_initialize(inode);\n\n\t/* We want to block signals in delete_inode as the lock and\n\t * messaging paths may return us -ERESTARTSYS. Which would\n\t * cause us to exit early, resulting in inodes being orphaned\n\t * forever. */\n\tocfs2_block_signals(&oldset);\n\n\t/*\n\t * Synchronize us against ocfs2_get_dentry. We take this in\n\t * shared mode so that all nodes can still concurrently\n\t * process deletes.\n\t */\n\tstatus = ocfs2_nfs_sync_lock(OCFS2_SB(inode->i_sb), 0);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(PR) failed %d\\n\", status);\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail_unblock;\n\t}\n\t/* Lock down the inode. This gives us an up to date view of\n\t * it's metadata (for verification), and allows us to\n\t * serialize delete_inode on multiple nodes.\n\t *\n\t * Even though we might be doing a truncate, we don't take the\n\t * allocation lock here as it won't be needed - nobody will\n\t * have the file open.\n\t */\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail_unlock_nfs_sync;\n\t}\n\n\t/* Query the cluster. This will be the final decision made\n\t * before we go ahead and wipe the inode. */\n\tstatus = ocfs2_query_inode_wipe(inode, di_bh, &wipe);\n\tif (!wipe || status < 0) {\n\t\t/* Error and remote inode busy both mean we won't be\n\t\t * removing the inode, so they take almost the same\n\t\t * path. */\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\n\t\t/* Someone in the cluster has disallowed a wipe of\n\t\t * this inode, or it was never completely\n\t\t * orphaned. Write out the pages and exit now. */\n\t\tocfs2_cleanup_delete_inode(inode, 1);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\tocfs2_cleanup_delete_inode(inode, 0);\n\n\tstatus = ocfs2_wipe_inode(inode, di_bh);\n\tif (status < 0) {\n\t\tif (status != -EDEADLK)\n\t\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\t/*\n\t * Mark the inode as successfully deleted.\n\t *\n\t * This is important for ocfs2_clear_inode() as it will check\n\t * this flag and skip any checkpointing work\n\t *\n\t * ocfs2_stuff_meta_lvb() also uses this flag to invalidate\n\t * the LVB for other nodes.\n\t */\n\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_DELETED;\n\nbail_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\nbail_unlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(OCFS2_SB(inode->i_sb), 0);\n\nbail_unblock:\n\tocfs2_unblock_signals(&oldset);\nbail:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_evict_inode(struct inode *inode)\n{\n\tif (!inode->i_nlink ||\n\t    (OCFS2_I(inode)->ip_flags & OCFS2_INODE_MAYBE_ORPHANED)) {\n\t\tocfs2_delete_inode(inode);\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tocfs2_clear_inode(inode);\n}"
  },
  {
    "function_name": "ocfs2_clear_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "1078-1175",
    "snippet": "static void ocfs2_clear_inode(struct inode *inode)\n{\n\tint status;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tclear_inode(inode);\n\ttrace_ocfs2_clear_inode((unsigned long long)oi->ip_blkno,\n\t\t\t\tinode->i_nlink);\n\n\tmlog_bug_on_msg(OCFS2_SB(inode->i_sb) == NULL,\n\t\t\t\"Inode=%lu\\n\", inode->i_ino);\n\n\tdquot_drop(inode);\n\n\t/* To preven remote deletes we hold open lock before, now it\n\t * is time to unlock PR and EX open locks. */\n\tocfs2_open_unlock(inode);\n\n\t/* Do these before all the other work so that we don't bounce\n\t * the downconvert thread while waiting to destroy the locks. */\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_rw_lockres);\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_inode_lockres);\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_open_lockres);\n\n\tocfs2_resv_discard(&OCFS2_SB(inode->i_sb)->osb_la_resmap,\n\t\t\t   &oi->ip_la_data_resv);\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\t/* We very well may get a clear_inode before all an inodes\n\t * metadata has hit disk. Of course, we can't drop any cluster\n\t * locks until the journal has finished with it. The only\n\t * exception here are successfully wiped inodes - their\n\t * metadata can now be considered to be part of the system\n\t * inodes from which it came. */\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED))\n\t\tocfs2_checkpoint_inode(inode);\n\n\tmlog_bug_on_msg(!list_empty(&oi->ip_io_markers),\n\t\t\t\"Clear inode of %llu, inode has io markers\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tocfs2_extent_map_trunc(inode, 0);\n\n\tstatus = ocfs2_drop_inode_locks(inode);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_lock_res_free(&oi->ip_rw_lockres);\n\tocfs2_lock_res_free(&oi->ip_inode_lockres);\n\tocfs2_lock_res_free(&oi->ip_open_lockres);\n\n\tocfs2_metadata_cache_exit(INODE_CACHE(inode));\n\n\tmlog_bug_on_msg(INODE_CACHE(inode)->ci_num_cached,\n\t\t\t\"Clear inode of %llu, inode has %u cache items\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\tINODE_CACHE(inode)->ci_num_cached);\n\n\tmlog_bug_on_msg(!(INODE_CACHE(inode)->ci_flags & OCFS2_CACHE_FL_INLINE),\n\t\t\t\"Clear inode of %llu, inode has a bad flag\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tmlog_bug_on_msg(spin_is_locked(&oi->ip_lock),\n\t\t\t\"Clear inode of %llu, inode is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tmlog_bug_on_msg(!mutex_trylock(&oi->ip_io_mutex),\n\t\t\t\"Clear inode of %llu, io_mutex is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tmutex_unlock(&oi->ip_io_mutex);\n\n\t/*\n\t * down_trylock() returns 0, down_write_trylock() returns 1\n\t * kernel 1, world 0\n\t */\n\tmlog_bug_on_msg(!down_write_trylock(&oi->ip_alloc_sem),\n\t\t\t\"Clear inode of %llu, alloc_sem is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tup_write(&oi->ip_alloc_sem);\n\n\tmlog_bug_on_msg(oi->ip_open_count,\n\t\t\t\"Clear inode of %llu has open count %d\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno, oi->ip_open_count);\n\n\t/* Clear all other flags. */\n\toi->ip_flags = 0;\n\toi->ip_dir_start_lookup = 0;\n\toi->ip_blkno = 0ULL;\n\n\t/*\n\t * ip_jinode is used to track txns against this inode. We ensure that\n\t * the journal is flushed before journal shutdown. Thus it is safe to\n\t * have inodes get cleaned up after journal shutdown.\n\t */\n\tjbd2_journal_release_jbd_inode(OCFS2_SB(inode->i_sb)->journal->j_journal,\n\t\t\t\t       &oi->ip_jinode);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_release_jbd_inode",
          "args": [
            "OCFS2_SB(inode->i_sb)->journal->j_journal",
            "&oi->ip_jinode"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_release_jbd_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2539-2563",
          "snippet": "void jbd2_journal_release_jbd_inode(journal_t *journal,\n\t\t\t\t    struct jbd2_inode *jinode)\n{\n\tif (!journal)\n\t\treturn;\nrestart:\n\tspin_lock(&journal->j_list_lock);\n\t/* Is commit writing out inode - we have to wait */\n\tif (test_bit(__JI_COMMIT_RUNNING, &jinode->i_flags)) {\n\t\twait_queue_head_t *wq;\n\t\tDEFINE_WAIT_BIT(wait, &jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\twq = bit_waitqueue(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait.wait);\n\t\tgoto restart;\n\t}\n\n\tif (jinode->i_transaction) {\n\t\tlist_del(&jinode->i_list);\n\t\tjinode->i_transaction = NULL;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_release_jbd_inode(journal_t *journal,\n\t\t\t\t    struct jbd2_inode *jinode)\n{\n\tif (!journal)\n\t\treturn;\nrestart:\n\tspin_lock(&journal->j_list_lock);\n\t/* Is commit writing out inode - we have to wait */\n\tif (test_bit(__JI_COMMIT_RUNNING, &jinode->i_flags)) {\n\t\twait_queue_head_t *wq;\n\t\tDEFINE_WAIT_BIT(wait, &jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\twq = bit_waitqueue(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait.wait);\n\t\tgoto restart;\n\t}\n\n\tif (jinode->i_transaction) {\n\t\tlist_del(&jinode->i_list);\n\t\tjinode->i_transaction = NULL;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "oi->ip_open_count",
            "\"Clear inode of %llu has open count %d\\n\"",
            "(unsigned long long)oi->ip_blkno",
            "oi->ip_open_count"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!down_write_trylock(&oi->ip_alloc_sem)",
            "\"Clear inode of %llu, alloc_sem is locked\\n\"",
            "(unsigned long long)oi->ip_blkno"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_trylock",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&oi->ip_io_mutex"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!mutex_trylock(&oi->ip_io_mutex)",
            "\"Clear inode of %llu, io_mutex is locked\\n\"",
            "(unsigned long long)oi->ip_blkno"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&oi->ip_io_mutex"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "spin_is_locked(&oi->ip_lock)",
            "\"Clear inode of %llu, inode is locked\\n\"",
            "(unsigned long long)oi->ip_blkno"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_locked",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!(INODE_CACHE(inode)->ci_flags & OCFS2_CACHE_FL_INLINE)",
            "\"Clear inode of %llu, inode has a bad flag\\n\"",
            "(unsigned long long)oi->ip_blkno"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "INODE_CACHE(inode)->ci_num_cached",
            "\"Clear inode of %llu, inode has %u cache items\\n\"",
            "(unsigned long long)oi->ip_blkno",
            "INODE_CACHE(inode)->ci_num_cached"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_exit",
          "args": [
            "INODE_CACHE(inode)"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "136-140",
          "snippet": "void ocfs2_metadata_cache_exit(struct ocfs2_caching_info *ci)\n{\n\tocfs2_metadata_cache_purge(ci);\n\tocfs2_metadata_cache_reset(ci, 1);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_metadata_cache_exit(struct ocfs2_caching_info *ci)\n{\n\tocfs2_metadata_cache_purge(ci);\n\tocfs2_metadata_cache_reset(ci, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_free",
          "args": [
            "&oi->ip_open_lockres"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "722-749",
          "snippet": "void ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_drop_inode_locks",
          "args": [
            "inode"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3242-3271",
          "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_trunc",
          "args": [
            "inode",
            "0"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "114-144",
          "snippet": "void ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!list_empty(&oi->ip_io_markers)",
            "\"Clear inode of %llu, inode has io markers\\n\"",
            "(unsigned long long)oi->ip_blkno"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&oi->ip_io_markers"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_checkpoint_inode",
          "args": [
            "inode"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_checkpoint_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "206-225",
          "snippet": "static inline void ocfs2_checkpoint_inode(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn;\n\n\tif (!ocfs2_ci_fully_checkpointed(INODE_CACHE(inode))) {\n\t\t/* WARNING: This only kicks off a single\n\t\t * checkpoint. If someone races you and adds more\n\t\t * metadata to the journal, you won't know, and will\n\t\t * wind up waiting *a lot* longer than necessary. Right\n\t\t * now we only use this in clear_inode so that's\n\t\t * OK. */\n\t\tocfs2_start_checkpoint(osb);\n\n\t\twait_event(osb->journal->j_checkpointed,\n\t\t\t   ocfs2_ci_fully_checkpointed(INODE_CACHE(inode)));\n\t}\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_checkpoint_inode(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn;\n\n\tif (!ocfs2_ci_fully_checkpointed(INODE_CACHE(inode))) {\n\t\t/* WARNING: This only kicks off a single\n\t\t * checkpoint. If someone races you and adds more\n\t\t * metadata to the journal, you won't know, and will\n\t\t * wind up waiting *a lot* longer than necessary. Right\n\t\t * now we only use this in clear_inode so that's\n\t\t * OK. */\n\t\tocfs2_start_checkpoint(osb);\n\n\t\twait_event(osb->journal->j_checkpointed,\n\t\t\t   ocfs2_ci_fully_checkpointed(INODE_CACHE(inode)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_init_once",
          "args": [
            "&oi->ip_la_data_resv"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "200-204",
          "snippet": "void ocfs2_resv_init_once(struct ocfs2_alloc_reservation *resv)\n{\n\tmemset(resv, 0, sizeof(*resv));\n\tINIT_LIST_HEAD(&resv->r_lru);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_resv_init_once(struct ocfs2_alloc_reservation *resv)\n{\n\tmemset(resv, 0, sizeof(*resv));\n\tINIT_LIST_HEAD(&resv->r_lru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_discard",
          "args": [
            "&OCFS2_SB(inode->i_sb)->osb_la_resmap",
            "&oi->ip_la_data_resv"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "270-278",
          "snippet": "void ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tif (resv) {\n\t\tspin_lock(&resv_lock);\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\tspin_unlock(&resv_lock);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nvoid ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tif (resv) {\n\t\tspin_lock(&resv_lock);\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\tspin_unlock(&resv_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_lockres_freeing",
          "args": [
            "osb",
            "&oi->ip_open_lockres"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_lockres_freeing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3163-3221",
          "snippet": "void ocfs2_mark_lockres_freeing(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_mask_waiter mw;\n\tunsigned long flags, flags2;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres->l_flags |= OCFS2_LOCK_FREEING;\n\tif (lockres->l_flags & OCFS2_LOCK_QUEUED && current == osb->dc_task) {\n\t\t/*\n\t\t * We know the downconvert is queued but not in progress\n\t\t * because we are the downconvert thread and processing\n\t\t * different lock. So we can just remove the lock from the\n\t\t * queue. This is not only an optimization but also a way\n\t\t * to avoid the following deadlock:\n\t\t *   ocfs2_dentry_post_unlock()\n\t\t *     ocfs2_dentry_lock_put()\n\t\t *       ocfs2_drop_dentry_lock()\n\t\t *         iput()\n\t\t *           ocfs2_evict_inode()\n\t\t *             ocfs2_clear_inode()\n\t\t *               ocfs2_mark_lockres_freeing()\n\t\t *                 ... blocks waiting for OCFS2_LOCK_QUEUED\n\t\t *                 since we are the downconvert thread which\n\t\t *                 should clear the flag.\n\t\t */\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tspin_lock_irqsave(&osb->dc_task_lock, flags2);\n\t\tlist_del_init(&lockres->l_blocked_list);\n\t\tosb->blocked_lock_count--;\n\t\tspin_unlock_irqrestore(&osb->dc_task_lock, flags2);\n\t\t/*\n\t\t * Warn if we recurse into another post_unlock call.  Strictly\n\t\t * speaking it isn't a problem but we need to be careful if\n\t\t * that happens (stack overflow, deadlocks, ...) so warn if\n\t\t * ocfs2 grows a path for which this can happen.\n\t\t */\n\t\tWARN_ON_ONCE(lockres->l_ops->post_unlock);\n\t\t/* Since the lock is freeing we don't do much in the fn below */\n\t\tocfs2_process_blocked_lock(osb, lockres);\n\t\treturn;\n\t}\n\twhile (lockres->l_flags & OCFS2_LOCK_QUEUED) {\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_QUEUED, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tmlog(0, \"Waiting on lockres %s\\n\", lockres->l_name);\n\n\t\tstatus = ocfs2_wait_for_mask(&mw);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_mark_lockres_freeing(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_mask_waiter mw;\n\tunsigned long flags, flags2;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres->l_flags |= OCFS2_LOCK_FREEING;\n\tif (lockres->l_flags & OCFS2_LOCK_QUEUED && current == osb->dc_task) {\n\t\t/*\n\t\t * We know the downconvert is queued but not in progress\n\t\t * because we are the downconvert thread and processing\n\t\t * different lock. So we can just remove the lock from the\n\t\t * queue. This is not only an optimization but also a way\n\t\t * to avoid the following deadlock:\n\t\t *   ocfs2_dentry_post_unlock()\n\t\t *     ocfs2_dentry_lock_put()\n\t\t *       ocfs2_drop_dentry_lock()\n\t\t *         iput()\n\t\t *           ocfs2_evict_inode()\n\t\t *             ocfs2_clear_inode()\n\t\t *               ocfs2_mark_lockres_freeing()\n\t\t *                 ... blocks waiting for OCFS2_LOCK_QUEUED\n\t\t *                 since we are the downconvert thread which\n\t\t *                 should clear the flag.\n\t\t */\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tspin_lock_irqsave(&osb->dc_task_lock, flags2);\n\t\tlist_del_init(&lockres->l_blocked_list);\n\t\tosb->blocked_lock_count--;\n\t\tspin_unlock_irqrestore(&osb->dc_task_lock, flags2);\n\t\t/*\n\t\t * Warn if we recurse into another post_unlock call.  Strictly\n\t\t * speaking it isn't a problem but we need to be careful if\n\t\t * that happens (stack overflow, deadlocks, ...) so warn if\n\t\t * ocfs2 grows a path for which this can happen.\n\t\t */\n\t\tWARN_ON_ONCE(lockres->l_ops->post_unlock);\n\t\t/* Since the lock is freeing we don't do much in the fn below */\n\t\tocfs2_process_blocked_lock(osb, lockres);\n\t\treturn;\n\t}\n\twhile (lockres->l_flags & OCFS2_LOCK_QUEUED) {\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_QUEUED, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tmlog(0, \"Waiting on lockres %s\\n\", lockres->l_name);\n\n\t\tstatus = ocfs2_wait_for_mask(&mw);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_open_unlock",
          "args": [
            "inode"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_open_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1775-1795",
          "snippet": "void ocfs2_open_unlock(struct inode *inode)\n{\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_open_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tif(lockres->l_ro_holders)\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t     DLM_LOCK_PR);\n\tif(lockres->l_ex_holders)\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t     DLM_LOCK_EX);\n\nout:\n\treturn;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_open_unlock(struct inode *inode)\n{\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_open_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tif(lockres->l_ro_holders)\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t     DLM_LOCK_PR);\n\tif(lockres->l_ex_holders)\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t     DLM_LOCK_EX);\n\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_drop",
          "args": [
            "inode"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1487-1508",
          "snippet": "void dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "OCFS2_SB(inode->i_sb) == NULL",
            "\"Inode=%lu\\n\"",
            "inode->i_ino"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_clear_inode",
          "args": [
            "(unsigned long long)oi->ip_blkno",
            "inode->i_nlink"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1078-1175",
          "snippet": "static void ocfs2_clear_inode(struct inode *inode)\n{\n\tint status;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tclear_inode(inode);\n\ttrace_ocfs2_clear_inode((unsigned long long)oi->ip_blkno,\n\t\t\t\tinode->i_nlink);\n\n\tmlog_bug_on_msg(OCFS2_SB(inode->i_sb) == NULL,\n\t\t\t\"Inode=%lu\\n\", inode->i_ino);\n\n\tdquot_drop(inode);\n\n\t/* To preven remote deletes we hold open lock before, now it\n\t * is time to unlock PR and EX open locks. */\n\tocfs2_open_unlock(inode);\n\n\t/* Do these before all the other work so that we don't bounce\n\t * the downconvert thread while waiting to destroy the locks. */\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_rw_lockres);\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_inode_lockres);\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_open_lockres);\n\n\tocfs2_resv_discard(&OCFS2_SB(inode->i_sb)->osb_la_resmap,\n\t\t\t   &oi->ip_la_data_resv);\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\t/* We very well may get a clear_inode before all an inodes\n\t * metadata has hit disk. Of course, we can't drop any cluster\n\t * locks until the journal has finished with it. The only\n\t * exception here are successfully wiped inodes - their\n\t * metadata can now be considered to be part of the system\n\t * inodes from which it came. */\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED))\n\t\tocfs2_checkpoint_inode(inode);\n\n\tmlog_bug_on_msg(!list_empty(&oi->ip_io_markers),\n\t\t\t\"Clear inode of %llu, inode has io markers\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tocfs2_extent_map_trunc(inode, 0);\n\n\tstatus = ocfs2_drop_inode_locks(inode);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_lock_res_free(&oi->ip_rw_lockres);\n\tocfs2_lock_res_free(&oi->ip_inode_lockres);\n\tocfs2_lock_res_free(&oi->ip_open_lockres);\n\n\tocfs2_metadata_cache_exit(INODE_CACHE(inode));\n\n\tmlog_bug_on_msg(INODE_CACHE(inode)->ci_num_cached,\n\t\t\t\"Clear inode of %llu, inode has %u cache items\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\tINODE_CACHE(inode)->ci_num_cached);\n\n\tmlog_bug_on_msg(!(INODE_CACHE(inode)->ci_flags & OCFS2_CACHE_FL_INLINE),\n\t\t\t\"Clear inode of %llu, inode has a bad flag\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tmlog_bug_on_msg(spin_is_locked(&oi->ip_lock),\n\t\t\t\"Clear inode of %llu, inode is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tmlog_bug_on_msg(!mutex_trylock(&oi->ip_io_mutex),\n\t\t\t\"Clear inode of %llu, io_mutex is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tmutex_unlock(&oi->ip_io_mutex);\n\n\t/*\n\t * down_trylock() returns 0, down_write_trylock() returns 1\n\t * kernel 1, world 0\n\t */\n\tmlog_bug_on_msg(!down_write_trylock(&oi->ip_alloc_sem),\n\t\t\t\"Clear inode of %llu, alloc_sem is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tup_write(&oi->ip_alloc_sem);\n\n\tmlog_bug_on_msg(oi->ip_open_count,\n\t\t\t\"Clear inode of %llu has open count %d\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno, oi->ip_open_count);\n\n\t/* Clear all other flags. */\n\toi->ip_flags = 0;\n\toi->ip_dir_start_lookup = 0;\n\toi->ip_blkno = 0ULL;\n\n\t/*\n\t * ip_jinode is used to track txns against this inode. We ensure that\n\t * the journal is flushed before journal shutdown. Thus it is safe to\n\t * have inodes get cleaned up after journal shutdown.\n\t */\n\tjbd2_journal_release_jbd_inode(OCFS2_SB(inode->i_sb)->journal->j_journal,\n\t\t\t\t       &oi->ip_jinode);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_clear_inode(struct inode *inode)\n{\n\tint status;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tclear_inode(inode);\n\ttrace_ocfs2_clear_inode((unsigned long long)oi->ip_blkno,\n\t\t\t\tinode->i_nlink);\n\n\tmlog_bug_on_msg(OCFS2_SB(inode->i_sb) == NULL,\n\t\t\t\"Inode=%lu\\n\", inode->i_ino);\n\n\tdquot_drop(inode);\n\n\t/* To preven remote deletes we hold open lock before, now it\n\t * is time to unlock PR and EX open locks. */\n\tocfs2_open_unlock(inode);\n\n\t/* Do these before all the other work so that we don't bounce\n\t * the downconvert thread while waiting to destroy the locks. */\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_rw_lockres);\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_inode_lockres);\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_open_lockres);\n\n\tocfs2_resv_discard(&OCFS2_SB(inode->i_sb)->osb_la_resmap,\n\t\t\t   &oi->ip_la_data_resv);\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\t/* We very well may get a clear_inode before all an inodes\n\t * metadata has hit disk. Of course, we can't drop any cluster\n\t * locks until the journal has finished with it. The only\n\t * exception here are successfully wiped inodes - their\n\t * metadata can now be considered to be part of the system\n\t * inodes from which it came. */\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED))\n\t\tocfs2_checkpoint_inode(inode);\n\n\tmlog_bug_on_msg(!list_empty(&oi->ip_io_markers),\n\t\t\t\"Clear inode of %llu, inode has io markers\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tocfs2_extent_map_trunc(inode, 0);\n\n\tstatus = ocfs2_drop_inode_locks(inode);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_lock_res_free(&oi->ip_rw_lockres);\n\tocfs2_lock_res_free(&oi->ip_inode_lockres);\n\tocfs2_lock_res_free(&oi->ip_open_lockres);\n\n\tocfs2_metadata_cache_exit(INODE_CACHE(inode));\n\n\tmlog_bug_on_msg(INODE_CACHE(inode)->ci_num_cached,\n\t\t\t\"Clear inode of %llu, inode has %u cache items\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\tINODE_CACHE(inode)->ci_num_cached);\n\n\tmlog_bug_on_msg(!(INODE_CACHE(inode)->ci_flags & OCFS2_CACHE_FL_INLINE),\n\t\t\t\"Clear inode of %llu, inode has a bad flag\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tmlog_bug_on_msg(spin_is_locked(&oi->ip_lock),\n\t\t\t\"Clear inode of %llu, inode is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tmlog_bug_on_msg(!mutex_trylock(&oi->ip_io_mutex),\n\t\t\t\"Clear inode of %llu, io_mutex is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tmutex_unlock(&oi->ip_io_mutex);\n\n\t/*\n\t * down_trylock() returns 0, down_write_trylock() returns 1\n\t * kernel 1, world 0\n\t */\n\tmlog_bug_on_msg(!down_write_trylock(&oi->ip_alloc_sem),\n\t\t\t\"Clear inode of %llu, alloc_sem is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tup_write(&oi->ip_alloc_sem);\n\n\tmlog_bug_on_msg(oi->ip_open_count,\n\t\t\t\"Clear inode of %llu has open count %d\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno, oi->ip_open_count);\n\n\t/* Clear all other flags. */\n\toi->ip_flags = 0;\n\toi->ip_dir_start_lookup = 0;\n\toi->ip_blkno = 0ULL;\n\n\t/*\n\t * ip_jinode is used to track txns against this inode. We ensure that\n\t * the journal is flushed before journal shutdown. Thus it is safe to\n\t * have inodes get cleaned up after journal shutdown.\n\t */\n\tjbd2_journal_release_jbd_inode(OCFS2_SB(inode->i_sb)->journal->j_journal,\n\t\t\t\t       &oi->ip_jinode);\n}"
  },
  {
    "function_name": "ocfs2_delete_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "969-1076",
    "snippet": "static void ocfs2_delete_inode(struct inode *inode)\n{\n\tint wipe, status;\n\tsigset_t oldset;\n\tstruct buffer_head *di_bh = NULL;\n\n\ttrace_ocfs2_delete_inode(inode->i_ino,\n\t\t\t\t (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t is_bad_inode(inode));\n\n\t/* When we fail in read_inode() we mark inode as bad. The second test\n\t * catches the case when inode allocation fails before allocating\n\t * a block for inode. */\n\tif (is_bad_inode(inode) || !OCFS2_I(inode)->ip_blkno)\n\t\tgoto bail;\n\n\tif (!ocfs2_inode_is_valid_to_delete(inode)) {\n\t\t/* It's probably not necessary to truncate_inode_pages\n\t\t * here but we do it for safety anyway (it will most\n\t\t * likely be a no-op anyway) */\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail;\n\t}\n\n\tdquot_initialize(inode);\n\n\t/* We want to block signals in delete_inode as the lock and\n\t * messaging paths may return us -ERESTARTSYS. Which would\n\t * cause us to exit early, resulting in inodes being orphaned\n\t * forever. */\n\tocfs2_block_signals(&oldset);\n\n\t/*\n\t * Synchronize us against ocfs2_get_dentry. We take this in\n\t * shared mode so that all nodes can still concurrently\n\t * process deletes.\n\t */\n\tstatus = ocfs2_nfs_sync_lock(OCFS2_SB(inode->i_sb), 0);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(PR) failed %d\\n\", status);\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail_unblock;\n\t}\n\t/* Lock down the inode. This gives us an up to date view of\n\t * it's metadata (for verification), and allows us to\n\t * serialize delete_inode on multiple nodes.\n\t *\n\t * Even though we might be doing a truncate, we don't take the\n\t * allocation lock here as it won't be needed - nobody will\n\t * have the file open.\n\t */\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail_unlock_nfs_sync;\n\t}\n\n\t/* Query the cluster. This will be the final decision made\n\t * before we go ahead and wipe the inode. */\n\tstatus = ocfs2_query_inode_wipe(inode, di_bh, &wipe);\n\tif (!wipe || status < 0) {\n\t\t/* Error and remote inode busy both mean we won't be\n\t\t * removing the inode, so they take almost the same\n\t\t * path. */\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\n\t\t/* Someone in the cluster has disallowed a wipe of\n\t\t * this inode, or it was never completely\n\t\t * orphaned. Write out the pages and exit now. */\n\t\tocfs2_cleanup_delete_inode(inode, 1);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\tocfs2_cleanup_delete_inode(inode, 0);\n\n\tstatus = ocfs2_wipe_inode(inode, di_bh);\n\tif (status < 0) {\n\t\tif (status != -EDEADLK)\n\t\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\t/*\n\t * Mark the inode as successfully deleted.\n\t *\n\t * This is important for ocfs2_clear_inode() as it will check\n\t * this flag and skip any checkpointing work\n\t *\n\t * ocfs2_stuff_meta_lvb() also uses this flag to invalidate\n\t * the LVB for other nodes.\n\t */\n\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_DELETED;\n\nbail_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\nbail_unlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(OCFS2_SB(inode->i_sb), 0);\n\nbail_unblock:\n\tocfs2_unblock_signals(&oldset);\nbail:\n\treturn;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_unblock_signals",
          "args": [
            "&oldset"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unblock_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2632-2636",
          "snippet": "void ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_nfs_sync_unlock",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "0"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_nfs_sync_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2642-2649",
          "snippet": "void ocfs2_nfs_sync_unlock(struct ocfs2_super *osb, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres,\n\t\t\t\t     ex ? LKM_EXMODE : LKM_PRMODE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_nfs_sync_unlock(struct ocfs2_super *osb, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres,\n\t\t\t\t     ex ? LKM_EXMODE : LKM_PRMODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_wipe_inode",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wipe_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "725-812",
          "snippet": "static int ocfs2_wipe_inode(struct inode *inode,\n\t\t\t    struct buffer_head *di_bh)\n{\n\tint status, orphaned_slot = -1;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\torphaned_slot = le16_to_cpu(di->i_orphaned_slot);\n\n\t\tstatus = ocfs2_check_orphan_recovery_state(osb, orphaned_slot);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t\t       orphaned_slot);\n\t\tif (!orphan_dir_inode) {\n\t\t\tstatus = -EEXIST;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Lock the orphan dir. The lock will be held for the entire\n\t\t * delete_inode operation. We do this now to avoid races with\n\t\t * recovery completion on other nodes. */\n\t\tmutex_lock(&orphan_dir_inode->i_mutex);\n\t\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\t\tif (status < 0) {\n\t\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* we do this while holding the orphan dir lock because we\n\t * don't want recovery being run from another node to try an\n\t * inode delete underneath us -- this will result in two nodes\n\t * truncating the same file! */\n\tstatus = ocfs2_truncate_for_delete(osb, inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\t/* Remove any dir index tree */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstatus = ocfs2_dx_dir_truncate(inode, di_bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock_dir;\n\t\t}\n\t}\n\n\t/*Free extended attribute resources associated with this inode.*/\n\tstatus = ocfs2_xattr_remove(inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\tstatus = ocfs2_remove_refcount_tree(inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\tstatus = ocfs2_remove_inode(inode, di_bh, orphan_dir_inode,\n\t\t\t\t    orphan_dir_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_unlock_dir:\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)\n\t\treturn status;\n\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tbrelse(orphan_dir_bh);\nbail:\n\tiput(orphan_dir_inode);\n\tocfs2_signal_wipe_completion(osb, orphaned_slot);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_wipe_inode(struct inode *inode,\n\t\t\t    struct buffer_head *di_bh)\n{\n\tint status, orphaned_slot = -1;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\torphaned_slot = le16_to_cpu(di->i_orphaned_slot);\n\n\t\tstatus = ocfs2_check_orphan_recovery_state(osb, orphaned_slot);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t\t       orphaned_slot);\n\t\tif (!orphan_dir_inode) {\n\t\t\tstatus = -EEXIST;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Lock the orphan dir. The lock will be held for the entire\n\t\t * delete_inode operation. We do this now to avoid races with\n\t\t * recovery completion on other nodes. */\n\t\tmutex_lock(&orphan_dir_inode->i_mutex);\n\t\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\t\tif (status < 0) {\n\t\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* we do this while holding the orphan dir lock because we\n\t * don't want recovery being run from another node to try an\n\t * inode delete underneath us -- this will result in two nodes\n\t * truncating the same file! */\n\tstatus = ocfs2_truncate_for_delete(osb, inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\t/* Remove any dir index tree */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstatus = ocfs2_dx_dir_truncate(inode, di_bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock_dir;\n\t\t}\n\t}\n\n\t/*Free extended attribute resources associated with this inode.*/\n\tstatus = ocfs2_xattr_remove(inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\tstatus = ocfs2_remove_refcount_tree(inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\tstatus = ocfs2_remove_inode(inode, di_bh, orphan_dir_inode,\n\t\t\t\t    orphan_dir_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_unlock_dir:\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)\n\t\treturn status;\n\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tbrelse(orphan_dir_bh);\nbail:\n\tiput(orphan_dir_inode);\n\tocfs2_signal_wipe_completion(osb, orphaned_slot);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cleanup_delete_inode",
          "args": [
            "inode",
            "0"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cleanup_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "959-967",
          "snippet": "static void ocfs2_cleanup_delete_inode(struct inode *inode,\n\t\t\t\t       int sync_data)\n{\n\ttrace_ocfs2_cleanup_delete_inode(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno, sync_data);\n\tif (sync_data)\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\ttruncate_inode_pages_final(&inode->i_data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_cleanup_delete_inode(struct inode *inode,\n\t\t\t\t       int sync_data)\n{\n\ttrace_ocfs2_cleanup_delete_inode(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno, sync_data);\n\tif (sync_data)\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\ttruncate_inode_pages_final(&inode->i_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_query_inode_wipe",
          "args": [
            "inode",
            "di_bh",
            "&wipe"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_query_inode_wipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "864-954",
          "snippet": "static int ocfs2_query_inode_wipe(struct inode *inode,\n\t\t\t\t  struct buffer_head *di_bh,\n\t\t\t\t  int *wipe)\n{\n\tint status = 0, reason = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di;\n\n\t*wipe = 0;\n\n\ttrace_ocfs2_query_inode_wipe_begin((unsigned long long)oi->ip_blkno,\n\t\t\t\t\t   inode->i_nlink);\n\n\t/* While we were waiting for the cluster lock in\n\t * ocfs2_delete_inode, another node might have asked to delete\n\t * the inode. Recheck our flags to catch this. */\n\tif (!ocfs2_inode_is_valid_to_delete(inode)) {\n\t\treason = 1;\n\t\tgoto bail;\n\t}\n\n\t/* Now that we have an up to date inode, we can double check\n\t * the link count. */\n\tif (inode->i_nlink)\n\t\tgoto bail;\n\n\t/* Do some basic inode verification... */\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tif (!(di->i_flags & cpu_to_le32(OCFS2_ORPHANED_FL)) &&\n\t    !(oi->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\t/*\n\t\t * Inodes in the orphan dir must have ORPHANED_FL.  The only\n\t\t * inodes that come back out of the orphan dir are reflink\n\t\t * targets. A reflink target may be moved out of the orphan\n\t\t * dir between the time we scan the directory and the time we\n\t\t * process it. This would lead to HAS_REFCOUNT_FL being set but\n\t\t * ORPHANED_FL not.\n\t\t */\n\t\tif (di->i_dyn_features & cpu_to_le16(OCFS2_HAS_REFCOUNT_FL)) {\n\t\t\treason = 2;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* for lack of a better error? */\n\t\tstatus = -EEXIST;\n\t\tmlog(ML_ERROR,\n\t\t     \"Inode %llu (on-disk %llu) not orphaned! \"\n\t\t     \"Disk flags  0x%x, inode flags 0x%x\\n\",\n\t\t     (unsigned long long)oi->ip_blkno,\n\t\t     (unsigned long long)le64_to_cpu(di->i_blkno),\n\t\t     le32_to_cpu(di->i_flags), oi->ip_flags);\n\t\tgoto bail;\n\t}\n\n\t/* has someone already deleted us?! baaad... */\n\tif (di->i_dtime) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * This is how ocfs2 determines whether an inode is still live\n\t * within the cluster. Every node takes a shared read lock on\n\t * the inode open lock in ocfs2_read_locked_inode(). When we\n\t * get to ->delete_inode(), each node tries to convert it's\n\t * lock to an exclusive. Trylocks are serialized by the inode\n\t * meta data lock. If the upconvert succeeds, we know the inode\n\t * is no longer live and can be deleted.\n\t *\n\t * Though we call this with the meta data lock held, the\n\t * trylock keeps us from ABBA deadlock.\n\t */\n\tstatus = ocfs2_try_open_lock(inode, 1);\n\tif (status == -EAGAIN) {\n\t\tstatus = 0;\n\t\treason = 3;\n\t\tgoto bail;\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*wipe = 1;\n\ttrace_ocfs2_query_inode_wipe_succ(le16_to_cpu(di->i_orphaned_slot));\n\nbail:\n\ttrace_ocfs2_query_inode_wipe_end(status, reason);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_query_inode_wipe(struct inode *inode,\n\t\t\t\t  struct buffer_head *di_bh,\n\t\t\t\t  int *wipe)\n{\n\tint status = 0, reason = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di;\n\n\t*wipe = 0;\n\n\ttrace_ocfs2_query_inode_wipe_begin((unsigned long long)oi->ip_blkno,\n\t\t\t\t\t   inode->i_nlink);\n\n\t/* While we were waiting for the cluster lock in\n\t * ocfs2_delete_inode, another node might have asked to delete\n\t * the inode. Recheck our flags to catch this. */\n\tif (!ocfs2_inode_is_valid_to_delete(inode)) {\n\t\treason = 1;\n\t\tgoto bail;\n\t}\n\n\t/* Now that we have an up to date inode, we can double check\n\t * the link count. */\n\tif (inode->i_nlink)\n\t\tgoto bail;\n\n\t/* Do some basic inode verification... */\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tif (!(di->i_flags & cpu_to_le32(OCFS2_ORPHANED_FL)) &&\n\t    !(oi->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\t/*\n\t\t * Inodes in the orphan dir must have ORPHANED_FL.  The only\n\t\t * inodes that come back out of the orphan dir are reflink\n\t\t * targets. A reflink target may be moved out of the orphan\n\t\t * dir between the time we scan the directory and the time we\n\t\t * process it. This would lead to HAS_REFCOUNT_FL being set but\n\t\t * ORPHANED_FL not.\n\t\t */\n\t\tif (di->i_dyn_features & cpu_to_le16(OCFS2_HAS_REFCOUNT_FL)) {\n\t\t\treason = 2;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* for lack of a better error? */\n\t\tstatus = -EEXIST;\n\t\tmlog(ML_ERROR,\n\t\t     \"Inode %llu (on-disk %llu) not orphaned! \"\n\t\t     \"Disk flags  0x%x, inode flags 0x%x\\n\",\n\t\t     (unsigned long long)oi->ip_blkno,\n\t\t     (unsigned long long)le64_to_cpu(di->i_blkno),\n\t\t     le32_to_cpu(di->i_flags), oi->ip_flags);\n\t\tgoto bail;\n\t}\n\n\t/* has someone already deleted us?! baaad... */\n\tif (di->i_dtime) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * This is how ocfs2 determines whether an inode is still live\n\t * within the cluster. Every node takes a shared read lock on\n\t * the inode open lock in ocfs2_read_locked_inode(). When we\n\t * get to ->delete_inode(), each node tries to convert it's\n\t * lock to an exclusive. Trylocks are serialized by the inode\n\t * meta data lock. If the upconvert succeeds, we know the inode\n\t * is no longer live and can be deleted.\n\t *\n\t * Though we call this with the meta data lock held, the\n\t * trylock keeps us from ABBA deadlock.\n\t */\n\tstatus = ocfs2_try_open_lock(inode, 1);\n\tif (status == -EAGAIN) {\n\t\tstatus = 0;\n\t\treason = 3;\n\t\tgoto bail;\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*wipe = 1;\n\ttrace_ocfs2_query_inode_wipe_succ(le16_to_cpu(di->i_orphaned_slot));\n\nbail:\n\ttrace_ocfs2_query_inode_wipe_end(status, reason);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "1"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"getting nfs sync lock(PR) failed %d\\n\"",
            "status"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_nfs_sync_lock",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "0"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_nfs_sync_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2623-2640",
          "snippet": "int ocfs2_nfs_sync_lock(struct ocfs2_super *osb, int ex)\n{\n\tint status;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, ex ? LKM_EXMODE : LKM_PRMODE,\n\t\t\t\t    0, 0);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"lock on nfs sync lock failed %d\\n\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_nfs_sync_lock(struct ocfs2_super *osb, int ex)\n{\n\tint status;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, ex ? LKM_EXMODE : LKM_PRMODE,\n\t\t\t\t    0, 0);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"lock on nfs sync lock failed %d\\n\", status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_block_signals",
          "args": [
            "&oldset"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2622-2630",
          "snippet": "void ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_is_valid_to_delete",
          "args": [
            "inode"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_is_valid_to_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "816-858",
          "snippet": "static int ocfs2_inode_is_valid_to_delete(struct inode *inode)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\ttrace_ocfs2_inode_is_valid_to_delete(current, osb->dc_task,\n\t\t\t\t\t     (unsigned long long)oi->ip_blkno,\n\t\t\t\t\t     oi->ip_flags);\n\n\t/* We shouldn't be getting here for the root directory\n\t * inode.. */\n\tif (inode == osb->root_inode) {\n\t\tmlog(ML_ERROR, \"Skipping delete of root inode.\\n\");\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * If we're coming from downconvert_thread we can't go into our own\n\t * voting [hello, deadlock city!] so we cannot delete the inode. But\n\t * since we dropped last inode ref when downconverting dentry lock,\n\t * we cannot have the file open and thus the node doing unlink will\n\t * take care of deleting the inode.\n\t */\n\tif (current == osb->dc_task)\n\t\tgoto bail;\n\n\tspin_lock(&oi->ip_lock);\n\t/* OCFS2 *never* deletes system files. This should technically\n\t * never get here as system file inodes should always have a\n\t * positive link count. */\n\tif (oi->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\n\t\tmlog(ML_ERROR, \"Skipping delete of system file %llu\\n\",\n\t\t     (unsigned long long)oi->ip_blkno);\n\t\tgoto bail_unlock;\n\t}\n\n\tret = 1;\nbail_unlock:\n\tspin_unlock(&oi->ip_lock);\nbail:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_inode_is_valid_to_delete(struct inode *inode)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\ttrace_ocfs2_inode_is_valid_to_delete(current, osb->dc_task,\n\t\t\t\t\t     (unsigned long long)oi->ip_blkno,\n\t\t\t\t\t     oi->ip_flags);\n\n\t/* We shouldn't be getting here for the root directory\n\t * inode.. */\n\tif (inode == osb->root_inode) {\n\t\tmlog(ML_ERROR, \"Skipping delete of root inode.\\n\");\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * If we're coming from downconvert_thread we can't go into our own\n\t * voting [hello, deadlock city!] so we cannot delete the inode. But\n\t * since we dropped last inode ref when downconverting dentry lock,\n\t * we cannot have the file open and thus the node doing unlink will\n\t * take care of deleting the inode.\n\t */\n\tif (current == osb->dc_task)\n\t\tgoto bail;\n\n\tspin_lock(&oi->ip_lock);\n\t/* OCFS2 *never* deletes system files. This should technically\n\t * never get here as system file inodes should always have a\n\t * positive link count. */\n\tif (oi->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\n\t\tmlog(ML_ERROR, \"Skipping delete of system file %llu\\n\",\n\t\t     (unsigned long long)oi->ip_blkno);\n\t\tgoto bail_unlock;\n\t}\n\n\tret = 1;\nbail_unlock:\n\tspin_unlock(&oi->ip_lock);\nbail:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_delete_inode",
          "args": [
            "inode->i_ino",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "is_bad_inode(inode)"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_delete_inode(struct inode *inode)\n{\n\tint wipe, status;\n\tsigset_t oldset;\n\tstruct buffer_head *di_bh = NULL;\n\n\ttrace_ocfs2_delete_inode(inode->i_ino,\n\t\t\t\t (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t is_bad_inode(inode));\n\n\t/* When we fail in read_inode() we mark inode as bad. The second test\n\t * catches the case when inode allocation fails before allocating\n\t * a block for inode. */\n\tif (is_bad_inode(inode) || !OCFS2_I(inode)->ip_blkno)\n\t\tgoto bail;\n\n\tif (!ocfs2_inode_is_valid_to_delete(inode)) {\n\t\t/* It's probably not necessary to truncate_inode_pages\n\t\t * here but we do it for safety anyway (it will most\n\t\t * likely be a no-op anyway) */\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail;\n\t}\n\n\tdquot_initialize(inode);\n\n\t/* We want to block signals in delete_inode as the lock and\n\t * messaging paths may return us -ERESTARTSYS. Which would\n\t * cause us to exit early, resulting in inodes being orphaned\n\t * forever. */\n\tocfs2_block_signals(&oldset);\n\n\t/*\n\t * Synchronize us against ocfs2_get_dentry. We take this in\n\t * shared mode so that all nodes can still concurrently\n\t * process deletes.\n\t */\n\tstatus = ocfs2_nfs_sync_lock(OCFS2_SB(inode->i_sb), 0);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(PR) failed %d\\n\", status);\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail_unblock;\n\t}\n\t/* Lock down the inode. This gives us an up to date view of\n\t * it's metadata (for verification), and allows us to\n\t * serialize delete_inode on multiple nodes.\n\t *\n\t * Even though we might be doing a truncate, we don't take the\n\t * allocation lock here as it won't be needed - nobody will\n\t * have the file open.\n\t */\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail_unlock_nfs_sync;\n\t}\n\n\t/* Query the cluster. This will be the final decision made\n\t * before we go ahead and wipe the inode. */\n\tstatus = ocfs2_query_inode_wipe(inode, di_bh, &wipe);\n\tif (!wipe || status < 0) {\n\t\t/* Error and remote inode busy both mean we won't be\n\t\t * removing the inode, so they take almost the same\n\t\t * path. */\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\n\t\t/* Someone in the cluster has disallowed a wipe of\n\t\t * this inode, or it was never completely\n\t\t * orphaned. Write out the pages and exit now. */\n\t\tocfs2_cleanup_delete_inode(inode, 1);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\tocfs2_cleanup_delete_inode(inode, 0);\n\n\tstatus = ocfs2_wipe_inode(inode, di_bh);\n\tif (status < 0) {\n\t\tif (status != -EDEADLK)\n\t\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\t/*\n\t * Mark the inode as successfully deleted.\n\t *\n\t * This is important for ocfs2_clear_inode() as it will check\n\t * this flag and skip any checkpointing work\n\t *\n\t * ocfs2_stuff_meta_lvb() also uses this flag to invalidate\n\t * the LVB for other nodes.\n\t */\n\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_DELETED;\n\nbail_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\nbail_unlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(OCFS2_SB(inode->i_sb), 0);\n\nbail_unblock:\n\tocfs2_unblock_signals(&oldset);\nbail:\n\treturn;\n}"
  },
  {
    "function_name": "ocfs2_cleanup_delete_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "959-967",
    "snippet": "static void ocfs2_cleanup_delete_inode(struct inode *inode,\n\t\t\t\t       int sync_data)\n{\n\ttrace_ocfs2_cleanup_delete_inode(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno, sync_data);\n\tif (sync_data)\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\ttruncate_inode_pages_final(&inode->i_data);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_cleanup_delete_inode",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "sync_data"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_cleanup_delete_inode(struct inode *inode,\n\t\t\t\t       int sync_data)\n{\n\ttrace_ocfs2_cleanup_delete_inode(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno, sync_data);\n\tif (sync_data)\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\ttruncate_inode_pages_final(&inode->i_data);\n}"
  },
  {
    "function_name": "ocfs2_query_inode_wipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "864-954",
    "snippet": "static int ocfs2_query_inode_wipe(struct inode *inode,\n\t\t\t\t  struct buffer_head *di_bh,\n\t\t\t\t  int *wipe)\n{\n\tint status = 0, reason = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di;\n\n\t*wipe = 0;\n\n\ttrace_ocfs2_query_inode_wipe_begin((unsigned long long)oi->ip_blkno,\n\t\t\t\t\t   inode->i_nlink);\n\n\t/* While we were waiting for the cluster lock in\n\t * ocfs2_delete_inode, another node might have asked to delete\n\t * the inode. Recheck our flags to catch this. */\n\tif (!ocfs2_inode_is_valid_to_delete(inode)) {\n\t\treason = 1;\n\t\tgoto bail;\n\t}\n\n\t/* Now that we have an up to date inode, we can double check\n\t * the link count. */\n\tif (inode->i_nlink)\n\t\tgoto bail;\n\n\t/* Do some basic inode verification... */\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tif (!(di->i_flags & cpu_to_le32(OCFS2_ORPHANED_FL)) &&\n\t    !(oi->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\t/*\n\t\t * Inodes in the orphan dir must have ORPHANED_FL.  The only\n\t\t * inodes that come back out of the orphan dir are reflink\n\t\t * targets. A reflink target may be moved out of the orphan\n\t\t * dir between the time we scan the directory and the time we\n\t\t * process it. This would lead to HAS_REFCOUNT_FL being set but\n\t\t * ORPHANED_FL not.\n\t\t */\n\t\tif (di->i_dyn_features & cpu_to_le16(OCFS2_HAS_REFCOUNT_FL)) {\n\t\t\treason = 2;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* for lack of a better error? */\n\t\tstatus = -EEXIST;\n\t\tmlog(ML_ERROR,\n\t\t     \"Inode %llu (on-disk %llu) not orphaned! \"\n\t\t     \"Disk flags  0x%x, inode flags 0x%x\\n\",\n\t\t     (unsigned long long)oi->ip_blkno,\n\t\t     (unsigned long long)le64_to_cpu(di->i_blkno),\n\t\t     le32_to_cpu(di->i_flags), oi->ip_flags);\n\t\tgoto bail;\n\t}\n\n\t/* has someone already deleted us?! baaad... */\n\tif (di->i_dtime) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * This is how ocfs2 determines whether an inode is still live\n\t * within the cluster. Every node takes a shared read lock on\n\t * the inode open lock in ocfs2_read_locked_inode(). When we\n\t * get to ->delete_inode(), each node tries to convert it's\n\t * lock to an exclusive. Trylocks are serialized by the inode\n\t * meta data lock. If the upconvert succeeds, we know the inode\n\t * is no longer live and can be deleted.\n\t *\n\t * Though we call this with the meta data lock held, the\n\t * trylock keeps us from ABBA deadlock.\n\t */\n\tstatus = ocfs2_try_open_lock(inode, 1);\n\tif (status == -EAGAIN) {\n\t\tstatus = 0;\n\t\treason = 3;\n\t\tgoto bail;\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*wipe = 1;\n\ttrace_ocfs2_query_inode_wipe_succ(le16_to_cpu(di->i_orphaned_slot));\n\nbail:\n\ttrace_ocfs2_query_inode_wipe_end(status, reason);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_query_inode_wipe_end",
          "args": [
            "status",
            "reason"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_query_inode_wipe_succ",
          "args": [
            "le16_to_cpu(di->i_orphaned_slot)"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_orphaned_slot"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_try_open_lock",
          "args": [
            "inode",
            "1"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_try_open_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1734-1770",
          "snippet": "int ocfs2_try_open_lock(struct inode *inode, int write)\n{\n\tint status = 0, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu try to take %s open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (write)\n\t\t\tstatus = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\t/*\n\t * The file system may already holding a PRMODE/EXMODE open lock.\n\t * Since we pass DLM_LKF_NOQUEUE, the request won't block waiting on\n\t * other nodes and the -EAGAIN will indicate to the caller that\n\t * this inode is still in use.\n\t */\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t    level, DLM_LKF_NOQUEUE, 0);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_try_open_lock(struct inode *inode, int write)\n{\n\tint status = 0, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu try to take %s open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (write)\n\t\t\tstatus = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\t/*\n\t * The file system may already holding a PRMODE/EXMODE open lock.\n\t * Since we pass DLM_LKF_NOQUEUE, the request won't block waiting on\n\t * other nodes and the -EAGAIN will indicate to the caller that\n\t * this inode is still in use.\n\t */\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t    level, DLM_LKF_NOQUEUE, 0);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Inode %llu (on-disk %llu) not orphaned! \"\n\t\t     \"Disk flags  0x%x, inode flags 0x%x\\n\"",
            "(unsigned long long)oi->ip_blkno",
            "(unsigned long long)le64_to_cpu(di->i_blkno)",
            "le32_to_cpu(di->i_flags)",
            "oi->ip_flags"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->i_flags"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_blkno"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "OCFS2_HAS_REFCOUNT_FL"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_ORPHANED_FL"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_is_valid_to_delete",
          "args": [
            "inode"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_is_valid_to_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "816-858",
          "snippet": "static int ocfs2_inode_is_valid_to_delete(struct inode *inode)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\ttrace_ocfs2_inode_is_valid_to_delete(current, osb->dc_task,\n\t\t\t\t\t     (unsigned long long)oi->ip_blkno,\n\t\t\t\t\t     oi->ip_flags);\n\n\t/* We shouldn't be getting here for the root directory\n\t * inode.. */\n\tif (inode == osb->root_inode) {\n\t\tmlog(ML_ERROR, \"Skipping delete of root inode.\\n\");\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * If we're coming from downconvert_thread we can't go into our own\n\t * voting [hello, deadlock city!] so we cannot delete the inode. But\n\t * since we dropped last inode ref when downconverting dentry lock,\n\t * we cannot have the file open and thus the node doing unlink will\n\t * take care of deleting the inode.\n\t */\n\tif (current == osb->dc_task)\n\t\tgoto bail;\n\n\tspin_lock(&oi->ip_lock);\n\t/* OCFS2 *never* deletes system files. This should technically\n\t * never get here as system file inodes should always have a\n\t * positive link count. */\n\tif (oi->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\n\t\tmlog(ML_ERROR, \"Skipping delete of system file %llu\\n\",\n\t\t     (unsigned long long)oi->ip_blkno);\n\t\tgoto bail_unlock;\n\t}\n\n\tret = 1;\nbail_unlock:\n\tspin_unlock(&oi->ip_lock);\nbail:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_inode_is_valid_to_delete(struct inode *inode)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\ttrace_ocfs2_inode_is_valid_to_delete(current, osb->dc_task,\n\t\t\t\t\t     (unsigned long long)oi->ip_blkno,\n\t\t\t\t\t     oi->ip_flags);\n\n\t/* We shouldn't be getting here for the root directory\n\t * inode.. */\n\tif (inode == osb->root_inode) {\n\t\tmlog(ML_ERROR, \"Skipping delete of root inode.\\n\");\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * If we're coming from downconvert_thread we can't go into our own\n\t * voting [hello, deadlock city!] so we cannot delete the inode. But\n\t * since we dropped last inode ref when downconverting dentry lock,\n\t * we cannot have the file open and thus the node doing unlink will\n\t * take care of deleting the inode.\n\t */\n\tif (current == osb->dc_task)\n\t\tgoto bail;\n\n\tspin_lock(&oi->ip_lock);\n\t/* OCFS2 *never* deletes system files. This should technically\n\t * never get here as system file inodes should always have a\n\t * positive link count. */\n\tif (oi->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\n\t\tmlog(ML_ERROR, \"Skipping delete of system file %llu\\n\",\n\t\t     (unsigned long long)oi->ip_blkno);\n\t\tgoto bail_unlock;\n\t}\n\n\tret = 1;\nbail_unlock:\n\tspin_unlock(&oi->ip_lock);\nbail:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_query_inode_wipe_begin",
          "args": [
            "(unsigned long long)oi->ip_blkno",
            "inode->i_nlink"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_query_inode_wipe(struct inode *inode,\n\t\t\t\t  struct buffer_head *di_bh,\n\t\t\t\t  int *wipe)\n{\n\tint status = 0, reason = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di;\n\n\t*wipe = 0;\n\n\ttrace_ocfs2_query_inode_wipe_begin((unsigned long long)oi->ip_blkno,\n\t\t\t\t\t   inode->i_nlink);\n\n\t/* While we were waiting for the cluster lock in\n\t * ocfs2_delete_inode, another node might have asked to delete\n\t * the inode. Recheck our flags to catch this. */\n\tif (!ocfs2_inode_is_valid_to_delete(inode)) {\n\t\treason = 1;\n\t\tgoto bail;\n\t}\n\n\t/* Now that we have an up to date inode, we can double check\n\t * the link count. */\n\tif (inode->i_nlink)\n\t\tgoto bail;\n\n\t/* Do some basic inode verification... */\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tif (!(di->i_flags & cpu_to_le32(OCFS2_ORPHANED_FL)) &&\n\t    !(oi->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\t/*\n\t\t * Inodes in the orphan dir must have ORPHANED_FL.  The only\n\t\t * inodes that come back out of the orphan dir are reflink\n\t\t * targets. A reflink target may be moved out of the orphan\n\t\t * dir between the time we scan the directory and the time we\n\t\t * process it. This would lead to HAS_REFCOUNT_FL being set but\n\t\t * ORPHANED_FL not.\n\t\t */\n\t\tif (di->i_dyn_features & cpu_to_le16(OCFS2_HAS_REFCOUNT_FL)) {\n\t\t\treason = 2;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* for lack of a better error? */\n\t\tstatus = -EEXIST;\n\t\tmlog(ML_ERROR,\n\t\t     \"Inode %llu (on-disk %llu) not orphaned! \"\n\t\t     \"Disk flags  0x%x, inode flags 0x%x\\n\",\n\t\t     (unsigned long long)oi->ip_blkno,\n\t\t     (unsigned long long)le64_to_cpu(di->i_blkno),\n\t\t     le32_to_cpu(di->i_flags), oi->ip_flags);\n\t\tgoto bail;\n\t}\n\n\t/* has someone already deleted us?! baaad... */\n\tif (di->i_dtime) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * This is how ocfs2 determines whether an inode is still live\n\t * within the cluster. Every node takes a shared read lock on\n\t * the inode open lock in ocfs2_read_locked_inode(). When we\n\t * get to ->delete_inode(), each node tries to convert it's\n\t * lock to an exclusive. Trylocks are serialized by the inode\n\t * meta data lock. If the upconvert succeeds, we know the inode\n\t * is no longer live and can be deleted.\n\t *\n\t * Though we call this with the meta data lock held, the\n\t * trylock keeps us from ABBA deadlock.\n\t */\n\tstatus = ocfs2_try_open_lock(inode, 1);\n\tif (status == -EAGAIN) {\n\t\tstatus = 0;\n\t\treason = 3;\n\t\tgoto bail;\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*wipe = 1;\n\ttrace_ocfs2_query_inode_wipe_succ(le16_to_cpu(di->i_orphaned_slot));\n\nbail:\n\ttrace_ocfs2_query_inode_wipe_end(status, reason);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_inode_is_valid_to_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "816-858",
    "snippet": "static int ocfs2_inode_is_valid_to_delete(struct inode *inode)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\ttrace_ocfs2_inode_is_valid_to_delete(current, osb->dc_task,\n\t\t\t\t\t     (unsigned long long)oi->ip_blkno,\n\t\t\t\t\t     oi->ip_flags);\n\n\t/* We shouldn't be getting here for the root directory\n\t * inode.. */\n\tif (inode == osb->root_inode) {\n\t\tmlog(ML_ERROR, \"Skipping delete of root inode.\\n\");\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * If we're coming from downconvert_thread we can't go into our own\n\t * voting [hello, deadlock city!] so we cannot delete the inode. But\n\t * since we dropped last inode ref when downconverting dentry lock,\n\t * we cannot have the file open and thus the node doing unlink will\n\t * take care of deleting the inode.\n\t */\n\tif (current == osb->dc_task)\n\t\tgoto bail;\n\n\tspin_lock(&oi->ip_lock);\n\t/* OCFS2 *never* deletes system files. This should technically\n\t * never get here as system file inodes should always have a\n\t * positive link count. */\n\tif (oi->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\n\t\tmlog(ML_ERROR, \"Skipping delete of system file %llu\\n\",\n\t\t     (unsigned long long)oi->ip_blkno);\n\t\tgoto bail_unlock;\n\t}\n\n\tret = 1;\nbail_unlock:\n\tspin_unlock(&oi->ip_lock);\nbail:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Skipping delete of system file %llu\\n\"",
            "(unsigned long long)oi->ip_blkno"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Skipping delete of root inode.\\n\""
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_inode_is_valid_to_delete",
          "args": [
            "current",
            "osb->dc_task",
            "(unsigned long long)oi->ip_blkno",
            "oi->ip_flags"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_inode_is_valid_to_delete(struct inode *inode)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\ttrace_ocfs2_inode_is_valid_to_delete(current, osb->dc_task,\n\t\t\t\t\t     (unsigned long long)oi->ip_blkno,\n\t\t\t\t\t     oi->ip_flags);\n\n\t/* We shouldn't be getting here for the root directory\n\t * inode.. */\n\tif (inode == osb->root_inode) {\n\t\tmlog(ML_ERROR, \"Skipping delete of root inode.\\n\");\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * If we're coming from downconvert_thread we can't go into our own\n\t * voting [hello, deadlock city!] so we cannot delete the inode. But\n\t * since we dropped last inode ref when downconverting dentry lock,\n\t * we cannot have the file open and thus the node doing unlink will\n\t * take care of deleting the inode.\n\t */\n\tif (current == osb->dc_task)\n\t\tgoto bail;\n\n\tspin_lock(&oi->ip_lock);\n\t/* OCFS2 *never* deletes system files. This should technically\n\t * never get here as system file inodes should always have a\n\t * positive link count. */\n\tif (oi->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\n\t\tmlog(ML_ERROR, \"Skipping delete of system file %llu\\n\",\n\t\t     (unsigned long long)oi->ip_blkno);\n\t\tgoto bail_unlock;\n\t}\n\n\tret = 1;\nbail_unlock:\n\tspin_unlock(&oi->ip_lock);\nbail:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_wipe_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "725-812",
    "snippet": "static int ocfs2_wipe_inode(struct inode *inode,\n\t\t\t    struct buffer_head *di_bh)\n{\n\tint status, orphaned_slot = -1;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\torphaned_slot = le16_to_cpu(di->i_orphaned_slot);\n\n\t\tstatus = ocfs2_check_orphan_recovery_state(osb, orphaned_slot);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t\t       orphaned_slot);\n\t\tif (!orphan_dir_inode) {\n\t\t\tstatus = -EEXIST;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Lock the orphan dir. The lock will be held for the entire\n\t\t * delete_inode operation. We do this now to avoid races with\n\t\t * recovery completion on other nodes. */\n\t\tmutex_lock(&orphan_dir_inode->i_mutex);\n\t\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\t\tif (status < 0) {\n\t\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* we do this while holding the orphan dir lock because we\n\t * don't want recovery being run from another node to try an\n\t * inode delete underneath us -- this will result in two nodes\n\t * truncating the same file! */\n\tstatus = ocfs2_truncate_for_delete(osb, inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\t/* Remove any dir index tree */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstatus = ocfs2_dx_dir_truncate(inode, di_bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock_dir;\n\t\t}\n\t}\n\n\t/*Free extended attribute resources associated with this inode.*/\n\tstatus = ocfs2_xattr_remove(inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\tstatus = ocfs2_remove_refcount_tree(inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\tstatus = ocfs2_remove_inode(inode, di_bh, orphan_dir_inode,\n\t\t\t\t    orphan_dir_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_unlock_dir:\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)\n\t\treturn status;\n\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tbrelse(orphan_dir_bh);\nbail:\n\tiput(orphan_dir_inode);\n\tocfs2_signal_wipe_completion(osb, orphaned_slot);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_signal_wipe_completion",
          "args": [
            "osb",
            "orphaned_slot"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_signal_wipe_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "715-723",
          "snippet": "static void ocfs2_signal_wipe_completion(struct ocfs2_super *osb,\n\t\t\t\t\t int slot)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_orphan_wipes[slot]--;\n\tspin_unlock(&osb->osb_lock);\n\n\twake_up(&osb->osb_wipe_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_signal_wipe_completion(struct ocfs2_super *osb,\n\t\t\t\t\t int slot)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_orphan_wipes[slot]--;\n\tspin_unlock(&osb->osb_lock);\n\n\twake_up(&osb->osb_wipe_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "orphan_dir_inode"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "orphan_dir_bh"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "orphan_dir_inode",
            "1"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_inode",
          "args": [
            "inode",
            "di_bh",
            "orphan_dir_inode",
            "orphan_dir_bh"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "611-688",
          "snippet": "static int ocfs2_remove_inode(struct inode *inode,\n\t\t\t      struct buffer_head *di_bh,\n\t\t\t      struct inode *orphan_dir_inode,\n\t\t\t      struct buffer_head *orphan_dir_bh)\n{\n\tint status;\n\tstruct inode *inode_alloc_inode = NULL;\n\tstruct buffer_head *inode_alloc_bh = NULL;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\n\tinode_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb, INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    le16_to_cpu(di->i_suballoc_slot));\n\tif (!inode_alloc_inode) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode_alloc_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(inode_alloc_inode, &inode_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_DELETE_INODE_CREDITS +\n\t\t\t\t   ocfs2_quota_trans_credits(inode->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock;\n\t}\n\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode, inode,\n\t\t\t\t\t  orphan_dir_bh, false);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_commit;\n\t\t}\n\t}\n\n\t/* set the inodes dtime */\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tdi->i_dtime = cpu_to_le64(CURRENT_TIME.tv_sec);\n\tdi->i_flags &= cpu_to_le32(~(OCFS2_VALID_FL | OCFS2_ORPHANED_FL));\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tocfs2_remove_from_cache(INODE_CACHE(inode), di_bh);\n\tdquot_free_inode(inode);\n\n\tstatus = ocfs2_free_dinode(handle, inode_alloc_inode,\n\t\t\t\t   inode_alloc_bh, di);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\nbail_unlock:\n\tocfs2_inode_unlock(inode_alloc_inode, 1);\n\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\tbrelse(inode_alloc_bh);\nbail:\n\tiput(inode_alloc_inode);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_remove_inode(struct inode *inode,\n\t\t\t      struct buffer_head *di_bh,\n\t\t\t      struct inode *orphan_dir_inode,\n\t\t\t      struct buffer_head *orphan_dir_bh)\n{\n\tint status;\n\tstruct inode *inode_alloc_inode = NULL;\n\tstruct buffer_head *inode_alloc_bh = NULL;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\n\tinode_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb, INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    le16_to_cpu(di->i_suballoc_slot));\n\tif (!inode_alloc_inode) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode_alloc_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(inode_alloc_inode, &inode_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_DELETE_INODE_CREDITS +\n\t\t\t\t   ocfs2_quota_trans_credits(inode->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock;\n\t}\n\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode, inode,\n\t\t\t\t\t  orphan_dir_bh, false);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_commit;\n\t\t}\n\t}\n\n\t/* set the inodes dtime */\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tdi->i_dtime = cpu_to_le64(CURRENT_TIME.tv_sec);\n\tdi->i_flags &= cpu_to_le32(~(OCFS2_VALID_FL | OCFS2_ORPHANED_FL));\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tocfs2_remove_from_cache(INODE_CACHE(inode), di_bh);\n\tdquot_free_inode(inode);\n\n\tstatus = ocfs2_free_dinode(handle, inode_alloc_inode,\n\t\t\t\t   inode_alloc_bh, di);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\nbail_unlock:\n\tocfs2_inode_unlock(inode_alloc_inode, 1);\n\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\tbrelse(inode_alloc_bh);\nbail:\n\tiput(inode_alloc_inode);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_refcount_tree",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "764-882",
          "snippet": "int ocfs2_remove_refcount_tree(struct inode *inode, struct buffer_head *di_bh)\n{\n\tint ret, delete_tree = 0;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct inode *alloc_inode = NULL;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tint credits = OCFS2_REFCOUNT_TREE_REMOVE_CREDITS;\n\tu64 blk = 0, bg_blkno = 0, ref_blkno = le64_to_cpu(di->i_refcount_loc);\n\tu16 bit = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL))\n\t\treturn 0;\n\n\tBUG_ON(!ref_blkno);\n\tret = ocfs2_lock_refcount_tree(osb, ref_blkno, 1, &ref_tree, &blk_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)blk_bh->b_data;\n\n\t/*\n\t * If we are the last user, we need to free the block.\n\t * So lock the allocator ahead.\n\t */\n\tif (le32_to_cpu(rb->rf_count) == 1) {\n\t\tblk = le64_to_cpu(rb->rf_blkno);\n\t\tbit = le16_to_cpu(rb->rf_suballoc_bit);\n\t\tif (rb->rf_suballoc_loc)\n\t\t\tbg_blkno = le64_to_cpu(rb->rf_suballoc_loc);\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\t\talloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_slot));\n\t\tif (!alloc_inode) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_lock(&alloc_inode->i_mutex);\n\n\t\tret = ocfs2_inode_lock(alloc_inode, &alloc_bh, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_mutex;\n\t\t}\n\n\t\tcredits += OCFS2_SUBALLOC_FREE;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, blk_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = 0;\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tle32_add_cpu(&rb->rf_count , -1);\n\tocfs2_journal_dirty(handle, blk_bh);\n\n\tif (!rb->rf_count) {\n\t\tdelete_tree = 1;\n\t\tocfs2_erase_refcount_tree_from_list(osb, ref_tree);\n\t\tret = ocfs2_free_suballoc_bits(handle, alloc_inode,\n\t\t\t\t\t       alloc_bh, bit, bg_blkno, 1);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tif (alloc_inode) {\n\t\tocfs2_inode_unlock(alloc_inode, 1);\n\t\tbrelse(alloc_bh);\n\t}\nout_mutex:\n\tif (alloc_inode) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\t}\nout:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tif (delete_tree)\n\t\tocfs2_refcount_tree_put(ref_tree);\n\tbrelse(blk_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_remove_refcount_tree(struct inode *inode, struct buffer_head *di_bh)\n{\n\tint ret, delete_tree = 0;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct inode *alloc_inode = NULL;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tint credits = OCFS2_REFCOUNT_TREE_REMOVE_CREDITS;\n\tu64 blk = 0, bg_blkno = 0, ref_blkno = le64_to_cpu(di->i_refcount_loc);\n\tu16 bit = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL))\n\t\treturn 0;\n\n\tBUG_ON(!ref_blkno);\n\tret = ocfs2_lock_refcount_tree(osb, ref_blkno, 1, &ref_tree, &blk_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)blk_bh->b_data;\n\n\t/*\n\t * If we are the last user, we need to free the block.\n\t * So lock the allocator ahead.\n\t */\n\tif (le32_to_cpu(rb->rf_count) == 1) {\n\t\tblk = le64_to_cpu(rb->rf_blkno);\n\t\tbit = le16_to_cpu(rb->rf_suballoc_bit);\n\t\tif (rb->rf_suballoc_loc)\n\t\t\tbg_blkno = le64_to_cpu(rb->rf_suballoc_loc);\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\t\talloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_slot));\n\t\tif (!alloc_inode) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_lock(&alloc_inode->i_mutex);\n\n\t\tret = ocfs2_inode_lock(alloc_inode, &alloc_bh, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_mutex;\n\t\t}\n\n\t\tcredits += OCFS2_SUBALLOC_FREE;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, blk_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = 0;\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tle32_add_cpu(&rb->rf_count , -1);\n\tocfs2_journal_dirty(handle, blk_bh);\n\n\tif (!rb->rf_count) {\n\t\tdelete_tree = 1;\n\t\tocfs2_erase_refcount_tree_from_list(osb, ref_tree);\n\t\tret = ocfs2_free_suballoc_bits(handle, alloc_inode,\n\t\t\t\t\t       alloc_bh, bit, bg_blkno, 1);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tif (alloc_inode) {\n\t\tocfs2_inode_unlock(alloc_inode, 1);\n\t\tbrelse(alloc_bh);\n\t}\nout_mutex:\n\tif (alloc_inode) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\t}\nout:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tif (delete_tree)\n\t\tocfs2_refcount_tree_put(ref_tree);\n\tbrelse(blk_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_remove",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2545-2622",
          "snippet": "int ocfs2_xattr_remove(struct inode *inode, struct buffer_head *di_bh)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_caching_info *ref_ci = NULL;\n\thandle_t *handle;\n\tint ret;\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL) {\n\t\tret = ocfs2_lock_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t       le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tref_ci = &ref_tree->rf_ci;\n\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_ibody_remove(inode, di_bh,\n\t\t\t\t\t       ref_ci, ref_root_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (di->i_xattr_loc) {\n\t\tret = ocfs2_xattr_free_block(inode,\n\t\t\t\t\t     le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t\t     ref_ci, ref_root_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans((OCFS2_SB(inode->i_sb)),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdi->i_xattr_loc = 0;\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~(OCFS2_INLINE_XATTR_FL | OCFS2_HAS_XATTR_FL);\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(OCFS2_SB(inode->i_sb), ref_tree, 1);\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_xattr_remove(struct inode *inode, struct buffer_head *di_bh)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_caching_info *ref_ci = NULL;\n\thandle_t *handle;\n\tint ret;\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL) {\n\t\tret = ocfs2_lock_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t       le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tref_ci = &ref_tree->rf_ci;\n\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_ibody_remove(inode, di_bh,\n\t\t\t\t\t       ref_ci, ref_root_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (di->i_xattr_loc) {\n\t\tret = ocfs2_xattr_free_block(inode,\n\t\t\t\t\t     le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t\t     ref_ci, ref_root_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans((OCFS2_SB(inode->i_sb)),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdi->i_xattr_loc = 0;\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~(OCFS2_INLINE_XATTR_FL | OCFS2_HAS_XATTR_FL);\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(OCFS2_SB(inode->i_sb), ref_tree, 1);\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_truncate",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "4436-4504",
          "snippet": "int ocfs2_dx_dir_truncate(struct inode *dir, struct buffer_head *di_bh)\n{\n\tint ret;\n\tunsigned int uninitialized_var(clen);\n\tu32 major_hash = UINT_MAX, p_cpos, uninitialized_var(cpos);\n\tu64 uninitialized_var(blkno);\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tif (!ocfs2_dir_indexed(dir))\n\t\treturn 0;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tif (ocfs2_dx_root_inline(dx_root))\n\t\tgoto remove_index;\n\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\n\t/* XXX: What if dr_clusters is too large? */\n\twhile (le32_to_cpu(dx_root->dr_clusters)) {\n\t\tret = ocfs2_dx_dir_lookup_rec(dir, &dx_root->dr_list,\n\t\t\t\t\t      major_hash, &cpos, &blkno, &clen);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tp_cpos = ocfs2_blocks_to_clusters(dir->i_sb, blkno);\n\n\t\tret = ocfs2_remove_btree_range(dir, &et, cpos, p_cpos, clen, 0,\n\t\t\t\t\t       &dealloc, 0, false);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos == 0)\n\t\t\tbreak;\n\n\t\tmajor_hash = cpos - 1;\n\t}\n\nremove_index:\n\tret = ocfs2_dx_dir_remove_index(dir, di_bh, dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_from_cache(INODE_CACHE(dir), dx_root_bh);\nout:\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tbrelse(dx_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_dx_dir_truncate(struct inode *dir, struct buffer_head *di_bh)\n{\n\tint ret;\n\tunsigned int uninitialized_var(clen);\n\tu32 major_hash = UINT_MAX, p_cpos, uninitialized_var(cpos);\n\tu64 uninitialized_var(blkno);\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tif (!ocfs2_dir_indexed(dir))\n\t\treturn 0;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tif (ocfs2_dx_root_inline(dx_root))\n\t\tgoto remove_index;\n\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\n\t/* XXX: What if dr_clusters is too large? */\n\twhile (le32_to_cpu(dx_root->dr_clusters)) {\n\t\tret = ocfs2_dx_dir_lookup_rec(dir, &dx_root->dr_list,\n\t\t\t\t\t      major_hash, &cpos, &blkno, &clen);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tp_cpos = ocfs2_blocks_to_clusters(dir->i_sb, blkno);\n\n\t\tret = ocfs2_remove_btree_range(dir, &et, cpos, p_cpos, clen, 0,\n\t\t\t\t\t       &dealloc, 0, false);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos == 0)\n\t\t\tbreak;\n\n\t\tmajor_hash = cpos - 1;\n\t}\n\nremove_index:\n\tret = ocfs2_dx_dir_remove_index(dir, di_bh, dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_from_cache(INODE_CACHE(dir), dx_root_bh);\nout:\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tbrelse(dx_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_for_delete",
          "args": [
            "osb",
            "inode",
            "di_bh"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_for_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "553-609",
          "snippet": "static int ocfs2_truncate_for_delete(struct ocfs2_super *osb,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *fe;\n\thandle_t *handle = NULL;\n\n\tfe = (struct ocfs2_dinode *) fe_bh->b_data;\n\n\t/*\n\t * This check will also skip truncate of inodes with inline\n\t * data and fast symlinks.\n\t */\n\tif (fe->i_clusters) {\n\t\tif (ocfs2_should_order_data(inode))\n\t\t\tocfs2_begin_ordered_truncate(inode, 0);\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\thandle = NULL;\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t\t fe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\ti_size_write(inode, 0);\n\n\t\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\n\t\tstatus = ocfs2_commit_truncate(osb, inode, fe_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_truncate_for_delete(struct ocfs2_super *osb,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct buffer_head *fe_bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_truncate_for_delete(struct ocfs2_super *osb,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct buffer_head *fe_bh);\n\nstatic int ocfs2_truncate_for_delete(struct ocfs2_super *osb,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *fe;\n\thandle_t *handle = NULL;\n\n\tfe = (struct ocfs2_dinode *) fe_bh->b_data;\n\n\t/*\n\t * This check will also skip truncate of inodes with inline\n\t * data and fast symlinks.\n\t */\n\tif (fe->i_clusters) {\n\t\tif (ocfs2_should_order_data(inode))\n\t\t\tocfs2_begin_ordered_truncate(inode, 0);\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\thandle = NULL;\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t\t fe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\ti_size_write(inode, 0);\n\n\t\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\n\t\tstatus = ocfs2_commit_truncate(osb, inode, fe_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "orphan_dir_inode",
            "&orphan_dir_bh",
            "1"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "ORPHAN_DIR_SYSTEM_INODE",
            "orphaned_slot"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_orphan_recovery_state",
          "args": [
            "osb",
            "orphaned_slot"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_orphan_recovery_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "696-713",
          "snippet": "static int ocfs2_check_orphan_recovery_state(struct ocfs2_super *osb,\n\t\t\t\t\t     int slot)\n{\n\tint ret = 0;\n\n\tspin_lock(&osb->osb_lock);\n\tif (ocfs2_node_map_test_bit(osb, &osb->osb_recovering_orphan_dirs, slot)) {\n\t\tret = -EDEADLK;\n\t\tgoto out;\n\t}\n\t/* This signals to the orphan recovery process that it should\n\t * wait for us to handle the wipe. */\n\tosb->osb_orphan_wipes[slot]++;\nout:\n\tspin_unlock(&osb->osb_lock);\n\ttrace_ocfs2_check_orphan_recovery_state(slot, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_check_orphan_recovery_state(struct ocfs2_super *osb,\n\t\t\t\t\t     int slot)\n{\n\tint ret = 0;\n\n\tspin_lock(&osb->osb_lock);\n\tif (ocfs2_node_map_test_bit(osb, &osb->osb_recovering_orphan_dirs, slot)) {\n\t\tret = -EDEADLK;\n\t\tgoto out;\n\t}\n\t/* This signals to the orphan recovery process that it should\n\t * wait for us to handle the wipe. */\n\tosb->osb_orphan_wipes[slot]++;\nout:\n\tspin_unlock(&osb->osb_lock);\n\ttrace_ocfs2_check_orphan_recovery_state(slot, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_orphaned_slot"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_wipe_inode(struct inode *inode,\n\t\t\t    struct buffer_head *di_bh)\n{\n\tint status, orphaned_slot = -1;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\torphaned_slot = le16_to_cpu(di->i_orphaned_slot);\n\n\t\tstatus = ocfs2_check_orphan_recovery_state(osb, orphaned_slot);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t\t       orphaned_slot);\n\t\tif (!orphan_dir_inode) {\n\t\t\tstatus = -EEXIST;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Lock the orphan dir. The lock will be held for the entire\n\t\t * delete_inode operation. We do this now to avoid races with\n\t\t * recovery completion on other nodes. */\n\t\tmutex_lock(&orphan_dir_inode->i_mutex);\n\t\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\t\tif (status < 0) {\n\t\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* we do this while holding the orphan dir lock because we\n\t * don't want recovery being run from another node to try an\n\t * inode delete underneath us -- this will result in two nodes\n\t * truncating the same file! */\n\tstatus = ocfs2_truncate_for_delete(osb, inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\t/* Remove any dir index tree */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstatus = ocfs2_dx_dir_truncate(inode, di_bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock_dir;\n\t\t}\n\t}\n\n\t/*Free extended attribute resources associated with this inode.*/\n\tstatus = ocfs2_xattr_remove(inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\tstatus = ocfs2_remove_refcount_tree(inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\tstatus = ocfs2_remove_inode(inode, di_bh, orphan_dir_inode,\n\t\t\t\t    orphan_dir_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_unlock_dir:\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)\n\t\treturn status;\n\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tbrelse(orphan_dir_bh);\nbail:\n\tiput(orphan_dir_inode);\n\tocfs2_signal_wipe_completion(osb, orphaned_slot);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_signal_wipe_completion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "715-723",
    "snippet": "static void ocfs2_signal_wipe_completion(struct ocfs2_super *osb,\n\t\t\t\t\t int slot)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_orphan_wipes[slot]--;\n\tspin_unlock(&osb->osb_lock);\n\n\twake_up(&osb->osb_wipe_event);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&osb->osb_wipe_event"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_signal_wipe_completion(struct ocfs2_super *osb,\n\t\t\t\t\t int slot)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_orphan_wipes[slot]--;\n\tspin_unlock(&osb->osb_lock);\n\n\twake_up(&osb->osb_wipe_event);\n}"
  },
  {
    "function_name": "ocfs2_check_orphan_recovery_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "696-713",
    "snippet": "static int ocfs2_check_orphan_recovery_state(struct ocfs2_super *osb,\n\t\t\t\t\t     int slot)\n{\n\tint ret = 0;\n\n\tspin_lock(&osb->osb_lock);\n\tif (ocfs2_node_map_test_bit(osb, &osb->osb_recovering_orphan_dirs, slot)) {\n\t\tret = -EDEADLK;\n\t\tgoto out;\n\t}\n\t/* This signals to the orphan recovery process that it should\n\t * wait for us to handle the wipe. */\n\tosb->osb_orphan_wipes[slot]++;\nout:\n\tspin_unlock(&osb->osb_lock);\n\ttrace_ocfs2_check_orphan_recovery_state(slot, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_check_orphan_recovery_state",
          "args": [
            "slot",
            "ret"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_node_map_test_bit",
          "args": [
            "osb",
            "&osb->osb_recovering_orphan_dirs",
            "slot"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_node_map_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/heartbeat.c",
          "lines": "120-133",
          "snippet": "int ocfs2_node_map_test_bit(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_node_map *map,\n\t\t\t    int bit)\n{\n\tint ret;\n\tif (bit >= map->num_nodes) {\n\t\tmlog(ML_ERROR, \"bit=%d map->num_nodes=%d\\n\", bit, map->num_nodes);\n\t\tBUG();\n\t}\n\tspin_lock(&osb->node_map_lock);\n\tret = test_bit(bit, map->map);\n\tspin_unlock(&osb->node_map_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void __ocfs2_node_map_set_bit(struct ocfs2_node_map *map,\n\t\t\t\t\t    int bit);",
            "static inline void __ocfs2_node_map_clear_bit(struct ocfs2_node_map *map,\n\t\t\t\t\t      int bit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void __ocfs2_node_map_set_bit(struct ocfs2_node_map *map,\n\t\t\t\t\t    int bit);\nstatic inline void __ocfs2_node_map_clear_bit(struct ocfs2_node_map *map,\n\t\t\t\t\t      int bit);\n\nint ocfs2_node_map_test_bit(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_node_map *map,\n\t\t\t    int bit)\n{\n\tint ret;\n\tif (bit >= map->num_nodes) {\n\t\tmlog(ML_ERROR, \"bit=%d map->num_nodes=%d\\n\", bit, map->num_nodes);\n\t\tBUG();\n\t}\n\tspin_lock(&osb->node_map_lock);\n\tret = test_bit(bit, map->map);\n\tspin_unlock(&osb->node_map_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_check_orphan_recovery_state(struct ocfs2_super *osb,\n\t\t\t\t\t     int slot)\n{\n\tint ret = 0;\n\n\tspin_lock(&osb->osb_lock);\n\tif (ocfs2_node_map_test_bit(osb, &osb->osb_recovering_orphan_dirs, slot)) {\n\t\tret = -EDEADLK;\n\t\tgoto out;\n\t}\n\t/* This signals to the orphan recovery process that it should\n\t * wait for us to handle the wipe. */\n\tosb->osb_orphan_wipes[slot]++;\nout:\n\tspin_unlock(&osb->osb_lock);\n\ttrace_ocfs2_check_orphan_recovery_state(slot, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_remove_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "611-688",
    "snippet": "static int ocfs2_remove_inode(struct inode *inode,\n\t\t\t      struct buffer_head *di_bh,\n\t\t\t      struct inode *orphan_dir_inode,\n\t\t\t      struct buffer_head *orphan_dir_bh)\n{\n\tint status;\n\tstruct inode *inode_alloc_inode = NULL;\n\tstruct buffer_head *inode_alloc_bh = NULL;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\n\tinode_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb, INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    le16_to_cpu(di->i_suballoc_slot));\n\tif (!inode_alloc_inode) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode_alloc_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(inode_alloc_inode, &inode_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_DELETE_INODE_CREDITS +\n\t\t\t\t   ocfs2_quota_trans_credits(inode->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock;\n\t}\n\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode, inode,\n\t\t\t\t\t  orphan_dir_bh, false);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_commit;\n\t\t}\n\t}\n\n\t/* set the inodes dtime */\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tdi->i_dtime = cpu_to_le64(CURRENT_TIME.tv_sec);\n\tdi->i_flags &= cpu_to_le32(~(OCFS2_VALID_FL | OCFS2_ORPHANED_FL));\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tocfs2_remove_from_cache(INODE_CACHE(inode), di_bh);\n\tdquot_free_inode(inode);\n\n\tstatus = ocfs2_free_dinode(handle, inode_alloc_inode,\n\t\t\t\t   inode_alloc_bh, di);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\nbail_unlock:\n\tocfs2_inode_unlock(inode_alloc_inode, 1);\n\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\tbrelse(inode_alloc_bh);\nbail:\n\tiput(inode_alloc_inode);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode_alloc_inode"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "inode_alloc_bh"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode_alloc_inode->i_mutex"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode_alloc_inode",
            "1"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_dinode",
          "args": [
            "handle",
            "inode_alloc_inode",
            "inode_alloc_bh",
            "di"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2530-2543",
          "snippet": "int ocfs2_free_dinode(handle_t *handle,\n\t\t      struct inode *inode_alloc_inode,\n\t\t      struct buffer_head *inode_alloc_bh,\n\t\t      struct ocfs2_dinode *di)\n{\n\tu64 blk = le64_to_cpu(di->i_blkno);\n\tu16 bit = le16_to_cpu(di->i_suballoc_bit);\n\tu64 bg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\tif (di->i_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(di->i_suballoc_loc);\n\treturn ocfs2_free_suballoc_bits(handle, inode_alloc_inode,\n\t\t\t\t\tinode_alloc_bh, bit, bg_blkno, 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_dinode(handle_t *handle,\n\t\t      struct inode *inode_alloc_inode,\n\t\t      struct buffer_head *inode_alloc_bh,\n\t\t      struct ocfs2_dinode *di)\n{\n\tu64 blk = le64_to_cpu(di->i_blkno);\n\tu16 bit = le16_to_cpu(di->i_suballoc_bit);\n\tu64 bg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\tif (di->i_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(di->i_suballoc_loc);\n\treturn ocfs2_free_suballoc_bits(handle, inode_alloc_inode,\n\t\t\t\t\tinode_alloc_bh, bit, bg_blkno, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_inode",
          "args": [
            "inode"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1792-1819",
          "snippet": "void dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_from_cache",
          "args": [
            "INODE_CACHE(inode)",
            "di_bh"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "603-609",
          "snippet": "void ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~(OCFS2_VALID_FL | OCFS2_ORPHANED_FL)"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "CURRENT_TIME.tv_sec"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_del",
          "args": [
            "osb",
            "handle",
            "orphan_dir_inode",
            "inode",
            "orphan_dir_bh",
            "false"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2292-2364",
          "snippet": "int ocfs2_orphan_del(struct ocfs2_super *osb,\n\t\t     handle_t *handle,\n\t\t     struct inode *orphan_dir_inode,\n\t\t     struct inode *inode,\n\t\t     struct buffer_head *orphan_dir_bh,\n\t\t     bool dio)\n{\n\tconst int namelen = OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN;\n\tchar name[namelen + 1];\n\tstruct ocfs2_dinode *orphan_fe;\n\tint status = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tif (dio) {\n\t\tstatus = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (status != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno, name);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\ttrace_ocfs2_orphan_del(\n\t     (unsigned long long)OCFS2_I(orphan_dir_inode)->ip_blkno,\n\t     name, namelen);\n\n\t/* find it's spot in the orphan directory */\n\tstatus = ocfs2_find_entry(name, namelen, orphan_dir_inode,\n\t\t\t\t  &lookup);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* remove it from the orphan directory */\n\tstatus = ocfs2_delete_entry(handle, orphan_dir_inode, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* do the i_nlink dance! :) */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, -1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\nleave:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4",
            "#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"",
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
          ],
          "globals_used": [
            "static int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);",
            "static int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DIO_ORPHAN_PREFIX_LEN 4\n#define OCFS2_DIO_ORPHAN_PREFIX \"dio-\"\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nint ocfs2_orphan_del(struct ocfs2_super *osb,\n\t\t     handle_t *handle,\n\t\t     struct inode *orphan_dir_inode,\n\t\t     struct inode *inode,\n\t\t     struct buffer_head *orphan_dir_bh,\n\t\t     bool dio)\n{\n\tconst int namelen = OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN;\n\tchar name[namelen + 1];\n\tstruct ocfs2_dinode *orphan_fe;\n\tint status = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tif (dio) {\n\t\tstatus = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (status != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno, name);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\ttrace_ocfs2_orphan_del(\n\t     (unsigned long long)OCFS2_I(orphan_dir_inode)->ip_blkno,\n\t     name, namelen);\n\n\t/* find it's spot in the orphan directory */\n\tstatus = ocfs2_find_entry(name, namelen, orphan_dir_inode,\n\t\t\t\t  &lookup);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* remove it from the orphan directory */\n\tstatus = ocfs2_delete_entry(handle, orphan_dir_inode, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* do the i_nlink dance! :) */\n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, -1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\nleave:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_DELETE_INODE_CREDITS +\n\t\t\t\t   ocfs2_quota_trans_credits(inode->i_sb)"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_quota_trans_credits",
          "args": [
            "inode->i_sb"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_quota_trans_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "378-387",
          "snippet": "static inline int ocfs2_quota_trans_credits(struct super_block *sb)\n{\n\tint credits = 0;\n\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\treturn credits;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_QWRITE_CREDITS (OCFS2_QINFO_WRITE_CREDITS + \\\n\t\t\t      OCFS2_QUOTA_BLOCK_UPDATE_CREDITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_QWRITE_CREDITS (OCFS2_QINFO_WRITE_CREDITS + \\\n\t\t\t      OCFS2_QUOTA_BLOCK_UPDATE_CREDITS)\n\nstatic inline int ocfs2_quota_trans_credits(struct super_block *sb)\n{\n\tint credits = 0;\n\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\treturn credits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode_alloc_inode->i_mutex"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode_alloc_inode",
            "&inode_alloc_bh",
            "1"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode_alloc_inode->i_mutex"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "INODE_ALLOC_SYSTEM_INODE",
            "le16_to_cpu(di->i_suballoc_slot)"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_suballoc_slot"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_remove_inode(struct inode *inode,\n\t\t\t      struct buffer_head *di_bh,\n\t\t\t      struct inode *orphan_dir_inode,\n\t\t\t      struct buffer_head *orphan_dir_bh)\n{\n\tint status;\n\tstruct inode *inode_alloc_inode = NULL;\n\tstruct buffer_head *inode_alloc_bh = NULL;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\n\tinode_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb, INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    le16_to_cpu(di->i_suballoc_slot));\n\tif (!inode_alloc_inode) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode_alloc_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(inode_alloc_inode, &inode_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_DELETE_INODE_CREDITS +\n\t\t\t\t   ocfs2_quota_trans_credits(inode->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock;\n\t}\n\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode, inode,\n\t\t\t\t\t  orphan_dir_bh, false);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_commit;\n\t\t}\n\t}\n\n\t/* set the inodes dtime */\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tdi->i_dtime = cpu_to_le64(CURRENT_TIME.tv_sec);\n\tdi->i_flags &= cpu_to_le32(~(OCFS2_VALID_FL | OCFS2_ORPHANED_FL));\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tocfs2_remove_from_cache(INODE_CACHE(inode), di_bh);\n\tdquot_free_inode(inode);\n\n\tstatus = ocfs2_free_dinode(handle, inode_alloc_inode,\n\t\t\t\t   inode_alloc_bh, di);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\nbail_unlock:\n\tocfs2_inode_unlock(inode_alloc_inode, 1);\n\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\tbrelse(inode_alloc_bh);\nbail:\n\tiput(inode_alloc_inode);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_truncate_for_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "553-609",
    "snippet": "static int ocfs2_truncate_for_delete(struct ocfs2_super *osb,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *fe;\n\thandle_t *handle = NULL;\n\n\tfe = (struct ocfs2_dinode *) fe_bh->b_data;\n\n\t/*\n\t * This check will also skip truncate of inodes with inline\n\t * data and fast symlinks.\n\t */\n\tif (fe->i_clusters) {\n\t\tif (ocfs2_should_order_data(inode))\n\t\t\tocfs2_begin_ordered_truncate(inode, 0);\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\thandle = NULL;\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t\t fe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\ti_size_write(inode, 0);\n\n\t\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\n\t\tstatus = ocfs2_commit_truncate(osb, inode, fe_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_truncate_for_delete(struct ocfs2_super *osb,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct buffer_head *fe_bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_truncate",
          "args": [
            "osb",
            "inode",
            "fe_bh"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "7011-7172",
          "snippet": "int ocfs2_commit_truncate(struct ocfs2_super *osb,\n\t\t\t  struct inode *inode,\n\t\t\t  struct buffer_head *di_bh)\n{\n\tint status = 0, i, flags = 0;\n\tu32 new_highest_cpos, range, trunc_cpos, trunc_len, phys_cpos, coff;\n\tu64 blkno = 0;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_extent_list *root_el = &(di->id2.i_list);\n\tu64 refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tnew_highest_cpos = ocfs2_clusters_for_bytes(osb->sb,\n\t\t\t\t\t\t     i_size_read(inode));\n\n\tpath = ocfs2_new_path(di_bh, &di->id2.i_list,\n\t\t\t      ocfs2_journal_access_di);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_extent_map_trunc(inode, new_highest_cpos);\n\nstart:\n\t/*\n\t * Check that we still have allocation to delete.\n\t */\n\tif (OCFS2_I(inode)->ip_clusters == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Truncate always works against the rightmost tree branch.\n\t */\n\tstatus = ocfs2_find_path(INODE_CACHE(inode), path, UINT_MAX);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_commit_truncate(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tnew_highest_cpos,\n\t\tOCFS2_I(inode)->ip_clusters,\n\t\tpath->p_tree_depth);\n\n\t/*\n\t * By now, el will point to the extent list on the bottom most\n\t * portion of this tree. Only the tail record is considered in\n\t * each pass.\n\t *\n\t * We handle the following cases, in order:\n\t * - empty extent: delete the remaining branch\n\t * - remove the entire record\n\t * - remove a partial record\n\t * - no record needs to be removed (truncate has completed)\n\t */\n\tel = path_leaf_el(path);\n\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has empty extent block at %llu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)path_leaf_bh(path)->b_blocknr);\n\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\tflags = rec->e_flags;\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (i == 0 && ocfs2_is_empty_extent(rec)) {\n\t\t/*\n\t\t * Lower levels depend on this never happening, but it's best\n\t\t * to check it up here before changing the tree.\n\t\t*/\n\t\tif (root_el->l_tree_depth && rec->e_int_clusters == 0) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has an empty \"\n\t\t\t\t    \"extent record, depth %u\\n\", inode->i_ino,\n\t\t\t\t    le16_to_cpu(root_el->l_tree_depth));\n\t\t\tstatus = -EROFS;\n\t\t\tgoto bail;\n\t\t}\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = 0;\n\t\tblkno = 0;\n\t} else if (le32_to_cpu(rec->e_cpos) >= new_highest_cpos) {\n\t\t/*\n\t\t * Truncate entire record.\n\t\t */\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = ocfs2_rec_clusters(el, rec);\n\t\tblkno = le64_to_cpu(rec->e_blkno);\n\t} else if (range > new_highest_cpos) {\n\t\t/*\n\t\t * Partial truncate. it also should be\n\t\t * the last truncate we're doing.\n\t\t */\n\t\ttrunc_cpos = new_highest_cpos;\n\t\ttrunc_len = range - new_highest_cpos;\n\t\tcoff = new_highest_cpos - le32_to_cpu(rec->e_cpos);\n\t\tblkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t} else {\n\t\t/*\n\t\t * Truncate completed, leave happily.\n\t\t */\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && trunc_len && !ref_tree) {\n\t\tstatus = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t&ref_tree, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t  phys_cpos, trunc_len, flags, &dealloc,\n\t\t\t\t\t  refcount_loc, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_reinit_path(path, 1);\n\n\t/*\n\t * The check above will catch the case where we've truncated\n\t * away all allocation.\n\t */\n\tgoto start;\n\nbail:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tocfs2_free_path(path);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_commit_truncate(struct ocfs2_super *osb,\n\t\t\t  struct inode *inode,\n\t\t\t  struct buffer_head *di_bh)\n{\n\tint status = 0, i, flags = 0;\n\tu32 new_highest_cpos, range, trunc_cpos, trunc_len, phys_cpos, coff;\n\tu64 blkno = 0;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_extent_list *root_el = &(di->id2.i_list);\n\tu64 refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tnew_highest_cpos = ocfs2_clusters_for_bytes(osb->sb,\n\t\t\t\t\t\t     i_size_read(inode));\n\n\tpath = ocfs2_new_path(di_bh, &di->id2.i_list,\n\t\t\t      ocfs2_journal_access_di);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_extent_map_trunc(inode, new_highest_cpos);\n\nstart:\n\t/*\n\t * Check that we still have allocation to delete.\n\t */\n\tif (OCFS2_I(inode)->ip_clusters == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Truncate always works against the rightmost tree branch.\n\t */\n\tstatus = ocfs2_find_path(INODE_CACHE(inode), path, UINT_MAX);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_commit_truncate(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tnew_highest_cpos,\n\t\tOCFS2_I(inode)->ip_clusters,\n\t\tpath->p_tree_depth);\n\n\t/*\n\t * By now, el will point to the extent list on the bottom most\n\t * portion of this tree. Only the tail record is considered in\n\t * each pass.\n\t *\n\t * We handle the following cases, in order:\n\t * - empty extent: delete the remaining branch\n\t * - remove the entire record\n\t * - remove a partial record\n\t * - no record needs to be removed (truncate has completed)\n\t */\n\tel = path_leaf_el(path);\n\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has empty extent block at %llu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)path_leaf_bh(path)->b_blocknr);\n\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\tflags = rec->e_flags;\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (i == 0 && ocfs2_is_empty_extent(rec)) {\n\t\t/*\n\t\t * Lower levels depend on this never happening, but it's best\n\t\t * to check it up here before changing the tree.\n\t\t*/\n\t\tif (root_el->l_tree_depth && rec->e_int_clusters == 0) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has an empty \"\n\t\t\t\t    \"extent record, depth %u\\n\", inode->i_ino,\n\t\t\t\t    le16_to_cpu(root_el->l_tree_depth));\n\t\t\tstatus = -EROFS;\n\t\t\tgoto bail;\n\t\t}\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = 0;\n\t\tblkno = 0;\n\t} else if (le32_to_cpu(rec->e_cpos) >= new_highest_cpos) {\n\t\t/*\n\t\t * Truncate entire record.\n\t\t */\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = ocfs2_rec_clusters(el, rec);\n\t\tblkno = le64_to_cpu(rec->e_blkno);\n\t} else if (range > new_highest_cpos) {\n\t\t/*\n\t\t * Partial truncate. it also should be\n\t\t * the last truncate we're doing.\n\t\t */\n\t\ttrunc_cpos = new_highest_cpos;\n\t\ttrunc_len = range - new_highest_cpos;\n\t\tcoff = new_highest_cpos - le32_to_cpu(rec->e_cpos);\n\t\tblkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t} else {\n\t\t/*\n\t\t * Truncate completed, leave happily.\n\t\t */\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && trunc_len && !ref_tree) {\n\t\tstatus = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t&ref_tree, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t  phys_cpos, trunc_len, flags, &dealloc,\n\t\t\t\t\t  refcount_loc, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_reinit_path(path, 1);\n\n\t/*\n\t * The check above will catch the case where we've truncated\n\t * away all allocation.\n\t */\n\tgoto start;\n\nbail:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tocfs2_free_path(path);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "inode",
            "fe_bh"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1250-1289",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "fe_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_begin_ordered_truncate",
          "args": [
            "inode",
            "0"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_begin_ordered_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "625-632",
          "snippet": "static inline int ocfs2_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t       loff_t new_size)\n{\n\treturn jbd2_journal_begin_ordered_truncate(\n\t\t\t\tOCFS2_SB(inode->i_sb)->journal->j_journal,\n\t\t\t\t&OCFS2_I(inode)->ip_jinode,\n\t\t\t\tnew_size);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t       loff_t new_size)\n{\n\treturn jbd2_journal_begin_ordered_truncate(\n\t\t\t\tOCFS2_SB(inode->i_sb)->journal->j_journal,\n\t\t\t\t&OCFS2_I(inode)->ip_jinode,\n\t\t\t\tnew_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_should_order_data",
          "args": [
            "inode"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_should_order_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "474-481",
          "snippet": "static inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_truncate_for_delete(struct ocfs2_super *osb,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct buffer_head *fe_bh);\n\nstatic int ocfs2_truncate_for_delete(struct ocfs2_super *osb,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *fe;\n\thandle_t *handle = NULL;\n\n\tfe = (struct ocfs2_dinode *) fe_bh->b_data;\n\n\t/*\n\t * This check will also skip truncate of inodes with inline\n\t * data and fast symlinks.\n\t */\n\tif (fe->i_clusters) {\n\t\tif (ocfs2_should_order_data(inode))\n\t\t\tocfs2_begin_ordered_truncate(inode, 0);\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\thandle = NULL;\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t\t fe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\ti_size_write(inode, 0);\n\n\t\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\n\t\tstatus = ocfs2_commit_truncate(osb, inode, fe_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_sync_blockdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "548-551",
    "snippet": "void ocfs2_sync_blockdev(struct super_block *sb)\n{\n\tsync_blockdev(sb->s_bdev);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "sb->s_bdev"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "548-551",
          "snippet": "void ocfs2_sync_blockdev(struct super_block *sb)\n{\n\tsync_blockdev(sb->s_bdev);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_sync_blockdev(struct super_block *sb)\n{\n\tsync_blockdev(sb->s_bdev);\n}"
  },
  {
    "function_name": "ocfs2_read_locked_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "405-546",
    "snippet": "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args)\n{\n\tstruct super_block *sb;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *fe;\n\tstruct buffer_head *bh = NULL;\n\tint status, can_lock;\n\tu32 generation = 0;\n\n\tstatus = -EINVAL;\n\tsb = inode->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\t/*\n\t * To improve performance of cold-cache inode stats, we take\n\t * the cluster lock here if possible.\n\t *\n\t * Generally, OCFS2 never trusts the contents of an inode\n\t * unless it's holding a cluster lock, so taking it here isn't\n\t * a correctness issue as much as it is a performance\n\t * improvement.\n\t *\n\t * There are three times when taking the lock is not a good idea:\n\t *\n\t * 1) During startup, before we have initialized the DLM.\n\t *\n\t * 2) If we are reading certain system files which never get\n\t *    cluster locks (local alloc, truncate log).\n\t *\n\t * 3) If the process doing the iget() is responsible for\n\t *    orphan dir recovery. We're holding the orphan dir lock and\n\t *    can get into a deadlock with another process on another\n\t *    node in ->delete_inode().\n\t *\n\t * #1 and #2 can be simply solved by never taking the lock\n\t * here for system files (which are the only type we read\n\t * during mount). It's a heavier approach, but our main\n\t * concern is user-accessible files anyway.\n\t *\n\t * #3 works itself out because we'll eventually take the\n\t * cluster lock before trusting anything anyway.\n\t */\n\tcan_lock = !(args->fi_flags & OCFS2_FI_FLAG_SYSFILE)\n\t\t&& !(args->fi_flags & OCFS2_FI_FLAG_ORPHAN_RECOVERY)\n\t\t&& !ocfs2_mount_local(osb);\n\n\ttrace_ocfs2_read_locked_inode(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno, can_lock);\n\n\t/*\n\t * To maintain backwards compatibility with older versions of\n\t * ocfs2-tools, we still store the generation value for system\n\t * files. The only ones that actually matter to userspace are\n\t * the journals, but it's easier and inexpensive to just flag\n\t * all system files similarly.\n\t */\n\tif (args->fi_flags & OCFS2_FI_FLAG_SYSFILE)\n\t\tgeneration = osb->fs_generation;\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_inode_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_META,\n\t\t\t\t  generation, inode);\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_open_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_OPEN,\n\t\t\t\t  0, inode);\n\n\tif (can_lock) {\n\t\tstatus = ocfs2_open_lock(inode);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\t\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (args->fi_flags & OCFS2_FI_FLAG_ORPHAN_RECOVERY) {\n\t\tstatus = ocfs2_try_open_lock(inode, 0);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (can_lock) {\n\t\tstatus = ocfs2_read_inode_block_full(inode, &bh,\n\t\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, args->fi_blkno, 1, &bh);\n\t\t/*\n\t\t * If buffer is in jbd, then its checksum may not have been\n\t\t * computed as yet.\n\t\t */\n\t\tif (!status && !buffer_jbd(bh))\n\t\t\tstatus = ocfs2_validate_inode_block(osb->sb, bh);\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = -EINVAL;\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/*\n\t * This is a code bug. Right now the caller needs to\n\t * understand whether it is asking for a system file inode or\n\t * not so the proper lock names can be built.\n\t */\n\tmlog_bug_on_msg(!!(fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) !=\n\t\t\t!!(args->fi_flags & OCFS2_FI_FLAG_SYSFILE),\n\t\t\t\"Inode %llu: system file state is ambigous\\n\",\n\t\t\t(unsigned long long)args->fi_blkno);\n\n\tif (S_ISCHR(le16_to_cpu(fe->i_mode)) ||\n\t    S_ISBLK(le16_to_cpu(fe->i_mode)))\n\t\tinode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));\n\n\tocfs2_populate_inode(inode, fe, 0);\n\n\tBUG_ON(args->fi_blkno != le64_to_cpu(fe->i_blkno));\n\n\tstatus = 0;\n\nbail:\n\tif (can_lock)\n\t\tocfs2_inode_unlock(inode, 0);\n\n\tif (status < 0)\n\t\tmake_bad_inode(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "0"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "args->fi_blkno != le64_to_cpu(fe->i_blkno)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_blkno"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_populate_inode",
          "args": [
            "inode",
            "fe",
            "0"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_populate_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "265-403",
          "snippet": "void ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,\n\t\t\t  int create_ino)\n{\n\tstruct super_block *sb;\n\tstruct ocfs2_super *osb;\n\tint use_plocks = 1;\n\n\tsb = inode->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_LOCALFLOCKS) ||\n\t    ocfs2_mount_local(osb) || !ocfs2_stack_supports_plocks())\n\t\tuse_plocks = 0;\n\n\t/*\n\t * These have all been checked by ocfs2_read_inode_block() or set\n\t * by ocfs2_mknod_locked(), so a failure is a code bug.\n\t */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));  /* This means that read_inode\n\t\t\t\t\t\tcannot create a superblock\n\t\t\t\t\t\tinode today.  change if\n\t\t\t\t\t\tthat is needed. */\n\tBUG_ON(!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)));\n\tBUG_ON(le32_to_cpu(fe->i_fs_generation) != osb->fs_generation);\n\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tOCFS2_I(inode)->ip_attr = le32_to_cpu(fe->i_attr);\n\tOCFS2_I(inode)->ip_dyn_features = le16_to_cpu(fe->i_dyn_features);\n\n\tinode->i_version = 1;\n\tinode->i_generation = le32_to_cpu(fe->i_generation);\n\tinode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));\n\tinode->i_mode = le16_to_cpu(fe->i_mode);\n\ti_uid_write(inode, le32_to_cpu(fe->i_uid));\n\ti_gid_write(inode, le32_to_cpu(fe->i_gid));\n\n\t/* Fast symlinks will have i_size but no allocated clusters. */\n\tif (S_ISLNK(inode->i_mode) && !fe->i_clusters) {\n\t\tinode->i_blocks = 0;\n\t\tinode->i_mapping->a_ops = &ocfs2_fast_symlink_aops;\n\t} else {\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t\tinode->i_mapping->a_ops = &ocfs2_aops;\n\t}\n\tinode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);\n\tinode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);\n\tinode->i_ctime.tv_sec = le64_to_cpu(fe->i_ctime);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(fe->i_ctime_nsec);\n\n\tif (OCFS2_I(inode)->ip_blkno != le64_to_cpu(fe->i_blkno))\n\t\tmlog(ML_ERROR,\n\t\t     \"ip_blkno %llu != i_blkno %llu!\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t     (unsigned long long)le64_to_cpu(fe->i_blkno));\n\n\tset_nlink(inode, ocfs2_read_links_count(fe));\n\n\ttrace_ocfs2_populate_inode(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   le32_to_cpu(fe->i_flags));\n\tif (fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SYSTEM_FILE;\n\t\tinode->i_flags |= S_NOQUOTA;\n\t}\n  \n\tif (fe->i_flags & cpu_to_le32(OCFS2_LOCAL_ALLOC_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_BITMAP_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_QUOTA_FL)) {\n\t\tinode->i_flags |= S_NOQUOTA;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_SUPER_BLOCK_FL)) {\n\t\t/* we can't actually hit this as read_inode can't\n\t\t * handle superblocks today ;-) */\n\t\tBUG();\n\t}\n\n\tswitch (inode->i_mode & S_IFMT) {\n\t    case S_IFREG:\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_fops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_fops_no_plocks;\n\t\t    inode->i_op = &ocfs2_file_iops;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    case S_IFDIR:\n\t\t    inode->i_op = &ocfs2_dir_iops;\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_dops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_dops_no_plocks;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    OCFS2_I(inode)->ip_dir_lock_gen = 1;\n\t\t    break;\n\t    case S_IFLNK:\n\t\t    inode->i_op = &ocfs2_symlink_inode_operations;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    default:\n\t\t    inode->i_op = &ocfs2_special_file_iops;\n\t\t    init_special_inode(inode, inode->i_mode,\n\t\t\t\t       inode->i_rdev);\n\t\t    break;\n\t}\n\n\tif (create_ino) {\n\t\tinode->i_ino = ino_from_blkno(inode->i_sb,\n\t\t\t       le64_to_cpu(fe->i_blkno));\n\n\t\t/*\n\t\t * If we ever want to create system files from kernel,\n\t\t * the generation argument to\n\t\t * ocfs2_inode_lock_res_init() will have to change.\n\t\t */\n\t\tBUG_ON(le32_to_cpu(fe->i_flags) & OCFS2_SYSTEM_FL);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_inode_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_META, 0, inode);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_open_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_OPEN, 0, inode);\n\t}\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_rw_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_RW, inode->i_generation,\n\t\t\t\t  inode);\n\n\tocfs2_set_inode_flags(inode);\n\n\tOCFS2_I(inode)->ip_last_used_slot = 0;\n\tOCFS2_I(inode)->ip_last_used_group = 0;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_resv_set_type(&OCFS2_I(inode)->ip_la_data_resv,\n\t\t\t\t    OCFS2_RESV_FLAG_DIR);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,\n\t\t\t  int create_ino)\n{\n\tstruct super_block *sb;\n\tstruct ocfs2_super *osb;\n\tint use_plocks = 1;\n\n\tsb = inode->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_LOCALFLOCKS) ||\n\t    ocfs2_mount_local(osb) || !ocfs2_stack_supports_plocks())\n\t\tuse_plocks = 0;\n\n\t/*\n\t * These have all been checked by ocfs2_read_inode_block() or set\n\t * by ocfs2_mknod_locked(), so a failure is a code bug.\n\t */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));  /* This means that read_inode\n\t\t\t\t\t\tcannot create a superblock\n\t\t\t\t\t\tinode today.  change if\n\t\t\t\t\t\tthat is needed. */\n\tBUG_ON(!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)));\n\tBUG_ON(le32_to_cpu(fe->i_fs_generation) != osb->fs_generation);\n\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tOCFS2_I(inode)->ip_attr = le32_to_cpu(fe->i_attr);\n\tOCFS2_I(inode)->ip_dyn_features = le16_to_cpu(fe->i_dyn_features);\n\n\tinode->i_version = 1;\n\tinode->i_generation = le32_to_cpu(fe->i_generation);\n\tinode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));\n\tinode->i_mode = le16_to_cpu(fe->i_mode);\n\ti_uid_write(inode, le32_to_cpu(fe->i_uid));\n\ti_gid_write(inode, le32_to_cpu(fe->i_gid));\n\n\t/* Fast symlinks will have i_size but no allocated clusters. */\n\tif (S_ISLNK(inode->i_mode) && !fe->i_clusters) {\n\t\tinode->i_blocks = 0;\n\t\tinode->i_mapping->a_ops = &ocfs2_fast_symlink_aops;\n\t} else {\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t\tinode->i_mapping->a_ops = &ocfs2_aops;\n\t}\n\tinode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);\n\tinode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);\n\tinode->i_ctime.tv_sec = le64_to_cpu(fe->i_ctime);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(fe->i_ctime_nsec);\n\n\tif (OCFS2_I(inode)->ip_blkno != le64_to_cpu(fe->i_blkno))\n\t\tmlog(ML_ERROR,\n\t\t     \"ip_blkno %llu != i_blkno %llu!\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t     (unsigned long long)le64_to_cpu(fe->i_blkno));\n\n\tset_nlink(inode, ocfs2_read_links_count(fe));\n\n\ttrace_ocfs2_populate_inode(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   le32_to_cpu(fe->i_flags));\n\tif (fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SYSTEM_FILE;\n\t\tinode->i_flags |= S_NOQUOTA;\n\t}\n  \n\tif (fe->i_flags & cpu_to_le32(OCFS2_LOCAL_ALLOC_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_BITMAP_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_QUOTA_FL)) {\n\t\tinode->i_flags |= S_NOQUOTA;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_SUPER_BLOCK_FL)) {\n\t\t/* we can't actually hit this as read_inode can't\n\t\t * handle superblocks today ;-) */\n\t\tBUG();\n\t}\n\n\tswitch (inode->i_mode & S_IFMT) {\n\t    case S_IFREG:\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_fops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_fops_no_plocks;\n\t\t    inode->i_op = &ocfs2_file_iops;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    case S_IFDIR:\n\t\t    inode->i_op = &ocfs2_dir_iops;\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_dops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_dops_no_plocks;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    OCFS2_I(inode)->ip_dir_lock_gen = 1;\n\t\t    break;\n\t    case S_IFLNK:\n\t\t    inode->i_op = &ocfs2_symlink_inode_operations;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    default:\n\t\t    inode->i_op = &ocfs2_special_file_iops;\n\t\t    init_special_inode(inode, inode->i_mode,\n\t\t\t\t       inode->i_rdev);\n\t\t    break;\n\t}\n\n\tif (create_ino) {\n\t\tinode->i_ino = ino_from_blkno(inode->i_sb,\n\t\t\t       le64_to_cpu(fe->i_blkno));\n\n\t\t/*\n\t\t * If we ever want to create system files from kernel,\n\t\t * the generation argument to\n\t\t * ocfs2_inode_lock_res_init() will have to change.\n\t\t */\n\t\tBUG_ON(le32_to_cpu(fe->i_flags) & OCFS2_SYSTEM_FL);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_inode_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_META, 0, inode);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_open_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_OPEN, 0, inode);\n\t}\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_rw_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_RW, inode->i_generation,\n\t\t\t\t  inode);\n\n\tocfs2_set_inode_flags(inode);\n\n\tOCFS2_I(inode)->ip_last_used_slot = 0;\n\tOCFS2_I(inode)->ip_last_used_group = 0;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_resv_set_type(&OCFS2_I(inode)->ip_la_data_resv,\n\t\t\t\t    OCFS2_RESV_FLAG_DIR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_decode_dev",
          "args": [
            "le64_to_cpu(fe->id1.dev1.i_rdev)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "le16_to_cpu(fe->i_mode)"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fe->i_mode"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "le16_to_cpu(fe->i_mode)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!!(fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) !=\n\t\t\t!!(args->fi_flags & OCFS2_FI_FLAG_SYSFILE)",
            "\"Inode %llu: system file state is ambigous\\n\"",
            "(unsigned long long)args->fi_blkno"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_SYSTEM_FL"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_inode_block",
          "args": [
            "osb->sb",
            "bh"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1324-1386",
          "snippet": "int ocfs2_validate_inode_block(struct super_block *sb,\n\t\t\t       struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\ttrace_ocfs2_validate_inode_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &di->i_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for dinode %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Errors after here are fatal.\n\t */\n\n\trc = -EINVAL;\n\n\tif (!OCFS2_IS_VALID_DINODE(di)) {\n\t\tocfs2_error(sb, \"Invalid dinode #%llu: signature = %.*s\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    di->i_signature);\n\t\tgoto bail;\n\t}\n\n\tif (le64_to_cpu(di->i_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb, \"Invalid dinode #%llu: i_blkno is %llu\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(di->i_blkno));\n\t\tgoto bail;\n\t}\n\n\tif (!(di->i_flags & cpu_to_le32(OCFS2_VALID_FL))) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid dinode #%llu: OCFS2_VALID_FL not set\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr);\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(di->i_fs_generation) !=\n\t    OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid dinode #%llu: fs_generation is %u\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(di->i_fs_generation));\n\t\tgoto bail;\n\t}\n\n\trc = 0;\n\nbail:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_validate_inode_block(struct super_block *sb,\n\t\t\t       struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\ttrace_ocfs2_validate_inode_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &di->i_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for dinode %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Errors after here are fatal.\n\t */\n\n\trc = -EINVAL;\n\n\tif (!OCFS2_IS_VALID_DINODE(di)) {\n\t\tocfs2_error(sb, \"Invalid dinode #%llu: signature = %.*s\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    di->i_signature);\n\t\tgoto bail;\n\t}\n\n\tif (le64_to_cpu(di->i_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb, \"Invalid dinode #%llu: i_blkno is %llu\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(di->i_blkno));\n\t\tgoto bail;\n\t}\n\n\tif (!(di->i_flags & cpu_to_le32(OCFS2_VALID_FL))) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid dinode #%llu: OCFS2_VALID_FL not set\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr);\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(di->i_fs_generation) !=\n\t    OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid dinode #%llu: fs_generation is %u\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(di->i_fs_generation));\n\t\tgoto bail;\n\t}\n\n\trc = 0;\n\nbail:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks_sync",
          "args": [
            "osb",
            "args->fi_blkno",
            "1",
            "&bh"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block_full",
          "args": [
            "inode",
            "&bh",
            "OCFS2_BH_IGNORE_CACHE"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1388-1402",
          "snippet": "int ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t/* If ocfs2_read_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t/* If ocfs2_read_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_try_open_lock",
          "args": [
            "inode",
            "0"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_try_open_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1734-1770",
          "snippet": "int ocfs2_try_open_lock(struct inode *inode, int write)\n{\n\tint status = 0, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu try to take %s open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (write)\n\t\t\tstatus = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\t/*\n\t * The file system may already holding a PRMODE/EXMODE open lock.\n\t * Since we pass DLM_LKF_NOQUEUE, the request won't block waiting on\n\t * other nodes and the -EAGAIN will indicate to the caller that\n\t * this inode is still in use.\n\t */\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t    level, DLM_LKF_NOQUEUE, 0);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_try_open_lock(struct inode *inode, int write)\n{\n\tint status = 0, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu try to take %s open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (write)\n\t\t\tstatus = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\t/*\n\t * The file system may already holding a PRMODE/EXMODE open lock.\n\t * Since we pass DLM_LKF_NOQUEUE, the request won't block waiting on\n\t * other nodes and the -EAGAIN will indicate to the caller that\n\t * this inode is still in use.\n\t */\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t    level, DLM_LKF_NOQUEUE, 0);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "NULL",
            "0"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_open_lock",
          "args": [
            "inode"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_open_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1709-1732",
          "snippet": "int ocfs2_open_lock(struct inode *inode)\n{\n\tint status = 0;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take PRMODE open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t    DLM_LOCK_PR, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_open_lock(struct inode *inode)\n{\n\tint status = 0;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take PRMODE open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t    DLM_LOCK_PR, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_res_init",
          "args": [
            "&OCFS2_I(inode)->ip_open_lockres",
            "OCFS2_LOCK_TYPE_OPEN",
            "0",
            "inode"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_res_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "536-562",
          "snippet": "void ocfs2_inode_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t       enum ocfs2_lock_type type,\n\t\t\t       unsigned int generation,\n\t\t\t       struct inode *inode)\n{\n\tstruct ocfs2_lock_res_ops *ops;\n\n\tswitch(type) {\n\t\tcase OCFS2_LOCK_TYPE_RW:\n\t\t\tops = &ocfs2_inode_rw_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_META:\n\t\t\tops = &ocfs2_inode_inode_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_OPEN:\n\t\t\tops = &ocfs2_inode_open_lops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog_bug_on_msg(1, \"type: %d\\n\", type);\n\t\t\tops = NULL; /* thanks, gcc */\n\t\t\tbreak;\n\t};\n\n\tocfs2_build_lock_name(type, OCFS2_I(inode)->ip_blkno,\n\t\t\t      generation, res->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), res, type, ops, inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_lock_res_ops ocfs2_inode_rw_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};",
            "static struct ocfs2_lock_res_ops ocfs2_inode_inode_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.check_downconvert = ocfs2_check_meta_downconvert,\n\t.set_lvb\t= ocfs2_set_meta_lvb,\n\t.downconvert_worker = ocfs2_data_convert_worker,\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};",
            "static struct ocfs2_lock_res_ops ocfs2_inode_open_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};",
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_lock_res_ops ocfs2_inode_rw_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};\nstatic struct ocfs2_lock_res_ops ocfs2_inode_inode_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.check_downconvert = ocfs2_check_meta_downconvert,\n\t.set_lvb\t= ocfs2_set_meta_lvb,\n\t.downconvert_worker = ocfs2_data_convert_worker,\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};\nstatic struct ocfs2_lock_res_ops ocfs2_inode_open_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nvoid ocfs2_inode_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t       enum ocfs2_lock_type type,\n\t\t\t       unsigned int generation,\n\t\t\t       struct inode *inode)\n{\n\tstruct ocfs2_lock_res_ops *ops;\n\n\tswitch(type) {\n\t\tcase OCFS2_LOCK_TYPE_RW:\n\t\t\tops = &ocfs2_inode_rw_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_META:\n\t\t\tops = &ocfs2_inode_inode_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_OPEN:\n\t\t\tops = &ocfs2_inode_open_lops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog_bug_on_msg(1, \"type: %d\\n\", type);\n\t\t\tops = NULL; /* thanks, gcc */\n\t\t\tbreak;\n\t};\n\n\tocfs2_build_lock_name(type, OCFS2_I(inode)->ip_blkno,\n\t\t\t      generation, res->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), res, type, ops, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_read_locked_inode",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "can_lock"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args)\n{\n\tstruct super_block *sb;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *fe;\n\tstruct buffer_head *bh = NULL;\n\tint status, can_lock;\n\tu32 generation = 0;\n\n\tstatus = -EINVAL;\n\tsb = inode->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\t/*\n\t * To improve performance of cold-cache inode stats, we take\n\t * the cluster lock here if possible.\n\t *\n\t * Generally, OCFS2 never trusts the contents of an inode\n\t * unless it's holding a cluster lock, so taking it here isn't\n\t * a correctness issue as much as it is a performance\n\t * improvement.\n\t *\n\t * There are three times when taking the lock is not a good idea:\n\t *\n\t * 1) During startup, before we have initialized the DLM.\n\t *\n\t * 2) If we are reading certain system files which never get\n\t *    cluster locks (local alloc, truncate log).\n\t *\n\t * 3) If the process doing the iget() is responsible for\n\t *    orphan dir recovery. We're holding the orphan dir lock and\n\t *    can get into a deadlock with another process on another\n\t *    node in ->delete_inode().\n\t *\n\t * #1 and #2 can be simply solved by never taking the lock\n\t * here for system files (which are the only type we read\n\t * during mount). It's a heavier approach, but our main\n\t * concern is user-accessible files anyway.\n\t *\n\t * #3 works itself out because we'll eventually take the\n\t * cluster lock before trusting anything anyway.\n\t */\n\tcan_lock = !(args->fi_flags & OCFS2_FI_FLAG_SYSFILE)\n\t\t&& !(args->fi_flags & OCFS2_FI_FLAG_ORPHAN_RECOVERY)\n\t\t&& !ocfs2_mount_local(osb);\n\n\ttrace_ocfs2_read_locked_inode(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno, can_lock);\n\n\t/*\n\t * To maintain backwards compatibility with older versions of\n\t * ocfs2-tools, we still store the generation value for system\n\t * files. The only ones that actually matter to userspace are\n\t * the journals, but it's easier and inexpensive to just flag\n\t * all system files similarly.\n\t */\n\tif (args->fi_flags & OCFS2_FI_FLAG_SYSFILE)\n\t\tgeneration = osb->fs_generation;\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_inode_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_META,\n\t\t\t\t  generation, inode);\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_open_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_OPEN,\n\t\t\t\t  0, inode);\n\n\tif (can_lock) {\n\t\tstatus = ocfs2_open_lock(inode);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\t\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (args->fi_flags & OCFS2_FI_FLAG_ORPHAN_RECOVERY) {\n\t\tstatus = ocfs2_try_open_lock(inode, 0);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (can_lock) {\n\t\tstatus = ocfs2_read_inode_block_full(inode, &bh,\n\t\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, args->fi_blkno, 1, &bh);\n\t\t/*\n\t\t * If buffer is in jbd, then its checksum may not have been\n\t\t * computed as yet.\n\t\t */\n\t\tif (!status && !buffer_jbd(bh))\n\t\t\tstatus = ocfs2_validate_inode_block(osb->sb, bh);\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = -EINVAL;\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/*\n\t * This is a code bug. Right now the caller needs to\n\t * understand whether it is asking for a system file inode or\n\t * not so the proper lock names can be built.\n\t */\n\tmlog_bug_on_msg(!!(fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) !=\n\t\t\t!!(args->fi_flags & OCFS2_FI_FLAG_SYSFILE),\n\t\t\t\"Inode %llu: system file state is ambigous\\n\",\n\t\t\t(unsigned long long)args->fi_blkno);\n\n\tif (S_ISCHR(le16_to_cpu(fe->i_mode)) ||\n\t    S_ISBLK(le16_to_cpu(fe->i_mode)))\n\t\tinode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));\n\n\tocfs2_populate_inode(inode, fe, 0);\n\n\tBUG_ON(args->fi_blkno != le64_to_cpu(fe->i_blkno));\n\n\tstatus = 0;\n\nbail:\n\tif (can_lock)\n\t\tocfs2_inode_unlock(inode, 0);\n\n\tif (status < 0)\n\t\tmake_bad_inode(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_populate_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "265-403",
    "snippet": "void ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,\n\t\t\t  int create_ino)\n{\n\tstruct super_block *sb;\n\tstruct ocfs2_super *osb;\n\tint use_plocks = 1;\n\n\tsb = inode->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_LOCALFLOCKS) ||\n\t    ocfs2_mount_local(osb) || !ocfs2_stack_supports_plocks())\n\t\tuse_plocks = 0;\n\n\t/*\n\t * These have all been checked by ocfs2_read_inode_block() or set\n\t * by ocfs2_mknod_locked(), so a failure is a code bug.\n\t */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));  /* This means that read_inode\n\t\t\t\t\t\tcannot create a superblock\n\t\t\t\t\t\tinode today.  change if\n\t\t\t\t\t\tthat is needed. */\n\tBUG_ON(!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)));\n\tBUG_ON(le32_to_cpu(fe->i_fs_generation) != osb->fs_generation);\n\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tOCFS2_I(inode)->ip_attr = le32_to_cpu(fe->i_attr);\n\tOCFS2_I(inode)->ip_dyn_features = le16_to_cpu(fe->i_dyn_features);\n\n\tinode->i_version = 1;\n\tinode->i_generation = le32_to_cpu(fe->i_generation);\n\tinode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));\n\tinode->i_mode = le16_to_cpu(fe->i_mode);\n\ti_uid_write(inode, le32_to_cpu(fe->i_uid));\n\ti_gid_write(inode, le32_to_cpu(fe->i_gid));\n\n\t/* Fast symlinks will have i_size but no allocated clusters. */\n\tif (S_ISLNK(inode->i_mode) && !fe->i_clusters) {\n\t\tinode->i_blocks = 0;\n\t\tinode->i_mapping->a_ops = &ocfs2_fast_symlink_aops;\n\t} else {\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t\tinode->i_mapping->a_ops = &ocfs2_aops;\n\t}\n\tinode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);\n\tinode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);\n\tinode->i_ctime.tv_sec = le64_to_cpu(fe->i_ctime);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(fe->i_ctime_nsec);\n\n\tif (OCFS2_I(inode)->ip_blkno != le64_to_cpu(fe->i_blkno))\n\t\tmlog(ML_ERROR,\n\t\t     \"ip_blkno %llu != i_blkno %llu!\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t     (unsigned long long)le64_to_cpu(fe->i_blkno));\n\n\tset_nlink(inode, ocfs2_read_links_count(fe));\n\n\ttrace_ocfs2_populate_inode(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   le32_to_cpu(fe->i_flags));\n\tif (fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SYSTEM_FILE;\n\t\tinode->i_flags |= S_NOQUOTA;\n\t}\n  \n\tif (fe->i_flags & cpu_to_le32(OCFS2_LOCAL_ALLOC_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_BITMAP_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_QUOTA_FL)) {\n\t\tinode->i_flags |= S_NOQUOTA;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_SUPER_BLOCK_FL)) {\n\t\t/* we can't actually hit this as read_inode can't\n\t\t * handle superblocks today ;-) */\n\t\tBUG();\n\t}\n\n\tswitch (inode->i_mode & S_IFMT) {\n\t    case S_IFREG:\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_fops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_fops_no_plocks;\n\t\t    inode->i_op = &ocfs2_file_iops;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    case S_IFDIR:\n\t\t    inode->i_op = &ocfs2_dir_iops;\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_dops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_dops_no_plocks;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    OCFS2_I(inode)->ip_dir_lock_gen = 1;\n\t\t    break;\n\t    case S_IFLNK:\n\t\t    inode->i_op = &ocfs2_symlink_inode_operations;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    default:\n\t\t    inode->i_op = &ocfs2_special_file_iops;\n\t\t    init_special_inode(inode, inode->i_mode,\n\t\t\t\t       inode->i_rdev);\n\t\t    break;\n\t}\n\n\tif (create_ino) {\n\t\tinode->i_ino = ino_from_blkno(inode->i_sb,\n\t\t\t       le64_to_cpu(fe->i_blkno));\n\n\t\t/*\n\t\t * If we ever want to create system files from kernel,\n\t\t * the generation argument to\n\t\t * ocfs2_inode_lock_res_init() will have to change.\n\t\t */\n\t\tBUG_ON(le32_to_cpu(fe->i_flags) & OCFS2_SYSTEM_FL);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_inode_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_META, 0, inode);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_open_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_OPEN, 0, inode);\n\t}\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_rw_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_RW, inode->i_generation,\n\t\t\t\t  inode);\n\n\tocfs2_set_inode_flags(inode);\n\n\tOCFS2_I(inode)->ip_last_used_slot = 0;\n\tOCFS2_I(inode)->ip_last_used_group = 0;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_resv_set_type(&OCFS2_I(inode)->ip_la_data_resv,\n\t\t\t\t    OCFS2_RESV_FLAG_DIR);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_resv_set_type",
          "args": [
            "&OCFS2_I(inode)->ip_la_data_resv",
            "OCFS2_RESV_FLAG_DIR"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "206-212",
          "snippet": "void ocfs2_resv_set_type(struct ocfs2_alloc_reservation *resv,\n\t\t\t unsigned int flags)\n{\n\tBUG_ON(flags & ~OCFS2_RESV_TYPES);\n\n\tresv->r_flags |= flags;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_resv_set_type(struct ocfs2_alloc_reservation *resv,\n\t\t\t unsigned int flags)\n{\n\tBUG_ON(flags & ~OCFS2_RESV_TYPES);\n\n\tresv->r_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "77-95",
          "snippet": "void ocfs2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = OCFS2_I(inode)->ip_attr;\n\n\tinode->i_flags &= ~(S_IMMUTABLE |\n\t\tS_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);\n\n\tif (flags & OCFS2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\n\tif (flags & OCFS2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & OCFS2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & OCFS2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & OCFS2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = OCFS2_I(inode)->ip_attr;\n\n\tinode->i_flags &= ~(S_IMMUTABLE |\n\t\tS_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);\n\n\tif (flags & OCFS2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\n\tif (flags & OCFS2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & OCFS2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & OCFS2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & OCFS2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_res_init",
          "args": [
            "&OCFS2_I(inode)->ip_rw_lockres",
            "OCFS2_LOCK_TYPE_RW",
            "inode->i_generation",
            "inode"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_res_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "536-562",
          "snippet": "void ocfs2_inode_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t       enum ocfs2_lock_type type,\n\t\t\t       unsigned int generation,\n\t\t\t       struct inode *inode)\n{\n\tstruct ocfs2_lock_res_ops *ops;\n\n\tswitch(type) {\n\t\tcase OCFS2_LOCK_TYPE_RW:\n\t\t\tops = &ocfs2_inode_rw_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_META:\n\t\t\tops = &ocfs2_inode_inode_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_OPEN:\n\t\t\tops = &ocfs2_inode_open_lops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog_bug_on_msg(1, \"type: %d\\n\", type);\n\t\t\tops = NULL; /* thanks, gcc */\n\t\t\tbreak;\n\t};\n\n\tocfs2_build_lock_name(type, OCFS2_I(inode)->ip_blkno,\n\t\t\t      generation, res->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), res, type, ops, inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_lock_res_ops ocfs2_inode_rw_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};",
            "static struct ocfs2_lock_res_ops ocfs2_inode_inode_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.check_downconvert = ocfs2_check_meta_downconvert,\n\t.set_lvb\t= ocfs2_set_meta_lvb,\n\t.downconvert_worker = ocfs2_data_convert_worker,\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};",
            "static struct ocfs2_lock_res_ops ocfs2_inode_open_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};",
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_lock_res_ops ocfs2_inode_rw_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};\nstatic struct ocfs2_lock_res_ops ocfs2_inode_inode_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.check_downconvert = ocfs2_check_meta_downconvert,\n\t.set_lvb\t= ocfs2_set_meta_lvb,\n\t.downconvert_worker = ocfs2_data_convert_worker,\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};\nstatic struct ocfs2_lock_res_ops ocfs2_inode_open_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nvoid ocfs2_inode_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t       enum ocfs2_lock_type type,\n\t\t\t       unsigned int generation,\n\t\t\t       struct inode *inode)\n{\n\tstruct ocfs2_lock_res_ops *ops;\n\n\tswitch(type) {\n\t\tcase OCFS2_LOCK_TYPE_RW:\n\t\t\tops = &ocfs2_inode_rw_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_META:\n\t\t\tops = &ocfs2_inode_inode_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_OPEN:\n\t\t\tops = &ocfs2_inode_open_lops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog_bug_on_msg(1, \"type: %d\\n\", type);\n\t\t\tops = NULL; /* thanks, gcc */\n\t\t\tbreak;\n\t};\n\n\tocfs2_build_lock_name(type, OCFS2_I(inode)->ip_blkno,\n\t\t\t      generation, res->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), res, type, ops, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le32_to_cpu(fe->i_flags) & OCFS2_SYSTEM_FL"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->i_flags"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ino_from_blkno",
          "args": [
            "inode->i_sb",
            "le64_to_cpu(fe->i_blkno)"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "ino_from_blkno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "705-709",
          "snippet": "static inline unsigned long ino_from_blkno(struct super_block *sb,\n\t\t\t\t\t   u64 blkno)\n{\n\treturn (unsigned long)(blkno & (u64)ULONG_MAX);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned long ino_from_blkno(struct super_block *sb,\n\t\t\t\t\t   u64 blkno)\n{\n\treturn (unsigned long)(blkno & (u64)ULONG_MAX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_blkno"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "inode->i_rdev"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "le64_to_cpu(fe->i_size)"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_SUPER_BLOCK_FL"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_QUOTA_FL"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_BITMAP_FL"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_LOCAL_ALLOC_FL"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_SYSTEM_FL"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_populate_inode",
          "args": [
            "OCFS2_I(inode)->ip_blkno",
            "le32_to_cpu(fe->i_flags)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "ocfs2_read_links_count(fe)"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_links_count",
          "args": [
            "fe"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_links_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "553-562",
          "snippet": "static inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tif (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))\n\t\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"ip_blkno %llu != i_blkno %llu!\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)le64_to_cpu(fe->i_blkno)"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "inode"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "le32_to_cpu(fe->i_gid)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "le32_to_cpu(fe->i_uid)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fe->i_mode"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_decode_dev",
          "args": [
            "le64_to_cpu(fe->id1.dev1.i_rdev)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le32_to_cpu(fe->i_fs_generation) != osb->fs_generation"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL))"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_VALID_FL"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(fe)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "fe"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_stack_supports_plocks",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_stack_supports_plocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "291-294",
          "snippet": "int ocfs2_stack_supports_plocks(void)\n{\n\treturn active_stack && active_stack->sp_ops->plock;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_stack_supports_plocks(void)\n{\n\treturn active_stack && active_stack->sp_ops->plock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,\n\t\t\t  int create_ino)\n{\n\tstruct super_block *sb;\n\tstruct ocfs2_super *osb;\n\tint use_plocks = 1;\n\n\tsb = inode->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_LOCALFLOCKS) ||\n\t    ocfs2_mount_local(osb) || !ocfs2_stack_supports_plocks())\n\t\tuse_plocks = 0;\n\n\t/*\n\t * These have all been checked by ocfs2_read_inode_block() or set\n\t * by ocfs2_mknod_locked(), so a failure is a code bug.\n\t */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));  /* This means that read_inode\n\t\t\t\t\t\tcannot create a superblock\n\t\t\t\t\t\tinode today.  change if\n\t\t\t\t\t\tthat is needed. */\n\tBUG_ON(!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)));\n\tBUG_ON(le32_to_cpu(fe->i_fs_generation) != osb->fs_generation);\n\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tOCFS2_I(inode)->ip_attr = le32_to_cpu(fe->i_attr);\n\tOCFS2_I(inode)->ip_dyn_features = le16_to_cpu(fe->i_dyn_features);\n\n\tinode->i_version = 1;\n\tinode->i_generation = le32_to_cpu(fe->i_generation);\n\tinode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));\n\tinode->i_mode = le16_to_cpu(fe->i_mode);\n\ti_uid_write(inode, le32_to_cpu(fe->i_uid));\n\ti_gid_write(inode, le32_to_cpu(fe->i_gid));\n\n\t/* Fast symlinks will have i_size but no allocated clusters. */\n\tif (S_ISLNK(inode->i_mode) && !fe->i_clusters) {\n\t\tinode->i_blocks = 0;\n\t\tinode->i_mapping->a_ops = &ocfs2_fast_symlink_aops;\n\t} else {\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t\tinode->i_mapping->a_ops = &ocfs2_aops;\n\t}\n\tinode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);\n\tinode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);\n\tinode->i_ctime.tv_sec = le64_to_cpu(fe->i_ctime);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(fe->i_ctime_nsec);\n\n\tif (OCFS2_I(inode)->ip_blkno != le64_to_cpu(fe->i_blkno))\n\t\tmlog(ML_ERROR,\n\t\t     \"ip_blkno %llu != i_blkno %llu!\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t     (unsigned long long)le64_to_cpu(fe->i_blkno));\n\n\tset_nlink(inode, ocfs2_read_links_count(fe));\n\n\ttrace_ocfs2_populate_inode(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   le32_to_cpu(fe->i_flags));\n\tif (fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SYSTEM_FILE;\n\t\tinode->i_flags |= S_NOQUOTA;\n\t}\n  \n\tif (fe->i_flags & cpu_to_le32(OCFS2_LOCAL_ALLOC_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_BITMAP_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_QUOTA_FL)) {\n\t\tinode->i_flags |= S_NOQUOTA;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_SUPER_BLOCK_FL)) {\n\t\t/* we can't actually hit this as read_inode can't\n\t\t * handle superblocks today ;-) */\n\t\tBUG();\n\t}\n\n\tswitch (inode->i_mode & S_IFMT) {\n\t    case S_IFREG:\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_fops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_fops_no_plocks;\n\t\t    inode->i_op = &ocfs2_file_iops;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    case S_IFDIR:\n\t\t    inode->i_op = &ocfs2_dir_iops;\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_dops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_dops_no_plocks;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    OCFS2_I(inode)->ip_dir_lock_gen = 1;\n\t\t    break;\n\t    case S_IFLNK:\n\t\t    inode->i_op = &ocfs2_symlink_inode_operations;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    default:\n\t\t    inode->i_op = &ocfs2_special_file_iops;\n\t\t    init_special_inode(inode, inode->i_mode,\n\t\t\t\t       inode->i_rdev);\n\t\t    break;\n\t}\n\n\tif (create_ino) {\n\t\tinode->i_ino = ino_from_blkno(inode->i_sb,\n\t\t\t       le64_to_cpu(fe->i_blkno));\n\n\t\t/*\n\t\t * If we ever want to create system files from kernel,\n\t\t * the generation argument to\n\t\t * ocfs2_inode_lock_res_init() will have to change.\n\t\t */\n\t\tBUG_ON(le32_to_cpu(fe->i_flags) & OCFS2_SYSTEM_FL);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_inode_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_META, 0, inode);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_open_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_OPEN, 0, inode);\n\t}\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_rw_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_RW, inode->i_generation,\n\t\t\t\t  inode);\n\n\tocfs2_set_inode_flags(inode);\n\n\tOCFS2_I(inode)->ip_last_used_slot = 0;\n\tOCFS2_I(inode)->ip_last_used_group = 0;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_resv_set_type(&OCFS2_I(inode)->ip_la_data_resv,\n\t\t\t\t    OCFS2_RESV_FLAG_DIR);\n}"
  },
  {
    "function_name": "ocfs2_init_locked_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "241-263",
    "snippet": "static int ocfs2_init_locked_inode(struct inode *inode, void *opaque)\n{\n\tstruct ocfs2_find_inode_args *args = opaque;\n\tstatic struct lock_class_key ocfs2_quota_ip_alloc_sem_key,\n\t\t\t\t     ocfs2_file_ip_alloc_sem_key;\n\n\tinode->i_ino = args->fi_ino;\n\tOCFS2_I(inode)->ip_blkno = args->fi_blkno;\n\tif (args->fi_sysfile_type != 0)\n\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t&ocfs2_sysfile_lock_key[args->fi_sysfile_type]);\n\tif (args->fi_sysfile_type == USER_QUOTA_SYSTEM_INODE ||\n\t    args->fi_sysfile_type == GROUP_QUOTA_SYSTEM_INODE ||\n\t    args->fi_sysfile_type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    args->fi_sysfile_type == LOCAL_GROUP_QUOTA_SYSTEM_INODE)\n\t\tlockdep_set_class(&OCFS2_I(inode)->ip_alloc_sem,\n\t\t\t\t  &ocfs2_quota_ip_alloc_sem_key);\n\telse\n\t\tlockdep_set_class(&OCFS2_I(inode)->ip_alloc_sem,\n\t\t\t\t  &ocfs2_file_ip_alloc_sem_key);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_class_key ocfs2_sysfile_lock_key[NUM_SYSTEM_INODES];",
      "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);",
      "static int ocfs2_init_locked_inode(struct inode *inode, void *opaque);",
      "static int ocfs2_find_actor(struct inode *inode, void *opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem",
            "&ocfs2_file_ip_alloc_sem_key"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem",
            "&ocfs2_quota_ip_alloc_sem_key"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&inode->i_mutex",
            "&ocfs2_sysfile_lock_key[args->fi_sysfile_type]"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct lock_class_key ocfs2_sysfile_lock_key[NUM_SYSTEM_INODES];\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\nstatic int ocfs2_init_locked_inode(struct inode *inode, void *opaque);\nstatic int ocfs2_find_actor(struct inode *inode, void *opaque);\n\nstatic int ocfs2_init_locked_inode(struct inode *inode, void *opaque)\n{\n\tstruct ocfs2_find_inode_args *args = opaque;\n\tstatic struct lock_class_key ocfs2_quota_ip_alloc_sem_key,\n\t\t\t\t     ocfs2_file_ip_alloc_sem_key;\n\n\tinode->i_ino = args->fi_ino;\n\tOCFS2_I(inode)->ip_blkno = args->fi_blkno;\n\tif (args->fi_sysfile_type != 0)\n\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t&ocfs2_sysfile_lock_key[args->fi_sysfile_type]);\n\tif (args->fi_sysfile_type == USER_QUOTA_SYSTEM_INODE ||\n\t    args->fi_sysfile_type == GROUP_QUOTA_SYSTEM_INODE ||\n\t    args->fi_sysfile_type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    args->fi_sysfile_type == LOCAL_GROUP_QUOTA_SYSTEM_INODE)\n\t\tlockdep_set_class(&OCFS2_I(inode)->ip_alloc_sem,\n\t\t\t\t  &ocfs2_quota_ip_alloc_sem_key);\n\telse\n\t\tlockdep_set_class(&OCFS2_I(inode)->ip_alloc_sem,\n\t\t\t\t  &ocfs2_file_ip_alloc_sem_key);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_find_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "216-234",
    "snippet": "static int ocfs2_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct ocfs2_find_inode_args *args = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tint ret = 0;\n\n\targs = opaque;\n\n\tmlog_bug_on_msg(!inode, \"No inode in find actor!\\n\");\n\n\ttrace_ocfs2_find_actor(inode, inode->i_ino, opaque, args->fi_blkno);\n\n\tif (oi->ip_blkno != args->fi_blkno)\n\t\tgoto bail;\n\n\tret = 1;\nbail:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);",
      "static int ocfs2_init_locked_inode(struct inode *inode, void *opaque);",
      "static int ocfs2_find_actor(struct inode *inode, void *opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_find_actor",
          "args": [
            "inode",
            "inode->i_ino",
            "opaque",
            "args->fi_blkno"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!inode",
            "\"No inode in find actor!\\n\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\nstatic int ocfs2_init_locked_inode(struct inode *inode, void *opaque);\nstatic int ocfs2_find_actor(struct inode *inode, void *opaque);\n\nstatic int ocfs2_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct ocfs2_find_inode_args *args = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tint ret = 0;\n\n\targs = opaque;\n\n\tmlog_bug_on_msg(!inode, \"No inode in find actor!\\n\");\n\n\ttrace_ocfs2_find_actor(inode, inode->i_ino, opaque, args->fi_blkno);\n\n\tif (oi->ip_blkno != args->fi_blkno)\n\t\tgoto bail;\n\n\tret = 1;\nbail:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "127-206",
    "snippet": "struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_iget_end",
          "args": [
            "inode",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_locked_inode",
          "args": [
            "inode",
            "&args"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "405-546",
          "snippet": "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args)\n{\n\tstruct super_block *sb;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *fe;\n\tstruct buffer_head *bh = NULL;\n\tint status, can_lock;\n\tu32 generation = 0;\n\n\tstatus = -EINVAL;\n\tsb = inode->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\t/*\n\t * To improve performance of cold-cache inode stats, we take\n\t * the cluster lock here if possible.\n\t *\n\t * Generally, OCFS2 never trusts the contents of an inode\n\t * unless it's holding a cluster lock, so taking it here isn't\n\t * a correctness issue as much as it is a performance\n\t * improvement.\n\t *\n\t * There are three times when taking the lock is not a good idea:\n\t *\n\t * 1) During startup, before we have initialized the DLM.\n\t *\n\t * 2) If we are reading certain system files which never get\n\t *    cluster locks (local alloc, truncate log).\n\t *\n\t * 3) If the process doing the iget() is responsible for\n\t *    orphan dir recovery. We're holding the orphan dir lock and\n\t *    can get into a deadlock with another process on another\n\t *    node in ->delete_inode().\n\t *\n\t * #1 and #2 can be simply solved by never taking the lock\n\t * here for system files (which are the only type we read\n\t * during mount). It's a heavier approach, but our main\n\t * concern is user-accessible files anyway.\n\t *\n\t * #3 works itself out because we'll eventually take the\n\t * cluster lock before trusting anything anyway.\n\t */\n\tcan_lock = !(args->fi_flags & OCFS2_FI_FLAG_SYSFILE)\n\t\t&& !(args->fi_flags & OCFS2_FI_FLAG_ORPHAN_RECOVERY)\n\t\t&& !ocfs2_mount_local(osb);\n\n\ttrace_ocfs2_read_locked_inode(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno, can_lock);\n\n\t/*\n\t * To maintain backwards compatibility with older versions of\n\t * ocfs2-tools, we still store the generation value for system\n\t * files. The only ones that actually matter to userspace are\n\t * the journals, but it's easier and inexpensive to just flag\n\t * all system files similarly.\n\t */\n\tif (args->fi_flags & OCFS2_FI_FLAG_SYSFILE)\n\t\tgeneration = osb->fs_generation;\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_inode_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_META,\n\t\t\t\t  generation, inode);\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_open_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_OPEN,\n\t\t\t\t  0, inode);\n\n\tif (can_lock) {\n\t\tstatus = ocfs2_open_lock(inode);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\t\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (args->fi_flags & OCFS2_FI_FLAG_ORPHAN_RECOVERY) {\n\t\tstatus = ocfs2_try_open_lock(inode, 0);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (can_lock) {\n\t\tstatus = ocfs2_read_inode_block_full(inode, &bh,\n\t\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, args->fi_blkno, 1, &bh);\n\t\t/*\n\t\t * If buffer is in jbd, then its checksum may not have been\n\t\t * computed as yet.\n\t\t */\n\t\tif (!status && !buffer_jbd(bh))\n\t\t\tstatus = ocfs2_validate_inode_block(osb->sb, bh);\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = -EINVAL;\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/*\n\t * This is a code bug. Right now the caller needs to\n\t * understand whether it is asking for a system file inode or\n\t * not so the proper lock names can be built.\n\t */\n\tmlog_bug_on_msg(!!(fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) !=\n\t\t\t!!(args->fi_flags & OCFS2_FI_FLAG_SYSFILE),\n\t\t\t\"Inode %llu: system file state is ambigous\\n\",\n\t\t\t(unsigned long long)args->fi_blkno);\n\n\tif (S_ISCHR(le16_to_cpu(fe->i_mode)) ||\n\t    S_ISBLK(le16_to_cpu(fe->i_mode)))\n\t\tinode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));\n\n\tocfs2_populate_inode(inode, fe, 0);\n\n\tBUG_ON(args->fi_blkno != le64_to_cpu(fe->i_blkno));\n\n\tstatus = 0;\n\nbail:\n\tif (can_lock)\n\t\tocfs2_inode_unlock(inode, 0);\n\n\tif (status < 0)\n\t\tmake_bad_inode(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args)\n{\n\tstruct super_block *sb;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *fe;\n\tstruct buffer_head *bh = NULL;\n\tint status, can_lock;\n\tu32 generation = 0;\n\n\tstatus = -EINVAL;\n\tsb = inode->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\t/*\n\t * To improve performance of cold-cache inode stats, we take\n\t * the cluster lock here if possible.\n\t *\n\t * Generally, OCFS2 never trusts the contents of an inode\n\t * unless it's holding a cluster lock, so taking it here isn't\n\t * a correctness issue as much as it is a performance\n\t * improvement.\n\t *\n\t * There are three times when taking the lock is not a good idea:\n\t *\n\t * 1) During startup, before we have initialized the DLM.\n\t *\n\t * 2) If we are reading certain system files which never get\n\t *    cluster locks (local alloc, truncate log).\n\t *\n\t * 3) If the process doing the iget() is responsible for\n\t *    orphan dir recovery. We're holding the orphan dir lock and\n\t *    can get into a deadlock with another process on another\n\t *    node in ->delete_inode().\n\t *\n\t * #1 and #2 can be simply solved by never taking the lock\n\t * here for system files (which are the only type we read\n\t * during mount). It's a heavier approach, but our main\n\t * concern is user-accessible files anyway.\n\t *\n\t * #3 works itself out because we'll eventually take the\n\t * cluster lock before trusting anything anyway.\n\t */\n\tcan_lock = !(args->fi_flags & OCFS2_FI_FLAG_SYSFILE)\n\t\t&& !(args->fi_flags & OCFS2_FI_FLAG_ORPHAN_RECOVERY)\n\t\t&& !ocfs2_mount_local(osb);\n\n\ttrace_ocfs2_read_locked_inode(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno, can_lock);\n\n\t/*\n\t * To maintain backwards compatibility with older versions of\n\t * ocfs2-tools, we still store the generation value for system\n\t * files. The only ones that actually matter to userspace are\n\t * the journals, but it's easier and inexpensive to just flag\n\t * all system files similarly.\n\t */\n\tif (args->fi_flags & OCFS2_FI_FLAG_SYSFILE)\n\t\tgeneration = osb->fs_generation;\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_inode_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_META,\n\t\t\t\t  generation, inode);\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_open_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_OPEN,\n\t\t\t\t  0, inode);\n\n\tif (can_lock) {\n\t\tstatus = ocfs2_open_lock(inode);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\t\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (args->fi_flags & OCFS2_FI_FLAG_ORPHAN_RECOVERY) {\n\t\tstatus = ocfs2_try_open_lock(inode, 0);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (can_lock) {\n\t\tstatus = ocfs2_read_inode_block_full(inode, &bh,\n\t\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, args->fi_blkno, 1, &bh);\n\t\t/*\n\t\t * If buffer is in jbd, then its checksum may not have been\n\t\t * computed as yet.\n\t\t */\n\t\tif (!status && !buffer_jbd(bh))\n\t\t\tstatus = ocfs2_validate_inode_block(osb->sb, bh);\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = -EINVAL;\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/*\n\t * This is a code bug. Right now the caller needs to\n\t * understand whether it is asking for a system file inode or\n\t * not so the proper lock names can be built.\n\t */\n\tmlog_bug_on_msg(!!(fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) !=\n\t\t\t!!(args->fi_flags & OCFS2_FI_FLAG_SYSFILE),\n\t\t\t\"Inode %llu: system file state is ambigous\\n\",\n\t\t\t(unsigned long long)args->fi_blkno);\n\n\tif (S_ISCHR(le16_to_cpu(fe->i_mode)) ||\n\t    S_ISBLK(le16_to_cpu(fe->i_mode)))\n\t\tinode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));\n\n\tocfs2_populate_inode(inode, fe, 0);\n\n\tBUG_ON(args->fi_blkno != le64_to_cpu(fe->i_blkno));\n\n\tstatus = 0;\n\nbail:\n\tif (can_lock)\n\t\tocfs2_inode_unlock(inode, 0);\n\n\tif (status < 0)\n\t\tmake_bad_inode(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_iget5_locked",
          "args": [
            "inode->i_state"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "PTR_ERR(inode)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "args.fi_ino",
            "ocfs2_find_actor",
            "ocfs2_init_locked_inode",
            "&args"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ino_from_blkno",
          "args": [
            "sb",
            "blkno"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "ino_from_blkno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "705-709",
          "snippet": "static inline unsigned long ino_from_blkno(struct super_block *sb,\n\t\t\t\t\t   u64 blkno)\n{\n\treturn (unsigned long)(blkno & (u64)ULONG_MAX);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned long ino_from_blkno(struct super_block *sb,\n\t\t\t\t\t   u64 blkno)\n{\n\treturn (unsigned long)(blkno & (u64)ULONG_MAX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "PTR_ERR(inode)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_iget_begin",
          "args": [
            "(unsigned long long)blkno",
            "flags",
            "sysfile_type"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\n\nstruct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "ocfs2_ilookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "116-126",
    "snippet": "struct inode *ocfs2_ilookup(struct super_block *sb, u64 blkno)\n{\n\tstruct ocfs2_find_inode_args args;\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = 0;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = 0;\n\n\treturn ilookup5(sb, blkno, ocfs2_find_actor, &args);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilookup5",
          "args": [
            "sb",
            "blkno",
            "ocfs2_find_actor",
            "&args"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1239-1247",
          "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ino_from_blkno",
          "args": [
            "sb",
            "blkno"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "ino_from_blkno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "705-709",
          "snippet": "static inline unsigned long ino_from_blkno(struct super_block *sb,\n\t\t\t\t\t   u64 blkno)\n{\n\treturn (unsigned long)(blkno & (u64)ULONG_MAX);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned long ino_from_blkno(struct super_block *sb,\n\t\t\t\t\t   u64 blkno)\n{\n\treturn (unsigned long)(blkno & (u64)ULONG_MAX);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\n\nstruct inode *ocfs2_ilookup(struct super_block *sb, u64 blkno)\n{\n\tstruct ocfs2_find_inode_args args;\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = 0;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = 0;\n\n\treturn ilookup5(sb, blkno, ocfs2_find_actor, &args);\n}"
  },
  {
    "function_name": "ocfs2_get_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "98-114",
    "snippet": "void ocfs2_get_inode_flags(struct ocfs2_inode_info *oi)\n{\n\tunsigned int flags = oi->vfs_inode.i_flags;\n\n\toi->ip_attr &= ~(OCFS2_SYNC_FL|OCFS2_APPEND_FL|\n\t\t\tOCFS2_IMMUTABLE_FL|OCFS2_NOATIME_FL|OCFS2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\toi->ip_attr |= OCFS2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\toi->ip_attr |= OCFS2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\toi->ip_attr |= OCFS2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\toi->ip_attr |= OCFS2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\toi->ip_attr |= OCFS2_DIRSYNC_FL;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_get_inode_flags(struct ocfs2_inode_info *oi)\n{\n\tunsigned int flags = oi->vfs_inode.i_flags;\n\n\toi->ip_attr &= ~(OCFS2_SYNC_FL|OCFS2_APPEND_FL|\n\t\t\tOCFS2_IMMUTABLE_FL|OCFS2_NOATIME_FL|OCFS2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\toi->ip_attr |= OCFS2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\toi->ip_attr |= OCFS2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\toi->ip_attr |= OCFS2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\toi->ip_attr |= OCFS2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\toi->ip_attr |= OCFS2_DIRSYNC_FL;\n}"
  },
  {
    "function_name": "ocfs2_set_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
    "lines": "77-95",
    "snippet": "void ocfs2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = OCFS2_I(inode)->ip_attr;\n\n\tinode->i_flags &= ~(S_IMMUTABLE |\n\t\tS_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);\n\n\tif (flags & OCFS2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\n\tif (flags & OCFS2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & OCFS2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & OCFS2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & OCFS2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = OCFS2_I(inode)->ip_attr;\n\n\tinode->i_flags &= ~(S_IMMUTABLE |\n\t\tS_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);\n\n\tif (flags & OCFS2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\n\tif (flags & OCFS2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & OCFS2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & OCFS2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & OCFS2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}"
  }
]