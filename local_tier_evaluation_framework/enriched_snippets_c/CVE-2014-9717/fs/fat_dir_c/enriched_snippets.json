[
  {
    "function_name": "fat_add_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "1273-1405",
    "snippet": "int fat_add_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t    struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh, *prev, *bhs[3]; /* 32*slots (672bytes) */\n\tstruct msdos_dir_entry *uninitialized_var(de);\n\tint err, free_slots, i, nr_bhs;\n\tloff_t pos, i_pos;\n\n\tsinfo->nr_slots = nr_slots;\n\n\t/* First stage: search free directory entries */\n\tfree_slots = nr_bhs = 0;\n\tbh = prev = NULL;\n\tpos = 0;\n\terr = -ENOSPC;\n\twhile (fat_get_entry(dir, &pos, &bh, &de) > -1) {\n\t\t/* check the maximum size of directory */\n\t\tif (pos >= FAT_MAX_DIR_SIZE)\n\t\t\tgoto error;\n\n\t\tif (IS_FREE(de->name)) {\n\t\t\tif (prev != bh) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tbhs[nr_bhs] = prev = bh;\n\t\t\t\tnr_bhs++;\n\t\t\t}\n\t\t\tfree_slots++;\n\t\t\tif (free_slots == nr_slots)\n\t\t\t\tgoto found;\n\t\t} else {\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tprev = NULL;\n\t\t\tfree_slots = nr_bhs = 0;\n\t\t}\n\t}\n\tif (dir->i_ino == MSDOS_ROOT_INO) {\n\t\tif (sbi->fat_bits != 32)\n\t\t\tgoto error;\n\t} else if (MSDOS_I(dir)->i_start == 0) {\n\t\tfat_msg(sb, KERN_ERR, \"Corrupted directory (i_pos %lld)\",\n\t\t       MSDOS_I(dir)->i_pos);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\nfound:\n\terr = 0;\n\tpos -= free_slots * sizeof(*de);\n\tnr_slots -= free_slots;\n\tif (free_slots) {\n\t\t/*\n\t\t * Second stage: filling the free entries with new entries.\n\t\t * NOTE: If this slots has shortname, first, we write\n\t\t * the long name slots, then write the short name.\n\t\t */\n\t\tint size = free_slots * sizeof(*de);\n\t\tint offset = pos & (sb->s_blocksize - 1);\n\t\tint long_bhs = nr_bhs - (nr_slots == 0);\n\n\t\t/* Fill the long name slots. */\n\t\tfor (i = 0; i < long_bhs; i++) {\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\toffset = 0;\n\t\t\tslots += copy;\n\t\t\tsize -= copy;\n\t\t}\n\t\tif (long_bhs && IS_DIRSYNC(dir))\n\t\t\terr = fat_sync_bhs(bhs, long_bhs);\n\t\tif (!err && i < nr_bhs) {\n\t\t\t/* Fill the short name slot. */\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\tif (IS_DIRSYNC(dir))\n\t\t\t\terr = sync_dirty_buffer(bhs[i]);\n\t\t}\n\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\tbrelse(bhs[i]);\n\t\tif (err)\n\t\t\tgoto error_remove;\n\t}\n\n\tif (nr_slots) {\n\t\tint cluster, nr_cluster;\n\n\t\t/*\n\t\t * Third stage: allocate the cluster for new entries.\n\t\t * And initialize the cluster with new entries, then\n\t\t * add the cluster to dir.\n\t\t */\n\t\tcluster = fat_add_new_entries(dir, slots, nr_slots, &nr_cluster,\n\t\t\t\t\t      &de, &bh, &i_pos);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error_remove;\n\t\t}\n\t\terr = fat_chain_add(dir, cluster, nr_cluster);\n\t\tif (err) {\n\t\t\tfat_free_clusters(dir, cluster);\n\t\t\tgoto error_remove;\n\t\t}\n\t\tif (dir->i_size & (sbi->cluster_size - 1)) {\n\t\t\tfat_fs_error(sb, \"Odd directory size\");\n\t\t\tdir->i_size = (dir->i_size + sbi->cluster_size - 1)\n\t\t\t\t& ~((loff_t)sbi->cluster_size - 1);\n\t\t}\n\t\tdir->i_size += nr_cluster << sbi->cluster_bits;\n\t\tMSDOS_I(dir)->mmu_private += nr_cluster << sbi->cluster_bits;\n\t}\n\tsinfo->slot_off = pos;\n\tsinfo->de = de;\n\tsinfo->bh = bh;\n\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\n\treturn 0;\n\nerror:\n\tbrelse(bh);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\treturn err;\n\nerror_remove:\n\tbrelse(bh);\n\tif (free_slots)\n\t\t__fat_remove_entries(dir, pos, free_slots);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fat_remove_entries",
          "args": [
            "dir",
            "pos",
            "free_slots"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_remove_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "995-1028",
          "snippet": "static int __fat_remove_entries(struct inode *dir, loff_t pos, int nr_slots)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de, *endp;\n\tint err = 0, orig_slots;\n\n\twhile (nr_slots) {\n\t\tbh = NULL;\n\t\tif (fat_get_entry(dir, &pos, &bh, &de) < 0) {\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\torig_slots = nr_slots;\n\t\tendp = (struct msdos_dir_entry *)(bh->b_data + sb->s_blocksize);\n\t\twhile (nr_slots && de < endp) {\n\t\t\tde->name[0] = DELETED_FLAG;\n\t\t\tde++;\n\t\t\tnr_slots--;\n\t\t}\n\t\tmark_buffer_dirty_inode(bh, dir);\n\t\tif (IS_DIRSYNC(dir))\n\t\t\terr = sync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t/* pos is *next* de's position, so this does `- sizeof(de)' */\n\t\tpos += ((orig_slots - nr_slots) * sizeof(*de)) - sizeof(*de);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int __fat_remove_entries(struct inode *dir, loff_t pos, int nr_slots)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de, *endp;\n\tint err = 0, orig_slots;\n\n\twhile (nr_slots) {\n\t\tbh = NULL;\n\t\tif (fat_get_entry(dir, &pos, &bh, &de) < 0) {\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\torig_slots = nr_slots;\n\t\tendp = (struct msdos_dir_entry *)(bh->b_data + sb->s_blocksize);\n\t\twhile (nr_slots && de < endp) {\n\t\t\tde->name[0] = DELETED_FLAG;\n\t\t\tde++;\n\t\t\tnr_slots--;\n\t\t}\n\t\tmark_buffer_dirty_inode(bh, dir);\n\t\tif (IS_DIRSYNC(dir))\n\t\t\terr = sync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t/* pos is *next* de's position, so this does `- sizeof(de)' */\n\t\tpos += ((orig_slots - nr_slots) * sizeof(*de)) - sizeof(*de);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_make_i_pos",
          "args": [
            "sb",
            "sinfo->bh",
            "sinfo->de"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "fat_make_i_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "43-49",
          "snippet": "static inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "dir"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_fs_error",
          "args": [
            "sb",
            "\"Odd directory size\""
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_free_clusters",
          "args": [
            "dir",
            "cluster"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "fat_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "553-633",
          "snippet": "int fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_chain_add",
          "args": [
            "dir",
            "cluster",
            "nr_cluster"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "fat_chain_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "103-165",
          "snippet": "int fat_chain_add(struct inode *inode, int new_dclus, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint ret, new_fclus, last;\n\n\t/*\n\t * We must locate the last cluster of the file to add this new\n\t * one (new_dclus) to the end of the link list (the FAT).\n\t */\n\tlast = new_fclus = 0;\n\tif (MSDOS_I(inode)->i_start) {\n\t\tint fclus, dclus;\n\n\t\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_fclus = fclus + 1;\n\t\tlast = dclus;\n\t}\n\n\t/* add new one to the last of the cluster chain */\n\tif (last) {\n\t\tstruct fat_entry fatent;\n\n\t\tfatent_init(&fatent);\n\t\tret = fat_ent_read(inode, &fatent, last);\n\t\tif (ret >= 0) {\n\t\t\tint wait = inode_needs_sync(inode);\n\t\t\tret = fat_ent_write(inode, &fatent, new_dclus, wait);\n\t\t\tfatent_brelse(&fatent);\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t/*\n\t\t * FIXME:Although we can add this cache, fat_cache_add() is\n\t\t * assuming to be called after linear search with fat_cache_id.\n\t\t */\n//\t\tfat_cache_add(inode, new_fclus, new_dclus);\n\t} else {\n\t\tMSDOS_I(inode)->i_start = new_dclus;\n\t\tMSDOS_I(inode)->i_logstart = new_dclus;\n\t\t/*\n\t\t * Since generic_write_sync() synchronizes regular files later,\n\t\t * we sync here only directories.\n\t\t */\n\t\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode)) {\n\t\t\tret = fat_sync_inode(inode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else\n\t\t\tmark_inode_dirty(inode);\n\t}\n\tif (new_fclus != (inode->i_blocks >> (sbi->cluster_bits - 9))) {\n\t\tfat_fs_error(sb, \"clusters badly computed (%d != %llu)\",\n\t\t\t     new_fclus,\n\t\t\t     (llu)(inode->i_blocks >> (sbi->cluster_bits - 9)));\n\t\tfat_cache_inval_inode(inode);\n\t}\n\tinode->i_blocks += nr_cluster << (sbi->cluster_bits - 9);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_chain_add(struct inode *inode, int new_dclus, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint ret, new_fclus, last;\n\n\t/*\n\t * We must locate the last cluster of the file to add this new\n\t * one (new_dclus) to the end of the link list (the FAT).\n\t */\n\tlast = new_fclus = 0;\n\tif (MSDOS_I(inode)->i_start) {\n\t\tint fclus, dclus;\n\n\t\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_fclus = fclus + 1;\n\t\tlast = dclus;\n\t}\n\n\t/* add new one to the last of the cluster chain */\n\tif (last) {\n\t\tstruct fat_entry fatent;\n\n\t\tfatent_init(&fatent);\n\t\tret = fat_ent_read(inode, &fatent, last);\n\t\tif (ret >= 0) {\n\t\t\tint wait = inode_needs_sync(inode);\n\t\t\tret = fat_ent_write(inode, &fatent, new_dclus, wait);\n\t\t\tfatent_brelse(&fatent);\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t/*\n\t\t * FIXME:Although we can add this cache, fat_cache_add() is\n\t\t * assuming to be called after linear search with fat_cache_id.\n\t\t */\n//\t\tfat_cache_add(inode, new_fclus, new_dclus);\n\t} else {\n\t\tMSDOS_I(inode)->i_start = new_dclus;\n\t\tMSDOS_I(inode)->i_logstart = new_dclus;\n\t\t/*\n\t\t * Since generic_write_sync() synchronizes regular files later,\n\t\t * we sync here only directories.\n\t\t */\n\t\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode)) {\n\t\t\tret = fat_sync_inode(inode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else\n\t\t\tmark_inode_dirty(inode);\n\t}\n\tif (new_fclus != (inode->i_blocks >> (sbi->cluster_bits - 9))) {\n\t\tfat_fs_error(sb, \"clusters badly computed (%d != %llu)\",\n\t\t\t     new_fclus,\n\t\t\t     (llu)(inode->i_blocks >> (sbi->cluster_bits - 9)));\n\t\tfat_cache_inval_inode(inode);\n\t}\n\tinode->i_blocks += nr_cluster << (sbi->cluster_bits - 9);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_add_new_entries",
          "args": [
            "dir",
            "slots",
            "nr_slots",
            "&nr_cluster",
            "&de",
            "&bh",
            "&i_pos"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "fat_add_new_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1193-1271",
          "snippet": "static int fat_add_new_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t\t       int *nr_cluster, struct msdos_dir_entry **de,\n\t\t\t       struct buffer_head **bh, loff_t *i_pos)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tsector_t blknr, start_blknr, last_blknr;\n\tunsigned long size, copy;\n\tint err, i, n, offset, cluster[2];\n\n\t/*\n\t * The minimum cluster size is 512bytes, and maximum entry\n\t * size is 32*slots (672bytes).  So, iff the cluster size is\n\t * 512bytes, we may need two clusters.\n\t */\n\tsize = nr_slots * sizeof(struct msdos_dir_entry);\n\t*nr_cluster = (size + (sbi->cluster_size - 1)) >> sbi->cluster_bits;\n\tBUG_ON(*nr_cluster > 2);\n\n\terr = fat_alloc_clusters(dir, cluster, *nr_cluster);\n\tif (err)\n\t\tgoto error;\n\n\t/*\n\t * First stage: Fill the directory entry.  NOTE: This cluster\n\t * is not referenced from any inode yet, so updates order is\n\t * not important.\n\t */\n\ti = n = copy = 0;\n\tdo {\n\t\tstart_blknr = blknr = fat_clus_to_blknr(sbi, cluster[i]);\n\t\tlast_blknr = start_blknr + sbi->sec_per_clus;\n\t\twhile (blknr < last_blknr) {\n\t\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\t\tif (!bhs[n]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error_nomem;\n\t\t\t}\n\n\t\t\t/* fill the directory entry */\n\t\t\tcopy = min(size, sb->s_blocksize);\n\t\t\tmemcpy(bhs[n]->b_data, slots, copy);\n\t\t\tslots += copy;\n\t\t\tsize -= copy;\n\t\t\tset_buffer_uptodate(bhs[n]);\n\t\t\tmark_buffer_dirty_inode(bhs[n], dir);\n\t\t\tif (!size)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tblknr++;\n\t\t}\n\t} while (++i < *nr_cluster);\n\n\tmemset(bhs[n]->b_data + copy, 0, sb->s_blocksize - copy);\n\toffset = copy - sizeof(struct msdos_dir_entry);\n\tget_bh(bhs[n]);\n\t*bh = bhs[n];\n\t*de = (struct msdos_dir_entry *)((*bh)->b_data + offset);\n\t*i_pos = fat_make_i_pos(sb, *bh, *de);\n\n\t/* Second stage: clear the rest of cluster, and write outs */\n\terr = fat_zeroed_cluster(dir, start_blknr, ++n, bhs, MAX_BUF_PER_PAGE);\n\tif (err)\n\t\tgoto error_free;\n\n\treturn cluster[0];\n\nerror_free:\n\tbrelse(*bh);\n\t*bh = NULL;\n\tn = 0;\nerror_nomem:\n\tfor (i = 0; i < n; i++)\n\t\tbforget(bhs[i]);\n\tfat_free_clusters(dir, cluster[0]);\nerror:\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_add_new_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t\t       int *nr_cluster, struct msdos_dir_entry **de,\n\t\t\t       struct buffer_head **bh, loff_t *i_pos)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tsector_t blknr, start_blknr, last_blknr;\n\tunsigned long size, copy;\n\tint err, i, n, offset, cluster[2];\n\n\t/*\n\t * The minimum cluster size is 512bytes, and maximum entry\n\t * size is 32*slots (672bytes).  So, iff the cluster size is\n\t * 512bytes, we may need two clusters.\n\t */\n\tsize = nr_slots * sizeof(struct msdos_dir_entry);\n\t*nr_cluster = (size + (sbi->cluster_size - 1)) >> sbi->cluster_bits;\n\tBUG_ON(*nr_cluster > 2);\n\n\terr = fat_alloc_clusters(dir, cluster, *nr_cluster);\n\tif (err)\n\t\tgoto error;\n\n\t/*\n\t * First stage: Fill the directory entry.  NOTE: This cluster\n\t * is not referenced from any inode yet, so updates order is\n\t * not important.\n\t */\n\ti = n = copy = 0;\n\tdo {\n\t\tstart_blknr = blknr = fat_clus_to_blknr(sbi, cluster[i]);\n\t\tlast_blknr = start_blknr + sbi->sec_per_clus;\n\t\twhile (blknr < last_blknr) {\n\t\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\t\tif (!bhs[n]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error_nomem;\n\t\t\t}\n\n\t\t\t/* fill the directory entry */\n\t\t\tcopy = min(size, sb->s_blocksize);\n\t\t\tmemcpy(bhs[n]->b_data, slots, copy);\n\t\t\tslots += copy;\n\t\t\tsize -= copy;\n\t\t\tset_buffer_uptodate(bhs[n]);\n\t\t\tmark_buffer_dirty_inode(bhs[n], dir);\n\t\t\tif (!size)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tblknr++;\n\t\t}\n\t} while (++i < *nr_cluster);\n\n\tmemset(bhs[n]->b_data + copy, 0, sb->s_blocksize - copy);\n\toffset = copy - sizeof(struct msdos_dir_entry);\n\tget_bh(bhs[n]);\n\t*bh = bhs[n];\n\t*de = (struct msdos_dir_entry *)((*bh)->b_data + offset);\n\t*i_pos = fat_make_i_pos(sb, *bh, *de);\n\n\t/* Second stage: clear the rest of cluster, and write outs */\n\terr = fat_zeroed_cluster(dir, start_blknr, ++n, bhs, MAX_BUF_PER_PAGE);\n\tif (err)\n\t\tgoto error_free;\n\n\treturn cluster[0];\n\nerror_free:\n\tbrelse(*bh);\n\t*bh = NULL;\n\tn = 0;\nerror_nomem:\n\tfor (i = 0; i < n; i++)\n\t\tbforget(bhs[i]);\n\tfat_free_clusters(dir, cluster[0]);\nerror:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bhs[i]"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bhs[i]",
            "dir"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bhs[i]->b_data + offset",
            "slots",
            "copy"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "sb->s_blocksize - offset",
            "size"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_sync_bhs",
          "args": [
            "bhs",
            "long_bhs"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sync_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "269-282",
          "snippet": "int fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bhs[i]->b_data + offset",
            "slots",
            "copy"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "sb->s_blocksize - offset",
            "size"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"Corrupted directory (i_pos %lld)\"",
            "MSDOS_I(dir)->i_pos"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FREE",
          "args": [
            "de->name"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_get_entry",
          "args": [
            "dir",
            "&pos",
            "&bh",
            "&de"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "120-133",
          "snippet": "static inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_add_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t    struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh, *prev, *bhs[3]; /* 32*slots (672bytes) */\n\tstruct msdos_dir_entry *uninitialized_var(de);\n\tint err, free_slots, i, nr_bhs;\n\tloff_t pos, i_pos;\n\n\tsinfo->nr_slots = nr_slots;\n\n\t/* First stage: search free directory entries */\n\tfree_slots = nr_bhs = 0;\n\tbh = prev = NULL;\n\tpos = 0;\n\terr = -ENOSPC;\n\twhile (fat_get_entry(dir, &pos, &bh, &de) > -1) {\n\t\t/* check the maximum size of directory */\n\t\tif (pos >= FAT_MAX_DIR_SIZE)\n\t\t\tgoto error;\n\n\t\tif (IS_FREE(de->name)) {\n\t\t\tif (prev != bh) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tbhs[nr_bhs] = prev = bh;\n\t\t\t\tnr_bhs++;\n\t\t\t}\n\t\t\tfree_slots++;\n\t\t\tif (free_slots == nr_slots)\n\t\t\t\tgoto found;\n\t\t} else {\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tprev = NULL;\n\t\t\tfree_slots = nr_bhs = 0;\n\t\t}\n\t}\n\tif (dir->i_ino == MSDOS_ROOT_INO) {\n\t\tif (sbi->fat_bits != 32)\n\t\t\tgoto error;\n\t} else if (MSDOS_I(dir)->i_start == 0) {\n\t\tfat_msg(sb, KERN_ERR, \"Corrupted directory (i_pos %lld)\",\n\t\t       MSDOS_I(dir)->i_pos);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\nfound:\n\terr = 0;\n\tpos -= free_slots * sizeof(*de);\n\tnr_slots -= free_slots;\n\tif (free_slots) {\n\t\t/*\n\t\t * Second stage: filling the free entries with new entries.\n\t\t * NOTE: If this slots has shortname, first, we write\n\t\t * the long name slots, then write the short name.\n\t\t */\n\t\tint size = free_slots * sizeof(*de);\n\t\tint offset = pos & (sb->s_blocksize - 1);\n\t\tint long_bhs = nr_bhs - (nr_slots == 0);\n\n\t\t/* Fill the long name slots. */\n\t\tfor (i = 0; i < long_bhs; i++) {\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\toffset = 0;\n\t\t\tslots += copy;\n\t\t\tsize -= copy;\n\t\t}\n\t\tif (long_bhs && IS_DIRSYNC(dir))\n\t\t\terr = fat_sync_bhs(bhs, long_bhs);\n\t\tif (!err && i < nr_bhs) {\n\t\t\t/* Fill the short name slot. */\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\tif (IS_DIRSYNC(dir))\n\t\t\t\terr = sync_dirty_buffer(bhs[i]);\n\t\t}\n\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\tbrelse(bhs[i]);\n\t\tif (err)\n\t\t\tgoto error_remove;\n\t}\n\n\tif (nr_slots) {\n\t\tint cluster, nr_cluster;\n\n\t\t/*\n\t\t * Third stage: allocate the cluster for new entries.\n\t\t * And initialize the cluster with new entries, then\n\t\t * add the cluster to dir.\n\t\t */\n\t\tcluster = fat_add_new_entries(dir, slots, nr_slots, &nr_cluster,\n\t\t\t\t\t      &de, &bh, &i_pos);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error_remove;\n\t\t}\n\t\terr = fat_chain_add(dir, cluster, nr_cluster);\n\t\tif (err) {\n\t\t\tfat_free_clusters(dir, cluster);\n\t\t\tgoto error_remove;\n\t\t}\n\t\tif (dir->i_size & (sbi->cluster_size - 1)) {\n\t\t\tfat_fs_error(sb, \"Odd directory size\");\n\t\t\tdir->i_size = (dir->i_size + sbi->cluster_size - 1)\n\t\t\t\t& ~((loff_t)sbi->cluster_size - 1);\n\t\t}\n\t\tdir->i_size += nr_cluster << sbi->cluster_bits;\n\t\tMSDOS_I(dir)->mmu_private += nr_cluster << sbi->cluster_bits;\n\t}\n\tsinfo->slot_off = pos;\n\tsinfo->de = de;\n\tsinfo->bh = bh;\n\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\n\treturn 0;\n\nerror:\n\tbrelse(bh);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\treturn err;\n\nerror_remove:\n\tbrelse(bh);\n\tif (free_slots)\n\t\t__fat_remove_entries(dir, pos, free_slots);\n\treturn err;\n}"
  },
  {
    "function_name": "fat_add_new_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "1193-1271",
    "snippet": "static int fat_add_new_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t\t       int *nr_cluster, struct msdos_dir_entry **de,\n\t\t\t       struct buffer_head **bh, loff_t *i_pos)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tsector_t blknr, start_blknr, last_blknr;\n\tunsigned long size, copy;\n\tint err, i, n, offset, cluster[2];\n\n\t/*\n\t * The minimum cluster size is 512bytes, and maximum entry\n\t * size is 32*slots (672bytes).  So, iff the cluster size is\n\t * 512bytes, we may need two clusters.\n\t */\n\tsize = nr_slots * sizeof(struct msdos_dir_entry);\n\t*nr_cluster = (size + (sbi->cluster_size - 1)) >> sbi->cluster_bits;\n\tBUG_ON(*nr_cluster > 2);\n\n\terr = fat_alloc_clusters(dir, cluster, *nr_cluster);\n\tif (err)\n\t\tgoto error;\n\n\t/*\n\t * First stage: Fill the directory entry.  NOTE: This cluster\n\t * is not referenced from any inode yet, so updates order is\n\t * not important.\n\t */\n\ti = n = copy = 0;\n\tdo {\n\t\tstart_blknr = blknr = fat_clus_to_blknr(sbi, cluster[i]);\n\t\tlast_blknr = start_blknr + sbi->sec_per_clus;\n\t\twhile (blknr < last_blknr) {\n\t\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\t\tif (!bhs[n]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error_nomem;\n\t\t\t}\n\n\t\t\t/* fill the directory entry */\n\t\t\tcopy = min(size, sb->s_blocksize);\n\t\t\tmemcpy(bhs[n]->b_data, slots, copy);\n\t\t\tslots += copy;\n\t\t\tsize -= copy;\n\t\t\tset_buffer_uptodate(bhs[n]);\n\t\t\tmark_buffer_dirty_inode(bhs[n], dir);\n\t\t\tif (!size)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tblknr++;\n\t\t}\n\t} while (++i < *nr_cluster);\n\n\tmemset(bhs[n]->b_data + copy, 0, sb->s_blocksize - copy);\n\toffset = copy - sizeof(struct msdos_dir_entry);\n\tget_bh(bhs[n]);\n\t*bh = bhs[n];\n\t*de = (struct msdos_dir_entry *)((*bh)->b_data + offset);\n\t*i_pos = fat_make_i_pos(sb, *bh, *de);\n\n\t/* Second stage: clear the rest of cluster, and write outs */\n\terr = fat_zeroed_cluster(dir, start_blknr, ++n, bhs, MAX_BUF_PER_PAGE);\n\tif (err)\n\t\tgoto error_free;\n\n\treturn cluster[0];\n\nerror_free:\n\tbrelse(*bh);\n\t*bh = NULL;\n\tn = 0;\nerror_nomem:\n\tfor (i = 0; i < n; i++)\n\t\tbforget(bhs[i]);\n\tfat_free_clusters(dir, cluster[0]);\nerror:\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_free_clusters",
          "args": [
            "dir",
            "cluster[0]"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "fat_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "553-633",
          "snippet": "int fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "bhs[i]"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*bh"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_zeroed_cluster",
          "args": [
            "dir",
            "start_blknr",
            "++n",
            "bhs",
            "MAX_BUF_PER_PAGE"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "fat_zeroed_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1082-1129",
          "snippet": "static int fat_zeroed_cluster(struct inode *dir, sector_t blknr, int nr_used,\n\t\t\t      struct buffer_head **bhs, int nr_bhs)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tsector_t last_blknr = blknr + MSDOS_SB(sb)->sec_per_clus;\n\tint err, i, n;\n\n\t/* Zeroing the unused blocks on this cluster */\n\tblknr += nr_used;\n\tn = nr_used;\n\twhile (blknr < last_blknr) {\n\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\tif (!bhs[n]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tmemset(bhs[n]->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bhs[n]);\n\t\tmark_buffer_dirty_inode(bhs[n], dir);\n\n\t\tn++;\n\t\tblknr++;\n\t\tif (n == nr_bhs) {\n\t\t\tif (IS_DIRSYNC(dir)) {\n\t\t\t\terr = fat_sync_bhs(bhs, n);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tn = 0;\n\t\t}\n\t}\n\tif (IS_DIRSYNC(dir)) {\n\t\terr = fat_sync_bhs(bhs, n);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\tfor (i = 0; i < n; i++)\n\t\tbrelse(bhs[i]);\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < n; i++)\n\t\tbforget(bhs[i]);\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_zeroed_cluster(struct inode *dir, sector_t blknr, int nr_used,\n\t\t\t      struct buffer_head **bhs, int nr_bhs)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tsector_t last_blknr = blknr + MSDOS_SB(sb)->sec_per_clus;\n\tint err, i, n;\n\n\t/* Zeroing the unused blocks on this cluster */\n\tblknr += nr_used;\n\tn = nr_used;\n\twhile (blknr < last_blknr) {\n\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\tif (!bhs[n]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tmemset(bhs[n]->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bhs[n]);\n\t\tmark_buffer_dirty_inode(bhs[n], dir);\n\n\t\tn++;\n\t\tblknr++;\n\t\tif (n == nr_bhs) {\n\t\t\tif (IS_DIRSYNC(dir)) {\n\t\t\t\terr = fat_sync_bhs(bhs, n);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tn = 0;\n\t\t}\n\t}\n\tif (IS_DIRSYNC(dir)) {\n\t\terr = fat_sync_bhs(bhs, n);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\tfor (i = 0; i < n; i++)\n\t\tbrelse(bhs[i]);\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < n; i++)\n\t\tbforget(bhs[i]);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_make_i_pos",
          "args": [
            "sb",
            "*bh",
            "*de"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "fat_make_i_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "43-49",
          "snippet": "static inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bhs[n]"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bhs[n]->b_data + copy",
            "0",
            "sb->s_blocksize - copy"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bhs[n]",
            "dir"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bhs[n]"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bhs[n]->b_data",
            "slots",
            "copy"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "size",
            "sb->s_blocksize"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "244-251",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "blknr"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_clus_to_blknr",
          "args": [
            "sbi",
            "cluster[i]"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "fat_clus_to_blknr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "219-223",
          "snippet": "static inline sector_t fat_clus_to_blknr(struct msdos_sb_info *sbi, int clus)\n{\n\treturn ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus\n\t\t+ sbi->data_start;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline sector_t fat_clus_to_blknr(struct msdos_sb_info *sbi, int clus)\n{\n\treturn ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus\n\t\t+ sbi->data_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_alloc_clusters",
          "args": [
            "dir",
            "cluster",
            "*nr_cluster"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "fat_alloc_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "465-551",
          "snippet": "int fat_alloc_clusters(struct inode *inode, int *cluster, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent, prev_ent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, count, err, nr_bhs, idx_clus;\n\n\tBUG_ON(nr_cluster > (MAX_BUF_PER_PAGE / 2));\t/* fixed limit */\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid &&\n\t    sbi->free_clusters < nr_cluster) {\n\t\tunlock_fat(sbi);\n\t\treturn -ENOSPC;\n\t}\n\n\terr = nr_bhs = idx_clus = 0;\n\tcount = FAT_START_ENT;\n\tfatent_init(&prev_ent);\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, sbi->prev_free + 1);\n\twhile (count < sbi->max_cluster) {\n\t\tif (fatent.entry >= sbi->max_cluster)\n\t\t\tfatent.entry = FAT_START_ENT;\n\t\tfatent_set_entry(&fatent, fatent.entry);\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Find the free entries in a block */\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE) {\n\t\t\t\tint entry = fatent.entry;\n\n\t\t\t\t/* make the cluster chain */\n\t\t\t\tops->ent_put(&fatent, FAT_ENT_EOF);\n\t\t\t\tif (prev_ent.nr_bhs)\n\t\t\t\t\tops->ent_put(&prev_ent, entry);\n\n\t\t\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\n\t\t\t\tsbi->prev_free = entry;\n\t\t\t\tif (sbi->free_clusters != -1)\n\t\t\t\t\tsbi->free_clusters--;\n\n\t\t\t\tcluster[idx_clus] = entry;\n\t\t\t\tidx_clus++;\n\t\t\t\tif (idx_clus == nr_cluster)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/*\n\t\t\t\t * fat_collect_bhs() gets ref-count of bhs,\n\t\t\t\t * so we can still use the prev_ent.\n\t\t\t\t */\n\t\t\t\tprev_ent = fatent;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count == sbi->max_cluster)\n\t\t\t\tbreak;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\n\t/* Couldn't allocate the free entries */\n\tsbi->free_clusters = 0;\n\tsbi->free_clus_valid = 1;\n\terr = -ENOSPC;\n\nout:\n\tunlock_fat(sbi);\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\n\tif (!err) {\n\t\tif (inode_needs_sync(inode))\n\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (!err)\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t}\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\tif (err && idx_clus)\n\t\tfat_free_clusters(inode, cluster[0]);\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_alloc_clusters(struct inode *inode, int *cluster, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent, prev_ent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, count, err, nr_bhs, idx_clus;\n\n\tBUG_ON(nr_cluster > (MAX_BUF_PER_PAGE / 2));\t/* fixed limit */\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid &&\n\t    sbi->free_clusters < nr_cluster) {\n\t\tunlock_fat(sbi);\n\t\treturn -ENOSPC;\n\t}\n\n\terr = nr_bhs = idx_clus = 0;\n\tcount = FAT_START_ENT;\n\tfatent_init(&prev_ent);\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, sbi->prev_free + 1);\n\twhile (count < sbi->max_cluster) {\n\t\tif (fatent.entry >= sbi->max_cluster)\n\t\t\tfatent.entry = FAT_START_ENT;\n\t\tfatent_set_entry(&fatent, fatent.entry);\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Find the free entries in a block */\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE) {\n\t\t\t\tint entry = fatent.entry;\n\n\t\t\t\t/* make the cluster chain */\n\t\t\t\tops->ent_put(&fatent, FAT_ENT_EOF);\n\t\t\t\tif (prev_ent.nr_bhs)\n\t\t\t\t\tops->ent_put(&prev_ent, entry);\n\n\t\t\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\n\t\t\t\tsbi->prev_free = entry;\n\t\t\t\tif (sbi->free_clusters != -1)\n\t\t\t\t\tsbi->free_clusters--;\n\n\t\t\t\tcluster[idx_clus] = entry;\n\t\t\t\tidx_clus++;\n\t\t\t\tif (idx_clus == nr_cluster)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/*\n\t\t\t\t * fat_collect_bhs() gets ref-count of bhs,\n\t\t\t\t * so we can still use the prev_ent.\n\t\t\t\t */\n\t\t\t\tprev_ent = fatent;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count == sbi->max_cluster)\n\t\t\t\tbreak;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\n\t/* Couldn't allocate the free entries */\n\tsbi->free_clusters = 0;\n\tsbi->free_clus_valid = 1;\n\terr = -ENOSPC;\n\nout:\n\tunlock_fat(sbi);\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\n\tif (!err) {\n\t\tif (inode_needs_sync(inode))\n\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (!err)\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t}\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\tif (err && idx_clus)\n\t\tfat_free_clusters(inode, cluster[0]);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*nr_cluster > 2"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_add_new_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t\t       int *nr_cluster, struct msdos_dir_entry **de,\n\t\t\t       struct buffer_head **bh, loff_t *i_pos)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tsector_t blknr, start_blknr, last_blknr;\n\tunsigned long size, copy;\n\tint err, i, n, offset, cluster[2];\n\n\t/*\n\t * The minimum cluster size is 512bytes, and maximum entry\n\t * size is 32*slots (672bytes).  So, iff the cluster size is\n\t * 512bytes, we may need two clusters.\n\t */\n\tsize = nr_slots * sizeof(struct msdos_dir_entry);\n\t*nr_cluster = (size + (sbi->cluster_size - 1)) >> sbi->cluster_bits;\n\tBUG_ON(*nr_cluster > 2);\n\n\terr = fat_alloc_clusters(dir, cluster, *nr_cluster);\n\tif (err)\n\t\tgoto error;\n\n\t/*\n\t * First stage: Fill the directory entry.  NOTE: This cluster\n\t * is not referenced from any inode yet, so updates order is\n\t * not important.\n\t */\n\ti = n = copy = 0;\n\tdo {\n\t\tstart_blknr = blknr = fat_clus_to_blknr(sbi, cluster[i]);\n\t\tlast_blknr = start_blknr + sbi->sec_per_clus;\n\t\twhile (blknr < last_blknr) {\n\t\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\t\tif (!bhs[n]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error_nomem;\n\t\t\t}\n\n\t\t\t/* fill the directory entry */\n\t\t\tcopy = min(size, sb->s_blocksize);\n\t\t\tmemcpy(bhs[n]->b_data, slots, copy);\n\t\t\tslots += copy;\n\t\t\tsize -= copy;\n\t\t\tset_buffer_uptodate(bhs[n]);\n\t\t\tmark_buffer_dirty_inode(bhs[n], dir);\n\t\t\tif (!size)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tblknr++;\n\t\t}\n\t} while (++i < *nr_cluster);\n\n\tmemset(bhs[n]->b_data + copy, 0, sb->s_blocksize - copy);\n\toffset = copy - sizeof(struct msdos_dir_entry);\n\tget_bh(bhs[n]);\n\t*bh = bhs[n];\n\t*de = (struct msdos_dir_entry *)((*bh)->b_data + offset);\n\t*i_pos = fat_make_i_pos(sb, *bh, *de);\n\n\t/* Second stage: clear the rest of cluster, and write outs */\n\terr = fat_zeroed_cluster(dir, start_blknr, ++n, bhs, MAX_BUF_PER_PAGE);\n\tif (err)\n\t\tgoto error_free;\n\n\treturn cluster[0];\n\nerror_free:\n\tbrelse(*bh);\n\t*bh = NULL;\n\tn = 0;\nerror_nomem:\n\tfor (i = 0; i < n; i++)\n\t\tbforget(bhs[i]);\n\tfat_free_clusters(dir, cluster[0]);\nerror:\n\treturn err;\n}"
  },
  {
    "function_name": "fat_alloc_new_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "1131-1190",
    "snippet": "int fat_alloc_new_dir(struct inode *dir, struct timespec *ts)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tstruct msdos_dir_entry *de;\n\tsector_t blknr;\n\t__le16 date, time;\n\tu8 time_cs;\n\tint err, cluster;\n\n\terr = fat_alloc_clusters(dir, &cluster, 1);\n\tif (err)\n\t\tgoto error;\n\n\tblknr = fat_clus_to_blknr(sbi, cluster);\n\tbhs[0] = sb_getblk(sb, blknr);\n\tif (!bhs[0]) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free;\n\t}\n\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\n\tde = (struct msdos_dir_entry *)bhs[0]->b_data;\n\t/* filling the new directory slots (\".\" and \"..\" entries) */\n\tmemcpy(de[0].name, MSDOS_DOT, MSDOS_NAME);\n\tmemcpy(de[1].name, MSDOS_DOTDOT, MSDOS_NAME);\n\tde->attr = de[1].attr = ATTR_DIR;\n\tde[0].lcase = de[1].lcase = 0;\n\tde[0].time = de[1].time = time;\n\tde[0].date = de[1].date = date;\n\tif (sbi->options.isvfat) {\n\t\t/* extra timestamps */\n\t\tde[0].ctime = de[1].ctime = time;\n\t\tde[0].ctime_cs = de[1].ctime_cs = time_cs;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = date;\n\t} else {\n\t\tde[0].ctime = de[1].ctime = 0;\n\t\tde[0].ctime_cs = de[1].ctime_cs = 0;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = 0;\n\t}\n\tfat_set_start(&de[0], cluster);\n\tfat_set_start(&de[1], MSDOS_I(dir)->i_logstart);\n\tde[0].size = de[1].size = 0;\n\tmemset(de + 2, 0, sb->s_blocksize - 2 * sizeof(*de));\n\tset_buffer_uptodate(bhs[0]);\n\tmark_buffer_dirty_inode(bhs[0], dir);\n\n\terr = fat_zeroed_cluster(dir, blknr, 1, bhs, MAX_BUF_PER_PAGE);\n\tif (err)\n\t\tgoto error_free;\n\n\treturn cluster;\n\nerror_free:\n\tfat_free_clusters(dir, cluster);\nerror:\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_free_clusters",
          "args": [
            "dir",
            "cluster"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "fat_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "553-633",
          "snippet": "int fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_zeroed_cluster",
          "args": [
            "dir",
            "blknr",
            "1",
            "bhs",
            "MAX_BUF_PER_PAGE"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "fat_zeroed_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1082-1129",
          "snippet": "static int fat_zeroed_cluster(struct inode *dir, sector_t blknr, int nr_used,\n\t\t\t      struct buffer_head **bhs, int nr_bhs)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tsector_t last_blknr = blknr + MSDOS_SB(sb)->sec_per_clus;\n\tint err, i, n;\n\n\t/* Zeroing the unused blocks on this cluster */\n\tblknr += nr_used;\n\tn = nr_used;\n\twhile (blknr < last_blknr) {\n\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\tif (!bhs[n]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tmemset(bhs[n]->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bhs[n]);\n\t\tmark_buffer_dirty_inode(bhs[n], dir);\n\n\t\tn++;\n\t\tblknr++;\n\t\tif (n == nr_bhs) {\n\t\t\tif (IS_DIRSYNC(dir)) {\n\t\t\t\terr = fat_sync_bhs(bhs, n);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tn = 0;\n\t\t}\n\t}\n\tif (IS_DIRSYNC(dir)) {\n\t\terr = fat_sync_bhs(bhs, n);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\tfor (i = 0; i < n; i++)\n\t\tbrelse(bhs[i]);\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < n; i++)\n\t\tbforget(bhs[i]);\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_zeroed_cluster(struct inode *dir, sector_t blknr, int nr_used,\n\t\t\t      struct buffer_head **bhs, int nr_bhs)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tsector_t last_blknr = blknr + MSDOS_SB(sb)->sec_per_clus;\n\tint err, i, n;\n\n\t/* Zeroing the unused blocks on this cluster */\n\tblknr += nr_used;\n\tn = nr_used;\n\twhile (blknr < last_blknr) {\n\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\tif (!bhs[n]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tmemset(bhs[n]->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bhs[n]);\n\t\tmark_buffer_dirty_inode(bhs[n], dir);\n\n\t\tn++;\n\t\tblknr++;\n\t\tif (n == nr_bhs) {\n\t\t\tif (IS_DIRSYNC(dir)) {\n\t\t\t\terr = fat_sync_bhs(bhs, n);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tn = 0;\n\t\t}\n\t}\n\tif (IS_DIRSYNC(dir)) {\n\t\terr = fat_sync_bhs(bhs, n);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\tfor (i = 0; i < n; i++)\n\t\tbrelse(bhs[i]);\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < n; i++)\n\t\tbforget(bhs[i]);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bhs[0]",
            "dir"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bhs[0]"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "de + 2",
            "0",
            "sb->s_blocksize - 2 * sizeof(*de)"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_set_start",
          "args": [
            "&de[1]",
            "MSDOS_I(dir)->i_logstart"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "fat_set_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "267-271",
          "snippet": "static inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "dir"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de[1].name",
            "MSDOS_DOTDOT",
            "MSDOS_NAME"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de[0].name",
            "MSDOS_DOT",
            "MSDOS_NAME"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_time_unix2fat",
          "args": [
            "sbi",
            "ts",
            "&time",
            "&date",
            "&time_cs"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "fat_time_unix2fat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "231-266",
          "snippet": "void fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 *time, __le16 *date, u8 *time_cs)\n{\n\tstruct tm tm;\n\ttime_to_tm(ts->tv_sec,\n\t\t   (sbi->options.tz_set ? sbi->options.time_offset :\n\t\t   -sys_tz.tz_minuteswest) * SECS_PER_MIN, &tm);\n\n\t/*  FAT can only support year between 1980 to 2107 */\n\tif (tm.tm_year < 1980 - 1900) {\n\t\t*time = 0;\n\t\t*date = cpu_to_le16((0 << 9) | (1 << 5) | 1);\n\t\tif (time_cs)\n\t\t\t*time_cs = 0;\n\t\treturn;\n\t}\n\tif (tm.tm_year > 2107 - 1900) {\n\t\t*time = cpu_to_le16((23 << 11) | (59 << 5) | 29);\n\t\t*date = cpu_to_le16((127 << 9) | (12 << 5) | 31);\n\t\tif (time_cs)\n\t\t\t*time_cs = 199;\n\t\treturn;\n\t}\n\n\t/* from 1900 -> from 1980 */\n\ttm.tm_year -= 80;\n\t/* 0~11 -> 1~12 */\n\ttm.tm_mon++;\n\t/* 0~59 -> 0~29(2sec counts) */\n\ttm.tm_sec >>= 1;\n\n\t*time = cpu_to_le16(tm.tm_hour << 11 | tm.tm_min << 5 | tm.tm_sec);\n\t*date = cpu_to_le16(tm.tm_year << 9 | tm.tm_mon << 5 | tm.tm_mday);\n\tif (time_cs)\n\t\t*time_cs = (ts->tv_sec & 1) * 100 + ts->tv_nsec / 10000000;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SECS_PER_MIN\t60"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define SECS_PER_MIN\t60\n\nvoid fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 *time, __le16 *date, u8 *time_cs)\n{\n\tstruct tm tm;\n\ttime_to_tm(ts->tv_sec,\n\t\t   (sbi->options.tz_set ? sbi->options.time_offset :\n\t\t   -sys_tz.tz_minuteswest) * SECS_PER_MIN, &tm);\n\n\t/*  FAT can only support year between 1980 to 2107 */\n\tif (tm.tm_year < 1980 - 1900) {\n\t\t*time = 0;\n\t\t*date = cpu_to_le16((0 << 9) | (1 << 5) | 1);\n\t\tif (time_cs)\n\t\t\t*time_cs = 0;\n\t\treturn;\n\t}\n\tif (tm.tm_year > 2107 - 1900) {\n\t\t*time = cpu_to_le16((23 << 11) | (59 << 5) | 29);\n\t\t*date = cpu_to_le16((127 << 9) | (12 << 5) | 31);\n\t\tif (time_cs)\n\t\t\t*time_cs = 199;\n\t\treturn;\n\t}\n\n\t/* from 1900 -> from 1980 */\n\ttm.tm_year -= 80;\n\t/* 0~11 -> 1~12 */\n\ttm.tm_mon++;\n\t/* 0~59 -> 0~29(2sec counts) */\n\ttm.tm_sec >>= 1;\n\n\t*time = cpu_to_le16(tm.tm_hour << 11 | tm.tm_min << 5 | tm.tm_sec);\n\t*date = cpu_to_le16(tm.tm_year << 9 | tm.tm_mon << 5 | tm.tm_mday);\n\tif (time_cs)\n\t\t*time_cs = (ts->tv_sec & 1) * 100 + ts->tv_nsec / 10000000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "blknr"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_clus_to_blknr",
          "args": [
            "sbi",
            "cluster"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "fat_clus_to_blknr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "219-223",
          "snippet": "static inline sector_t fat_clus_to_blknr(struct msdos_sb_info *sbi, int clus)\n{\n\treturn ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus\n\t\t+ sbi->data_start;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline sector_t fat_clus_to_blknr(struct msdos_sb_info *sbi, int clus)\n{\n\treturn ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus\n\t\t+ sbi->data_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_alloc_clusters",
          "args": [
            "dir",
            "&cluster",
            "1"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "fat_alloc_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "465-551",
          "snippet": "int fat_alloc_clusters(struct inode *inode, int *cluster, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent, prev_ent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, count, err, nr_bhs, idx_clus;\n\n\tBUG_ON(nr_cluster > (MAX_BUF_PER_PAGE / 2));\t/* fixed limit */\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid &&\n\t    sbi->free_clusters < nr_cluster) {\n\t\tunlock_fat(sbi);\n\t\treturn -ENOSPC;\n\t}\n\n\terr = nr_bhs = idx_clus = 0;\n\tcount = FAT_START_ENT;\n\tfatent_init(&prev_ent);\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, sbi->prev_free + 1);\n\twhile (count < sbi->max_cluster) {\n\t\tif (fatent.entry >= sbi->max_cluster)\n\t\t\tfatent.entry = FAT_START_ENT;\n\t\tfatent_set_entry(&fatent, fatent.entry);\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Find the free entries in a block */\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE) {\n\t\t\t\tint entry = fatent.entry;\n\n\t\t\t\t/* make the cluster chain */\n\t\t\t\tops->ent_put(&fatent, FAT_ENT_EOF);\n\t\t\t\tif (prev_ent.nr_bhs)\n\t\t\t\t\tops->ent_put(&prev_ent, entry);\n\n\t\t\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\n\t\t\t\tsbi->prev_free = entry;\n\t\t\t\tif (sbi->free_clusters != -1)\n\t\t\t\t\tsbi->free_clusters--;\n\n\t\t\t\tcluster[idx_clus] = entry;\n\t\t\t\tidx_clus++;\n\t\t\t\tif (idx_clus == nr_cluster)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/*\n\t\t\t\t * fat_collect_bhs() gets ref-count of bhs,\n\t\t\t\t * so we can still use the prev_ent.\n\t\t\t\t */\n\t\t\t\tprev_ent = fatent;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count == sbi->max_cluster)\n\t\t\t\tbreak;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\n\t/* Couldn't allocate the free entries */\n\tsbi->free_clusters = 0;\n\tsbi->free_clus_valid = 1;\n\terr = -ENOSPC;\n\nout:\n\tunlock_fat(sbi);\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\n\tif (!err) {\n\t\tif (inode_needs_sync(inode))\n\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (!err)\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t}\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\tif (err && idx_clus)\n\t\tfat_free_clusters(inode, cluster[0]);\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_alloc_clusters(struct inode *inode, int *cluster, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent, prev_ent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, count, err, nr_bhs, idx_clus;\n\n\tBUG_ON(nr_cluster > (MAX_BUF_PER_PAGE / 2));\t/* fixed limit */\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid &&\n\t    sbi->free_clusters < nr_cluster) {\n\t\tunlock_fat(sbi);\n\t\treturn -ENOSPC;\n\t}\n\n\terr = nr_bhs = idx_clus = 0;\n\tcount = FAT_START_ENT;\n\tfatent_init(&prev_ent);\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, sbi->prev_free + 1);\n\twhile (count < sbi->max_cluster) {\n\t\tif (fatent.entry >= sbi->max_cluster)\n\t\t\tfatent.entry = FAT_START_ENT;\n\t\tfatent_set_entry(&fatent, fatent.entry);\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Find the free entries in a block */\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE) {\n\t\t\t\tint entry = fatent.entry;\n\n\t\t\t\t/* make the cluster chain */\n\t\t\t\tops->ent_put(&fatent, FAT_ENT_EOF);\n\t\t\t\tif (prev_ent.nr_bhs)\n\t\t\t\t\tops->ent_put(&prev_ent, entry);\n\n\t\t\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\n\t\t\t\tsbi->prev_free = entry;\n\t\t\t\tif (sbi->free_clusters != -1)\n\t\t\t\t\tsbi->free_clusters--;\n\n\t\t\t\tcluster[idx_clus] = entry;\n\t\t\t\tidx_clus++;\n\t\t\t\tif (idx_clus == nr_cluster)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/*\n\t\t\t\t * fat_collect_bhs() gets ref-count of bhs,\n\t\t\t\t * so we can still use the prev_ent.\n\t\t\t\t */\n\t\t\t\tprev_ent = fatent;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count == sbi->max_cluster)\n\t\t\t\tbreak;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\n\t/* Couldn't allocate the free entries */\n\tsbi->free_clusters = 0;\n\tsbi->free_clus_valid = 1;\n\terr = -ENOSPC;\n\nout:\n\tunlock_fat(sbi);\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\n\tif (!err) {\n\t\tif (inode_needs_sync(inode))\n\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (!err)\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t}\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\tif (err && idx_clus)\n\t\tfat_free_clusters(inode, cluster[0]);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_alloc_new_dir(struct inode *dir, struct timespec *ts)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tstruct msdos_dir_entry *de;\n\tsector_t blknr;\n\t__le16 date, time;\n\tu8 time_cs;\n\tint err, cluster;\n\n\terr = fat_alloc_clusters(dir, &cluster, 1);\n\tif (err)\n\t\tgoto error;\n\n\tblknr = fat_clus_to_blknr(sbi, cluster);\n\tbhs[0] = sb_getblk(sb, blknr);\n\tif (!bhs[0]) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free;\n\t}\n\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\n\tde = (struct msdos_dir_entry *)bhs[0]->b_data;\n\t/* filling the new directory slots (\".\" and \"..\" entries) */\n\tmemcpy(de[0].name, MSDOS_DOT, MSDOS_NAME);\n\tmemcpy(de[1].name, MSDOS_DOTDOT, MSDOS_NAME);\n\tde->attr = de[1].attr = ATTR_DIR;\n\tde[0].lcase = de[1].lcase = 0;\n\tde[0].time = de[1].time = time;\n\tde[0].date = de[1].date = date;\n\tif (sbi->options.isvfat) {\n\t\t/* extra timestamps */\n\t\tde[0].ctime = de[1].ctime = time;\n\t\tde[0].ctime_cs = de[1].ctime_cs = time_cs;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = date;\n\t} else {\n\t\tde[0].ctime = de[1].ctime = 0;\n\t\tde[0].ctime_cs = de[1].ctime_cs = 0;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = 0;\n\t}\n\tfat_set_start(&de[0], cluster);\n\tfat_set_start(&de[1], MSDOS_I(dir)->i_logstart);\n\tde[0].size = de[1].size = 0;\n\tmemset(de + 2, 0, sb->s_blocksize - 2 * sizeof(*de));\n\tset_buffer_uptodate(bhs[0]);\n\tmark_buffer_dirty_inode(bhs[0], dir);\n\n\terr = fat_zeroed_cluster(dir, blknr, 1, bhs, MAX_BUF_PER_PAGE);\n\tif (err)\n\t\tgoto error_free;\n\n\treturn cluster;\n\nerror_free:\n\tfat_free_clusters(dir, cluster);\nerror:\n\treturn err;\n}"
  },
  {
    "function_name": "fat_zeroed_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "1082-1129",
    "snippet": "static int fat_zeroed_cluster(struct inode *dir, sector_t blknr, int nr_used,\n\t\t\t      struct buffer_head **bhs, int nr_bhs)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tsector_t last_blknr = blknr + MSDOS_SB(sb)->sec_per_clus;\n\tint err, i, n;\n\n\t/* Zeroing the unused blocks on this cluster */\n\tblknr += nr_used;\n\tn = nr_used;\n\twhile (blknr < last_blknr) {\n\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\tif (!bhs[n]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tmemset(bhs[n]->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bhs[n]);\n\t\tmark_buffer_dirty_inode(bhs[n], dir);\n\n\t\tn++;\n\t\tblknr++;\n\t\tif (n == nr_bhs) {\n\t\t\tif (IS_DIRSYNC(dir)) {\n\t\t\t\terr = fat_sync_bhs(bhs, n);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tn = 0;\n\t\t}\n\t}\n\tif (IS_DIRSYNC(dir)) {\n\t\terr = fat_sync_bhs(bhs, n);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\tfor (i = 0; i < n; i++)\n\t\tbrelse(bhs[i]);\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < n; i++)\n\t\tbforget(bhs[i]);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "bhs[i]"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhs[i]"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_sync_bhs",
          "args": [
            "bhs",
            "n"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sync_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "269-282",
          "snippet": "int fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bhs[n]",
            "dir"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bhs[n]"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bhs[n]->b_data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "blknr"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_zeroed_cluster(struct inode *dir, sector_t blknr, int nr_used,\n\t\t\t      struct buffer_head **bhs, int nr_bhs)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tsector_t last_blknr = blknr + MSDOS_SB(sb)->sec_per_clus;\n\tint err, i, n;\n\n\t/* Zeroing the unused blocks on this cluster */\n\tblknr += nr_used;\n\tn = nr_used;\n\twhile (blknr < last_blknr) {\n\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\tif (!bhs[n]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tmemset(bhs[n]->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bhs[n]);\n\t\tmark_buffer_dirty_inode(bhs[n], dir);\n\n\t\tn++;\n\t\tblknr++;\n\t\tif (n == nr_bhs) {\n\t\t\tif (IS_DIRSYNC(dir)) {\n\t\t\t\terr = fat_sync_bhs(bhs, n);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tn = 0;\n\t\t}\n\t}\n\tif (IS_DIRSYNC(dir)) {\n\t\terr = fat_sync_bhs(bhs, n);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\tfor (i = 0; i < n; i++)\n\t\tbrelse(bhs[i]);\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < n; i++)\n\t\tbforget(bhs[i]);\n\treturn err;\n}"
  },
  {
    "function_name": "fat_remove_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "1030-1079",
    "snippet": "int fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_sync_inode",
          "args": [
            "dir"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "824-827",
          "snippet": "int fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"Couldn't remove the long name slots\""
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fat_remove_entries",
          "args": [
            "dir",
            "sinfo->slot_off",
            "nr_slots"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_remove_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "995-1028",
          "snippet": "static int __fat_remove_entries(struct inode *dir, loff_t pos, int nr_slots)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de, *endp;\n\tint err = 0, orig_slots;\n\n\twhile (nr_slots) {\n\t\tbh = NULL;\n\t\tif (fat_get_entry(dir, &pos, &bh, &de) < 0) {\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\torig_slots = nr_slots;\n\t\tendp = (struct msdos_dir_entry *)(bh->b_data + sb->s_blocksize);\n\t\twhile (nr_slots && de < endp) {\n\t\t\tde->name[0] = DELETED_FLAG;\n\t\t\tde++;\n\t\t\tnr_slots--;\n\t\t}\n\t\tmark_buffer_dirty_inode(bh, dir);\n\t\tif (IS_DIRSYNC(dir))\n\t\t\terr = sync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t/* pos is *next* de's position, so this does `- sizeof(de)' */\n\t\tpos += ((orig_slots - nr_slots) * sizeof(*de)) - sizeof(*de);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int __fat_remove_entries(struct inode *dir, loff_t pos, int nr_slots)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de, *endp;\n\tint err = 0, orig_slots;\n\n\twhile (nr_slots) {\n\t\tbh = NULL;\n\t\tif (fat_get_entry(dir, &pos, &bh, &de) < 0) {\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\torig_slots = nr_slots;\n\t\tendp = (struct msdos_dir_entry *)(bh->b_data + sb->s_blocksize);\n\t\twhile (nr_slots && de < endp) {\n\t\t\tde->name[0] = DELETED_FLAG;\n\t\t\tde++;\n\t\t\tnr_slots--;\n\t\t}\n\t\tmark_buffer_dirty_inode(bh, dir);\n\t\tif (IS_DIRSYNC(dir))\n\t\t\terr = sync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t/* pos is *next* de's position, so this does `- sizeof(de)' */\n\t\tpos += ((orig_slots - nr_slots) * sizeof(*de)) - sizeof(*de);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "dir"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__fat_remove_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "995-1028",
    "snippet": "static int __fat_remove_entries(struct inode *dir, loff_t pos, int nr_slots)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de, *endp;\n\tint err = 0, orig_slots;\n\n\twhile (nr_slots) {\n\t\tbh = NULL;\n\t\tif (fat_get_entry(dir, &pos, &bh, &de) < 0) {\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\torig_slots = nr_slots;\n\t\tendp = (struct msdos_dir_entry *)(bh->b_data + sb->s_blocksize);\n\t\twhile (nr_slots && de < endp) {\n\t\t\tde->name[0] = DELETED_FLAG;\n\t\t\tde++;\n\t\t\tnr_slots--;\n\t\t}\n\t\tmark_buffer_dirty_inode(bh, dir);\n\t\tif (IS_DIRSYNC(dir))\n\t\t\terr = sync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t/* pos is *next* de's position, so this does `- sizeof(de)' */\n\t\tpos += ((orig_slots - nr_slots) * sizeof(*de)) - sizeof(*de);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "dir"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_entry",
          "args": [
            "dir",
            "&pos",
            "&bh",
            "&de"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "120-133",
          "snippet": "static inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int __fat_remove_entries(struct inode *dir, loff_t pos, int nr_slots)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de, *endp;\n\tint err = 0, orig_slots;\n\n\twhile (nr_slots) {\n\t\tbh = NULL;\n\t\tif (fat_get_entry(dir, &pos, &bh, &de) < 0) {\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\torig_slots = nr_slots;\n\t\tendp = (struct msdos_dir_entry *)(bh->b_data + sb->s_blocksize);\n\t\twhile (nr_slots && de < endp) {\n\t\t\tde->name[0] = DELETED_FLAG;\n\t\t\tde++;\n\t\t\tnr_slots--;\n\t\t}\n\t\tmark_buffer_dirty_inode(bh, dir);\n\t\tif (IS_DIRSYNC(dir))\n\t\t\terr = sync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t/* pos is *next* de's position, so this does `- sizeof(de)' */\n\t\tpos += ((orig_slots - nr_slots) * sizeof(*de)) - sizeof(*de);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "fat_scan_logstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "976-993",
    "snippet": "int fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_make_i_pos",
          "args": [
            "sb",
            "sinfo->bh",
            "sinfo->de"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "fat_make_i_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "43-49",
          "snippet": "static inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_start",
          "args": [
            "MSDOS_SB(sb)",
            "sinfo->de"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "258-265",
          "snippet": "static inline int fat_get_start(const struct msdos_sb_info *sbi,\n\t\t\t\tconst struct msdos_dir_entry *de)\n{\n\tint cluster = le16_to_cpu(de->start);\n\tif (sbi->fat_bits == 32)\n\t\tcluster |= (le16_to_cpu(de->starthi) << 16);\n\treturn cluster;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int fat_get_start(const struct msdos_sb_info *sbi,\n\t\t\t\tconst struct msdos_dir_entry *de)\n{\n\tint cluster = le16_to_cpu(de->start);\n\tif (sbi->fat_bits == 32)\n\t\tcluster |= (le16_to_cpu(de->starthi) << 16);\n\treturn cluster;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_short_entry",
          "args": [
            "dir",
            "&sinfo->slot_off",
            "&sinfo->bh",
            "&sinfo->de"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_short_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "870-880",
          "snippet": "static int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t/* free entry or long name entry or volume label */\n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t/* free entry or long name entry or volume label */\n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "fat_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "952-969",
    "snippet": "int fat_scan(struct inode *dir, const unsigned char *name,\n\t     struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (!strncmp(sinfo->de->name, name, MSDOS_NAME)) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_make_i_pos",
          "args": [
            "sb",
            "sinfo->bh",
            "sinfo->de"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "fat_make_i_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "43-49",
          "snippet": "static inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "sinfo->de->name",
            "name",
            "MSDOS_NAME"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_get_short_entry",
          "args": [
            "dir",
            "&sinfo->slot_off",
            "&sinfo->bh",
            "&sinfo->de"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_short_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "870-880",
          "snippet": "static int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t/* free entry or long name entry or volume label */\n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t/* free entry or long name entry or volume label */\n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_scan(struct inode *dir, const unsigned char *name,\n\t     struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (!strncmp(sinfo->de->name, name, MSDOS_NAME)) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "fat_subdirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "931-946",
    "snippet": "int fat_subdirs(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint count = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (de->attr & ATTR_DIR)\n\t\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_short_entry",
          "args": [
            "dir",
            "&cpos",
            "&bh",
            "&de"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_short_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "870-880",
          "snippet": "static int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t/* free entry or long name entry or volume label */\n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t/* free entry or long name entry or volume label */\n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_subdirs(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint count = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (de->attr & ATTR_DIR)\n\t\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}"
  },
  {
    "function_name": "fat_dir_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "906-924",
    "snippet": "int fat_dir_empty(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint result = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (strncmp(de->name, MSDOS_DOT   , MSDOS_NAME) &&\n\t\t    strncmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\t\tresult = -ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn result;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "de->name",
            "MSDOS_DOTDOT",
            "MSDOS_NAME"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "de->name",
            "MSDOS_DOT",
            "MSDOS_NAME"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_get_short_entry",
          "args": [
            "dir",
            "&cpos",
            "&bh",
            "&de"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_short_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "870-880",
          "snippet": "static int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t/* free entry or long name entry or volume label */\n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t/* free entry or long name entry or volume label */\n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_dir_empty(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint result = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (strncmp(de->name, MSDOS_DOT   , MSDOS_NAME) &&\n\t\t    strncmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\t\tresult = -ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn result;\n}"
  },
  {
    "function_name": "fat_get_dotdot_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "891-902",
    "snippet": "int fat_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,\n\t\t\t struct msdos_dir_entry **de)\n{\n\tloff_t offset = 0;\n\n\t*de = NULL;\n\twhile (fat_get_short_entry(dir, &offset, bh, de) >= 0) {\n\t\tif (!strncmp((*de)->name, MSDOS_DOTDOT, MSDOS_NAME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "(*de)->name",
            "MSDOS_DOTDOT",
            "MSDOS_NAME"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_get_short_entry",
          "args": [
            "dir",
            "&offset",
            "bh",
            "de"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_short_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "870-880",
          "snippet": "static int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t/* free entry or long name entry or volume label */\n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t/* free entry or long name entry or volume label */\n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,\n\t\t\t struct msdos_dir_entry **de)\n{\n\tloff_t offset = 0;\n\n\t*de = NULL;\n\twhile (fat_get_short_entry(dir, &offset, bh, de) >= 0) {\n\t\tif (!strncmp((*de)->name, MSDOS_DOTDOT, MSDOS_NAME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "fat_get_short_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "870-880",
    "snippet": "static int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t/* free entry or long name entry or volume label */\n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_FREE",
          "args": [
            "(*de)->name"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_get_entry",
          "args": [
            "dir",
            "pos",
            "bh",
            "de"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "120-133",
          "snippet": "static inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t/* free entry or long name entry or volume label */\n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "fat_compat_dir_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "824-856",
    "snippet": "static long fat_compat_dir_ioctl(struct file *filp, unsigned cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct compat_dirent __user *d1 = compat_ptr(arg);\n\tint short_only, both;\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_SHORT32:\n\t\tshort_only = 1;\n\t\tboth = 0;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_BOTH32:\n\t\tshort_only = 0;\n\t\tboth = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn fat_generic_ioctl(filp, cmd, (unsigned long)arg);\n\t}\n\n\tif (!access_ok(VERIFY_WRITE, d1, sizeof(struct compat_dirent[2])))\n\t\treturn -EFAULT;\n\t/*\n\t * Yes, we don't need this put_user() absolutely. However old\n\t * code didn't return the right value. So, app use this value,\n\t * in order to check whether it is EOF.\n\t */\n\tif (put_user(0, &d1->d_reclen))\n\t\treturn -EFAULT;\n\n\treturn fat_ioctl_readdir(inode, filp, d1, fat_compat_ioctl_filldir,\n\t\t\t\t short_only, both);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define\tVFAT_IOCTL_READDIR_SHORT32\t_IOR('r', 2, struct compat_dirent[2])",
      "#define\tVFAT_IOCTL_READDIR_BOTH32\t_IOR('r', 1, struct compat_dirent[2])"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_ioctl_readdir",
          "args": [
            "inode",
            "filp",
            "d1",
            "fat_compat_ioctl_filldir",
            "short_only",
            "both"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ioctl_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "758-782",
          "snippet": "int fat_ioctl_readdir(struct inode *inode, struct file *file,\n\t\t\t     void __user *dirent, filldir_t filldir,\n\t\t\t     int short_only, int both)\n{\n\tstruct fat_ioctl_filldir_callback buf = {\n\t\t.ctx.actor = filldir,\n\t\t.dirent = dirent\n\t};\n\tint ret;\n\n\tbuf.dirent = dirent;\n\tbuf.result = 0;\n\tmutex_lock(&inode->i_mutex);\n\tbuf.ctx.pos = file->f_pos;\n\tret = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tret = __fat_readdir(inode, file, &buf.ctx,\n\t\t\t\t    short_only, both ? &buf : NULL);\n\t\tfile->f_pos = buf.ctx.pos;\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret >= 0)\n\t\tret = buf.result;\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_ioctl_readdir(struct inode *inode, struct file *file,\n\t\t\t     void __user *dirent, filldir_t filldir,\n\t\t\t     int short_only, int both)\n{\n\tstruct fat_ioctl_filldir_callback buf = {\n\t\t.ctx.actor = filldir,\n\t\t.dirent = dirent\n\t};\n\tint ret;\n\n\tbuf.dirent = dirent;\n\tbuf.result = 0;\n\tmutex_lock(&inode->i_mutex);\n\tbuf.ctx.pos = file->f_pos;\n\tret = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tret = __fat_readdir(inode, file, &buf.ctx,\n\t\t\t\t    short_only, both ? &buf : NULL);\n\t\tfile->f_pos = buf.ctx.pos;\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret >= 0)\n\t\tret = buf.result;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "0",
            "&d1->d_reclen"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "d1",
            "sizeof(struct compat_dirent[2])"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_generic_ioctl",
          "args": [
            "filp",
            "cmd",
            "(unsigned long)arg"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "fat_generic_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "123-138",
          "snippet": "long fat_generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 __user *user_attr = (u32 __user *)arg;\n\n\tswitch (cmd) {\n\tcase FAT_IOCTL_GET_ATTRIBUTES:\n\t\treturn fat_ioctl_get_attributes(inode, user_attr);\n\tcase FAT_IOCTL_SET_ATTRIBUTES:\n\t\treturn fat_ioctl_set_attributes(filp, user_attr);\n\tcase FAT_IOCTL_GET_VOLUME_ID:\n\t\treturn fat_ioctl_get_volume_id(inode, user_attr);\n\tdefault:\n\t\treturn -ENOTTY;\t/* Inappropriate ioctl for device */\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nlong fat_generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 __user *user_attr = (u32 __user *)arg;\n\n\tswitch (cmd) {\n\tcase FAT_IOCTL_GET_ATTRIBUTES:\n\t\treturn fat_ioctl_get_attributes(inode, user_attr);\n\tcase FAT_IOCTL_SET_ATTRIBUTES:\n\t\treturn fat_ioctl_set_attributes(filp, user_attr);\n\tcase FAT_IOCTL_GET_VOLUME_ID:\n\t\treturn fat_ioctl_get_volume_id(inode, user_attr);\n\tdefault:\n\t\treturn -ENOTTY;\t/* Inappropriate ioctl for device */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define\tVFAT_IOCTL_READDIR_SHORT32\t_IOR('r', 2, struct compat_dirent[2])\n#define\tVFAT_IOCTL_READDIR_BOTH32\t_IOR('r', 1, struct compat_dirent[2])\n\nstatic long fat_compat_dir_ioctl(struct file *filp, unsigned cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct compat_dirent __user *d1 = compat_ptr(arg);\n\tint short_only, both;\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_SHORT32:\n\t\tshort_only = 1;\n\t\tboth = 0;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_BOTH32:\n\t\tshort_only = 0;\n\t\tboth = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn fat_generic_ioctl(filp, cmd, (unsigned long)arg);\n\t}\n\n\tif (!access_ok(VERIFY_WRITE, d1, sizeof(struct compat_dirent[2])))\n\t\treturn -EFAULT;\n\t/*\n\t * Yes, we don't need this put_user() absolutely. However old\n\t * code didn't return the right value. So, app use this value,\n\t * in order to check whether it is EOF.\n\t */\n\tif (put_user(0, &d1->d_reclen))\n\t\treturn -EFAULT;\n\n\treturn fat_ioctl_readdir(inode, filp, d1, fat_compat_ioctl_filldir,\n\t\t\t\t short_only, both);\n}"
  },
  {
    "function_name": "fat_dir_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "784-816",
    "snippet": "static long fat_dir_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct __fat_dirent __user *d1 = (struct __fat_dirent __user *)arg;\n\tint short_only, both;\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_SHORT:\n\t\tshort_only = 1;\n\t\tboth = 0;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_BOTH:\n\t\tshort_only = 0;\n\t\tboth = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn fat_generic_ioctl(filp, cmd, arg);\n\t}\n\n\tif (!access_ok(VERIFY_WRITE, d1, sizeof(struct __fat_dirent[2])))\n\t\treturn -EFAULT;\n\t/*\n\t * Yes, we don't need this put_user() absolutely. However old\n\t * code didn't return the right value. So, app use this value,\n\t * in order to check whether it is EOF.\n\t */\n\tif (put_user(0, &d1->d_reclen))\n\t\treturn -EFAULT;\n\n\treturn fat_ioctl_readdir(inode, filp, d1, fat_ioctl_filldir,\n\t\t\t\t short_only, both);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_ioctl_readdir",
          "args": [
            "inode",
            "filp",
            "d1",
            "fat_ioctl_filldir",
            "short_only",
            "both"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ioctl_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "758-782",
          "snippet": "int fat_ioctl_readdir(struct inode *inode, struct file *file,\n\t\t\t     void __user *dirent, filldir_t filldir,\n\t\t\t     int short_only, int both)\n{\n\tstruct fat_ioctl_filldir_callback buf = {\n\t\t.ctx.actor = filldir,\n\t\t.dirent = dirent\n\t};\n\tint ret;\n\n\tbuf.dirent = dirent;\n\tbuf.result = 0;\n\tmutex_lock(&inode->i_mutex);\n\tbuf.ctx.pos = file->f_pos;\n\tret = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tret = __fat_readdir(inode, file, &buf.ctx,\n\t\t\t\t    short_only, both ? &buf : NULL);\n\t\tfile->f_pos = buf.ctx.pos;\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret >= 0)\n\t\tret = buf.result;\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_ioctl_readdir(struct inode *inode, struct file *file,\n\t\t\t     void __user *dirent, filldir_t filldir,\n\t\t\t     int short_only, int both)\n{\n\tstruct fat_ioctl_filldir_callback buf = {\n\t\t.ctx.actor = filldir,\n\t\t.dirent = dirent\n\t};\n\tint ret;\n\n\tbuf.dirent = dirent;\n\tbuf.result = 0;\n\tmutex_lock(&inode->i_mutex);\n\tbuf.ctx.pos = file->f_pos;\n\tret = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tret = __fat_readdir(inode, file, &buf.ctx,\n\t\t\t\t    short_only, both ? &buf : NULL);\n\t\tfile->f_pos = buf.ctx.pos;\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret >= 0)\n\t\tret = buf.result;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "0",
            "&d1->d_reclen"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "d1",
            "sizeof(struct __fat_dirent[2])"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_generic_ioctl",
          "args": [
            "filp",
            "cmd",
            "arg"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "fat_generic_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "123-138",
          "snippet": "long fat_generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 __user *user_attr = (u32 __user *)arg;\n\n\tswitch (cmd) {\n\tcase FAT_IOCTL_GET_ATTRIBUTES:\n\t\treturn fat_ioctl_get_attributes(inode, user_attr);\n\tcase FAT_IOCTL_SET_ATTRIBUTES:\n\t\treturn fat_ioctl_set_attributes(filp, user_attr);\n\tcase FAT_IOCTL_GET_VOLUME_ID:\n\t\treturn fat_ioctl_get_volume_id(inode, user_attr);\n\tdefault:\n\t\treturn -ENOTTY;\t/* Inappropriate ioctl for device */\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nlong fat_generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 __user *user_attr = (u32 __user *)arg;\n\n\tswitch (cmd) {\n\tcase FAT_IOCTL_GET_ATTRIBUTES:\n\t\treturn fat_ioctl_get_attributes(inode, user_attr);\n\tcase FAT_IOCTL_SET_ATTRIBUTES:\n\t\treturn fat_ioctl_set_attributes(filp, user_attr);\n\tcase FAT_IOCTL_GET_VOLUME_ID:\n\t\treturn fat_ioctl_get_volume_id(inode, user_attr);\n\tdefault:\n\t\treturn -ENOTTY;\t/* Inappropriate ioctl for device */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic long fat_dir_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct __fat_dirent __user *d1 = (struct __fat_dirent __user *)arg;\n\tint short_only, both;\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_SHORT:\n\t\tshort_only = 1;\n\t\tboth = 0;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_BOTH:\n\t\tshort_only = 0;\n\t\tboth = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn fat_generic_ioctl(filp, cmd, arg);\n\t}\n\n\tif (!access_ok(VERIFY_WRITE, d1, sizeof(struct __fat_dirent[2])))\n\t\treturn -EFAULT;\n\t/*\n\t * Yes, we don't need this put_user() absolutely. However old\n\t * code didn't return the right value. So, app use this value,\n\t * in order to check whether it is EOF.\n\t */\n\tif (put_user(0, &d1->d_reclen))\n\t\treturn -EFAULT;\n\n\treturn fat_ioctl_readdir(inode, filp, d1, fat_ioctl_filldir,\n\t\t\t\t short_only, both);\n}"
  },
  {
    "function_name": "fat_ioctl_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "758-782",
    "snippet": "int fat_ioctl_readdir(struct inode *inode, struct file *file,\n\t\t\t     void __user *dirent, filldir_t filldir,\n\t\t\t     int short_only, int both)\n{\n\tstruct fat_ioctl_filldir_callback buf = {\n\t\t.ctx.actor = filldir,\n\t\t.dirent = dirent\n\t};\n\tint ret;\n\n\tbuf.dirent = dirent;\n\tbuf.result = 0;\n\tmutex_lock(&inode->i_mutex);\n\tbuf.ctx.pos = file->f_pos;\n\tret = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tret = __fat_readdir(inode, file, &buf.ctx,\n\t\t\t\t    short_only, both ? &buf : NULL);\n\t\tfile->f_pos = buf.ctx.pos;\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret >= 0)\n\t\tret = buf.result;\n\treturn ret;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fat_readdir",
          "args": [
            "inode",
            "file",
            "&buf.ctx",
            "short_only",
            "both ? &buf : NULL"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "556-697",
          "snippet": "static int __fat_readdir(struct inode *inode, struct file *file,\n\t\t\t struct dir_context *ctx, int short_only,\n\t\t\t struct fat_ioctl_filldir_callback *both)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tunsigned char nr_slots;\n\twchar_t *unicode = NULL;\n\tunsigned char bufname[FAT_MAX_SHORT_SIZE];\n\tint isvfat = sbi->options.isvfat;\n\tconst char *fill_name = NULL;\n\tint fake_offset = 0;\n\tloff_t cpos;\n\tint short_len = 0, fill_len = 0;\n\tint ret = 0;\n\n\tmutex_lock(&sbi->s_lock);\n\n\tcpos = ctx->pos;\n\t/* Fake . and .. for the root directory. */\n\tif (inode->i_ino == MSDOS_ROOT_INO) {\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\tgoto out;\n\t\tif (ctx->pos == 2) {\n\t\t\tfake_offset = 1;\n\t\t\tcpos = 0;\n\t\t}\n\t}\n\tif (cpos & (sizeof(struct msdos_dir_entry) - 1)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbh = NULL;\nget_new:\n\tif (fat_get_entry(inode, &cpos, &bh, &de) == -1)\n\t\tgoto end_of_dir;\nparse_record:\n\tnr_slots = 0;\n\t/*\n\t * Check for long filename entry, but if short_only, we don't\n\t * need to parse long filename.\n\t */\n\tif (isvfat && !short_only) {\n\t\tif (de->name[0] == DELETED_FLAG)\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t} else {\n\t\tif ((de->attr & ATTR_VOLUME) || IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t}\n\n\tif (isvfat && de->attr == ATTR_EXT) {\n\t\tint status = fat_parse_long(inode, &cpos, &bh, &de,\n\t\t\t\t\t    &unicode, &nr_slots);\n\t\tif (status < 0) {\n\t\t\tctx->pos = cpos;\n\t\t\tret = status;\n\t\t\tgoto out;\n\t\t} else if (status == PARSE_INVALID)\n\t\t\tgoto record_end;\n\t\telse if (status == PARSE_NOT_LONGNAME)\n\t\t\tgoto parse_record;\n\t\telse if (status == PARSE_EOF)\n\t\t\tgoto end_of_dir;\n\n\t\tif (nr_slots) {\n\t\t\tvoid *longname = unicode + FAT_MAX_UNI_CHARS;\n\t\t\tint size = PATH_MAX - FAT_MAX_UNI_SIZE;\n\t\t\tint len = fat_uni_to_x8(sb, unicode, longname, size);\n\n\t\t\tfill_name = longname;\n\t\t\tfill_len = len;\n\t\t\t/* !both && !short_only, so we don't need shortname. */\n\t\t\tif (!both)\n\t\t\t\tgoto start_filldir;\n\n\t\t\tshort_len = fat_parse_short(sb, de, bufname,\n\t\t\t\t\t\t    sbi->options.dotsOK);\n\t\t\tif (short_len == 0)\n\t\t\t\tgoto record_end;\n\t\t\t/* hack for fat_ioctl_filldir() */\n\t\t\tboth->longname = fill_name;\n\t\t\tboth->long_len = fill_len;\n\t\t\tboth->shortname = bufname;\n\t\t\tboth->short_len = short_len;\n\t\t\tfill_name = NULL;\n\t\t\tfill_len = 0;\n\t\t\tgoto start_filldir;\n\t\t}\n\t}\n\n\tshort_len = fat_parse_short(sb, de, bufname, sbi->options.dotsOK);\n\tif (short_len == 0)\n\t\tgoto record_end;\n\n\tfill_name = bufname;\n\tfill_len = short_len;\n\nstart_filldir:\n\tif (!fake_offset)\n\t\tctx->pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);\n\n\tif (!memcmp(de->name, MSDOS_DOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else if (!memcmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else {\n\t\tunsigned long inum;\n\t\tloff_t i_pos = fat_make_i_pos(sb, bh, de);\n\t\tstruct inode *tmp = fat_iget(sb, i_pos);\n\t\tif (tmp) {\n\t\t\tinum = tmp->i_ino;\n\t\t\tiput(tmp);\n\t\t} else\n\t\t\tinum = iunique(sb, MSDOS_ROOT_INO);\n\t\tif (!dir_emit(ctx, fill_name, fill_len, inum,\n\t\t\t    (de->attr & ATTR_DIR) ? DT_DIR : DT_REG))\n\t\t\tgoto fill_failed;\n\t}\n\nrecord_end:\n\tfake_offset = 0;\n\tctx->pos = cpos;\n\tgoto get_new;\nend_of_dir:\n\tctx->pos = cpos;\nfill_failed:\n\tbrelse(bh);\n\tif (unicode)\n\t\t__putname(unicode);\nout:\n\tmutex_unlock(&sbi->s_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define FAT_MAX_UNI_SIZE\t(FAT_MAX_UNI_CHARS * sizeof(wchar_t))",
            "#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)",
            "#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define FAT_MAX_UNI_SIZE\t(FAT_MAX_UNI_CHARS * sizeof(wchar_t))\n#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)\n#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)\n\nstatic int __fat_readdir(struct inode *inode, struct file *file,\n\t\t\t struct dir_context *ctx, int short_only,\n\t\t\t struct fat_ioctl_filldir_callback *both)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tunsigned char nr_slots;\n\twchar_t *unicode = NULL;\n\tunsigned char bufname[FAT_MAX_SHORT_SIZE];\n\tint isvfat = sbi->options.isvfat;\n\tconst char *fill_name = NULL;\n\tint fake_offset = 0;\n\tloff_t cpos;\n\tint short_len = 0, fill_len = 0;\n\tint ret = 0;\n\n\tmutex_lock(&sbi->s_lock);\n\n\tcpos = ctx->pos;\n\t/* Fake . and .. for the root directory. */\n\tif (inode->i_ino == MSDOS_ROOT_INO) {\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\tgoto out;\n\t\tif (ctx->pos == 2) {\n\t\t\tfake_offset = 1;\n\t\t\tcpos = 0;\n\t\t}\n\t}\n\tif (cpos & (sizeof(struct msdos_dir_entry) - 1)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbh = NULL;\nget_new:\n\tif (fat_get_entry(inode, &cpos, &bh, &de) == -1)\n\t\tgoto end_of_dir;\nparse_record:\n\tnr_slots = 0;\n\t/*\n\t * Check for long filename entry, but if short_only, we don't\n\t * need to parse long filename.\n\t */\n\tif (isvfat && !short_only) {\n\t\tif (de->name[0] == DELETED_FLAG)\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t} else {\n\t\tif ((de->attr & ATTR_VOLUME) || IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t}\n\n\tif (isvfat && de->attr == ATTR_EXT) {\n\t\tint status = fat_parse_long(inode, &cpos, &bh, &de,\n\t\t\t\t\t    &unicode, &nr_slots);\n\t\tif (status < 0) {\n\t\t\tctx->pos = cpos;\n\t\t\tret = status;\n\t\t\tgoto out;\n\t\t} else if (status == PARSE_INVALID)\n\t\t\tgoto record_end;\n\t\telse if (status == PARSE_NOT_LONGNAME)\n\t\t\tgoto parse_record;\n\t\telse if (status == PARSE_EOF)\n\t\t\tgoto end_of_dir;\n\n\t\tif (nr_slots) {\n\t\t\tvoid *longname = unicode + FAT_MAX_UNI_CHARS;\n\t\t\tint size = PATH_MAX - FAT_MAX_UNI_SIZE;\n\t\t\tint len = fat_uni_to_x8(sb, unicode, longname, size);\n\n\t\t\tfill_name = longname;\n\t\t\tfill_len = len;\n\t\t\t/* !both && !short_only, so we don't need shortname. */\n\t\t\tif (!both)\n\t\t\t\tgoto start_filldir;\n\n\t\t\tshort_len = fat_parse_short(sb, de, bufname,\n\t\t\t\t\t\t    sbi->options.dotsOK);\n\t\t\tif (short_len == 0)\n\t\t\t\tgoto record_end;\n\t\t\t/* hack for fat_ioctl_filldir() */\n\t\t\tboth->longname = fill_name;\n\t\t\tboth->long_len = fill_len;\n\t\t\tboth->shortname = bufname;\n\t\t\tboth->short_len = short_len;\n\t\t\tfill_name = NULL;\n\t\t\tfill_len = 0;\n\t\t\tgoto start_filldir;\n\t\t}\n\t}\n\n\tshort_len = fat_parse_short(sb, de, bufname, sbi->options.dotsOK);\n\tif (short_len == 0)\n\t\tgoto record_end;\n\n\tfill_name = bufname;\n\tfill_len = short_len;\n\nstart_filldir:\n\tif (!fake_offset)\n\t\tctx->pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);\n\n\tif (!memcmp(de->name, MSDOS_DOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else if (!memcmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else {\n\t\tunsigned long inum;\n\t\tloff_t i_pos = fat_make_i_pos(sb, bh, de);\n\t\tstruct inode *tmp = fat_iget(sb, i_pos);\n\t\tif (tmp) {\n\t\t\tinum = tmp->i_ino;\n\t\t\tiput(tmp);\n\t\t} else\n\t\t\tinum = iunique(sb, MSDOS_ROOT_INO);\n\t\tif (!dir_emit(ctx, fill_name, fill_len, inum,\n\t\t\t    (de->attr & ATTR_DIR) ? DT_DIR : DT_REG))\n\t\t\tgoto fill_failed;\n\t}\n\nrecord_end:\n\tfake_offset = 0;\n\tctx->pos = cpos;\n\tgoto get_new;\nend_of_dir:\n\tctx->pos = cpos;\nfill_failed:\n\tbrelse(bh);\n\tif (unicode)\n\t\t__putname(unicode);\nout:\n\tmutex_unlock(&sbi->s_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DEADDIR",
          "args": [
            "inode"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_ioctl_readdir(struct inode *inode, struct file *file,\n\t\t\t     void __user *dirent, filldir_t filldir,\n\t\t\t     int short_only, int both)\n{\n\tstruct fat_ioctl_filldir_callback buf = {\n\t\t.ctx.actor = filldir,\n\t\t.dirent = dirent\n\t};\n\tint ret;\n\n\tbuf.dirent = dirent;\n\tbuf.result = 0;\n\tmutex_lock(&inode->i_mutex);\n\tbuf.ctx.pos = file->f_pos;\n\tret = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tret = __fat_readdir(inode, file, &buf.ctx,\n\t\t\t\t    short_only, both ? &buf : NULL);\n\t\tfile->f_pos = buf.ctx.pos;\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret >= 0)\n\t\tret = buf.result;\n\treturn ret;\n}"
  },
  {
    "function_name": "fat_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "699-702",
    "snippet": "static int fat_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn __fat_readdir(file_inode(file), file, ctx, 0, NULL);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fat_readdir",
          "args": [
            "file_inode(file)",
            "file",
            "ctx",
            "0",
            "NULL"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "556-697",
          "snippet": "static int __fat_readdir(struct inode *inode, struct file *file,\n\t\t\t struct dir_context *ctx, int short_only,\n\t\t\t struct fat_ioctl_filldir_callback *both)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tunsigned char nr_slots;\n\twchar_t *unicode = NULL;\n\tunsigned char bufname[FAT_MAX_SHORT_SIZE];\n\tint isvfat = sbi->options.isvfat;\n\tconst char *fill_name = NULL;\n\tint fake_offset = 0;\n\tloff_t cpos;\n\tint short_len = 0, fill_len = 0;\n\tint ret = 0;\n\n\tmutex_lock(&sbi->s_lock);\n\n\tcpos = ctx->pos;\n\t/* Fake . and .. for the root directory. */\n\tif (inode->i_ino == MSDOS_ROOT_INO) {\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\tgoto out;\n\t\tif (ctx->pos == 2) {\n\t\t\tfake_offset = 1;\n\t\t\tcpos = 0;\n\t\t}\n\t}\n\tif (cpos & (sizeof(struct msdos_dir_entry) - 1)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbh = NULL;\nget_new:\n\tif (fat_get_entry(inode, &cpos, &bh, &de) == -1)\n\t\tgoto end_of_dir;\nparse_record:\n\tnr_slots = 0;\n\t/*\n\t * Check for long filename entry, but if short_only, we don't\n\t * need to parse long filename.\n\t */\n\tif (isvfat && !short_only) {\n\t\tif (de->name[0] == DELETED_FLAG)\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t} else {\n\t\tif ((de->attr & ATTR_VOLUME) || IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t}\n\n\tif (isvfat && de->attr == ATTR_EXT) {\n\t\tint status = fat_parse_long(inode, &cpos, &bh, &de,\n\t\t\t\t\t    &unicode, &nr_slots);\n\t\tif (status < 0) {\n\t\t\tctx->pos = cpos;\n\t\t\tret = status;\n\t\t\tgoto out;\n\t\t} else if (status == PARSE_INVALID)\n\t\t\tgoto record_end;\n\t\telse if (status == PARSE_NOT_LONGNAME)\n\t\t\tgoto parse_record;\n\t\telse if (status == PARSE_EOF)\n\t\t\tgoto end_of_dir;\n\n\t\tif (nr_slots) {\n\t\t\tvoid *longname = unicode + FAT_MAX_UNI_CHARS;\n\t\t\tint size = PATH_MAX - FAT_MAX_UNI_SIZE;\n\t\t\tint len = fat_uni_to_x8(sb, unicode, longname, size);\n\n\t\t\tfill_name = longname;\n\t\t\tfill_len = len;\n\t\t\t/* !both && !short_only, so we don't need shortname. */\n\t\t\tif (!both)\n\t\t\t\tgoto start_filldir;\n\n\t\t\tshort_len = fat_parse_short(sb, de, bufname,\n\t\t\t\t\t\t    sbi->options.dotsOK);\n\t\t\tif (short_len == 0)\n\t\t\t\tgoto record_end;\n\t\t\t/* hack for fat_ioctl_filldir() */\n\t\t\tboth->longname = fill_name;\n\t\t\tboth->long_len = fill_len;\n\t\t\tboth->shortname = bufname;\n\t\t\tboth->short_len = short_len;\n\t\t\tfill_name = NULL;\n\t\t\tfill_len = 0;\n\t\t\tgoto start_filldir;\n\t\t}\n\t}\n\n\tshort_len = fat_parse_short(sb, de, bufname, sbi->options.dotsOK);\n\tif (short_len == 0)\n\t\tgoto record_end;\n\n\tfill_name = bufname;\n\tfill_len = short_len;\n\nstart_filldir:\n\tif (!fake_offset)\n\t\tctx->pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);\n\n\tif (!memcmp(de->name, MSDOS_DOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else if (!memcmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else {\n\t\tunsigned long inum;\n\t\tloff_t i_pos = fat_make_i_pos(sb, bh, de);\n\t\tstruct inode *tmp = fat_iget(sb, i_pos);\n\t\tif (tmp) {\n\t\t\tinum = tmp->i_ino;\n\t\t\tiput(tmp);\n\t\t} else\n\t\t\tinum = iunique(sb, MSDOS_ROOT_INO);\n\t\tif (!dir_emit(ctx, fill_name, fill_len, inum,\n\t\t\t    (de->attr & ATTR_DIR) ? DT_DIR : DT_REG))\n\t\t\tgoto fill_failed;\n\t}\n\nrecord_end:\n\tfake_offset = 0;\n\tctx->pos = cpos;\n\tgoto get_new;\nend_of_dir:\n\tctx->pos = cpos;\nfill_failed:\n\tbrelse(bh);\n\tif (unicode)\n\t\t__putname(unicode);\nout:\n\tmutex_unlock(&sbi->s_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define FAT_MAX_UNI_SIZE\t(FAT_MAX_UNI_CHARS * sizeof(wchar_t))",
            "#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)",
            "#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define FAT_MAX_UNI_SIZE\t(FAT_MAX_UNI_CHARS * sizeof(wchar_t))\n#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)\n#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)\n\nstatic int __fat_readdir(struct inode *inode, struct file *file,\n\t\t\t struct dir_context *ctx, int short_only,\n\t\t\t struct fat_ioctl_filldir_callback *both)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tunsigned char nr_slots;\n\twchar_t *unicode = NULL;\n\tunsigned char bufname[FAT_MAX_SHORT_SIZE];\n\tint isvfat = sbi->options.isvfat;\n\tconst char *fill_name = NULL;\n\tint fake_offset = 0;\n\tloff_t cpos;\n\tint short_len = 0, fill_len = 0;\n\tint ret = 0;\n\n\tmutex_lock(&sbi->s_lock);\n\n\tcpos = ctx->pos;\n\t/* Fake . and .. for the root directory. */\n\tif (inode->i_ino == MSDOS_ROOT_INO) {\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\tgoto out;\n\t\tif (ctx->pos == 2) {\n\t\t\tfake_offset = 1;\n\t\t\tcpos = 0;\n\t\t}\n\t}\n\tif (cpos & (sizeof(struct msdos_dir_entry) - 1)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbh = NULL;\nget_new:\n\tif (fat_get_entry(inode, &cpos, &bh, &de) == -1)\n\t\tgoto end_of_dir;\nparse_record:\n\tnr_slots = 0;\n\t/*\n\t * Check for long filename entry, but if short_only, we don't\n\t * need to parse long filename.\n\t */\n\tif (isvfat && !short_only) {\n\t\tif (de->name[0] == DELETED_FLAG)\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t} else {\n\t\tif ((de->attr & ATTR_VOLUME) || IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t}\n\n\tif (isvfat && de->attr == ATTR_EXT) {\n\t\tint status = fat_parse_long(inode, &cpos, &bh, &de,\n\t\t\t\t\t    &unicode, &nr_slots);\n\t\tif (status < 0) {\n\t\t\tctx->pos = cpos;\n\t\t\tret = status;\n\t\t\tgoto out;\n\t\t} else if (status == PARSE_INVALID)\n\t\t\tgoto record_end;\n\t\telse if (status == PARSE_NOT_LONGNAME)\n\t\t\tgoto parse_record;\n\t\telse if (status == PARSE_EOF)\n\t\t\tgoto end_of_dir;\n\n\t\tif (nr_slots) {\n\t\t\tvoid *longname = unicode + FAT_MAX_UNI_CHARS;\n\t\t\tint size = PATH_MAX - FAT_MAX_UNI_SIZE;\n\t\t\tint len = fat_uni_to_x8(sb, unicode, longname, size);\n\n\t\t\tfill_name = longname;\n\t\t\tfill_len = len;\n\t\t\t/* !both && !short_only, so we don't need shortname. */\n\t\t\tif (!both)\n\t\t\t\tgoto start_filldir;\n\n\t\t\tshort_len = fat_parse_short(sb, de, bufname,\n\t\t\t\t\t\t    sbi->options.dotsOK);\n\t\t\tif (short_len == 0)\n\t\t\t\tgoto record_end;\n\t\t\t/* hack for fat_ioctl_filldir() */\n\t\t\tboth->longname = fill_name;\n\t\t\tboth->long_len = fill_len;\n\t\t\tboth->shortname = bufname;\n\t\t\tboth->short_len = short_len;\n\t\t\tfill_name = NULL;\n\t\t\tfill_len = 0;\n\t\t\tgoto start_filldir;\n\t\t}\n\t}\n\n\tshort_len = fat_parse_short(sb, de, bufname, sbi->options.dotsOK);\n\tif (short_len == 0)\n\t\tgoto record_end;\n\n\tfill_name = bufname;\n\tfill_len = short_len;\n\nstart_filldir:\n\tif (!fake_offset)\n\t\tctx->pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);\n\n\tif (!memcmp(de->name, MSDOS_DOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else if (!memcmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else {\n\t\tunsigned long inum;\n\t\tloff_t i_pos = fat_make_i_pos(sb, bh, de);\n\t\tstruct inode *tmp = fat_iget(sb, i_pos);\n\t\tif (tmp) {\n\t\t\tinum = tmp->i_ino;\n\t\t\tiput(tmp);\n\t\t} else\n\t\t\tinum = iunique(sb, MSDOS_ROOT_INO);\n\t\tif (!dir_emit(ctx, fill_name, fill_len, inum,\n\t\t\t    (de->attr & ATTR_DIR) ? DT_DIR : DT_REG))\n\t\t\tgoto fill_failed;\n\t}\n\nrecord_end:\n\tfake_offset = 0;\n\tctx->pos = cpos;\n\tgoto get_new;\nend_of_dir:\n\tctx->pos = cpos;\nfill_failed:\n\tbrelse(bh);\n\tif (unicode)\n\t\t__putname(unicode);\nout:\n\tmutex_unlock(&sbi->s_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn __fat_readdir(file_inode(file), file, ctx, 0, NULL);\n}"
  },
  {
    "function_name": "__fat_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "556-697",
    "snippet": "static int __fat_readdir(struct inode *inode, struct file *file,\n\t\t\t struct dir_context *ctx, int short_only,\n\t\t\t struct fat_ioctl_filldir_callback *both)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tunsigned char nr_slots;\n\twchar_t *unicode = NULL;\n\tunsigned char bufname[FAT_MAX_SHORT_SIZE];\n\tint isvfat = sbi->options.isvfat;\n\tconst char *fill_name = NULL;\n\tint fake_offset = 0;\n\tloff_t cpos;\n\tint short_len = 0, fill_len = 0;\n\tint ret = 0;\n\n\tmutex_lock(&sbi->s_lock);\n\n\tcpos = ctx->pos;\n\t/* Fake . and .. for the root directory. */\n\tif (inode->i_ino == MSDOS_ROOT_INO) {\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\tgoto out;\n\t\tif (ctx->pos == 2) {\n\t\t\tfake_offset = 1;\n\t\t\tcpos = 0;\n\t\t}\n\t}\n\tif (cpos & (sizeof(struct msdos_dir_entry) - 1)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbh = NULL;\nget_new:\n\tif (fat_get_entry(inode, &cpos, &bh, &de) == -1)\n\t\tgoto end_of_dir;\nparse_record:\n\tnr_slots = 0;\n\t/*\n\t * Check for long filename entry, but if short_only, we don't\n\t * need to parse long filename.\n\t */\n\tif (isvfat && !short_only) {\n\t\tif (de->name[0] == DELETED_FLAG)\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t} else {\n\t\tif ((de->attr & ATTR_VOLUME) || IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t}\n\n\tif (isvfat && de->attr == ATTR_EXT) {\n\t\tint status = fat_parse_long(inode, &cpos, &bh, &de,\n\t\t\t\t\t    &unicode, &nr_slots);\n\t\tif (status < 0) {\n\t\t\tctx->pos = cpos;\n\t\t\tret = status;\n\t\t\tgoto out;\n\t\t} else if (status == PARSE_INVALID)\n\t\t\tgoto record_end;\n\t\telse if (status == PARSE_NOT_LONGNAME)\n\t\t\tgoto parse_record;\n\t\telse if (status == PARSE_EOF)\n\t\t\tgoto end_of_dir;\n\n\t\tif (nr_slots) {\n\t\t\tvoid *longname = unicode + FAT_MAX_UNI_CHARS;\n\t\t\tint size = PATH_MAX - FAT_MAX_UNI_SIZE;\n\t\t\tint len = fat_uni_to_x8(sb, unicode, longname, size);\n\n\t\t\tfill_name = longname;\n\t\t\tfill_len = len;\n\t\t\t/* !both && !short_only, so we don't need shortname. */\n\t\t\tif (!both)\n\t\t\t\tgoto start_filldir;\n\n\t\t\tshort_len = fat_parse_short(sb, de, bufname,\n\t\t\t\t\t\t    sbi->options.dotsOK);\n\t\t\tif (short_len == 0)\n\t\t\t\tgoto record_end;\n\t\t\t/* hack for fat_ioctl_filldir() */\n\t\t\tboth->longname = fill_name;\n\t\t\tboth->long_len = fill_len;\n\t\t\tboth->shortname = bufname;\n\t\t\tboth->short_len = short_len;\n\t\t\tfill_name = NULL;\n\t\t\tfill_len = 0;\n\t\t\tgoto start_filldir;\n\t\t}\n\t}\n\n\tshort_len = fat_parse_short(sb, de, bufname, sbi->options.dotsOK);\n\tif (short_len == 0)\n\t\tgoto record_end;\n\n\tfill_name = bufname;\n\tfill_len = short_len;\n\nstart_filldir:\n\tif (!fake_offset)\n\t\tctx->pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);\n\n\tif (!memcmp(de->name, MSDOS_DOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else if (!memcmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else {\n\t\tunsigned long inum;\n\t\tloff_t i_pos = fat_make_i_pos(sb, bh, de);\n\t\tstruct inode *tmp = fat_iget(sb, i_pos);\n\t\tif (tmp) {\n\t\t\tinum = tmp->i_ino;\n\t\t\tiput(tmp);\n\t\t} else\n\t\t\tinum = iunique(sb, MSDOS_ROOT_INO);\n\t\tif (!dir_emit(ctx, fill_name, fill_len, inum,\n\t\t\t    (de->attr & ATTR_DIR) ? DT_DIR : DT_REG))\n\t\t\tgoto fill_failed;\n\t}\n\nrecord_end:\n\tfake_offset = 0;\n\tctx->pos = cpos;\n\tgoto get_new;\nend_of_dir:\n\tctx->pos = cpos;\nfill_failed:\n\tbrelse(bh);\n\tif (unicode)\n\t\t__putname(unicode);\nout:\n\tmutex_unlock(&sbi->s_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define FAT_MAX_UNI_SIZE\t(FAT_MAX_UNI_CHARS * sizeof(wchar_t))",
      "#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)",
      "#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "unicode"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "fill_name",
            "fill_len",
            "inum",
            "(de->attr & ATTR_DIR) ? DT_DIR : DT_REG"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iunique",
          "args": [
            "sb",
            "MSDOS_ROOT_INO"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1150-1170",
          "snippet": "ino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "tmp"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_iget",
          "args": [
            "sb",
            "i_pos"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "fat_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "414-432",
          "snippet": "struct inode *fat_iget(struct super_block *sb, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head = sbi->inode_hashtable + fat_hash(i_pos);\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&sbi->inode_hash_lock);\n\thlist_for_each_entry(i, head, i_fat_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_pos != i_pos)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_iget(struct super_block *sb, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head = sbi->inode_hashtable + fat_hash(i_pos);\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&sbi->inode_hash_lock);\n\thlist_for_each_entry(i, head, i_fat_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_pos != i_pos)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_make_i_pos",
          "args": [
            "sb",
            "bh",
            "de"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "fat_make_i_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "43-49",
          "snippet": "static inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dotdot",
          "args": [
            "file",
            "ctx"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "de->name",
            "MSDOS_DOTDOT",
            "MSDOS_NAME"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dot",
          "args": [
            "file",
            "ctx"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "de->name",
            "MSDOS_DOT",
            "MSDOS_NAME"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_parse_short",
          "args": [
            "sb",
            "de",
            "bufname",
            "sbi->options.dotsOK"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "fat_parse_short",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "354-461",
          "snippet": "static int fat_parse_short(struct super_block *sb,\n\t\t\t   const struct msdos_dir_entry *de,\n\t\t\t   unsigned char *name, int dot_hidden)\n{\n\tconst struct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint isvfat = sbi->options.isvfat;\n\tint nocase = sbi->options.nocase;\n\tunsigned short opt_shortname = sbi->options.shortname;\n\tstruct nls_table *nls_disk = sbi->nls_disk;\n\twchar_t uni_name[14];\n\tunsigned char c, work[MSDOS_NAME];\n\tunsigned char *ptname = name;\n\tint chi, chl, i, j, k;\n\tint dotoffset = 0;\n\tint name_len = 0, uni_len = 0;\n\n\tif (!isvfat && dot_hidden && (de->attr & ATTR_HIDDEN)) {\n\t\t*ptname++ = '.';\n\t\tdotoffset = 1;\n\t}\n\n\tmemcpy(work, de->name, sizeof(work));\n\t/* see namei.c, msdos_format_name */\n\tif (work[0] == 0x05)\n\t\twork[0] = 0xE5;\n\n\t/* Filename */\n\tfor (i = 0, j = 0; i < 8;) {\n\t\tc = work[i];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[i], 8 - i,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_BASE);\n\t\tif (chl <= 1) {\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat)\n\t\t\t\ti += min(chl, 8-i);\n\t\t\telse {\n\t\t\t\tfor (chi = 0; chi < chl && i < 8; chi++, i++)\n\t\t\t\t\tptname[i] = work[i];\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\ti = name_len;\n\tj = uni_len;\n\tfat_short2uni(nls_disk, \".\", 1, &uni_name[j++]);\n\tif (!isvfat)\n\t\tptname[i] = '.';\n\ti++;\n\n\t/* Extension */\n\tfor (k = 8; k < MSDOS_NAME;) {\n\t\tc = work[k];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[k], MSDOS_NAME - k,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_EXT);\n\t\tif (chl <= 1) {\n\t\t\tk++;\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat) {\n\t\t\t\tint offset = min(chl, MSDOS_NAME-k);\n\t\t\t\tk += offset;\n\t\t\t\ti += offset;\n\t\t\t} else {\n\t\t\t\tfor (chi = 0; chi < chl && k < MSDOS_NAME;\n\t\t\t\t     chi++, i++, k++) {\n\t\t\t\t\t\tptname[i] = work[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\tif (name_len > 0) {\n\t\tname_len += dotoffset;\n\n\t\tif (sbi->options.isvfat) {\n\t\t\tuni_name[uni_len] = 0x0000;\n\t\t\tname_len = fat_uni_to_x8(sb, uni_name, name,\n\t\t\t\t\t\t FAT_MAX_SHORT_SIZE);\n\t\t}\n\t}\n\n\treturn name_len;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)\n\nstatic int fat_parse_short(struct super_block *sb,\n\t\t\t   const struct msdos_dir_entry *de,\n\t\t\t   unsigned char *name, int dot_hidden)\n{\n\tconst struct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint isvfat = sbi->options.isvfat;\n\tint nocase = sbi->options.nocase;\n\tunsigned short opt_shortname = sbi->options.shortname;\n\tstruct nls_table *nls_disk = sbi->nls_disk;\n\twchar_t uni_name[14];\n\tunsigned char c, work[MSDOS_NAME];\n\tunsigned char *ptname = name;\n\tint chi, chl, i, j, k;\n\tint dotoffset = 0;\n\tint name_len = 0, uni_len = 0;\n\n\tif (!isvfat && dot_hidden && (de->attr & ATTR_HIDDEN)) {\n\t\t*ptname++ = '.';\n\t\tdotoffset = 1;\n\t}\n\n\tmemcpy(work, de->name, sizeof(work));\n\t/* see namei.c, msdos_format_name */\n\tif (work[0] == 0x05)\n\t\twork[0] = 0xE5;\n\n\t/* Filename */\n\tfor (i = 0, j = 0; i < 8;) {\n\t\tc = work[i];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[i], 8 - i,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_BASE);\n\t\tif (chl <= 1) {\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat)\n\t\t\t\ti += min(chl, 8-i);\n\t\t\telse {\n\t\t\t\tfor (chi = 0; chi < chl && i < 8; chi++, i++)\n\t\t\t\t\tptname[i] = work[i];\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\ti = name_len;\n\tj = uni_len;\n\tfat_short2uni(nls_disk, \".\", 1, &uni_name[j++]);\n\tif (!isvfat)\n\t\tptname[i] = '.';\n\ti++;\n\n\t/* Extension */\n\tfor (k = 8; k < MSDOS_NAME;) {\n\t\tc = work[k];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[k], MSDOS_NAME - k,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_EXT);\n\t\tif (chl <= 1) {\n\t\t\tk++;\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat) {\n\t\t\t\tint offset = min(chl, MSDOS_NAME-k);\n\t\t\t\tk += offset;\n\t\t\t\ti += offset;\n\t\t\t} else {\n\t\t\t\tfor (chi = 0; chi < chl && k < MSDOS_NAME;\n\t\t\t\t     chi++, i++, k++) {\n\t\t\t\t\t\tptname[i] = work[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\tif (name_len > 0) {\n\t\tname_len += dotoffset;\n\n\t\tif (sbi->options.isvfat) {\n\t\t\tuni_name[uni_len] = 0x0000;\n\t\t\tname_len = fat_uni_to_x8(sb, uni_name, name,\n\t\t\t\t\t\t FAT_MAX_SHORT_SIZE);\n\t\t}\n\t}\n\n\treturn name_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_uni_to_x8",
          "args": [
            "sb",
            "unicode",
            "longname",
            "size"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "fat_uni_to_x8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "185-194",
          "snippet": "static inline int fat_uni_to_x8(struct super_block *sb, const wchar_t *uni,\n\t\t\t\tunsigned char *buf, int size)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tif (sbi->options.utf8)\n\t\treturn utf16s_to_utf8s(uni, FAT_MAX_UNI_CHARS,\n\t\t\t\tUTF16_HOST_ENDIAN, buf, size);\n\telse\n\t\treturn uni16_to_x8(sb, buf, uni, size, sbi->nls_io);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)\n\nstatic inline int fat_uni_to_x8(struct super_block *sb, const wchar_t *uni,\n\t\t\t\tunsigned char *buf, int size)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tif (sbi->options.utf8)\n\t\treturn utf16s_to_utf8s(uni, FAT_MAX_UNI_CHARS,\n\t\t\t\tUTF16_HOST_ENDIAN, buf, size);\n\telse\n\t\treturn uni16_to_x8(sb, buf, uni, size, sbi->nls_io);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_parse_long",
          "args": [
            "inode",
            "&cpos",
            "&bh",
            "&de",
            "&unicode",
            "&nr_slots"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "fat_parse_long",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "283-343",
          "snippet": "static int fat_parse_long(struct inode *dir, loff_t *pos,\n\t\t\t  struct buffer_head **bh, struct msdos_dir_entry **de,\n\t\t\t  wchar_t **unicode, unsigned char *nr_slots)\n{\n\tstruct msdos_dir_slot *ds;\n\tunsigned char id, slot, slots, alias_checksum;\n\n\tif (!*unicode) {\n\t\t*unicode = __getname();\n\t\tif (!*unicode) {\n\t\t\tbrelse(*bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\nparse_long:\n\tslots = 0;\n\tds = (struct msdos_dir_slot *)*de;\n\tid = ds->id;\n\tif (!(id & 0x40))\n\t\treturn PARSE_INVALID;\n\tslots = id & ~0x40;\n\tif (slots > 20 || !slots)\t/* ceil(256 * 2 / 26) */\n\t\treturn PARSE_INVALID;\n\t*nr_slots = slots;\n\talias_checksum = ds->alias_checksum;\n\n\tslot = slots;\n\twhile (1) {\n\t\tint offset;\n\n\t\tslot--;\n\t\toffset = slot * 13;\n\t\tfat16_towchar(*unicode + offset, ds->name0_4, 5);\n\t\tfat16_towchar(*unicode + offset + 5, ds->name5_10, 6);\n\t\tfat16_towchar(*unicode + offset + 11, ds->name11_12, 2);\n\n\t\tif (ds->id & 0x40)\n\t\t\t(*unicode)[offset + 13] = 0;\n\t\tif (fat_get_entry(dir, pos, bh, de) < 0)\n\t\t\treturn PARSE_EOF;\n\t\tif (slot == 0)\n\t\t\tbreak;\n\t\tds = (struct msdos_dir_slot *)*de;\n\t\tif (ds->attr != ATTR_EXT)\n\t\t\treturn PARSE_NOT_LONGNAME;\n\t\tif ((ds->id & ~0x40) != slot)\n\t\t\tgoto parse_long;\n\t\tif (ds->alias_checksum != alias_checksum)\n\t\t\tgoto parse_long;\n\t}\n\tif ((*de)->name[0] == DELETED_FLAG)\n\t\treturn PARSE_INVALID;\n\tif ((*de)->attr == ATTR_EXT)\n\t\tgoto parse_long;\n\tif (IS_FREE((*de)->name) || ((*de)->attr & ATTR_VOLUME))\n\t\treturn PARSE_INVALID;\n\tif (fat_checksum((*de)->name) != alias_checksum)\n\t\t*nr_slots = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_parse_long(struct inode *dir, loff_t *pos,\n\t\t\t  struct buffer_head **bh, struct msdos_dir_entry **de,\n\t\t\t  wchar_t **unicode, unsigned char *nr_slots)\n{\n\tstruct msdos_dir_slot *ds;\n\tunsigned char id, slot, slots, alias_checksum;\n\n\tif (!*unicode) {\n\t\t*unicode = __getname();\n\t\tif (!*unicode) {\n\t\t\tbrelse(*bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\nparse_long:\n\tslots = 0;\n\tds = (struct msdos_dir_slot *)*de;\n\tid = ds->id;\n\tif (!(id & 0x40))\n\t\treturn PARSE_INVALID;\n\tslots = id & ~0x40;\n\tif (slots > 20 || !slots)\t/* ceil(256 * 2 / 26) */\n\t\treturn PARSE_INVALID;\n\t*nr_slots = slots;\n\talias_checksum = ds->alias_checksum;\n\n\tslot = slots;\n\twhile (1) {\n\t\tint offset;\n\n\t\tslot--;\n\t\toffset = slot * 13;\n\t\tfat16_towchar(*unicode + offset, ds->name0_4, 5);\n\t\tfat16_towchar(*unicode + offset + 5, ds->name5_10, 6);\n\t\tfat16_towchar(*unicode + offset + 11, ds->name11_12, 2);\n\n\t\tif (ds->id & 0x40)\n\t\t\t(*unicode)[offset + 13] = 0;\n\t\tif (fat_get_entry(dir, pos, bh, de) < 0)\n\t\t\treturn PARSE_EOF;\n\t\tif (slot == 0)\n\t\t\tbreak;\n\t\tds = (struct msdos_dir_slot *)*de;\n\t\tif (ds->attr != ATTR_EXT)\n\t\t\treturn PARSE_NOT_LONGNAME;\n\t\tif ((ds->id & ~0x40) != slot)\n\t\t\tgoto parse_long;\n\t\tif (ds->alias_checksum != alias_checksum)\n\t\t\tgoto parse_long;\n\t}\n\tif ((*de)->name[0] == DELETED_FLAG)\n\t\treturn PARSE_INVALID;\n\tif ((*de)->attr == ATTR_EXT)\n\t\tgoto parse_long;\n\tif (IS_FREE((*de)->name) || ((*de)->attr & ATTR_VOLUME))\n\t\treturn PARSE_INVALID;\n\tif (fat_checksum((*de)->name) != alias_checksum)\n\t\t*nr_slots = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FREE",
          "args": [
            "de->name"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FREE",
          "args": [
            "de->name"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_get_entry",
          "args": [
            "inode",
            "&cpos",
            "&bh",
            "&de"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "120-133",
          "snippet": "static inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define FAT_MAX_UNI_SIZE\t(FAT_MAX_UNI_CHARS * sizeof(wchar_t))\n#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)\n#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)\n\nstatic int __fat_readdir(struct inode *inode, struct file *file,\n\t\t\t struct dir_context *ctx, int short_only,\n\t\t\t struct fat_ioctl_filldir_callback *both)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tunsigned char nr_slots;\n\twchar_t *unicode = NULL;\n\tunsigned char bufname[FAT_MAX_SHORT_SIZE];\n\tint isvfat = sbi->options.isvfat;\n\tconst char *fill_name = NULL;\n\tint fake_offset = 0;\n\tloff_t cpos;\n\tint short_len = 0, fill_len = 0;\n\tint ret = 0;\n\n\tmutex_lock(&sbi->s_lock);\n\n\tcpos = ctx->pos;\n\t/* Fake . and .. for the root directory. */\n\tif (inode->i_ino == MSDOS_ROOT_INO) {\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\tgoto out;\n\t\tif (ctx->pos == 2) {\n\t\t\tfake_offset = 1;\n\t\t\tcpos = 0;\n\t\t}\n\t}\n\tif (cpos & (sizeof(struct msdos_dir_entry) - 1)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbh = NULL;\nget_new:\n\tif (fat_get_entry(inode, &cpos, &bh, &de) == -1)\n\t\tgoto end_of_dir;\nparse_record:\n\tnr_slots = 0;\n\t/*\n\t * Check for long filename entry, but if short_only, we don't\n\t * need to parse long filename.\n\t */\n\tif (isvfat && !short_only) {\n\t\tif (de->name[0] == DELETED_FLAG)\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t} else {\n\t\tif ((de->attr & ATTR_VOLUME) || IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t}\n\n\tif (isvfat && de->attr == ATTR_EXT) {\n\t\tint status = fat_parse_long(inode, &cpos, &bh, &de,\n\t\t\t\t\t    &unicode, &nr_slots);\n\t\tif (status < 0) {\n\t\t\tctx->pos = cpos;\n\t\t\tret = status;\n\t\t\tgoto out;\n\t\t} else if (status == PARSE_INVALID)\n\t\t\tgoto record_end;\n\t\telse if (status == PARSE_NOT_LONGNAME)\n\t\t\tgoto parse_record;\n\t\telse if (status == PARSE_EOF)\n\t\t\tgoto end_of_dir;\n\n\t\tif (nr_slots) {\n\t\t\tvoid *longname = unicode + FAT_MAX_UNI_CHARS;\n\t\t\tint size = PATH_MAX - FAT_MAX_UNI_SIZE;\n\t\t\tint len = fat_uni_to_x8(sb, unicode, longname, size);\n\n\t\t\tfill_name = longname;\n\t\t\tfill_len = len;\n\t\t\t/* !both && !short_only, so we don't need shortname. */\n\t\t\tif (!both)\n\t\t\t\tgoto start_filldir;\n\n\t\t\tshort_len = fat_parse_short(sb, de, bufname,\n\t\t\t\t\t\t    sbi->options.dotsOK);\n\t\t\tif (short_len == 0)\n\t\t\t\tgoto record_end;\n\t\t\t/* hack for fat_ioctl_filldir() */\n\t\t\tboth->longname = fill_name;\n\t\t\tboth->long_len = fill_len;\n\t\t\tboth->shortname = bufname;\n\t\t\tboth->short_len = short_len;\n\t\t\tfill_name = NULL;\n\t\t\tfill_len = 0;\n\t\t\tgoto start_filldir;\n\t\t}\n\t}\n\n\tshort_len = fat_parse_short(sb, de, bufname, sbi->options.dotsOK);\n\tif (short_len == 0)\n\t\tgoto record_end;\n\n\tfill_name = bufname;\n\tfill_len = short_len;\n\nstart_filldir:\n\tif (!fake_offset)\n\t\tctx->pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);\n\n\tif (!memcmp(de->name, MSDOS_DOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else if (!memcmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else {\n\t\tunsigned long inum;\n\t\tloff_t i_pos = fat_make_i_pos(sb, bh, de);\n\t\tstruct inode *tmp = fat_iget(sb, i_pos);\n\t\tif (tmp) {\n\t\t\tinum = tmp->i_ino;\n\t\t\tiput(tmp);\n\t\t} else\n\t\t\tinum = iunique(sb, MSDOS_ROOT_INO);\n\t\tif (!dir_emit(ctx, fill_name, fill_len, inum,\n\t\t\t    (de->attr & ATTR_DIR) ? DT_DIR : DT_REG))\n\t\t\tgoto fill_failed;\n\t}\n\nrecord_end:\n\tfake_offset = 0;\n\tctx->pos = cpos;\n\tgoto get_new;\nend_of_dir:\n\tctx->pos = cpos;\nfill_failed:\n\tbrelse(bh);\n\tif (unicode)\n\t\t__putname(unicode);\nout:\n\tmutex_unlock(&sbi->s_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "fat_search_long",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "466-542",
    "snippet": "int fat_search_long(struct inode *inode, const unsigned char *name,\n\t\t    int name_len, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\tstruct msdos_dir_entry *de;\n\tunsigned char nr_slots;\n\twchar_t *unicode = NULL;\n\tunsigned char bufname[FAT_MAX_SHORT_SIZE];\n\tloff_t cpos = 0;\n\tint err, len;\n\n\terr = -ENOENT;\n\twhile (1) {\n\t\tif (fat_get_entry(inode, &cpos, &bh, &de) == -1)\n\t\t\tgoto end_of_dir;\nparse_record:\n\t\tnr_slots = 0;\n\t\tif (de->name[0] == DELETED_FLAG)\n\t\t\tcontinue;\n\t\tif (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))\n\t\t\tcontinue;\n\t\tif (de->attr != ATTR_EXT && IS_FREE(de->name))\n\t\t\tcontinue;\n\t\tif (de->attr == ATTR_EXT) {\n\t\t\tint status = fat_parse_long(inode, &cpos, &bh, &de,\n\t\t\t\t\t\t    &unicode, &nr_slots);\n\t\t\tif (status < 0) {\n\t\t\t\terr = status;\n\t\t\t\tgoto end_of_dir;\n\t\t\t} else if (status == PARSE_INVALID)\n\t\t\t\tcontinue;\n\t\t\telse if (status == PARSE_NOT_LONGNAME)\n\t\t\t\tgoto parse_record;\n\t\t\telse if (status == PARSE_EOF)\n\t\t\t\tgoto end_of_dir;\n\t\t}\n\n\t\t/* Never prepend '.' to hidden files here.\n\t\t * That is done only for msdos mounts (and only when\n\t\t * 'dotsOK=yes'); if we are executing here, it is in the\n\t\t * context of a vfat mount.\n\t\t */\n\t\tlen = fat_parse_short(sb, de, bufname, 0);\n\t\tif (len == 0)\n\t\t\tcontinue;\n\n\t\t/* Compare shortname */\n\t\tif (fat_name_match(sbi, name, name_len, bufname, len))\n\t\t\tgoto found;\n\n\t\tif (nr_slots) {\n\t\t\tvoid *longname = unicode + FAT_MAX_UNI_CHARS;\n\t\t\tint size = PATH_MAX - FAT_MAX_UNI_SIZE;\n\n\t\t\t/* Compare longname */\n\t\t\tlen = fat_uni_to_x8(sb, unicode, longname, size);\n\t\t\tif (fat_name_match(sbi, name, name_len, longname, len))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\nfound:\n\tnr_slots++;\t/* include the de */\n\tsinfo->slot_off = cpos - nr_slots * sizeof(*de);\n\tsinfo->nr_slots = nr_slots;\n\tsinfo->de = de;\n\tsinfo->bh = bh;\n\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\terr = 0;\nend_of_dir:\n\tif (unicode)\n\t\t__putname(unicode);\n\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define FAT_MAX_UNI_SIZE\t(FAT_MAX_UNI_CHARS * sizeof(wchar_t))",
      "#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)",
      "#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "unicode"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_make_i_pos",
          "args": [
            "sb",
            "sinfo->bh",
            "sinfo->de"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "fat_make_i_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "43-49",
          "snippet": "static inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_name_match",
          "args": [
            "sbi",
            "name",
            "name_len",
            "longname",
            "len"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "fat_name_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "258-269",
          "snippet": "static inline int fat_name_match(struct msdos_sb_info *sbi,\n\t\t\t\t const unsigned char *a, int a_len,\n\t\t\t\t const unsigned char *b, int b_len)\n{\n\tif (a_len != b_len)\n\t\treturn 0;\n\n\tif (sbi->options.name_check != 's')\n\t\treturn !nls_strnicmp(sbi->nls_io, a, b, a_len);\n\telse\n\t\treturn !memcmp(a, b, a_len);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int fat_name_match(struct msdos_sb_info *sbi,\n\t\t\t\t const unsigned char *a, int a_len,\n\t\t\t\t const unsigned char *b, int b_len)\n{\n\tif (a_len != b_len)\n\t\treturn 0;\n\n\tif (sbi->options.name_check != 's')\n\t\treturn !nls_strnicmp(sbi->nls_io, a, b, a_len);\n\telse\n\t\treturn !memcmp(a, b, a_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_uni_to_x8",
          "args": [
            "sb",
            "unicode",
            "longname",
            "size"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "fat_uni_to_x8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "185-194",
          "snippet": "static inline int fat_uni_to_x8(struct super_block *sb, const wchar_t *uni,\n\t\t\t\tunsigned char *buf, int size)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tif (sbi->options.utf8)\n\t\treturn utf16s_to_utf8s(uni, FAT_MAX_UNI_CHARS,\n\t\t\t\tUTF16_HOST_ENDIAN, buf, size);\n\telse\n\t\treturn uni16_to_x8(sb, buf, uni, size, sbi->nls_io);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)\n\nstatic inline int fat_uni_to_x8(struct super_block *sb, const wchar_t *uni,\n\t\t\t\tunsigned char *buf, int size)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tif (sbi->options.utf8)\n\t\treturn utf16s_to_utf8s(uni, FAT_MAX_UNI_CHARS,\n\t\t\t\tUTF16_HOST_ENDIAN, buf, size);\n\telse\n\t\treturn uni16_to_x8(sb, buf, uni, size, sbi->nls_io);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_parse_short",
          "args": [
            "sb",
            "de",
            "bufname",
            "0"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "fat_parse_short",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "354-461",
          "snippet": "static int fat_parse_short(struct super_block *sb,\n\t\t\t   const struct msdos_dir_entry *de,\n\t\t\t   unsigned char *name, int dot_hidden)\n{\n\tconst struct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint isvfat = sbi->options.isvfat;\n\tint nocase = sbi->options.nocase;\n\tunsigned short opt_shortname = sbi->options.shortname;\n\tstruct nls_table *nls_disk = sbi->nls_disk;\n\twchar_t uni_name[14];\n\tunsigned char c, work[MSDOS_NAME];\n\tunsigned char *ptname = name;\n\tint chi, chl, i, j, k;\n\tint dotoffset = 0;\n\tint name_len = 0, uni_len = 0;\n\n\tif (!isvfat && dot_hidden && (de->attr & ATTR_HIDDEN)) {\n\t\t*ptname++ = '.';\n\t\tdotoffset = 1;\n\t}\n\n\tmemcpy(work, de->name, sizeof(work));\n\t/* see namei.c, msdos_format_name */\n\tif (work[0] == 0x05)\n\t\twork[0] = 0xE5;\n\n\t/* Filename */\n\tfor (i = 0, j = 0; i < 8;) {\n\t\tc = work[i];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[i], 8 - i,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_BASE);\n\t\tif (chl <= 1) {\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat)\n\t\t\t\ti += min(chl, 8-i);\n\t\t\telse {\n\t\t\t\tfor (chi = 0; chi < chl && i < 8; chi++, i++)\n\t\t\t\t\tptname[i] = work[i];\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\ti = name_len;\n\tj = uni_len;\n\tfat_short2uni(nls_disk, \".\", 1, &uni_name[j++]);\n\tif (!isvfat)\n\t\tptname[i] = '.';\n\ti++;\n\n\t/* Extension */\n\tfor (k = 8; k < MSDOS_NAME;) {\n\t\tc = work[k];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[k], MSDOS_NAME - k,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_EXT);\n\t\tif (chl <= 1) {\n\t\t\tk++;\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat) {\n\t\t\t\tint offset = min(chl, MSDOS_NAME-k);\n\t\t\t\tk += offset;\n\t\t\t\ti += offset;\n\t\t\t} else {\n\t\t\t\tfor (chi = 0; chi < chl && k < MSDOS_NAME;\n\t\t\t\t     chi++, i++, k++) {\n\t\t\t\t\t\tptname[i] = work[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\tif (name_len > 0) {\n\t\tname_len += dotoffset;\n\n\t\tif (sbi->options.isvfat) {\n\t\t\tuni_name[uni_len] = 0x0000;\n\t\t\tname_len = fat_uni_to_x8(sb, uni_name, name,\n\t\t\t\t\t\t FAT_MAX_SHORT_SIZE);\n\t\t}\n\t}\n\n\treturn name_len;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)\n\nstatic int fat_parse_short(struct super_block *sb,\n\t\t\t   const struct msdos_dir_entry *de,\n\t\t\t   unsigned char *name, int dot_hidden)\n{\n\tconst struct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint isvfat = sbi->options.isvfat;\n\tint nocase = sbi->options.nocase;\n\tunsigned short opt_shortname = sbi->options.shortname;\n\tstruct nls_table *nls_disk = sbi->nls_disk;\n\twchar_t uni_name[14];\n\tunsigned char c, work[MSDOS_NAME];\n\tunsigned char *ptname = name;\n\tint chi, chl, i, j, k;\n\tint dotoffset = 0;\n\tint name_len = 0, uni_len = 0;\n\n\tif (!isvfat && dot_hidden && (de->attr & ATTR_HIDDEN)) {\n\t\t*ptname++ = '.';\n\t\tdotoffset = 1;\n\t}\n\n\tmemcpy(work, de->name, sizeof(work));\n\t/* see namei.c, msdos_format_name */\n\tif (work[0] == 0x05)\n\t\twork[0] = 0xE5;\n\n\t/* Filename */\n\tfor (i = 0, j = 0; i < 8;) {\n\t\tc = work[i];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[i], 8 - i,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_BASE);\n\t\tif (chl <= 1) {\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat)\n\t\t\t\ti += min(chl, 8-i);\n\t\t\telse {\n\t\t\t\tfor (chi = 0; chi < chl && i < 8; chi++, i++)\n\t\t\t\t\tptname[i] = work[i];\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\ti = name_len;\n\tj = uni_len;\n\tfat_short2uni(nls_disk, \".\", 1, &uni_name[j++]);\n\tif (!isvfat)\n\t\tptname[i] = '.';\n\ti++;\n\n\t/* Extension */\n\tfor (k = 8; k < MSDOS_NAME;) {\n\t\tc = work[k];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[k], MSDOS_NAME - k,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_EXT);\n\t\tif (chl <= 1) {\n\t\t\tk++;\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat) {\n\t\t\t\tint offset = min(chl, MSDOS_NAME-k);\n\t\t\t\tk += offset;\n\t\t\t\ti += offset;\n\t\t\t} else {\n\t\t\t\tfor (chi = 0; chi < chl && k < MSDOS_NAME;\n\t\t\t\t     chi++, i++, k++) {\n\t\t\t\t\t\tptname[i] = work[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\tif (name_len > 0) {\n\t\tname_len += dotoffset;\n\n\t\tif (sbi->options.isvfat) {\n\t\t\tuni_name[uni_len] = 0x0000;\n\t\t\tname_len = fat_uni_to_x8(sb, uni_name, name,\n\t\t\t\t\t\t FAT_MAX_SHORT_SIZE);\n\t\t}\n\t}\n\n\treturn name_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_parse_long",
          "args": [
            "inode",
            "&cpos",
            "&bh",
            "&de",
            "&unicode",
            "&nr_slots"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "fat_parse_long",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "283-343",
          "snippet": "static int fat_parse_long(struct inode *dir, loff_t *pos,\n\t\t\t  struct buffer_head **bh, struct msdos_dir_entry **de,\n\t\t\t  wchar_t **unicode, unsigned char *nr_slots)\n{\n\tstruct msdos_dir_slot *ds;\n\tunsigned char id, slot, slots, alias_checksum;\n\n\tif (!*unicode) {\n\t\t*unicode = __getname();\n\t\tif (!*unicode) {\n\t\t\tbrelse(*bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\nparse_long:\n\tslots = 0;\n\tds = (struct msdos_dir_slot *)*de;\n\tid = ds->id;\n\tif (!(id & 0x40))\n\t\treturn PARSE_INVALID;\n\tslots = id & ~0x40;\n\tif (slots > 20 || !slots)\t/* ceil(256 * 2 / 26) */\n\t\treturn PARSE_INVALID;\n\t*nr_slots = slots;\n\talias_checksum = ds->alias_checksum;\n\n\tslot = slots;\n\twhile (1) {\n\t\tint offset;\n\n\t\tslot--;\n\t\toffset = slot * 13;\n\t\tfat16_towchar(*unicode + offset, ds->name0_4, 5);\n\t\tfat16_towchar(*unicode + offset + 5, ds->name5_10, 6);\n\t\tfat16_towchar(*unicode + offset + 11, ds->name11_12, 2);\n\n\t\tif (ds->id & 0x40)\n\t\t\t(*unicode)[offset + 13] = 0;\n\t\tif (fat_get_entry(dir, pos, bh, de) < 0)\n\t\t\treturn PARSE_EOF;\n\t\tif (slot == 0)\n\t\t\tbreak;\n\t\tds = (struct msdos_dir_slot *)*de;\n\t\tif (ds->attr != ATTR_EXT)\n\t\t\treturn PARSE_NOT_LONGNAME;\n\t\tif ((ds->id & ~0x40) != slot)\n\t\t\tgoto parse_long;\n\t\tif (ds->alias_checksum != alias_checksum)\n\t\t\tgoto parse_long;\n\t}\n\tif ((*de)->name[0] == DELETED_FLAG)\n\t\treturn PARSE_INVALID;\n\tif ((*de)->attr == ATTR_EXT)\n\t\tgoto parse_long;\n\tif (IS_FREE((*de)->name) || ((*de)->attr & ATTR_VOLUME))\n\t\treturn PARSE_INVALID;\n\tif (fat_checksum((*de)->name) != alias_checksum)\n\t\t*nr_slots = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_parse_long(struct inode *dir, loff_t *pos,\n\t\t\t  struct buffer_head **bh, struct msdos_dir_entry **de,\n\t\t\t  wchar_t **unicode, unsigned char *nr_slots)\n{\n\tstruct msdos_dir_slot *ds;\n\tunsigned char id, slot, slots, alias_checksum;\n\n\tif (!*unicode) {\n\t\t*unicode = __getname();\n\t\tif (!*unicode) {\n\t\t\tbrelse(*bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\nparse_long:\n\tslots = 0;\n\tds = (struct msdos_dir_slot *)*de;\n\tid = ds->id;\n\tif (!(id & 0x40))\n\t\treturn PARSE_INVALID;\n\tslots = id & ~0x40;\n\tif (slots > 20 || !slots)\t/* ceil(256 * 2 / 26) */\n\t\treturn PARSE_INVALID;\n\t*nr_slots = slots;\n\talias_checksum = ds->alias_checksum;\n\n\tslot = slots;\n\twhile (1) {\n\t\tint offset;\n\n\t\tslot--;\n\t\toffset = slot * 13;\n\t\tfat16_towchar(*unicode + offset, ds->name0_4, 5);\n\t\tfat16_towchar(*unicode + offset + 5, ds->name5_10, 6);\n\t\tfat16_towchar(*unicode + offset + 11, ds->name11_12, 2);\n\n\t\tif (ds->id & 0x40)\n\t\t\t(*unicode)[offset + 13] = 0;\n\t\tif (fat_get_entry(dir, pos, bh, de) < 0)\n\t\t\treturn PARSE_EOF;\n\t\tif (slot == 0)\n\t\t\tbreak;\n\t\tds = (struct msdos_dir_slot *)*de;\n\t\tif (ds->attr != ATTR_EXT)\n\t\t\treturn PARSE_NOT_LONGNAME;\n\t\tif ((ds->id & ~0x40) != slot)\n\t\t\tgoto parse_long;\n\t\tif (ds->alias_checksum != alias_checksum)\n\t\t\tgoto parse_long;\n\t}\n\tif ((*de)->name[0] == DELETED_FLAG)\n\t\treturn PARSE_INVALID;\n\tif ((*de)->attr == ATTR_EXT)\n\t\tgoto parse_long;\n\tif (IS_FREE((*de)->name) || ((*de)->attr & ATTR_VOLUME))\n\t\treturn PARSE_INVALID;\n\tif (fat_checksum((*de)->name) != alias_checksum)\n\t\t*nr_slots = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FREE",
          "args": [
            "de->name"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_get_entry",
          "args": [
            "inode",
            "&cpos",
            "&bh",
            "&de"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "120-133",
          "snippet": "static inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define FAT_MAX_UNI_SIZE\t(FAT_MAX_UNI_CHARS * sizeof(wchar_t))\n#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)\n#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)\n\nint fat_search_long(struct inode *inode, const unsigned char *name,\n\t\t    int name_len, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\tstruct msdos_dir_entry *de;\n\tunsigned char nr_slots;\n\twchar_t *unicode = NULL;\n\tunsigned char bufname[FAT_MAX_SHORT_SIZE];\n\tloff_t cpos = 0;\n\tint err, len;\n\n\terr = -ENOENT;\n\twhile (1) {\n\t\tif (fat_get_entry(inode, &cpos, &bh, &de) == -1)\n\t\t\tgoto end_of_dir;\nparse_record:\n\t\tnr_slots = 0;\n\t\tif (de->name[0] == DELETED_FLAG)\n\t\t\tcontinue;\n\t\tif (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))\n\t\t\tcontinue;\n\t\tif (de->attr != ATTR_EXT && IS_FREE(de->name))\n\t\t\tcontinue;\n\t\tif (de->attr == ATTR_EXT) {\n\t\t\tint status = fat_parse_long(inode, &cpos, &bh, &de,\n\t\t\t\t\t\t    &unicode, &nr_slots);\n\t\t\tif (status < 0) {\n\t\t\t\terr = status;\n\t\t\t\tgoto end_of_dir;\n\t\t\t} else if (status == PARSE_INVALID)\n\t\t\t\tcontinue;\n\t\t\telse if (status == PARSE_NOT_LONGNAME)\n\t\t\t\tgoto parse_record;\n\t\t\telse if (status == PARSE_EOF)\n\t\t\t\tgoto end_of_dir;\n\t\t}\n\n\t\t/* Never prepend '.' to hidden files here.\n\t\t * That is done only for msdos mounts (and only when\n\t\t * 'dotsOK=yes'); if we are executing here, it is in the\n\t\t * context of a vfat mount.\n\t\t */\n\t\tlen = fat_parse_short(sb, de, bufname, 0);\n\t\tif (len == 0)\n\t\t\tcontinue;\n\n\t\t/* Compare shortname */\n\t\tif (fat_name_match(sbi, name, name_len, bufname, len))\n\t\t\tgoto found;\n\n\t\tif (nr_slots) {\n\t\t\tvoid *longname = unicode + FAT_MAX_UNI_CHARS;\n\t\t\tint size = PATH_MAX - FAT_MAX_UNI_SIZE;\n\n\t\t\t/* Compare longname */\n\t\t\tlen = fat_uni_to_x8(sb, unicode, longname, size);\n\t\t\tif (fat_name_match(sbi, name, name_len, longname, len))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\nfound:\n\tnr_slots++;\t/* include the de */\n\tsinfo->slot_off = cpos - nr_slots * sizeof(*de);\n\tsinfo->nr_slots = nr_slots;\n\tsinfo->de = de;\n\tsinfo->bh = bh;\n\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\terr = 0;\nend_of_dir:\n\tif (unicode)\n\t\t__putname(unicode);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fat_parse_short",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "354-461",
    "snippet": "static int fat_parse_short(struct super_block *sb,\n\t\t\t   const struct msdos_dir_entry *de,\n\t\t\t   unsigned char *name, int dot_hidden)\n{\n\tconst struct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint isvfat = sbi->options.isvfat;\n\tint nocase = sbi->options.nocase;\n\tunsigned short opt_shortname = sbi->options.shortname;\n\tstruct nls_table *nls_disk = sbi->nls_disk;\n\twchar_t uni_name[14];\n\tunsigned char c, work[MSDOS_NAME];\n\tunsigned char *ptname = name;\n\tint chi, chl, i, j, k;\n\tint dotoffset = 0;\n\tint name_len = 0, uni_len = 0;\n\n\tif (!isvfat && dot_hidden && (de->attr & ATTR_HIDDEN)) {\n\t\t*ptname++ = '.';\n\t\tdotoffset = 1;\n\t}\n\n\tmemcpy(work, de->name, sizeof(work));\n\t/* see namei.c, msdos_format_name */\n\tif (work[0] == 0x05)\n\t\twork[0] = 0xE5;\n\n\t/* Filename */\n\tfor (i = 0, j = 0; i < 8;) {\n\t\tc = work[i];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[i], 8 - i,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_BASE);\n\t\tif (chl <= 1) {\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat)\n\t\t\t\ti += min(chl, 8-i);\n\t\t\telse {\n\t\t\t\tfor (chi = 0; chi < chl && i < 8; chi++, i++)\n\t\t\t\t\tptname[i] = work[i];\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\ti = name_len;\n\tj = uni_len;\n\tfat_short2uni(nls_disk, \".\", 1, &uni_name[j++]);\n\tif (!isvfat)\n\t\tptname[i] = '.';\n\ti++;\n\n\t/* Extension */\n\tfor (k = 8; k < MSDOS_NAME;) {\n\t\tc = work[k];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[k], MSDOS_NAME - k,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_EXT);\n\t\tif (chl <= 1) {\n\t\t\tk++;\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat) {\n\t\t\t\tint offset = min(chl, MSDOS_NAME-k);\n\t\t\t\tk += offset;\n\t\t\t\ti += offset;\n\t\t\t} else {\n\t\t\t\tfor (chi = 0; chi < chl && k < MSDOS_NAME;\n\t\t\t\t     chi++, i++, k++) {\n\t\t\t\t\t\tptname[i] = work[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\tif (name_len > 0) {\n\t\tname_len += dotoffset;\n\n\t\tif (sbi->options.isvfat) {\n\t\t\tuni_name[uni_len] = 0x0000;\n\t\t\tname_len = fat_uni_to_x8(sb, uni_name, name,\n\t\t\t\t\t\t FAT_MAX_SHORT_SIZE);\n\t\t}\n\t}\n\n\treturn name_len;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_uni_to_x8",
          "args": [
            "sb",
            "uni_name",
            "name",
            "FAT_MAX_SHORT_SIZE"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "fat_uni_to_x8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "185-194",
          "snippet": "static inline int fat_uni_to_x8(struct super_block *sb, const wchar_t *uni,\n\t\t\t\tunsigned char *buf, int size)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tif (sbi->options.utf8)\n\t\treturn utf16s_to_utf8s(uni, FAT_MAX_UNI_CHARS,\n\t\t\t\tUTF16_HOST_ENDIAN, buf, size);\n\telse\n\t\treturn uni16_to_x8(sb, buf, uni, size, sbi->nls_io);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)\n\nstatic inline int fat_uni_to_x8(struct super_block *sb, const wchar_t *uni,\n\t\t\t\tunsigned char *buf, int size)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tif (sbi->options.utf8)\n\t\treturn utf16s_to_utf8s(uni, FAT_MAX_UNI_CHARS,\n\t\t\t\tUTF16_HOST_ENDIAN, buf, size);\n\telse\n\t\treturn uni16_to_x8(sb, buf, uni, size, sbi->nls_io);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "chl",
            "MSDOS_NAME-k"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "244-251",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_tolower",
          "args": [
            "c"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "fat_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "38-41",
          "snippet": "static inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_shortname2uni",
          "args": [
            "nls_disk",
            "&work[k]",
            "MSDOS_NAME - k",
            "&uni_name[j++]",
            "opt_shortname",
            "de->lcase & CASE_LOWER_EXT"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "fat_shortname2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "237-256",
          "snippet": "static inline int\nfat_shortname2uni(struct nls_table *nls, unsigned char *buf, int buf_size,\n\t\t  wchar_t *uni_buf, unsigned short opt, int lower)\n{\n\tint len = 0;\n\n\tif (opt & VFAT_SFN_DISPLAY_LOWER)\n\t\tlen =  fat_short2lower_uni(nls, buf, buf_size, uni_buf);\n\telse if (opt & VFAT_SFN_DISPLAY_WIN95)\n\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\telse if (opt & VFAT_SFN_DISPLAY_WINNT) {\n\t\tif (lower)\n\t\t\tlen = fat_short2lower_uni(nls, buf, buf_size, uni_buf);\n\t\telse\n\t\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\t} else\n\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\n\treturn len;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int\nfat_shortname2uni(struct nls_table *nls, unsigned char *buf, int buf_size,\n\t\t  wchar_t *uni_buf, unsigned short opt, int lower)\n{\n\tint len = 0;\n\n\tif (opt & VFAT_SFN_DISPLAY_LOWER)\n\t\tlen =  fat_short2lower_uni(nls, buf, buf_size, uni_buf);\n\telse if (opt & VFAT_SFN_DISPLAY_WIN95)\n\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\telse if (opt & VFAT_SFN_DISPLAY_WINNT) {\n\t\tif (lower)\n\t\t\tlen = fat_short2lower_uni(nls, buf, buf_size, uni_buf);\n\t\telse\n\t\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\t} else\n\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_short2uni",
          "args": [
            "nls_disk",
            "\".\"",
            "1",
            "&uni_name[j++]"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "fat_short2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "196-207",
          "snippet": "static inline int\nfat_short2uni(struct nls_table *t, unsigned char *c, int clen, wchar_t *uni)\n{\n\tint charlen;\n\n\tcharlen = t->char2uni(c, clen, uni);\n\tif (charlen < 0) {\n\t\t*uni = 0x003f;\t/* a question mark */\n\t\tcharlen = 1;\n\t}\n\treturn charlen;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int\nfat_short2uni(struct nls_table *t, unsigned char *c, int clen, wchar_t *uni)\n{\n\tint charlen;\n\n\tcharlen = t->char2uni(c, clen, uni);\n\tif (charlen < 0) {\n\t\t*uni = 0x003f;\t/* a question mark */\n\t\tcharlen = 1;\n\t}\n\treturn charlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "work",
            "de->name",
            "sizeof(work)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)\n\nstatic int fat_parse_short(struct super_block *sb,\n\t\t\t   const struct msdos_dir_entry *de,\n\t\t\t   unsigned char *name, int dot_hidden)\n{\n\tconst struct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint isvfat = sbi->options.isvfat;\n\tint nocase = sbi->options.nocase;\n\tunsigned short opt_shortname = sbi->options.shortname;\n\tstruct nls_table *nls_disk = sbi->nls_disk;\n\twchar_t uni_name[14];\n\tunsigned char c, work[MSDOS_NAME];\n\tunsigned char *ptname = name;\n\tint chi, chl, i, j, k;\n\tint dotoffset = 0;\n\tint name_len = 0, uni_len = 0;\n\n\tif (!isvfat && dot_hidden && (de->attr & ATTR_HIDDEN)) {\n\t\t*ptname++ = '.';\n\t\tdotoffset = 1;\n\t}\n\n\tmemcpy(work, de->name, sizeof(work));\n\t/* see namei.c, msdos_format_name */\n\tif (work[0] == 0x05)\n\t\twork[0] = 0xE5;\n\n\t/* Filename */\n\tfor (i = 0, j = 0; i < 8;) {\n\t\tc = work[i];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[i], 8 - i,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_BASE);\n\t\tif (chl <= 1) {\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat)\n\t\t\t\ti += min(chl, 8-i);\n\t\t\telse {\n\t\t\t\tfor (chi = 0; chi < chl && i < 8; chi++, i++)\n\t\t\t\t\tptname[i] = work[i];\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\ti = name_len;\n\tj = uni_len;\n\tfat_short2uni(nls_disk, \".\", 1, &uni_name[j++]);\n\tif (!isvfat)\n\t\tptname[i] = '.';\n\ti++;\n\n\t/* Extension */\n\tfor (k = 8; k < MSDOS_NAME;) {\n\t\tc = work[k];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[k], MSDOS_NAME - k,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_EXT);\n\t\tif (chl <= 1) {\n\t\t\tk++;\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat) {\n\t\t\t\tint offset = min(chl, MSDOS_NAME-k);\n\t\t\t\tk += offset;\n\t\t\t\ti += offset;\n\t\t\t} else {\n\t\t\t\tfor (chi = 0; chi < chl && k < MSDOS_NAME;\n\t\t\t\t     chi++, i++, k++) {\n\t\t\t\t\t\tptname[i] = work[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\tif (name_len > 0) {\n\t\tname_len += dotoffset;\n\n\t\tif (sbi->options.isvfat) {\n\t\t\tuni_name[uni_len] = 0x0000;\n\t\t\tname_len = fat_uni_to_x8(sb, uni_name, name,\n\t\t\t\t\t\t FAT_MAX_SHORT_SIZE);\n\t\t}\n\t}\n\n\treturn name_len;\n}"
  },
  {
    "function_name": "fat_parse_long",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "283-343",
    "snippet": "static int fat_parse_long(struct inode *dir, loff_t *pos,\n\t\t\t  struct buffer_head **bh, struct msdos_dir_entry **de,\n\t\t\t  wchar_t **unicode, unsigned char *nr_slots)\n{\n\tstruct msdos_dir_slot *ds;\n\tunsigned char id, slot, slots, alias_checksum;\n\n\tif (!*unicode) {\n\t\t*unicode = __getname();\n\t\tif (!*unicode) {\n\t\t\tbrelse(*bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\nparse_long:\n\tslots = 0;\n\tds = (struct msdos_dir_slot *)*de;\n\tid = ds->id;\n\tif (!(id & 0x40))\n\t\treturn PARSE_INVALID;\n\tslots = id & ~0x40;\n\tif (slots > 20 || !slots)\t/* ceil(256 * 2 / 26) */\n\t\treturn PARSE_INVALID;\n\t*nr_slots = slots;\n\talias_checksum = ds->alias_checksum;\n\n\tslot = slots;\n\twhile (1) {\n\t\tint offset;\n\n\t\tslot--;\n\t\toffset = slot * 13;\n\t\tfat16_towchar(*unicode + offset, ds->name0_4, 5);\n\t\tfat16_towchar(*unicode + offset + 5, ds->name5_10, 6);\n\t\tfat16_towchar(*unicode + offset + 11, ds->name11_12, 2);\n\n\t\tif (ds->id & 0x40)\n\t\t\t(*unicode)[offset + 13] = 0;\n\t\tif (fat_get_entry(dir, pos, bh, de) < 0)\n\t\t\treturn PARSE_EOF;\n\t\tif (slot == 0)\n\t\t\tbreak;\n\t\tds = (struct msdos_dir_slot *)*de;\n\t\tif (ds->attr != ATTR_EXT)\n\t\t\treturn PARSE_NOT_LONGNAME;\n\t\tif ((ds->id & ~0x40) != slot)\n\t\t\tgoto parse_long;\n\t\tif (ds->alias_checksum != alias_checksum)\n\t\t\tgoto parse_long;\n\t}\n\tif ((*de)->name[0] == DELETED_FLAG)\n\t\treturn PARSE_INVALID;\n\tif ((*de)->attr == ATTR_EXT)\n\t\tgoto parse_long;\n\tif (IS_FREE((*de)->name) || ((*de)->attr & ATTR_VOLUME))\n\t\treturn PARSE_INVALID;\n\tif (fat_checksum((*de)->name) != alias_checksum)\n\t\t*nr_slots = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_checksum",
          "args": [
            "(*de)->name"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "fat_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "208-217",
          "snippet": "static inline unsigned char fat_checksum(const __u8 *name)\n{\n\tunsigned char s = name[0];\n\ts = (s<<7) + (s>>1) + name[1];\ts = (s<<7) + (s>>1) + name[2];\n\ts = (s<<7) + (s>>1) + name[3];\ts = (s<<7) + (s>>1) + name[4];\n\ts = (s<<7) + (s>>1) + name[5];\ts = (s<<7) + (s>>1) + name[6];\n\ts = (s<<7) + (s>>1) + name[7];\ts = (s<<7) + (s>>1) + name[8];\n\ts = (s<<7) + (s>>1) + name[9];\ts = (s<<7) + (s>>1) + name[10];\n\treturn s;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline unsigned char fat_checksum(const __u8 *name)\n{\n\tunsigned char s = name[0];\n\ts = (s<<7) + (s>>1) + name[1];\ts = (s<<7) + (s>>1) + name[2];\n\ts = (s<<7) + (s>>1) + name[3];\ts = (s<<7) + (s>>1) + name[4];\n\ts = (s<<7) + (s>>1) + name[5];\ts = (s<<7) + (s>>1) + name[6];\n\ts = (s<<7) + (s>>1) + name[7];\ts = (s<<7) + (s>>1) + name[8];\n\ts = (s<<7) + (s>>1) + name[9];\ts = (s<<7) + (s>>1) + name[10];\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FREE",
          "args": [
            "(*de)->name"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_get_entry",
          "args": [
            "dir",
            "pos",
            "bh",
            "de"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "120-133",
          "snippet": "static inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat16_towchar",
          "args": [
            "*unicode + offset + 11",
            "ds->name11_12",
            "2"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "fat16_towchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "246-256",
          "snippet": "static inline void fat16_towchar(wchar_t *dst, const __u8 *src, size_t len)\n{\n#ifdef __BIG_ENDIAN\n\twhile (len--) {\n\t\t*dst++ = src[0] | (src[1] << 8);\n\t\tsrc += 2;\n\t}\n#else\n\tmemcpy(dst, src, len * 2);\n#endif\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fat16_towchar(wchar_t *dst, const __u8 *src, size_t len)\n{\n#ifdef __BIG_ENDIAN\n\twhile (len--) {\n\t\t*dst++ = src[0] | (src[1] << 8);\n\t\tsrc += 2;\n\t}\n#else\n\tmemcpy(dst, src, len * 2);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*bh"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__getname",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat_parse_long(struct inode *dir, loff_t *pos,\n\t\t\t  struct buffer_head **bh, struct msdos_dir_entry **de,\n\t\t\t  wchar_t **unicode, unsigned char *nr_slots)\n{\n\tstruct msdos_dir_slot *ds;\n\tunsigned char id, slot, slots, alias_checksum;\n\n\tif (!*unicode) {\n\t\t*unicode = __getname();\n\t\tif (!*unicode) {\n\t\t\tbrelse(*bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\nparse_long:\n\tslots = 0;\n\tds = (struct msdos_dir_slot *)*de;\n\tid = ds->id;\n\tif (!(id & 0x40))\n\t\treturn PARSE_INVALID;\n\tslots = id & ~0x40;\n\tif (slots > 20 || !slots)\t/* ceil(256 * 2 / 26) */\n\t\treturn PARSE_INVALID;\n\t*nr_slots = slots;\n\talias_checksum = ds->alias_checksum;\n\n\tslot = slots;\n\twhile (1) {\n\t\tint offset;\n\n\t\tslot--;\n\t\toffset = slot * 13;\n\t\tfat16_towchar(*unicode + offset, ds->name0_4, 5);\n\t\tfat16_towchar(*unicode + offset + 5, ds->name5_10, 6);\n\t\tfat16_towchar(*unicode + offset + 11, ds->name11_12, 2);\n\n\t\tif (ds->id & 0x40)\n\t\t\t(*unicode)[offset + 13] = 0;\n\t\tif (fat_get_entry(dir, pos, bh, de) < 0)\n\t\t\treturn PARSE_EOF;\n\t\tif (slot == 0)\n\t\t\tbreak;\n\t\tds = (struct msdos_dir_slot *)*de;\n\t\tif (ds->attr != ATTR_EXT)\n\t\t\treturn PARSE_NOT_LONGNAME;\n\t\tif ((ds->id & ~0x40) != slot)\n\t\t\tgoto parse_long;\n\t\tif (ds->alias_checksum != alias_checksum)\n\t\t\tgoto parse_long;\n\t}\n\tif ((*de)->name[0] == DELETED_FLAG)\n\t\treturn PARSE_INVALID;\n\tif ((*de)->attr == ATTR_EXT)\n\t\tgoto parse_long;\n\tif (IS_FREE((*de)->name) || ((*de)->attr & ATTR_VOLUME))\n\t\treturn PARSE_INVALID;\n\tif (fat_checksum((*de)->name) != alias_checksum)\n\t\t*nr_slots = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_name_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "258-269",
    "snippet": "static inline int fat_name_match(struct msdos_sb_info *sbi,\n\t\t\t\t const unsigned char *a, int a_len,\n\t\t\t\t const unsigned char *b, int b_len)\n{\n\tif (a_len != b_len)\n\t\treturn 0;\n\n\tif (sbi->options.name_check != 's')\n\t\treturn !nls_strnicmp(sbi->nls_io, a, b, a_len);\n\telse\n\t\treturn !memcmp(a, b, a_len);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a",
            "b",
            "a_len"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nls_strnicmp",
          "args": [
            "sbi->nls_io",
            "a",
            "b",
            "a_len"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int fat_name_match(struct msdos_sb_info *sbi,\n\t\t\t\t const unsigned char *a, int a_len,\n\t\t\t\t const unsigned char *b, int b_len)\n{\n\tif (a_len != b_len)\n\t\treturn 0;\n\n\tif (sbi->options.name_check != 's')\n\t\treturn !nls_strnicmp(sbi->nls_io, a, b, a_len);\n\telse\n\t\treturn !memcmp(a, b, a_len);\n}"
  },
  {
    "function_name": "fat_shortname2uni",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "237-256",
    "snippet": "static inline int\nfat_shortname2uni(struct nls_table *nls, unsigned char *buf, int buf_size,\n\t\t  wchar_t *uni_buf, unsigned short opt, int lower)\n{\n\tint len = 0;\n\n\tif (opt & VFAT_SFN_DISPLAY_LOWER)\n\t\tlen =  fat_short2lower_uni(nls, buf, buf_size, uni_buf);\n\telse if (opt & VFAT_SFN_DISPLAY_WIN95)\n\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\telse if (opt & VFAT_SFN_DISPLAY_WINNT) {\n\t\tif (lower)\n\t\t\tlen = fat_short2lower_uni(nls, buf, buf_size, uni_buf);\n\t\telse\n\t\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\t} else\n\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\n\treturn len;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_short2uni",
          "args": [
            "nls",
            "buf",
            "buf_size",
            "uni_buf"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "fat_short2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "196-207",
          "snippet": "static inline int\nfat_short2uni(struct nls_table *t, unsigned char *c, int clen, wchar_t *uni)\n{\n\tint charlen;\n\n\tcharlen = t->char2uni(c, clen, uni);\n\tif (charlen < 0) {\n\t\t*uni = 0x003f;\t/* a question mark */\n\t\tcharlen = 1;\n\t}\n\treturn charlen;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int\nfat_short2uni(struct nls_table *t, unsigned char *c, int clen, wchar_t *uni)\n{\n\tint charlen;\n\n\tcharlen = t->char2uni(c, clen, uni);\n\tif (charlen < 0) {\n\t\t*uni = 0x003f;\t/* a question mark */\n\t\tcharlen = 1;\n\t}\n\treturn charlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_short2lower_uni",
          "args": [
            "nls",
            "buf",
            "buf_size",
            "uni_buf"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "fat_short2lower_uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "209-235",
          "snippet": "static inline int\nfat_short2lower_uni(struct nls_table *t, unsigned char *c,\n\t\t    int clen, wchar_t *uni)\n{\n\tint charlen;\n\twchar_t wc;\n\n\tcharlen = t->char2uni(c, clen, &wc);\n\tif (charlen < 0) {\n\t\t*uni = 0x003f;\t/* a question mark */\n\t\tcharlen = 1;\n\t} else if (charlen <= 1) {\n\t\tunsigned char nc = t->charset2lower[*c];\n\n\t\tif (!nc)\n\t\t\tnc = *c;\n\n\t\tcharlen = t->char2uni(&nc, 1, uni);\n\t\tif (charlen < 0) {\n\t\t\t*uni = 0x003f;\t/* a question mark */\n\t\t\tcharlen = 1;\n\t\t}\n\t} else\n\t\t*uni = wc;\n\n\treturn charlen;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int\nfat_short2lower_uni(struct nls_table *t, unsigned char *c,\n\t\t    int clen, wchar_t *uni)\n{\n\tint charlen;\n\twchar_t wc;\n\n\tcharlen = t->char2uni(c, clen, &wc);\n\tif (charlen < 0) {\n\t\t*uni = 0x003f;\t/* a question mark */\n\t\tcharlen = 1;\n\t} else if (charlen <= 1) {\n\t\tunsigned char nc = t->charset2lower[*c];\n\n\t\tif (!nc)\n\t\t\tnc = *c;\n\n\t\tcharlen = t->char2uni(&nc, 1, uni);\n\t\tif (charlen < 0) {\n\t\t\t*uni = 0x003f;\t/* a question mark */\n\t\t\tcharlen = 1;\n\t\t}\n\t} else\n\t\t*uni = wc;\n\n\treturn charlen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int\nfat_shortname2uni(struct nls_table *nls, unsigned char *buf, int buf_size,\n\t\t  wchar_t *uni_buf, unsigned short opt, int lower)\n{\n\tint len = 0;\n\n\tif (opt & VFAT_SFN_DISPLAY_LOWER)\n\t\tlen =  fat_short2lower_uni(nls, buf, buf_size, uni_buf);\n\telse if (opt & VFAT_SFN_DISPLAY_WIN95)\n\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\telse if (opt & VFAT_SFN_DISPLAY_WINNT) {\n\t\tif (lower)\n\t\t\tlen = fat_short2lower_uni(nls, buf, buf_size, uni_buf);\n\t\telse\n\t\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\t} else\n\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\n\treturn len;\n}"
  },
  {
    "function_name": "fat_short2lower_uni",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "209-235",
    "snippet": "static inline int\nfat_short2lower_uni(struct nls_table *t, unsigned char *c,\n\t\t    int clen, wchar_t *uni)\n{\n\tint charlen;\n\twchar_t wc;\n\n\tcharlen = t->char2uni(c, clen, &wc);\n\tif (charlen < 0) {\n\t\t*uni = 0x003f;\t/* a question mark */\n\t\tcharlen = 1;\n\t} else if (charlen <= 1) {\n\t\tunsigned char nc = t->charset2lower[*c];\n\n\t\tif (!nc)\n\t\t\tnc = *c;\n\n\t\tcharlen = t->char2uni(&nc, 1, uni);\n\t\tif (charlen < 0) {\n\t\t\t*uni = 0x003f;\t/* a question mark */\n\t\t\tcharlen = 1;\n\t\t}\n\t} else\n\t\t*uni = wc;\n\n\treturn charlen;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->char2uni",
          "args": [
            "&nc",
            "1",
            "uni"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "char2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7877-7908",
          "snippet": "static int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};\n\nstatic int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int\nfat_short2lower_uni(struct nls_table *t, unsigned char *c,\n\t\t    int clen, wchar_t *uni)\n{\n\tint charlen;\n\twchar_t wc;\n\n\tcharlen = t->char2uni(c, clen, &wc);\n\tif (charlen < 0) {\n\t\t*uni = 0x003f;\t/* a question mark */\n\t\tcharlen = 1;\n\t} else if (charlen <= 1) {\n\t\tunsigned char nc = t->charset2lower[*c];\n\n\t\tif (!nc)\n\t\t\tnc = *c;\n\n\t\tcharlen = t->char2uni(&nc, 1, uni);\n\t\tif (charlen < 0) {\n\t\t\t*uni = 0x003f;\t/* a question mark */\n\t\t\tcharlen = 1;\n\t\t}\n\t} else\n\t\t*uni = wc;\n\n\treturn charlen;\n}"
  },
  {
    "function_name": "fat_short2uni",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "196-207",
    "snippet": "static inline int\nfat_short2uni(struct nls_table *t, unsigned char *c, int clen, wchar_t *uni)\n{\n\tint charlen;\n\n\tcharlen = t->char2uni(c, clen, uni);\n\tif (charlen < 0) {\n\t\t*uni = 0x003f;\t/* a question mark */\n\t\tcharlen = 1;\n\t}\n\treturn charlen;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->char2uni",
          "args": [
            "c",
            "clen",
            "uni"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "char2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7877-7908",
          "snippet": "static int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};\n\nstatic int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int\nfat_short2uni(struct nls_table *t, unsigned char *c, int clen, wchar_t *uni)\n{\n\tint charlen;\n\n\tcharlen = t->char2uni(c, clen, uni);\n\tif (charlen < 0) {\n\t\t*uni = 0x003f;\t/* a question mark */\n\t\tcharlen = 1;\n\t}\n\treturn charlen;\n}"
  },
  {
    "function_name": "fat_uni_to_x8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "185-194",
    "snippet": "static inline int fat_uni_to_x8(struct super_block *sb, const wchar_t *uni,\n\t\t\t\tunsigned char *buf, int size)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tif (sbi->options.utf8)\n\t\treturn utf16s_to_utf8s(uni, FAT_MAX_UNI_CHARS,\n\t\t\t\tUTF16_HOST_ENDIAN, buf, size);\n\telse\n\t\treturn uni16_to_x8(sb, buf, uni, size, sbi->nls_io);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uni16_to_x8",
          "args": [
            "sb",
            "buf",
            "uni",
            "size",
            "sbi->nls_io"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "uni16_to_x8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "145-183",
          "snippet": "static int uni16_to_x8(struct super_block *sb, unsigned char *ascii,\n\t\t       const wchar_t *uni, int len, struct nls_table *nls)\n{\n\tint uni_xlate = MSDOS_SB(sb)->options.unicode_xlate;\n\tconst wchar_t *ip;\n\twchar_t ec;\n\tunsigned char *op;\n\tint charlen;\n\n\tip = uni;\n\top = ascii;\n\n\twhile (*ip && ((len - NLS_MAX_CHARSET_SIZE) > 0)) {\n\t\tec = *ip++;\n\t\tcharlen = nls->uni2char(ec, op, NLS_MAX_CHARSET_SIZE);\n\t\tif (charlen > 0) {\n\t\t\top += charlen;\n\t\t\tlen -= charlen;\n\t\t} else {\n\t\t\tif (uni_xlate == 1) {\n\t\t\t\t*op++ = ':';\n\t\t\t\top = hex_byte_pack(op, ec >> 8);\n\t\t\t\top = hex_byte_pack(op, ec);\n\t\t\t\tlen -= 5;\n\t\t\t} else {\n\t\t\t\t*op++ = '?';\n\t\t\t\tlen--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(*ip)) {\n\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\"filename was truncated while converting.\");\n\t}\n\n\t*op = 0;\n\treturn op - ascii;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int uni16_to_x8(struct super_block *sb, unsigned char *ascii,\n\t\t       const wchar_t *uni, int len, struct nls_table *nls)\n{\n\tint uni_xlate = MSDOS_SB(sb)->options.unicode_xlate;\n\tconst wchar_t *ip;\n\twchar_t ec;\n\tunsigned char *op;\n\tint charlen;\n\n\tip = uni;\n\top = ascii;\n\n\twhile (*ip && ((len - NLS_MAX_CHARSET_SIZE) > 0)) {\n\t\tec = *ip++;\n\t\tcharlen = nls->uni2char(ec, op, NLS_MAX_CHARSET_SIZE);\n\t\tif (charlen > 0) {\n\t\t\top += charlen;\n\t\t\tlen -= charlen;\n\t\t} else {\n\t\t\tif (uni_xlate == 1) {\n\t\t\t\t*op++ = ':';\n\t\t\t\top = hex_byte_pack(op, ec >> 8);\n\t\t\t\top = hex_byte_pack(op, ec);\n\t\t\t\tlen -= 5;\n\t\t\t} else {\n\t\t\t\t*op++ = '?';\n\t\t\t\tlen--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(*ip)) {\n\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\"filename was truncated while converting.\");\n\t}\n\n\t*op = 0;\n\treturn op - ascii;\n}"
        }
      },
      {
        "call_info": {
          "callee": "utf16s_to_utf8s",
          "args": [
            "uni",
            "FAT_MAX_UNI_CHARS",
            "UTF16_HOST_ENDIAN",
            "buf",
            "size"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "utf16s_to_utf8s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "186-232",
          "snippet": "int utf16s_to_utf8s(const wchar_t *pwcs, int inlen, enum utf16_endian endian,\n\t\tu8 *s, int maxout)\n{\n\tu8 *op;\n\tint size;\n\tunsigned long u, v;\n\n\top = s;\n\twhile (inlen > 0 && maxout > 0) {\n\t\tu = get_utf16(*pwcs, endian);\n\t\tif (!u)\n\t\t\tbreak;\n\t\tpwcs++;\n\t\tinlen--;\n\t\tif (u > 0x7f) {\n\t\t\tif ((u & SURROGATE_MASK) == SURROGATE_PAIR) {\n\t\t\t\tif (u & SURROGATE_LOW) {\n\t\t\t\t\t/* Ignore character and move on */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (inlen <= 0)\n\t\t\t\t\tbreak;\n\t\t\t\tv = get_utf16(*pwcs, endian);\n\t\t\t\tif ((v & SURROGATE_MASK) != SURROGATE_PAIR ||\n\t\t\t\t\t\t!(v & SURROGATE_LOW)) {\n\t\t\t\t\t/* Ignore character and move on */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tu = PLANE_SIZE + ((u & SURROGATE_BITS) << 10)\n\t\t\t\t\t\t+ (v & SURROGATE_BITS);\n\t\t\t\tpwcs++;\n\t\t\t\tinlen--;\n\t\t\t}\n\t\t\tsize = utf32_to_utf8(u, op, maxout);\n\t\t\tif (size == -1) {\n\t\t\t\t/* Ignore character and move on */\n\t\t\t} else {\n\t\t\t\top += size;\n\t\t\t\tmaxout -= size;\n\t\t\t}\n\t\t} else {\n\t\t\t*op++ = (u8) u;\n\t\t\tmaxout--;\n\t\t}\n\t}\n\treturn op - s;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SURROGATE_BITS\t0x000003ff",
            "#define SURROGATE_LOW\t0x00000400",
            "#define SURROGATE_PAIR\t0x0000d800",
            "#define SURROGATE_MASK\t0xfffff800",
            "#define PLANE_SIZE\t0x00010000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#define SURROGATE_BITS\t0x000003ff\n#define SURROGATE_LOW\t0x00000400\n#define SURROGATE_PAIR\t0x0000d800\n#define SURROGATE_MASK\t0xfffff800\n#define PLANE_SIZE\t0x00010000\n\nint utf16s_to_utf8s(const wchar_t *pwcs, int inlen, enum utf16_endian endian,\n\t\tu8 *s, int maxout)\n{\n\tu8 *op;\n\tint size;\n\tunsigned long u, v;\n\n\top = s;\n\twhile (inlen > 0 && maxout > 0) {\n\t\tu = get_utf16(*pwcs, endian);\n\t\tif (!u)\n\t\t\tbreak;\n\t\tpwcs++;\n\t\tinlen--;\n\t\tif (u > 0x7f) {\n\t\t\tif ((u & SURROGATE_MASK) == SURROGATE_PAIR) {\n\t\t\t\tif (u & SURROGATE_LOW) {\n\t\t\t\t\t/* Ignore character and move on */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (inlen <= 0)\n\t\t\t\t\tbreak;\n\t\t\t\tv = get_utf16(*pwcs, endian);\n\t\t\t\tif ((v & SURROGATE_MASK) != SURROGATE_PAIR ||\n\t\t\t\t\t\t!(v & SURROGATE_LOW)) {\n\t\t\t\t\t/* Ignore character and move on */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tu = PLANE_SIZE + ((u & SURROGATE_BITS) << 10)\n\t\t\t\t\t\t+ (v & SURROGATE_BITS);\n\t\t\t\tpwcs++;\n\t\t\t\tinlen--;\n\t\t\t}\n\t\t\tsize = utf32_to_utf8(u, op, maxout);\n\t\t\tif (size == -1) {\n\t\t\t\t/* Ignore character and move on */\n\t\t\t} else {\n\t\t\t\top += size;\n\t\t\t\tmaxout -= size;\n\t\t\t}\n\t\t} else {\n\t\t\t*op++ = (u8) u;\n\t\t\tmaxout--;\n\t\t}\n\t}\n\treturn op - s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)\n\nstatic inline int fat_uni_to_x8(struct super_block *sb, const wchar_t *uni,\n\t\t\t\tunsigned char *buf, int size)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tif (sbi->options.utf8)\n\t\treturn utf16s_to_utf8s(uni, FAT_MAX_UNI_CHARS,\n\t\t\t\tUTF16_HOST_ENDIAN, buf, size);\n\telse\n\t\treturn uni16_to_x8(sb, buf, uni, size, sbi->nls_io);\n}"
  },
  {
    "function_name": "uni16_to_x8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "145-183",
    "snippet": "static int uni16_to_x8(struct super_block *sb, unsigned char *ascii,\n\t\t       const wchar_t *uni, int len, struct nls_table *nls)\n{\n\tint uni_xlate = MSDOS_SB(sb)->options.unicode_xlate;\n\tconst wchar_t *ip;\n\twchar_t ec;\n\tunsigned char *op;\n\tint charlen;\n\n\tip = uni;\n\top = ascii;\n\n\twhile (*ip && ((len - NLS_MAX_CHARSET_SIZE) > 0)) {\n\t\tec = *ip++;\n\t\tcharlen = nls->uni2char(ec, op, NLS_MAX_CHARSET_SIZE);\n\t\tif (charlen > 0) {\n\t\t\top += charlen;\n\t\t\tlen -= charlen;\n\t\t} else {\n\t\t\tif (uni_xlate == 1) {\n\t\t\t\t*op++ = ':';\n\t\t\t\top = hex_byte_pack(op, ec >> 8);\n\t\t\t\top = hex_byte_pack(op, ec);\n\t\t\t\tlen -= 5;\n\t\t\t} else {\n\t\t\t\t*op++ = '?';\n\t\t\t\tlen--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(*ip)) {\n\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\"filename was truncated while converting.\");\n\t}\n\n\t*op = 0;\n\treturn op - ascii;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"filename was truncated while converting.\""
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*ip"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_byte_pack",
          "args": [
            "op",
            "ec"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_byte_pack",
          "args": [
            "op",
            "ec >> 8"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nls->uni2char",
          "args": [
            "ec",
            "op",
            "NLS_MAX_CHARSET_SIZE"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "uni2char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7837-7875",
          "snippet": "static int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};",
            "static const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};\nstatic const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };\n\nstatic int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int uni16_to_x8(struct super_block *sb, unsigned char *ascii,\n\t\t       const wchar_t *uni, int len, struct nls_table *nls)\n{\n\tint uni_xlate = MSDOS_SB(sb)->options.unicode_xlate;\n\tconst wchar_t *ip;\n\twchar_t ec;\n\tunsigned char *op;\n\tint charlen;\n\n\tip = uni;\n\top = ascii;\n\n\twhile (*ip && ((len - NLS_MAX_CHARSET_SIZE) > 0)) {\n\t\tec = *ip++;\n\t\tcharlen = nls->uni2char(ec, op, NLS_MAX_CHARSET_SIZE);\n\t\tif (charlen > 0) {\n\t\t\top += charlen;\n\t\t\tlen -= charlen;\n\t\t} else {\n\t\t\tif (uni_xlate == 1) {\n\t\t\t\t*op++ = ':';\n\t\t\t\top = hex_byte_pack(op, ec >> 8);\n\t\t\t\top = hex_byte_pack(op, ec);\n\t\t\t\tlen -= 5;\n\t\t\t} else {\n\t\t\t\t*op++ = '?';\n\t\t\t\tlen--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(*ip)) {\n\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\"filename was truncated while converting.\");\n\t}\n\n\t*op = 0;\n\treturn op - ascii;\n}"
  },
  {
    "function_name": "fat_get_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "120-133",
    "snippet": "static inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat__get_entry",
          "args": [
            "dir",
            "pos",
            "bh",
            "de"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "fat__get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "84-118",
          "snippet": "static int fat__get_entry(struct inode *dir, loff_t *pos,\n\t\t\t  struct buffer_head **bh, struct msdos_dir_entry **de)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tsector_t phys, iblock;\n\tunsigned long mapped_blocks;\n\tint err, offset;\n\nnext:\n\tif (*bh)\n\t\tbrelse(*bh);\n\n\t*bh = NULL;\n\tiblock = *pos >> sb->s_blocksize_bits;\n\terr = fat_bmap(dir, iblock, &phys, &mapped_blocks, 0);\n\tif (err || !phys)\n\t\treturn -1;\t/* beyond EOF or error */\n\n\tfat_dir_readahead(dir, iblock, phys);\n\n\t*bh = sb_bread(sb, phys);\n\tif (*bh == NULL) {\n\t\tfat_msg_ratelimit(sb, KERN_ERR,\n\t\t\t\"Directory bread(block %llu) failed\", (llu)phys);\n\t\t/* skip this block */\n\t\t*pos = (iblock + 1) << sb->s_blocksize_bits;\n\t\tgoto next;\n\t}\n\n\toffset = *pos & (sb->s_blocksize - 1);\n\t*pos += sizeof(struct msdos_dir_entry);\n\t*de = (struct msdos_dir_entry *)((*bh)->b_data + offset);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat__get_entry(struct inode *dir, loff_t *pos,\n\t\t\t  struct buffer_head **bh, struct msdos_dir_entry **de)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tsector_t phys, iblock;\n\tunsigned long mapped_blocks;\n\tint err, offset;\n\nnext:\n\tif (*bh)\n\t\tbrelse(*bh);\n\n\t*bh = NULL;\n\tiblock = *pos >> sb->s_blocksize_bits;\n\terr = fat_bmap(dir, iblock, &phys, &mapped_blocks, 0);\n\tif (err || !phys)\n\t\treturn -1;\t/* beyond EOF or error */\n\n\tfat_dir_readahead(dir, iblock, phys);\n\n\t*bh = sb_bread(sb, phys);\n\tif (*bh == NULL) {\n\t\tfat_msg_ratelimit(sb, KERN_ERR,\n\t\t\t\"Directory bread(block %llu) failed\", (llu)phys);\n\t\t/* skip this block */\n\t\t*pos = (iblock + 1) << sb->s_blocksize_bits;\n\t\tgoto next;\n\t}\n\n\toffset = *pos & (sb->s_blocksize - 1);\n\t*pos += sizeof(struct msdos_dir_entry);\n\t*de = (struct msdos_dir_entry *)((*bh)->b_data + offset);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t/* Fast stuff first */\n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}"
  },
  {
    "function_name": "fat__get_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "84-118",
    "snippet": "static int fat__get_entry(struct inode *dir, loff_t *pos,\n\t\t\t  struct buffer_head **bh, struct msdos_dir_entry **de)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tsector_t phys, iblock;\n\tunsigned long mapped_blocks;\n\tint err, offset;\n\nnext:\n\tif (*bh)\n\t\tbrelse(*bh);\n\n\t*bh = NULL;\n\tiblock = *pos >> sb->s_blocksize_bits;\n\terr = fat_bmap(dir, iblock, &phys, &mapped_blocks, 0);\n\tif (err || !phys)\n\t\treturn -1;\t/* beyond EOF or error */\n\n\tfat_dir_readahead(dir, iblock, phys);\n\n\t*bh = sb_bread(sb, phys);\n\tif (*bh == NULL) {\n\t\tfat_msg_ratelimit(sb, KERN_ERR,\n\t\t\t\"Directory bread(block %llu) failed\", (llu)phys);\n\t\t/* skip this block */\n\t\t*pos = (iblock + 1) << sb->s_blocksize_bits;\n\t\tgoto next;\n\t}\n\n\toffset = *pos & (sb->s_blocksize - 1);\n\t*pos += sizeof(struct msdos_dir_entry);\n\t*de = (struct msdos_dir_entry *)((*bh)->b_data + offset);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_msg_ratelimit",
          "args": [
            "sb",
            "KERN_ERR",
            "\"Directory bread(block %llu) failed\"",
            "(llu)phys"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "phys"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_dir_readahead",
          "args": [
            "dir",
            "iblock",
            "phys"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "fat_dir_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "51-72",
          "snippet": "static inline void fat_dir_readahead(struct inode *dir, sector_t iblock,\n\t\t\t\t     sector_t phys)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tint sec;\n\n\t/* This is not a first sector of cluster, or sec_per_clus == 1 */\n\tif ((iblock & (sbi->sec_per_clus - 1)) || sbi->sec_per_clus == 1)\n\t\treturn;\n\t/* root dir of FAT12/FAT16 */\n\tif ((sbi->fat_bits != 32) && (dir->i_ino == MSDOS_ROOT_INO))\n\t\treturn;\n\n\tbh = sb_find_get_block(sb, phys);\n\tif (bh == NULL || !buffer_uptodate(bh)) {\n\t\tfor (sec = 0; sec < sbi->sec_per_clus; sec++)\n\t\t\tsb_breadahead(sb, phys + sec);\n\t}\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void fat_dir_readahead(struct inode *dir, sector_t iblock,\n\t\t\t\t     sector_t phys)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tint sec;\n\n\t/* This is not a first sector of cluster, or sec_per_clus == 1 */\n\tif ((iblock & (sbi->sec_per_clus - 1)) || sbi->sec_per_clus == 1)\n\t\treturn;\n\t/* root dir of FAT12/FAT16 */\n\tif ((sbi->fat_bits != 32) && (dir->i_ino == MSDOS_ROOT_INO))\n\t\treturn;\n\n\tbh = sb_find_get_block(sb, phys);\n\tif (bh == NULL || !buffer_uptodate(bh)) {\n\t\tfor (sec = 0; sec < sbi->sec_per_clus; sec++)\n\t\t\tsb_breadahead(sb, phys + sec);\n\t}\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_bmap",
          "args": [
            "dir",
            "iblock",
            "&phys",
            "&mapped_blocks",
            "0"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "fat_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "306-353",
          "snippet": "int fat_bmap(struct inode *inode, sector_t sector, sector_t *phys,\n\t     unsigned long *mapped_blocks, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst unsigned long blocksize = sb->s_blocksize;\n\tconst unsigned char blocksize_bits = sb->s_blocksize_bits;\n\tsector_t last_block;\n\tint cluster, offset;\n\n\t*phys = 0;\n\t*mapped_blocks = 0;\n\tif ((sbi->fat_bits != 32) && (inode->i_ino == MSDOS_ROOT_INO)) {\n\t\tif (sector < (sbi->dir_entries >> sbi->dir_per_block_bits)) {\n\t\t\t*phys = sector + sbi->dir_start;\n\t\t\t*mapped_blocks = 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tlast_block = (i_size_read(inode) + (blocksize - 1)) >> blocksize_bits;\n\tif (sector >= last_block) {\n\t\tif (!create)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * ->mmu_private can access on only allocation path.\n\t\t * (caller must hold ->i_mutex)\n\t\t */\n\t\tlast_block = (MSDOS_I(inode)->mmu_private + (blocksize - 1))\n\t\t\t>> blocksize_bits;\n\t\tif (sector >= last_block)\n\t\t\treturn 0;\n\t}\n\n\tcluster = sector >> (sbi->cluster_bits - sb->s_blocksize_bits);\n\toffset  = sector & (sbi->sec_per_clus - 1);\n\tcluster = fat_bmap_cluster(inode, cluster);\n\tif (cluster < 0)\n\t\treturn cluster;\n\telse if (cluster) {\n\t\t*phys = fat_clus_to_blknr(sbi, cluster) + offset;\n\t\t*mapped_blocks = sbi->sec_per_clus - offset;\n\t\tif (*mapped_blocks > last_block - sector)\n\t\t\t*mapped_blocks = last_block - sector;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint fat_bmap(struct inode *inode, sector_t sector, sector_t *phys,\n\t     unsigned long *mapped_blocks, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst unsigned long blocksize = sb->s_blocksize;\n\tconst unsigned char blocksize_bits = sb->s_blocksize_bits;\n\tsector_t last_block;\n\tint cluster, offset;\n\n\t*phys = 0;\n\t*mapped_blocks = 0;\n\tif ((sbi->fat_bits != 32) && (inode->i_ino == MSDOS_ROOT_INO)) {\n\t\tif (sector < (sbi->dir_entries >> sbi->dir_per_block_bits)) {\n\t\t\t*phys = sector + sbi->dir_start;\n\t\t\t*mapped_blocks = 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tlast_block = (i_size_read(inode) + (blocksize - 1)) >> blocksize_bits;\n\tif (sector >= last_block) {\n\t\tif (!create)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * ->mmu_private can access on only allocation path.\n\t\t * (caller must hold ->i_mutex)\n\t\t */\n\t\tlast_block = (MSDOS_I(inode)->mmu_private + (blocksize - 1))\n\t\t\t>> blocksize_bits;\n\t\tif (sector >= last_block)\n\t\t\treturn 0;\n\t}\n\n\tcluster = sector >> (sbi->cluster_bits - sb->s_blocksize_bits);\n\toffset  = sector & (sbi->sec_per_clus - 1);\n\tcluster = fat_bmap_cluster(inode, cluster);\n\tif (cluster < 0)\n\t\treturn cluster;\n\telse if (cluster) {\n\t\t*phys = fat_clus_to_blknr(sbi, cluster) + offset;\n\t\t*mapped_blocks = sbi->sec_per_clus - offset;\n\t\tif (*mapped_blocks > last_block - sector)\n\t\t\t*mapped_blocks = last_block - sector;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*bh"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fat__get_entry(struct inode *dir, loff_t *pos,\n\t\t\t  struct buffer_head **bh, struct msdos_dir_entry **de)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tsector_t phys, iblock;\n\tunsigned long mapped_blocks;\n\tint err, offset;\n\nnext:\n\tif (*bh)\n\t\tbrelse(*bh);\n\n\t*bh = NULL;\n\tiblock = *pos >> sb->s_blocksize_bits;\n\terr = fat_bmap(dir, iblock, &phys, &mapped_blocks, 0);\n\tif (err || !phys)\n\t\treturn -1;\t/* beyond EOF or error */\n\n\tfat_dir_readahead(dir, iblock, phys);\n\n\t*bh = sb_bread(sb, phys);\n\tif (*bh == NULL) {\n\t\tfat_msg_ratelimit(sb, KERN_ERR,\n\t\t\t\"Directory bread(block %llu) failed\", (llu)phys);\n\t\t/* skip this block */\n\t\t*pos = (iblock + 1) << sb->s_blocksize_bits;\n\t\tgoto next;\n\t}\n\n\toffset = *pos & (sb->s_blocksize - 1);\n\t*pos += sizeof(struct msdos_dir_entry);\n\t*de = (struct msdos_dir_entry *)((*bh)->b_data + offset);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_dir_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "51-72",
    "snippet": "static inline void fat_dir_readahead(struct inode *dir, sector_t iblock,\n\t\t\t\t     sector_t phys)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tint sec;\n\n\t/* This is not a first sector of cluster, or sec_per_clus == 1 */\n\tif ((iblock & (sbi->sec_per_clus - 1)) || sbi->sec_per_clus == 1)\n\t\treturn;\n\t/* root dir of FAT12/FAT16 */\n\tif ((sbi->fat_bits != 32) && (dir->i_ino == MSDOS_ROOT_INO))\n\t\treturn;\n\n\tbh = sb_find_get_block(sb, phys);\n\tif (bh == NULL || !buffer_uptodate(bh)) {\n\t\tfor (sec = 0; sec < sbi->sec_per_clus; sec++)\n\t\t\tsb_breadahead(sb, phys + sec);\n\t}\n\tbrelse(bh);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_breadahead",
          "args": [
            "sb",
            "phys + sec"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_find_get_block",
          "args": [
            "sb",
            "phys"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void fat_dir_readahead(struct inode *dir, sector_t iblock,\n\t\t\t\t     sector_t phys)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tint sec;\n\n\t/* This is not a first sector of cluster, or sec_per_clus == 1 */\n\tif ((iblock & (sbi->sec_per_clus - 1)) || sbi->sec_per_clus == 1)\n\t\treturn;\n\t/* root dir of FAT12/FAT16 */\n\tif ((sbi->fat_bits != 32) && (dir->i_ino == MSDOS_ROOT_INO))\n\t\treturn;\n\n\tbh = sb_find_get_block(sb, phys);\n\tif (bh == NULL || !buffer_uptodate(bh)) {\n\t\tfor (sec = 0; sec < sbi->sec_per_clus; sec++)\n\t\t\tsb_breadahead(sb, phys + sec);\n\t}\n\tbrelse(bh);\n}"
  },
  {
    "function_name": "fat_make_i_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "43-49",
    "snippet": "static inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}"
  },
  {
    "function_name": "fat_tolower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
    "lines": "38-41",
    "snippet": "static inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}"
  }
]