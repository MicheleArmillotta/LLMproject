[
  {
    "function_name": "exit_xfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1827-1842",
    "snippet": "__exit\nexit_xfs_fs(void)\n{\n\txfs_qm_exit();\n\tunregister_filesystem(&xfs_fs_type);\n#ifdef DEBUG\n\txfs_sysfs_del(&xfs_dbg_kobj);\n#endif\n\tkset_unregister(xfs_kset);\n\txfs_sysctl_unregister();\n\txfs_cleanup_procfs();\n\txfs_buf_terminate();\n\txfs_mru_cache_uninit();\n\txfs_destroy_workqueues();\n\txfs_destroy_zones();\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kset *xfs_kset;",
      "static struct file_system_type xfs_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"xfs\",\n\t.mount\t\t\t= xfs_fs_mount,\n\t.kill_sb\t\t= kill_block_super,\n\t.fs_flags\t\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_destroy_zones",
          "args": [],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_destroy_zones",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1698-1722",
          "snippet": "STATIC void\nxfs_destroy_zones(void)\n{\n\t/*\n\t * Make sure all delayed rcu free are flushed before we\n\t * destroy caches.\n\t */\n\trcu_barrier();\n\tkmem_zone_destroy(xfs_icreate_zone);\n\tkmem_zone_destroy(xfs_ili_zone);\n\tkmem_zone_destroy(xfs_inode_zone);\n\tkmem_zone_destroy(xfs_efi_zone);\n\tkmem_zone_destroy(xfs_efd_zone);\n\tkmem_zone_destroy(xfs_buf_item_zone);\n\tkmem_zone_destroy(xfs_log_item_desc_zone);\n\tkmem_zone_destroy(xfs_trans_zone);\n\tkmem_zone_destroy(xfs_ifork_zone);\n\tkmem_zone_destroy(xfs_da_state_zone);\n\tkmem_zone_destroy(xfs_btree_cur_zone);\n\tkmem_zone_destroy(xfs_bmap_free_item_zone);\n\tkmem_zone_destroy(xfs_log_ticket_zone);\n\tmempool_destroy(xfs_ioend_pool);\n\tkmem_zone_destroy(xfs_ioend_zone);\n\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_ioend_zone;",
            "mempool_t *xfs_ioend_pool;",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_ioend_zone;\nmempool_t *xfs_ioend_pool;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_destroy_zones(void)\n{\n\t/*\n\t * Make sure all delayed rcu free are flushed before we\n\t * destroy caches.\n\t */\n\trcu_barrier();\n\tkmem_zone_destroy(xfs_icreate_zone);\n\tkmem_zone_destroy(xfs_ili_zone);\n\tkmem_zone_destroy(xfs_inode_zone);\n\tkmem_zone_destroy(xfs_efi_zone);\n\tkmem_zone_destroy(xfs_efd_zone);\n\tkmem_zone_destroy(xfs_buf_item_zone);\n\tkmem_zone_destroy(xfs_log_item_desc_zone);\n\tkmem_zone_destroy(xfs_trans_zone);\n\tkmem_zone_destroy(xfs_ifork_zone);\n\tkmem_zone_destroy(xfs_da_state_zone);\n\tkmem_zone_destroy(xfs_btree_cur_zone);\n\tkmem_zone_destroy(xfs_bmap_free_item_zone);\n\tkmem_zone_destroy(xfs_log_ticket_zone);\n\tmempool_destroy(xfs_ioend_pool);\n\tkmem_zone_destroy(xfs_ioend_zone);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_destroy_workqueues",
          "args": [],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_destroy_workqueues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1741-1745",
          "snippet": "STATIC void\nxfs_destroy_workqueues(void)\n{\n\tdestroy_workqueue(xfs_alloc_wq);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_destroy_workqueues(void)\n{\n\tdestroy_workqueue(xfs_alloc_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mru_cache_uninit",
          "args": [],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mru_cache_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "314-318",
          "snippet": "void\nxfs_mru_cache_uninit(void)\n{\n\tdestroy_workqueue(xfs_mru_reap_wq);\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct\t*xfs_mru_reap_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstatic struct workqueue_struct\t*xfs_mru_reap_wq;\n\nvoid\nxfs_mru_cache_uninit(void)\n{\n\tdestroy_workqueue(xfs_mru_reap_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_terminate",
          "args": [],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_terminate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1897-1901",
          "snippet": "void\nxfs_buf_terminate(void)\n{\n\tkmem_zone_destroy(xfs_buf_zone);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nvoid\nxfs_buf_terminate(void)\n{\n\tkmem_zone_destroy(xfs_buf_zone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_cleanup_procfs",
          "args": [],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_cleanup_procfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.h",
          "lines": "243-245",
          "snippet": "static inline void xfs_cleanup_procfs(void)\n{\n}",
          "includes": [
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu.h>\n\nstatic inline void xfs_cleanup_procfs(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sysctl_unregister",
          "args": [],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sysctl_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysctl.c",
          "lines": "239-243",
          "snippet": "void\nxfs_sysctl_unregister(void)\n{\n\tunregister_sysctl_table(xfs_table_header);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_header *xfs_table_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include \"xfs.h\"\n\nstatic struct ctl_table_header *xfs_table_header;\n\nvoid\nxfs_sysctl_unregister(void)\n{\n\tunregister_sysctl_table(xfs_table_header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kset_unregister",
          "args": [
            "xfs_kset"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sysfs_del",
          "args": [
            "&xfs_dbg_kobj"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sysfs_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysfs.h",
          "lines": "51-58",
          "snippet": "static inline void\nxfs_sysfs_del(\n\tstruct xfs_kobj\t*kobj)\n{\n\tkobject_del(&kobj->kobject);\n\tkobject_put(&kobj->kobject);\n\twait_for_completion(&kobj->complete);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_sysfs_del(\n\tstruct xfs_kobj\t*kobj)\n{\n\tkobject_del(&kobj->kobject);\n\tkobject_put(&kobj->kobject);\n\twait_for_completion(&kobj->complete);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&xfs_fs_type"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_exit",
          "args": [],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "1099-1104",
          "snippet": "void\nxfs_qm_exit(void)\n{\n\tkmem_zone_destroy(xfs_qm_dqtrxzone);\n\tkmem_zone_destroy(xfs_qm_dqzone);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_zone\t\t*xfs_qm_dqtrxzone;",
            "static struct kmem_zone\t\t*xfs_qm_dqzone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct kmem_zone\t\t*xfs_qm_dqtrxzone;\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\n\nvoid\nxfs_qm_exit(void)\n{\n\tkmem_zone_destroy(xfs_qm_dqtrxzone);\n\tkmem_zone_destroy(xfs_qm_dqzone);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nstatic struct kset *xfs_kset;\nstatic struct file_system_type xfs_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"xfs\",\n\t.mount\t\t\t= xfs_fs_mount,\n\t.kill_sb\t\t= kill_block_super,\n\t.fs_flags\t\t= FS_REQUIRES_DEV,\n};\n\n__exit\nexit_xfs_fs(void)\n{\n\txfs_qm_exit();\n\tunregister_filesystem(&xfs_fs_type);\n#ifdef DEBUG\n\txfs_sysfs_del(&xfs_dbg_kobj);\n#endif\n\tkset_unregister(xfs_kset);\n\txfs_sysctl_unregister();\n\txfs_cleanup_procfs();\n\txfs_buf_terminate();\n\txfs_mru_cache_uninit();\n\txfs_destroy_workqueues();\n\txfs_destroy_zones();\n}"
  },
  {
    "function_name": "init_xfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1747-1825",
    "snippet": "__init\ninit_xfs_fs(void)\n{\n\tint\t\t\terror;\n\n\tprintk(KERN_INFO XFS_VERSION_STRING \" with \"\n\t\t\t XFS_BUILD_OPTIONS \" enabled\\n\");\n\n\txfs_dir_startup();\n\n\terror = xfs_init_zones();\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_init_workqueues();\n\tif (error)\n\t\tgoto out_destroy_zones;\n\n\terror = xfs_mru_cache_init();\n\tif (error)\n\t\tgoto out_destroy_wq;\n\n\terror = xfs_buf_init();\n\tif (error)\n\t\tgoto out_mru_cache_uninit;\n\n\terror = xfs_init_procfs();\n\tif (error)\n\t\tgoto out_buf_terminate;\n\n\terror = xfs_sysctl_register();\n\tif (error)\n\t\tgoto out_cleanup_procfs;\n\n\txfs_kset = kset_create_and_add(\"xfs\", NULL, fs_kobj);\n\tif (!xfs_kset) {\n\t\terror = -ENOMEM;\n\t\tgoto out_sysctl_unregister;;\n\t}\n\n#ifdef DEBUG\n\txfs_dbg_kobj.kobject.kset = xfs_kset;\n\terror = xfs_sysfs_init(&xfs_dbg_kobj, &xfs_dbg_ktype, NULL, \"debug\");\n\tif (error)\n\t\tgoto out_kset_unregister;\n#endif\n\n\terror = xfs_qm_init();\n\tif (error)\n\t\tgoto out_remove_kobj;\n\n\terror = register_filesystem(&xfs_fs_type);\n\tif (error)\n\t\tgoto out_qm_exit;\n\treturn 0;\n\n out_qm_exit:\n\txfs_qm_exit();\n out_remove_kobj:\n#ifdef DEBUG\n\txfs_sysfs_del(&xfs_dbg_kobj);\n out_kset_unregister:\n#endif\n\tkset_unregister(xfs_kset);\n out_sysctl_unregister:\n\txfs_sysctl_unregister();\n out_cleanup_procfs:\n\txfs_cleanup_procfs();\n out_buf_terminate:\n\txfs_buf_terminate();\n out_mru_cache_uninit:\n\txfs_mru_cache_uninit();\n out_destroy_wq:\n\txfs_destroy_workqueues();\n out_destroy_zones:\n\txfs_destroy_zones();\n out:\n\treturn error;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kset *xfs_kset;",
      "static struct file_system_type xfs_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"xfs\",\n\t.mount\t\t\t= xfs_fs_mount,\n\t.kill_sb\t\t= kill_block_super,\n\t.fs_flags\t\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_destroy_zones",
          "args": [],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_destroy_zones",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1698-1722",
          "snippet": "STATIC void\nxfs_destroy_zones(void)\n{\n\t/*\n\t * Make sure all delayed rcu free are flushed before we\n\t * destroy caches.\n\t */\n\trcu_barrier();\n\tkmem_zone_destroy(xfs_icreate_zone);\n\tkmem_zone_destroy(xfs_ili_zone);\n\tkmem_zone_destroy(xfs_inode_zone);\n\tkmem_zone_destroy(xfs_efi_zone);\n\tkmem_zone_destroy(xfs_efd_zone);\n\tkmem_zone_destroy(xfs_buf_item_zone);\n\tkmem_zone_destroy(xfs_log_item_desc_zone);\n\tkmem_zone_destroy(xfs_trans_zone);\n\tkmem_zone_destroy(xfs_ifork_zone);\n\tkmem_zone_destroy(xfs_da_state_zone);\n\tkmem_zone_destroy(xfs_btree_cur_zone);\n\tkmem_zone_destroy(xfs_bmap_free_item_zone);\n\tkmem_zone_destroy(xfs_log_ticket_zone);\n\tmempool_destroy(xfs_ioend_pool);\n\tkmem_zone_destroy(xfs_ioend_zone);\n\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_ioend_zone;",
            "mempool_t *xfs_ioend_pool;",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_ioend_zone;\nmempool_t *xfs_ioend_pool;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_destroy_zones(void)\n{\n\t/*\n\t * Make sure all delayed rcu free are flushed before we\n\t * destroy caches.\n\t */\n\trcu_barrier();\n\tkmem_zone_destroy(xfs_icreate_zone);\n\tkmem_zone_destroy(xfs_ili_zone);\n\tkmem_zone_destroy(xfs_inode_zone);\n\tkmem_zone_destroy(xfs_efi_zone);\n\tkmem_zone_destroy(xfs_efd_zone);\n\tkmem_zone_destroy(xfs_buf_item_zone);\n\tkmem_zone_destroy(xfs_log_item_desc_zone);\n\tkmem_zone_destroy(xfs_trans_zone);\n\tkmem_zone_destroy(xfs_ifork_zone);\n\tkmem_zone_destroy(xfs_da_state_zone);\n\tkmem_zone_destroy(xfs_btree_cur_zone);\n\tkmem_zone_destroy(xfs_bmap_free_item_zone);\n\tkmem_zone_destroy(xfs_log_ticket_zone);\n\tmempool_destroy(xfs_ioend_pool);\n\tkmem_zone_destroy(xfs_ioend_zone);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_destroy_workqueues",
          "args": [],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_destroy_workqueues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1741-1745",
          "snippet": "STATIC void\nxfs_destroy_workqueues(void)\n{\n\tdestroy_workqueue(xfs_alloc_wq);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_destroy_workqueues(void)\n{\n\tdestroy_workqueue(xfs_alloc_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mru_cache_uninit",
          "args": [],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mru_cache_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "314-318",
          "snippet": "void\nxfs_mru_cache_uninit(void)\n{\n\tdestroy_workqueue(xfs_mru_reap_wq);\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct\t*xfs_mru_reap_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstatic struct workqueue_struct\t*xfs_mru_reap_wq;\n\nvoid\nxfs_mru_cache_uninit(void)\n{\n\tdestroy_workqueue(xfs_mru_reap_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_terminate",
          "args": [],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_terminate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1897-1901",
          "snippet": "void\nxfs_buf_terminate(void)\n{\n\tkmem_zone_destroy(xfs_buf_zone);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nvoid\nxfs_buf_terminate(void)\n{\n\tkmem_zone_destroy(xfs_buf_zone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_cleanup_procfs",
          "args": [],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_cleanup_procfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.h",
          "lines": "243-245",
          "snippet": "static inline void xfs_cleanup_procfs(void)\n{\n}",
          "includes": [
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu.h>\n\nstatic inline void xfs_cleanup_procfs(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sysctl_unregister",
          "args": [],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sysctl_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysctl.c",
          "lines": "239-243",
          "snippet": "void\nxfs_sysctl_unregister(void)\n{\n\tunregister_sysctl_table(xfs_table_header);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_header *xfs_table_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include \"xfs.h\"\n\nstatic struct ctl_table_header *xfs_table_header;\n\nvoid\nxfs_sysctl_unregister(void)\n{\n\tunregister_sysctl_table(xfs_table_header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kset_unregister",
          "args": [
            "xfs_kset"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sysfs_del",
          "args": [
            "&xfs_dbg_kobj"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sysfs_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysfs.h",
          "lines": "51-58",
          "snippet": "static inline void\nxfs_sysfs_del(\n\tstruct xfs_kobj\t*kobj)\n{\n\tkobject_del(&kobj->kobject);\n\tkobject_put(&kobj->kobject);\n\twait_for_completion(&kobj->complete);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_sysfs_del(\n\tstruct xfs_kobj\t*kobj)\n{\n\tkobject_del(&kobj->kobject);\n\tkobject_put(&kobj->kobject);\n\twait_for_completion(&kobj->complete);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_exit",
          "args": [],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "1099-1104",
          "snippet": "void\nxfs_qm_exit(void)\n{\n\tkmem_zone_destroy(xfs_qm_dqtrxzone);\n\tkmem_zone_destroy(xfs_qm_dqzone);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_zone\t\t*xfs_qm_dqtrxzone;",
            "static struct kmem_zone\t\t*xfs_qm_dqzone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct kmem_zone\t\t*xfs_qm_dqtrxzone;\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\n\nvoid\nxfs_qm_exit(void)\n{\n\tkmem_zone_destroy(xfs_qm_dqtrxzone);\n\tkmem_zone_destroy(xfs_qm_dqzone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&xfs_fs_type"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_init",
          "args": [],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "1078-1097",
          "snippet": "int __init\nxfs_qm_init(void)\n{\n\txfs_qm_dqzone =\n\t\tkmem_zone_init(sizeof(struct xfs_dquot), \"xfs_dquot\");\n\tif (!xfs_qm_dqzone)\n\t\tgoto out;\n\n\txfs_qm_dqtrxzone =\n\t\tkmem_zone_init(sizeof(struct xfs_dquot_acct), \"xfs_dqtrx\");\n\tif (!xfs_qm_dqtrxzone)\n\t\tgoto out_free_dqzone;\n\n\treturn 0;\n\nout_free_dqzone:\n\tkmem_zone_destroy(xfs_qm_dqzone);\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_zone\t\t*xfs_qm_dqtrxzone;",
            "static struct kmem_zone\t\t*xfs_qm_dqzone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct kmem_zone\t\t*xfs_qm_dqtrxzone;\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\n\nint __init\nxfs_qm_init(void)\n{\n\txfs_qm_dqzone =\n\t\tkmem_zone_init(sizeof(struct xfs_dquot), \"xfs_dquot\");\n\tif (!xfs_qm_dqzone)\n\t\tgoto out;\n\n\txfs_qm_dqtrxzone =\n\t\tkmem_zone_init(sizeof(struct xfs_dquot_acct), \"xfs_dqtrx\");\n\tif (!xfs_qm_dqtrxzone)\n\t\tgoto out_free_dqzone;\n\n\treturn 0;\n\nout_free_dqzone:\n\tkmem_zone_destroy(xfs_qm_dqzone);\nout:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sysfs_init",
          "args": [
            "&xfs_dbg_kobj",
            "&xfs_dbg_ktype",
            "NULL",
            "\"debug\""
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sysfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysfs.h",
          "lines": "39-49",
          "snippet": "static inline int\nxfs_sysfs_init(\n\tstruct xfs_kobj\t\t*kobj,\n\tstruct kobj_type\t*ktype,\n\tstruct xfs_kobj\t\t*parent_kobj,\n\tconst char\t\t*name)\n{\n\tinit_completion(&kobj->complete);\n\treturn kobject_init_and_add(&kobj->kobject, ktype,\n\t\t\t\t    &parent_kobj->kobject, \"%s\", name);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_sysfs_init(\n\tstruct xfs_kobj\t\t*kobj,\n\tstruct kobj_type\t*ktype,\n\tstruct xfs_kobj\t\t*parent_kobj,\n\tconst char\t\t*name)\n{\n\tinit_completion(&kobj->complete);\n\treturn kobject_init_and_add(&kobj->kobject, ktype,\n\t\t\t\t    &parent_kobj->kobject, \"%s\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kset_create_and_add",
          "args": [
            "\"xfs\"",
            "NULL",
            "fs_kobj"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sysctl_register",
          "args": [],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sysctl_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysctl.c",
          "lines": "230-237",
          "snippet": "int\nxfs_sysctl_register(void)\n{\n\txfs_table_header = register_sysctl_table(xfs_root_table);\n\tif (!xfs_table_header)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_header *xfs_table_header;",
            "static struct ctl_table xfs_root_table[] = {\n\t{\n\t\t.procname\t= \"fs\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= xfs_dir_table\n\t},\n\t{}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include \"xfs.h\"\n\nstatic struct ctl_table_header *xfs_table_header;\nstatic struct ctl_table xfs_root_table[] = {\n\t{\n\t\t.procname\t= \"fs\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= xfs_dir_table\n\t},\n\t{}\n};\n\nint\nxfs_sysctl_register(void)\n{\n\txfs_table_header = register_sysctl_table(xfs_root_table);\n\tif (!xfs_table_header)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_init_procfs",
          "args": [],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_init_procfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.h",
          "lines": "238-241",
          "snippet": "static inline int xfs_init_procfs(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu.h>\n\nstatic inline int xfs_init_procfs(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_init",
          "args": [],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1883-1895",
          "snippet": "int __init\nxfs_buf_init(void)\n{\n\txfs_buf_zone = kmem_zone_init_flags(sizeof(xfs_buf_t), \"xfs_buf\",\n\t\t\t\t\t\tKM_ZONE_HWALIGN, NULL);\n\tif (!xfs_buf_zone)\n\t\tgoto out;\n\n\treturn 0;\n\n out:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nint __init\nxfs_buf_init(void)\n{\n\txfs_buf_zone = kmem_zone_init_flags(sizeof(xfs_buf_t), \"xfs_buf\",\n\t\t\t\t\t\tKM_ZONE_HWALIGN, NULL);\n\tif (!xfs_buf_zone)\n\t\tgoto out;\n\n\treturn 0;\n\n out:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mru_cache_init",
          "args": [],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mru_cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "304-312",
          "snippet": "int\nxfs_mru_cache_init(void)\n{\n\txfs_mru_reap_wq = alloc_workqueue(\"xfs_mru_cache\",\n\t\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 1);\n\tif (!xfs_mru_reap_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct\t*xfs_mru_reap_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstatic struct workqueue_struct\t*xfs_mru_reap_wq;\n\nint\nxfs_mru_cache_init(void)\n{\n\txfs_mru_reap_wq = alloc_workqueue(\"xfs_mru_cache\",\n\t\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 1);\n\tif (!xfs_mru_reap_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_init_workqueues",
          "args": [],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_init_workqueues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1724-1739",
          "snippet": "__init\nxfs_init_workqueues(void)\n{\n\t/*\n\t * The allocation workqueue can be used in memory reclaim situations\n\t * (writepage path), and parallelism is only limited by the number of\n\t * AGs in all the filesystems mounted. Hence use the default large\n\t * max_active value for this workqueue.\n\t */\n\txfs_alloc_wq = alloc_workqueue(\"xfsalloc\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0);\n\tif (!xfs_alloc_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n__init\nxfs_init_workqueues(void)\n{\n\t/*\n\t * The allocation workqueue can be used in memory reclaim situations\n\t * (writepage path), and parallelism is only limited by the number of\n\t * AGs in all the filesystems mounted. Hence use the default large\n\t * max_active value for this workqueue.\n\t */\n\txfs_alloc_wq = alloc_workqueue(\"xfsalloc\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0);\n\tif (!xfs_alloc_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_init_zones",
          "args": [],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_init_zones",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1578-1696",
          "snippet": "__init\nxfs_init_zones(void)\n{\n\n\txfs_ioend_zone = kmem_zone_init(sizeof(xfs_ioend_t), \"xfs_ioend\");\n\tif (!xfs_ioend_zone)\n\t\tgoto out;\n\n\txfs_ioend_pool = mempool_create_slab_pool(4 * MAX_BUF_PER_PAGE,\n\t\t\t\t\t\t  xfs_ioend_zone);\n\tif (!xfs_ioend_pool)\n\t\tgoto out_destroy_ioend_zone;\n\n\txfs_log_ticket_zone = kmem_zone_init(sizeof(xlog_ticket_t),\n\t\t\t\t\t\t\"xfs_log_ticket\");\n\tif (!xfs_log_ticket_zone)\n\t\tgoto out_destroy_ioend_pool;\n\n\txfs_bmap_free_item_zone = kmem_zone_init(sizeof(xfs_bmap_free_item_t),\n\t\t\t\t\t\t\"xfs_bmap_free_item\");\n\tif (!xfs_bmap_free_item_zone)\n\t\tgoto out_destroy_log_ticket_zone;\n\n\txfs_btree_cur_zone = kmem_zone_init(sizeof(xfs_btree_cur_t),\n\t\t\t\t\t\t\"xfs_btree_cur\");\n\tif (!xfs_btree_cur_zone)\n\t\tgoto out_destroy_bmap_free_item_zone;\n\n\txfs_da_state_zone = kmem_zone_init(sizeof(xfs_da_state_t),\n\t\t\t\t\t\t\"xfs_da_state\");\n\tif (!xfs_da_state_zone)\n\t\tgoto out_destroy_btree_cur_zone;\n\n\txfs_ifork_zone = kmem_zone_init(sizeof(xfs_ifork_t), \"xfs_ifork\");\n\tif (!xfs_ifork_zone)\n\t\tgoto out_destroy_da_state_zone;\n\n\txfs_trans_zone = kmem_zone_init(sizeof(xfs_trans_t), \"xfs_trans\");\n\tif (!xfs_trans_zone)\n\t\tgoto out_destroy_ifork_zone;\n\n\txfs_log_item_desc_zone =\n\t\tkmem_zone_init(sizeof(struct xfs_log_item_desc),\n\t\t\t       \"xfs_log_item_desc\");\n\tif (!xfs_log_item_desc_zone)\n\t\tgoto out_destroy_trans_zone;\n\n\t/*\n\t * The size of the zone allocated buf log item is the maximum\n\t * size possible under XFS.  This wastes a little bit of memory,\n\t * but it is much faster.\n\t */\n\txfs_buf_item_zone = kmem_zone_init(sizeof(struct xfs_buf_log_item),\n\t\t\t\t\t   \"xfs_buf_item\");\n\tif (!xfs_buf_item_zone)\n\t\tgoto out_destroy_log_item_desc_zone;\n\n\txfs_efd_zone = kmem_zone_init((sizeof(xfs_efd_log_item_t) +\n\t\t\t((XFS_EFD_MAX_FAST_EXTENTS - 1) *\n\t\t\t\t sizeof(xfs_extent_t))), \"xfs_efd_item\");\n\tif (!xfs_efd_zone)\n\t\tgoto out_destroy_buf_item_zone;\n\n\txfs_efi_zone = kmem_zone_init((sizeof(xfs_efi_log_item_t) +\n\t\t\t((XFS_EFI_MAX_FAST_EXTENTS - 1) *\n\t\t\t\tsizeof(xfs_extent_t))), \"xfs_efi_item\");\n\tif (!xfs_efi_zone)\n\t\tgoto out_destroy_efd_zone;\n\n\txfs_inode_zone =\n\t\tkmem_zone_init_flags(sizeof(xfs_inode_t), \"xfs_inode\",\n\t\t\tKM_ZONE_HWALIGN | KM_ZONE_RECLAIM | KM_ZONE_SPREAD,\n\t\t\txfs_fs_inode_init_once);\n\tif (!xfs_inode_zone)\n\t\tgoto out_destroy_efi_zone;\n\n\txfs_ili_zone =\n\t\tkmem_zone_init_flags(sizeof(xfs_inode_log_item_t), \"xfs_ili\",\n\t\t\t\t\tKM_ZONE_SPREAD, NULL);\n\tif (!xfs_ili_zone)\n\t\tgoto out_destroy_inode_zone;\n\txfs_icreate_zone = kmem_zone_init(sizeof(struct xfs_icreate_item),\n\t\t\t\t\t\"xfs_icr\");\n\tif (!xfs_icreate_zone)\n\t\tgoto out_destroy_ili_zone;\n\n\treturn 0;\n\n out_destroy_ili_zone:\n\tkmem_zone_destroy(xfs_ili_zone);\n out_destroy_inode_zone:\n\tkmem_zone_destroy(xfs_inode_zone);\n out_destroy_efi_zone:\n\tkmem_zone_destroy(xfs_efi_zone);\n out_destroy_efd_zone:\n\tkmem_zone_destroy(xfs_efd_zone);\n out_destroy_buf_item_zone:\n\tkmem_zone_destroy(xfs_buf_item_zone);\n out_destroy_log_item_desc_zone:\n\tkmem_zone_destroy(xfs_log_item_desc_zone);\n out_destroy_trans_zone:\n\tkmem_zone_destroy(xfs_trans_zone);\n out_destroy_ifork_zone:\n\tkmem_zone_destroy(xfs_ifork_zone);\n out_destroy_da_state_zone:\n\tkmem_zone_destroy(xfs_da_state_zone);\n out_destroy_btree_cur_zone:\n\tkmem_zone_destroy(xfs_btree_cur_zone);\n out_destroy_bmap_free_item_zone:\n\tkmem_zone_destroy(xfs_bmap_free_item_zone);\n out_destroy_log_ticket_zone:\n\tkmem_zone_destroy(xfs_log_ticket_zone);\n out_destroy_ioend_pool:\n\tmempool_destroy(xfs_ioend_pool);\n out_destroy_ioend_zone:\n\tkmem_zone_destroy(xfs_ioend_zone);\n out:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_ioend_zone;",
            "mempool_t *xfs_ioend_pool;",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_ioend_zone;\nmempool_t *xfs_ioend_pool;\nSTATIC struct;\nSTATIC struct;\n\n__init\nxfs_init_zones(void)\n{\n\n\txfs_ioend_zone = kmem_zone_init(sizeof(xfs_ioend_t), \"xfs_ioend\");\n\tif (!xfs_ioend_zone)\n\t\tgoto out;\n\n\txfs_ioend_pool = mempool_create_slab_pool(4 * MAX_BUF_PER_PAGE,\n\t\t\t\t\t\t  xfs_ioend_zone);\n\tif (!xfs_ioend_pool)\n\t\tgoto out_destroy_ioend_zone;\n\n\txfs_log_ticket_zone = kmem_zone_init(sizeof(xlog_ticket_t),\n\t\t\t\t\t\t\"xfs_log_ticket\");\n\tif (!xfs_log_ticket_zone)\n\t\tgoto out_destroy_ioend_pool;\n\n\txfs_bmap_free_item_zone = kmem_zone_init(sizeof(xfs_bmap_free_item_t),\n\t\t\t\t\t\t\"xfs_bmap_free_item\");\n\tif (!xfs_bmap_free_item_zone)\n\t\tgoto out_destroy_log_ticket_zone;\n\n\txfs_btree_cur_zone = kmem_zone_init(sizeof(xfs_btree_cur_t),\n\t\t\t\t\t\t\"xfs_btree_cur\");\n\tif (!xfs_btree_cur_zone)\n\t\tgoto out_destroy_bmap_free_item_zone;\n\n\txfs_da_state_zone = kmem_zone_init(sizeof(xfs_da_state_t),\n\t\t\t\t\t\t\"xfs_da_state\");\n\tif (!xfs_da_state_zone)\n\t\tgoto out_destroy_btree_cur_zone;\n\n\txfs_ifork_zone = kmem_zone_init(sizeof(xfs_ifork_t), \"xfs_ifork\");\n\tif (!xfs_ifork_zone)\n\t\tgoto out_destroy_da_state_zone;\n\n\txfs_trans_zone = kmem_zone_init(sizeof(xfs_trans_t), \"xfs_trans\");\n\tif (!xfs_trans_zone)\n\t\tgoto out_destroy_ifork_zone;\n\n\txfs_log_item_desc_zone =\n\t\tkmem_zone_init(sizeof(struct xfs_log_item_desc),\n\t\t\t       \"xfs_log_item_desc\");\n\tif (!xfs_log_item_desc_zone)\n\t\tgoto out_destroy_trans_zone;\n\n\t/*\n\t * The size of the zone allocated buf log item is the maximum\n\t * size possible under XFS.  This wastes a little bit of memory,\n\t * but it is much faster.\n\t */\n\txfs_buf_item_zone = kmem_zone_init(sizeof(struct xfs_buf_log_item),\n\t\t\t\t\t   \"xfs_buf_item\");\n\tif (!xfs_buf_item_zone)\n\t\tgoto out_destroy_log_item_desc_zone;\n\n\txfs_efd_zone = kmem_zone_init((sizeof(xfs_efd_log_item_t) +\n\t\t\t((XFS_EFD_MAX_FAST_EXTENTS - 1) *\n\t\t\t\t sizeof(xfs_extent_t))), \"xfs_efd_item\");\n\tif (!xfs_efd_zone)\n\t\tgoto out_destroy_buf_item_zone;\n\n\txfs_efi_zone = kmem_zone_init((sizeof(xfs_efi_log_item_t) +\n\t\t\t((XFS_EFI_MAX_FAST_EXTENTS - 1) *\n\t\t\t\tsizeof(xfs_extent_t))), \"xfs_efi_item\");\n\tif (!xfs_efi_zone)\n\t\tgoto out_destroy_efd_zone;\n\n\txfs_inode_zone =\n\t\tkmem_zone_init_flags(sizeof(xfs_inode_t), \"xfs_inode\",\n\t\t\tKM_ZONE_HWALIGN | KM_ZONE_RECLAIM | KM_ZONE_SPREAD,\n\t\t\txfs_fs_inode_init_once);\n\tif (!xfs_inode_zone)\n\t\tgoto out_destroy_efi_zone;\n\n\txfs_ili_zone =\n\t\tkmem_zone_init_flags(sizeof(xfs_inode_log_item_t), \"xfs_ili\",\n\t\t\t\t\tKM_ZONE_SPREAD, NULL);\n\tif (!xfs_ili_zone)\n\t\tgoto out_destroy_inode_zone;\n\txfs_icreate_zone = kmem_zone_init(sizeof(struct xfs_icreate_item),\n\t\t\t\t\t\"xfs_icr\");\n\tif (!xfs_icreate_zone)\n\t\tgoto out_destroy_ili_zone;\n\n\treturn 0;\n\n out_destroy_ili_zone:\n\tkmem_zone_destroy(xfs_ili_zone);\n out_destroy_inode_zone:\n\tkmem_zone_destroy(xfs_inode_zone);\n out_destroy_efi_zone:\n\tkmem_zone_destroy(xfs_efi_zone);\n out_destroy_efd_zone:\n\tkmem_zone_destroy(xfs_efd_zone);\n out_destroy_buf_item_zone:\n\tkmem_zone_destroy(xfs_buf_item_zone);\n out_destroy_log_item_desc_zone:\n\tkmem_zone_destroy(xfs_log_item_desc_zone);\n out_destroy_trans_zone:\n\tkmem_zone_destroy(xfs_trans_zone);\n out_destroy_ifork_zone:\n\tkmem_zone_destroy(xfs_ifork_zone);\n out_destroy_da_state_zone:\n\tkmem_zone_destroy(xfs_da_state_zone);\n out_destroy_btree_cur_zone:\n\tkmem_zone_destroy(xfs_btree_cur_zone);\n out_destroy_bmap_free_item_zone:\n\tkmem_zone_destroy(xfs_bmap_free_item_zone);\n out_destroy_log_ticket_zone:\n\tkmem_zone_destroy(xfs_log_ticket_zone);\n out_destroy_ioend_pool:\n\tmempool_destroy(xfs_ioend_pool);\n out_destroy_ioend_zone:\n\tkmem_zone_destroy(xfs_ioend_zone);\n out:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_startup",
          "args": [],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_startup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "53-58",
          "snippet": "void\nxfs_dir_startup(void)\n{\n\txfs_dir_hash_dot = xfs_da_hashname((unsigned char *)\".\", 1);\n\txfs_dir_hash_dotdot = xfs_da_hashname((unsigned char *)\"..\", 2);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static xfs_dahash_t xfs_dir_hash_dot, xfs_dir_hash_dotdot;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic xfs_dahash_t xfs_dir_hash_dot, xfs_dir_hash_dotdot;\n\nvoid\nxfs_dir_startup(void)\n{\n\txfs_dir_hash_dot = xfs_da_hashname((unsigned char *)\".\", 1);\n\txfs_dir_hash_dotdot = xfs_da_hashname((unsigned char *)\"..\", 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nstatic struct kset *xfs_kset;\nstatic struct file_system_type xfs_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"xfs\",\n\t.mount\t\t\t= xfs_fs_mount,\n\t.kill_sb\t\t= kill_block_super,\n\t.fs_flags\t\t= FS_REQUIRES_DEV,\n};\n\n__init\ninit_xfs_fs(void)\n{\n\tint\t\t\terror;\n\n\tprintk(KERN_INFO XFS_VERSION_STRING \" with \"\n\t\t\t XFS_BUILD_OPTIONS \" enabled\\n\");\n\n\txfs_dir_startup();\n\n\terror = xfs_init_zones();\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_init_workqueues();\n\tif (error)\n\t\tgoto out_destroy_zones;\n\n\terror = xfs_mru_cache_init();\n\tif (error)\n\t\tgoto out_destroy_wq;\n\n\terror = xfs_buf_init();\n\tif (error)\n\t\tgoto out_mru_cache_uninit;\n\n\terror = xfs_init_procfs();\n\tif (error)\n\t\tgoto out_buf_terminate;\n\n\terror = xfs_sysctl_register();\n\tif (error)\n\t\tgoto out_cleanup_procfs;\n\n\txfs_kset = kset_create_and_add(\"xfs\", NULL, fs_kobj);\n\tif (!xfs_kset) {\n\t\terror = -ENOMEM;\n\t\tgoto out_sysctl_unregister;;\n\t}\n\n#ifdef DEBUG\n\txfs_dbg_kobj.kobject.kset = xfs_kset;\n\terror = xfs_sysfs_init(&xfs_dbg_kobj, &xfs_dbg_ktype, NULL, \"debug\");\n\tif (error)\n\t\tgoto out_kset_unregister;\n#endif\n\n\terror = xfs_qm_init();\n\tif (error)\n\t\tgoto out_remove_kobj;\n\n\terror = register_filesystem(&xfs_fs_type);\n\tif (error)\n\t\tgoto out_qm_exit;\n\treturn 0;\n\n out_qm_exit:\n\txfs_qm_exit();\n out_remove_kobj:\n#ifdef DEBUG\n\txfs_sysfs_del(&xfs_dbg_kobj);\n out_kset_unregister:\n#endif\n\tkset_unregister(xfs_kset);\n out_sysctl_unregister:\n\txfs_sysctl_unregister();\n out_cleanup_procfs:\n\txfs_cleanup_procfs();\n out_buf_terminate:\n\txfs_buf_terminate();\n out_mru_cache_uninit:\n\txfs_mru_cache_uninit();\n out_destroy_wq:\n\txfs_destroy_workqueues();\n out_destroy_zones:\n\txfs_destroy_zones();\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_destroy_workqueues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1741-1745",
    "snippet": "STATIC void\nxfs_destroy_workqueues(void)\n{\n\tdestroy_workqueue(xfs_alloc_wq);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "xfs_alloc_wq"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_destroy_workqueues(void)\n{\n\tdestroy_workqueue(xfs_alloc_wq);\n}"
  },
  {
    "function_name": "xfs_init_workqueues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1724-1739",
    "snippet": "__init\nxfs_init_workqueues(void)\n{\n\t/*\n\t * The allocation workqueue can be used in memory reclaim situations\n\t * (writepage path), and parallelism is only limited by the number of\n\t * AGs in all the filesystems mounted. Hence use the default large\n\t * max_active value for this workqueue.\n\t */\n\txfs_alloc_wq = alloc_workqueue(\"xfsalloc\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0);\n\tif (!xfs_alloc_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"xfsalloc\"",
            "WQ_MEM_RECLAIM|WQ_FREEZABLE",
            "0"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n__init\nxfs_init_workqueues(void)\n{\n\t/*\n\t * The allocation workqueue can be used in memory reclaim situations\n\t * (writepage path), and parallelism is only limited by the number of\n\t * AGs in all the filesystems mounted. Hence use the default large\n\t * max_active value for this workqueue.\n\t */\n\txfs_alloc_wq = alloc_workqueue(\"xfsalloc\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0);\n\tif (!xfs_alloc_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_destroy_zones",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1698-1722",
    "snippet": "STATIC void\nxfs_destroy_zones(void)\n{\n\t/*\n\t * Make sure all delayed rcu free are flushed before we\n\t * destroy caches.\n\t */\n\trcu_barrier();\n\tkmem_zone_destroy(xfs_icreate_zone);\n\tkmem_zone_destroy(xfs_ili_zone);\n\tkmem_zone_destroy(xfs_inode_zone);\n\tkmem_zone_destroy(xfs_efi_zone);\n\tkmem_zone_destroy(xfs_efd_zone);\n\tkmem_zone_destroy(xfs_buf_item_zone);\n\tkmem_zone_destroy(xfs_log_item_desc_zone);\n\tkmem_zone_destroy(xfs_trans_zone);\n\tkmem_zone_destroy(xfs_ifork_zone);\n\tkmem_zone_destroy(xfs_da_state_zone);\n\tkmem_zone_destroy(xfs_btree_cur_zone);\n\tkmem_zone_destroy(xfs_bmap_free_item_zone);\n\tkmem_zone_destroy(xfs_log_ticket_zone);\n\tmempool_destroy(xfs_ioend_pool);\n\tkmem_zone_destroy(xfs_ioend_zone);\n\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static kmem_zone_t *xfs_ioend_zone;",
      "mempool_t *xfs_ioend_pool;",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_destroy",
          "args": [
            "xfs_ioend_zone"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "110-115",
          "snippet": "static inline void\nkmem_zone_destroy(kmem_zone_t *zone)\n{\n\tif (zone)\n\t\tkmem_cache_destroy(zone);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_destroy(kmem_zone_t *zone)\n{\n\tif (zone)\n\t\tkmem_cache_destroy(zone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool_destroy",
          "args": [
            "xfs_ioend_pool"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mempool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "730-734",
          "snippet": "static inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_ioend_zone;\nmempool_t *xfs_ioend_pool;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_destroy_zones(void)\n{\n\t/*\n\t * Make sure all delayed rcu free are flushed before we\n\t * destroy caches.\n\t */\n\trcu_barrier();\n\tkmem_zone_destroy(xfs_icreate_zone);\n\tkmem_zone_destroy(xfs_ili_zone);\n\tkmem_zone_destroy(xfs_inode_zone);\n\tkmem_zone_destroy(xfs_efi_zone);\n\tkmem_zone_destroy(xfs_efd_zone);\n\tkmem_zone_destroy(xfs_buf_item_zone);\n\tkmem_zone_destroy(xfs_log_item_desc_zone);\n\tkmem_zone_destroy(xfs_trans_zone);\n\tkmem_zone_destroy(xfs_ifork_zone);\n\tkmem_zone_destroy(xfs_da_state_zone);\n\tkmem_zone_destroy(xfs_btree_cur_zone);\n\tkmem_zone_destroy(xfs_bmap_free_item_zone);\n\tkmem_zone_destroy(xfs_log_ticket_zone);\n\tmempool_destroy(xfs_ioend_pool);\n\tkmem_zone_destroy(xfs_ioend_zone);\n\n}"
  },
  {
    "function_name": "xfs_init_zones",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1578-1696",
    "snippet": "__init\nxfs_init_zones(void)\n{\n\n\txfs_ioend_zone = kmem_zone_init(sizeof(xfs_ioend_t), \"xfs_ioend\");\n\tif (!xfs_ioend_zone)\n\t\tgoto out;\n\n\txfs_ioend_pool = mempool_create_slab_pool(4 * MAX_BUF_PER_PAGE,\n\t\t\t\t\t\t  xfs_ioend_zone);\n\tif (!xfs_ioend_pool)\n\t\tgoto out_destroy_ioend_zone;\n\n\txfs_log_ticket_zone = kmem_zone_init(sizeof(xlog_ticket_t),\n\t\t\t\t\t\t\"xfs_log_ticket\");\n\tif (!xfs_log_ticket_zone)\n\t\tgoto out_destroy_ioend_pool;\n\n\txfs_bmap_free_item_zone = kmem_zone_init(sizeof(xfs_bmap_free_item_t),\n\t\t\t\t\t\t\"xfs_bmap_free_item\");\n\tif (!xfs_bmap_free_item_zone)\n\t\tgoto out_destroy_log_ticket_zone;\n\n\txfs_btree_cur_zone = kmem_zone_init(sizeof(xfs_btree_cur_t),\n\t\t\t\t\t\t\"xfs_btree_cur\");\n\tif (!xfs_btree_cur_zone)\n\t\tgoto out_destroy_bmap_free_item_zone;\n\n\txfs_da_state_zone = kmem_zone_init(sizeof(xfs_da_state_t),\n\t\t\t\t\t\t\"xfs_da_state\");\n\tif (!xfs_da_state_zone)\n\t\tgoto out_destroy_btree_cur_zone;\n\n\txfs_ifork_zone = kmem_zone_init(sizeof(xfs_ifork_t), \"xfs_ifork\");\n\tif (!xfs_ifork_zone)\n\t\tgoto out_destroy_da_state_zone;\n\n\txfs_trans_zone = kmem_zone_init(sizeof(xfs_trans_t), \"xfs_trans\");\n\tif (!xfs_trans_zone)\n\t\tgoto out_destroy_ifork_zone;\n\n\txfs_log_item_desc_zone =\n\t\tkmem_zone_init(sizeof(struct xfs_log_item_desc),\n\t\t\t       \"xfs_log_item_desc\");\n\tif (!xfs_log_item_desc_zone)\n\t\tgoto out_destroy_trans_zone;\n\n\t/*\n\t * The size of the zone allocated buf log item is the maximum\n\t * size possible under XFS.  This wastes a little bit of memory,\n\t * but it is much faster.\n\t */\n\txfs_buf_item_zone = kmem_zone_init(sizeof(struct xfs_buf_log_item),\n\t\t\t\t\t   \"xfs_buf_item\");\n\tif (!xfs_buf_item_zone)\n\t\tgoto out_destroy_log_item_desc_zone;\n\n\txfs_efd_zone = kmem_zone_init((sizeof(xfs_efd_log_item_t) +\n\t\t\t((XFS_EFD_MAX_FAST_EXTENTS - 1) *\n\t\t\t\t sizeof(xfs_extent_t))), \"xfs_efd_item\");\n\tif (!xfs_efd_zone)\n\t\tgoto out_destroy_buf_item_zone;\n\n\txfs_efi_zone = kmem_zone_init((sizeof(xfs_efi_log_item_t) +\n\t\t\t((XFS_EFI_MAX_FAST_EXTENTS - 1) *\n\t\t\t\tsizeof(xfs_extent_t))), \"xfs_efi_item\");\n\tif (!xfs_efi_zone)\n\t\tgoto out_destroy_efd_zone;\n\n\txfs_inode_zone =\n\t\tkmem_zone_init_flags(sizeof(xfs_inode_t), \"xfs_inode\",\n\t\t\tKM_ZONE_HWALIGN | KM_ZONE_RECLAIM | KM_ZONE_SPREAD,\n\t\t\txfs_fs_inode_init_once);\n\tif (!xfs_inode_zone)\n\t\tgoto out_destroy_efi_zone;\n\n\txfs_ili_zone =\n\t\tkmem_zone_init_flags(sizeof(xfs_inode_log_item_t), \"xfs_ili\",\n\t\t\t\t\tKM_ZONE_SPREAD, NULL);\n\tif (!xfs_ili_zone)\n\t\tgoto out_destroy_inode_zone;\n\txfs_icreate_zone = kmem_zone_init(sizeof(struct xfs_icreate_item),\n\t\t\t\t\t\"xfs_icr\");\n\tif (!xfs_icreate_zone)\n\t\tgoto out_destroy_ili_zone;\n\n\treturn 0;\n\n out_destroy_ili_zone:\n\tkmem_zone_destroy(xfs_ili_zone);\n out_destroy_inode_zone:\n\tkmem_zone_destroy(xfs_inode_zone);\n out_destroy_efi_zone:\n\tkmem_zone_destroy(xfs_efi_zone);\n out_destroy_efd_zone:\n\tkmem_zone_destroy(xfs_efd_zone);\n out_destroy_buf_item_zone:\n\tkmem_zone_destroy(xfs_buf_item_zone);\n out_destroy_log_item_desc_zone:\n\tkmem_zone_destroy(xfs_log_item_desc_zone);\n out_destroy_trans_zone:\n\tkmem_zone_destroy(xfs_trans_zone);\n out_destroy_ifork_zone:\n\tkmem_zone_destroy(xfs_ifork_zone);\n out_destroy_da_state_zone:\n\tkmem_zone_destroy(xfs_da_state_zone);\n out_destroy_btree_cur_zone:\n\tkmem_zone_destroy(xfs_btree_cur_zone);\n out_destroy_bmap_free_item_zone:\n\tkmem_zone_destroy(xfs_bmap_free_item_zone);\n out_destroy_log_ticket_zone:\n\tkmem_zone_destroy(xfs_log_ticket_zone);\n out_destroy_ioend_pool:\n\tmempool_destroy(xfs_ioend_pool);\n out_destroy_ioend_zone:\n\tkmem_zone_destroy(xfs_ioend_zone);\n out:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static kmem_zone_t *xfs_ioend_zone;",
      "mempool_t *xfs_ioend_pool;",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_destroy",
          "args": [
            "xfs_ioend_zone"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "110-115",
          "snippet": "static inline void\nkmem_zone_destroy(kmem_zone_t *zone)\n{\n\tif (zone)\n\t\tkmem_cache_destroy(zone);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_destroy(kmem_zone_t *zone)\n{\n\tif (zone)\n\t\tkmem_cache_destroy(zone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool_destroy",
          "args": [
            "xfs_ioend_pool"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mempool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "730-734",
          "snippet": "static inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zone_init",
          "args": [
            "sizeof(struct xfs_icreate_item)",
            "\"xfs_icr\""
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "91-95",
          "snippet": "static inline kmem_zone_t *\nkmem_zone_init(int size, char *zone_name)\n{\n\treturn kmem_cache_create(zone_name, size, 0, 0, NULL);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline kmem_zone_t *\nkmem_zone_init(int size, char *zone_name)\n{\n\treturn kmem_cache_create(zone_name, size, 0, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zone_init_flags",
          "args": [
            "sizeof(xfs_inode_log_item_t)",
            "\"xfs_ili\"",
            "KM_ZONE_SPREAD",
            "NULL"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_init_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "97-102",
          "snippet": "static inline kmem_zone_t *\nkmem_zone_init_flags(int size, char *zone_name, unsigned long flags,\n\t\t     void (*construct)(void *))\n{\n\treturn kmem_cache_create(zone_name, size, 0, flags, construct);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline kmem_zone_t *\nkmem_zone_init_flags(int size, char *zone_name, unsigned long flags,\n\t\t     void (*construct)(void *))\n{\n\treturn kmem_cache_create(zone_name, size, 0, flags, construct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool_create_slab_pool",
          "args": [
            "4 * MAX_BUF_PER_PAGE",
            "xfs_ioend_zone"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_ioend_zone;\nmempool_t *xfs_ioend_pool;\nSTATIC struct;\nSTATIC struct;\n\n__init\nxfs_init_zones(void)\n{\n\n\txfs_ioend_zone = kmem_zone_init(sizeof(xfs_ioend_t), \"xfs_ioend\");\n\tif (!xfs_ioend_zone)\n\t\tgoto out;\n\n\txfs_ioend_pool = mempool_create_slab_pool(4 * MAX_BUF_PER_PAGE,\n\t\t\t\t\t\t  xfs_ioend_zone);\n\tif (!xfs_ioend_pool)\n\t\tgoto out_destroy_ioend_zone;\n\n\txfs_log_ticket_zone = kmem_zone_init(sizeof(xlog_ticket_t),\n\t\t\t\t\t\t\"xfs_log_ticket\");\n\tif (!xfs_log_ticket_zone)\n\t\tgoto out_destroy_ioend_pool;\n\n\txfs_bmap_free_item_zone = kmem_zone_init(sizeof(xfs_bmap_free_item_t),\n\t\t\t\t\t\t\"xfs_bmap_free_item\");\n\tif (!xfs_bmap_free_item_zone)\n\t\tgoto out_destroy_log_ticket_zone;\n\n\txfs_btree_cur_zone = kmem_zone_init(sizeof(xfs_btree_cur_t),\n\t\t\t\t\t\t\"xfs_btree_cur\");\n\tif (!xfs_btree_cur_zone)\n\t\tgoto out_destroy_bmap_free_item_zone;\n\n\txfs_da_state_zone = kmem_zone_init(sizeof(xfs_da_state_t),\n\t\t\t\t\t\t\"xfs_da_state\");\n\tif (!xfs_da_state_zone)\n\t\tgoto out_destroy_btree_cur_zone;\n\n\txfs_ifork_zone = kmem_zone_init(sizeof(xfs_ifork_t), \"xfs_ifork\");\n\tif (!xfs_ifork_zone)\n\t\tgoto out_destroy_da_state_zone;\n\n\txfs_trans_zone = kmem_zone_init(sizeof(xfs_trans_t), \"xfs_trans\");\n\tif (!xfs_trans_zone)\n\t\tgoto out_destroy_ifork_zone;\n\n\txfs_log_item_desc_zone =\n\t\tkmem_zone_init(sizeof(struct xfs_log_item_desc),\n\t\t\t       \"xfs_log_item_desc\");\n\tif (!xfs_log_item_desc_zone)\n\t\tgoto out_destroy_trans_zone;\n\n\t/*\n\t * The size of the zone allocated buf log item is the maximum\n\t * size possible under XFS.  This wastes a little bit of memory,\n\t * but it is much faster.\n\t */\n\txfs_buf_item_zone = kmem_zone_init(sizeof(struct xfs_buf_log_item),\n\t\t\t\t\t   \"xfs_buf_item\");\n\tif (!xfs_buf_item_zone)\n\t\tgoto out_destroy_log_item_desc_zone;\n\n\txfs_efd_zone = kmem_zone_init((sizeof(xfs_efd_log_item_t) +\n\t\t\t((XFS_EFD_MAX_FAST_EXTENTS - 1) *\n\t\t\t\t sizeof(xfs_extent_t))), \"xfs_efd_item\");\n\tif (!xfs_efd_zone)\n\t\tgoto out_destroy_buf_item_zone;\n\n\txfs_efi_zone = kmem_zone_init((sizeof(xfs_efi_log_item_t) +\n\t\t\t((XFS_EFI_MAX_FAST_EXTENTS - 1) *\n\t\t\t\tsizeof(xfs_extent_t))), \"xfs_efi_item\");\n\tif (!xfs_efi_zone)\n\t\tgoto out_destroy_efd_zone;\n\n\txfs_inode_zone =\n\t\tkmem_zone_init_flags(sizeof(xfs_inode_t), \"xfs_inode\",\n\t\t\tKM_ZONE_HWALIGN | KM_ZONE_RECLAIM | KM_ZONE_SPREAD,\n\t\t\txfs_fs_inode_init_once);\n\tif (!xfs_inode_zone)\n\t\tgoto out_destroy_efi_zone;\n\n\txfs_ili_zone =\n\t\tkmem_zone_init_flags(sizeof(xfs_inode_log_item_t), \"xfs_ili\",\n\t\t\t\t\tKM_ZONE_SPREAD, NULL);\n\tif (!xfs_ili_zone)\n\t\tgoto out_destroy_inode_zone;\n\txfs_icreate_zone = kmem_zone_init(sizeof(struct xfs_icreate_item),\n\t\t\t\t\t\"xfs_icr\");\n\tif (!xfs_icreate_zone)\n\t\tgoto out_destroy_ili_zone;\n\n\treturn 0;\n\n out_destroy_ili_zone:\n\tkmem_zone_destroy(xfs_ili_zone);\n out_destroy_inode_zone:\n\tkmem_zone_destroy(xfs_inode_zone);\n out_destroy_efi_zone:\n\tkmem_zone_destroy(xfs_efi_zone);\n out_destroy_efd_zone:\n\tkmem_zone_destroy(xfs_efd_zone);\n out_destroy_buf_item_zone:\n\tkmem_zone_destroy(xfs_buf_item_zone);\n out_destroy_log_item_desc_zone:\n\tkmem_zone_destroy(xfs_log_item_desc_zone);\n out_destroy_trans_zone:\n\tkmem_zone_destroy(xfs_trans_zone);\n out_destroy_ifork_zone:\n\tkmem_zone_destroy(xfs_ifork_zone);\n out_destroy_da_state_zone:\n\tkmem_zone_destroy(xfs_da_state_zone);\n out_destroy_btree_cur_zone:\n\tkmem_zone_destroy(xfs_btree_cur_zone);\n out_destroy_bmap_free_item_zone:\n\tkmem_zone_destroy(xfs_bmap_free_item_zone);\n out_destroy_log_ticket_zone:\n\tkmem_zone_destroy(xfs_log_ticket_zone);\n out_destroy_ioend_pool:\n\tmempool_destroy(xfs_ioend_pool);\n out_destroy_ioend_zone:\n\tkmem_zone_destroy(xfs_ioend_zone);\n out:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "xfs_fs_free_cached_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1545-1551",
    "snippet": "static long\nxfs_fs_free_cached_objects(\n\tstruct super_block\t*sb,\n\tstruct shrink_control\t*sc)\n{\n\treturn xfs_reclaim_inodes_nr(XFS_M(sb), sc->nr_to_scan);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_reclaim_inodes_nr",
          "args": [
            "XFS_M(sb)",
            "sc->nr_to_scan"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reclaim_inodes_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1156-1166",
          "snippet": "long\nxfs_reclaim_inodes_nr(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tnr_to_scan)\n{\n\t/* kick background reclaimer and push the AIL */\n\txfs_reclaim_work_queue(mp);\n\txfs_ail_push_all(mp->m_ail);\n\n\treturn xfs_reclaim_inodes_ag(mp, SYNC_TRYLOCK | SYNC_WAIT, &nr_to_scan);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nlong\nxfs_reclaim_inodes_nr(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tnr_to_scan)\n{\n\t/* kick background reclaimer and push the AIL */\n\txfs_reclaim_work_queue(mp);\n\txfs_ail_push_all(mp->m_ail);\n\n\treturn xfs_reclaim_inodes_ag(mp, SYNC_TRYLOCK | SYNC_WAIT, &nr_to_scan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic long\nxfs_fs_free_cached_objects(\n\tstruct super_block\t*sb,\n\tstruct shrink_control\t*sc)\n{\n\treturn xfs_reclaim_inodes_nr(XFS_M(sb), sc->nr_to_scan);\n}"
  },
  {
    "function_name": "xfs_fs_nr_cached_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1537-1543",
    "snippet": "static long\nxfs_fs_nr_cached_objects(\n\tstruct super_block\t*sb,\n\tstruct shrink_control\t*sc)\n{\n\treturn xfs_reclaim_inodes_count(XFS_M(sb));\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_reclaim_inodes_count",
          "args": [
            "XFS_M(sb)"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reclaim_inodes_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1172-1186",
          "snippet": "int\nxfs_reclaim_inodes_count(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tag = 0;\n\tint\t\t\treclaimable = 0;\n\n\twhile ((pag = xfs_perag_get_tag(mp, ag, XFS_ICI_RECLAIM_TAG))) {\n\t\tag = pag->pag_agno + 1;\n\t\treclaimable += pag->pag_ici_reclaimable;\n\t\txfs_perag_put(pag);\n\t}\n\treturn reclaimable;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_reclaim_inodes_count(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tag = 0;\n\tint\t\t\treclaimable = 0;\n\n\twhile ((pag = xfs_perag_get_tag(mp, ag, XFS_ICI_RECLAIM_TAG))) {\n\t\tag = pag->pag_agno + 1;\n\t\treclaimable += pag->pag_ici_reclaimable;\n\t\txfs_perag_put(pag);\n\t}\n\treturn reclaimable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic long\nxfs_fs_nr_cached_objects(\n\tstruct super_block\t*sb,\n\tstruct shrink_control\t*sc)\n{\n\treturn xfs_reclaim_inodes_count(XFS_M(sb));\n}"
  },
  {
    "function_name": "xfs_fs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1527-1535",
    "snippet": "dentry *\nxfs_fs_mount(\n\tstruct file_system_type\t*fs_type,\n\tint\t\t\tflags,\n\tconst char\t\t*dev_name,\n\tvoid\t\t\t*data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, xfs_fs_fill_super);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "xfs_fs_fill_super"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\ndentry *\nxfs_fs_mount(\n\tstruct file_system_type\t*fs_type,\n\tint\t\t\tflags,\n\tconst char\t\t*dev_name,\n\tvoid\t\t\t*data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, xfs_fs_fill_super);\n}"
  },
  {
    "function_name": "xfs_fs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1404-1525",
    "snippet": "STATIC int\nxfs_fs_fill_super(\n\tstruct super_block\t*sb,\n\tvoid\t\t\t*data,\n\tint\t\t\tsilent)\n{\n\tstruct inode\t\t*root;\n\tstruct xfs_mount\t*mp = NULL;\n\tint\t\t\tflags = 0, error = -ENOMEM;\n\n\tmp = kzalloc(sizeof(struct xfs_mount), GFP_KERNEL);\n\tif (!mp)\n\t\tgoto out;\n\n\tspin_lock_init(&mp->m_sb_lock);\n\tmutex_init(&mp->m_growlock);\n\tatomic_set(&mp->m_active_trans, 0);\n\tINIT_DELAYED_WORK(&mp->m_reclaim_work, xfs_reclaim_worker);\n\tINIT_DELAYED_WORK(&mp->m_eofblocks_work, xfs_eofblocks_worker);\n\tmp->m_kobj.kobject.kset = xfs_kset;\n\n\tmp->m_super = sb;\n\tsb->s_fs_info = mp;\n\n\terror = xfs_parseargs(mp, (char *)data);\n\tif (error)\n\t\tgoto out_free_fsname;\n\n\tsb_min_blocksize(sb, BBSIZE);\n\tsb->s_xattr = xfs_xattr_handlers;\n\tsb->s_export_op = &xfs_export_operations;\n#ifdef CONFIG_XFS_QUOTA\n\tsb->s_qcop = &xfs_quotactl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tsb->s_op = &xfs_super_operations;\n\n\tif (silent)\n\t\tflags |= XFS_MFSI_QUIET;\n\n\terror = xfs_open_devices(mp);\n\tif (error)\n\t\tgoto out_free_fsname;\n\n\terror = xfs_init_mount_workqueues(mp);\n\tif (error)\n\t\tgoto out_close_devices;\n\n\terror = xfs_icsb_init_counters(mp);\n\tif (error)\n\t\tgoto out_destroy_workqueues;\n\n\terror = xfs_readsb(mp, flags);\n\tif (error)\n\t\tgoto out_destroy_counters;\n\n\terror = xfs_finish_flags(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\terror = xfs_setup_devices(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\terror = xfs_filestream_mount(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\t/*\n\t * we must configure the block size in the superblock before we run the\n\t * full mount process as the mount process can lookup and cache inodes.\n\t */\n\tsb->s_magic = XFS_SB_MAGIC;\n\tsb->s_blocksize = mp->m_sb.sb_blocksize;\n\tsb->s_blocksize_bits = ffs(sb->s_blocksize) - 1;\n\tsb->s_maxbytes = xfs_max_file_offset(sb->s_blocksize_bits);\n\tsb->s_max_links = XFS_MAXLINK;\n\tsb->s_time_gran = 1;\n\tset_posix_acl_flag(sb);\n\n\t/* version 5 superblocks support inode version counters. */\n\tif (XFS_SB_VERSION_NUM(&mp->m_sb) == XFS_SB_VERSION_5)\n\t\tsb->s_flags |= MS_I_VERSION;\n\n\terror = xfs_mountfs(mp);\n\tif (error)\n\t\tgoto out_filestream_unmount;\n\n\troot = igrab(VFS_I(mp->m_rootip));\n\tif (!root) {\n\t\terror = -ENOENT;\n\t\tgoto out_unmount;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terror = -ENOMEM;\n\t\tgoto out_unmount;\n\t}\n\n\treturn 0;\n\n out_filestream_unmount:\n\txfs_filestream_unmount(mp);\n out_free_sb:\n\txfs_freesb(mp);\n out_destroy_counters:\n\txfs_icsb_destroy_counters(mp);\nout_destroy_workqueues:\n\txfs_destroy_mount_workqueues(mp);\n out_close_devices:\n\txfs_close_devices(mp);\n out_free_fsname:\n\txfs_free_fsname(mp);\n\tkfree(mp);\n out:\n\treturn error;\n\n out_unmount:\n\txfs_filestream_unmount(mp);\n\txfs_unmountfs(mp);\n\tgoto out_free_sb;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations xfs_super_operations;",
      "static struct kset *xfs_kset;",
      "STATIC struct",
      "STATIC struct",
      "static const struct super_operations xfs_super_operations = {\n\t.alloc_inode\t\t= xfs_fs_alloc_inode,\n\t.destroy_inode\t\t= xfs_fs_destroy_inode,\n\t.evict_inode\t\t= xfs_fs_evict_inode,\n\t.drop_inode\t\t= xfs_fs_drop_inode,\n\t.put_super\t\t= xfs_fs_put_super,\n\t.sync_fs\t\t= xfs_fs_sync_fs,\n\t.freeze_fs\t\t= xfs_fs_freeze,\n\t.unfreeze_fs\t\t= xfs_fs_unfreeze,\n\t.statfs\t\t\t= xfs_fs_statfs,\n\t.remount_fs\t\t= xfs_fs_remount,\n\t.show_options\t\t= xfs_fs_show_options,\n\t.nr_cached_objects\t= xfs_fs_nr_cached_objects,\n\t.free_cached_objects\t= xfs_fs_free_cached_objects,\n};",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_unmountfs",
          "args": [
            "mp"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_unmountfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "977-1053",
          "snippet": "void\nxfs_unmountfs(\n\tstruct xfs_mount\t*mp)\n{\n\t__uint64_t\t\tresblks;\n\tint\t\t\terror;\n\n\tcancel_delayed_work_sync(&mp->m_eofblocks_work);\n\n\txfs_qm_unmount_quotas(mp);\n\txfs_rtunmount_inodes(mp);\n\tIRELE(mp->m_rootip);\n\n\t/*\n\t * We can potentially deadlock here if we have an inode cluster\n\t * that has been freed has its buffer still pinned in memory because\n\t * the transaction is still sitting in a iclog. The stale inodes\n\t * on that buffer will have their flush locks held until the\n\t * transaction hits the disk and the callbacks run. the inode\n\t * flush takes the flush lock unconditionally and with nothing to\n\t * push out the iclog we will never get that unlocked. hence we\n\t * need to force the log first.\n\t */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * Flush all pending changes from the AIL.\n\t */\n\txfs_ail_push_all_sync(mp->m_ail);\n\n\t/*\n\t * And reclaim all inodes.  At this point there should be no dirty\n\t * inodes and none should be pinned or locked, but use synchronous\n\t * reclaim just to be sure. We can stop background inode reclaim\n\t * here as well if it is still running.\n\t */\n\tcancel_delayed_work_sync(&mp->m_reclaim_work);\n\txfs_reclaim_inodes(mp, SYNC_WAIT);\n\n\txfs_qm_unmount(mp);\n\n\t/*\n\t * Unreserve any blocks we have so that when we unmount we don't account\n\t * the reserved free space as used. This is really only necessary for\n\t * lazy superblock counting because it trusts the incore superblock\n\t * counters to be absolutely correct on clean unmount.\n\t *\n\t * We don't bother correcting this elsewhere for lazy superblock\n\t * counting because on mount of an unclean filesystem we reconstruct the\n\t * correct counter value and this is irrelevant.\n\t *\n\t * For non-lazy counter filesystems, this doesn't matter at all because\n\t * we only every apply deltas to the superblock and hence the incore\n\t * value does not matter....\n\t */\n\tresblks = 0;\n\terror = xfs_reserve_blocks(mp, &resblks, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to free reserved block pool. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\n\terror = xfs_log_sbcount(mp);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to update superblock counters. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\n\txfs_log_unmount(mp);\n\txfs_da_unmount(mp);\n\txfs_uuid_unmount(mp);\n\n#if defined(DEBUG)\n\txfs_errortag_clearall(mp, 0);\n#endif\n\txfs_free_perag(mp);\n\n\txfs_sysfs_del(&mp->m_kobj);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_unmountfs(\n\tstruct xfs_mount\t*mp)\n{\n\t__uint64_t\t\tresblks;\n\tint\t\t\terror;\n\n\tcancel_delayed_work_sync(&mp->m_eofblocks_work);\n\n\txfs_qm_unmount_quotas(mp);\n\txfs_rtunmount_inodes(mp);\n\tIRELE(mp->m_rootip);\n\n\t/*\n\t * We can potentially deadlock here if we have an inode cluster\n\t * that has been freed has its buffer still pinned in memory because\n\t * the transaction is still sitting in a iclog. The stale inodes\n\t * on that buffer will have their flush locks held until the\n\t * transaction hits the disk and the callbacks run. the inode\n\t * flush takes the flush lock unconditionally and with nothing to\n\t * push out the iclog we will never get that unlocked. hence we\n\t * need to force the log first.\n\t */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * Flush all pending changes from the AIL.\n\t */\n\txfs_ail_push_all_sync(mp->m_ail);\n\n\t/*\n\t * And reclaim all inodes.  At this point there should be no dirty\n\t * inodes and none should be pinned or locked, but use synchronous\n\t * reclaim just to be sure. We can stop background inode reclaim\n\t * here as well if it is still running.\n\t */\n\tcancel_delayed_work_sync(&mp->m_reclaim_work);\n\txfs_reclaim_inodes(mp, SYNC_WAIT);\n\n\txfs_qm_unmount(mp);\n\n\t/*\n\t * Unreserve any blocks we have so that when we unmount we don't account\n\t * the reserved free space as used. This is really only necessary for\n\t * lazy superblock counting because it trusts the incore superblock\n\t * counters to be absolutely correct on clean unmount.\n\t *\n\t * We don't bother correcting this elsewhere for lazy superblock\n\t * counting because on mount of an unclean filesystem we reconstruct the\n\t * correct counter value and this is irrelevant.\n\t *\n\t * For non-lazy counter filesystems, this doesn't matter at all because\n\t * we only every apply deltas to the superblock and hence the incore\n\t * value does not matter....\n\t */\n\tresblks = 0;\n\terror = xfs_reserve_blocks(mp, &resblks, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to free reserved block pool. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\n\terror = xfs_log_sbcount(mp);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to update superblock counters. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\n\txfs_log_unmount(mp);\n\txfs_da_unmount(mp);\n\txfs_uuid_unmount(mp);\n\n#if defined(DEBUG)\n\txfs_errortag_clearall(mp, 0);\n#endif\n\txfs_free_perag(mp);\n\n\txfs_sysfs_del(&mp->m_kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_filestream_unmount",
          "args": [
            "mp"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "426-431",
          "snippet": "void\nxfs_filestream_unmount(\n\txfs_mount_t\t*mp)\n{\n\txfs_mru_cache_destroy(mp->m_filestream);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_filestream_unmount(\n\txfs_mount_t\t*mp)\n{\n\txfs_mru_cache_destroy(mp->m_filestream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mp"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_free_fsname",
          "args": [
            "mp"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_fsname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1027-1034",
          "snippet": "STATIC void\nxfs_free_fsname(\n\tstruct xfs_mount\t*mp)\n{\n\tkfree(mp->m_fsname);\n\tkfree(mp->m_rtname);\n\tkfree(mp->m_logname);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_free_fsname(\n\tstruct xfs_mount\t*mp)\n{\n\tkfree(mp->m_fsname);\n\tkfree(mp->m_rtname);\n\tkfree(mp->m_logname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_close_devices",
          "args": [
            "mp"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_close_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "709-724",
          "snippet": "STATIC void\nxfs_close_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\tstruct block_device *logdev = mp->m_logdev_targp->bt_bdev;\n\t\txfs_free_buftarg(mp, mp->m_logdev_targp);\n\t\txfs_blkdev_put(logdev);\n\t}\n\tif (mp->m_rtdev_targp) {\n\t\tstruct block_device *rtdev = mp->m_rtdev_targp->bt_bdev;\n\t\txfs_free_buftarg(mp, mp->m_rtdev_targp);\n\t\txfs_blkdev_put(rtdev);\n\t}\n\txfs_free_buftarg(mp, mp->m_ddev_targp);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_close_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\tstruct block_device *logdev = mp->m_logdev_targp->bt_bdev;\n\t\txfs_free_buftarg(mp, mp->m_logdev_targp);\n\t\txfs_blkdev_put(logdev);\n\t}\n\tif (mp->m_rtdev_targp) {\n\t\tstruct block_device *rtdev = mp->m_rtdev_targp->bt_bdev;\n\t\txfs_free_buftarg(mp, mp->m_rtdev_targp);\n\t\txfs_blkdev_put(rtdev);\n\t}\n\txfs_free_buftarg(mp, mp->m_ddev_targp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_destroy_mount_workqueues",
          "args": [
            "mp"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_destroy_mount_workqueues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "894-905",
          "snippet": "STATIC void\nxfs_destroy_mount_workqueues(\n\tstruct xfs_mount\t*mp)\n{\n\tdestroy_workqueue(mp->m_eofblocks_workqueue);\n\tdestroy_workqueue(mp->m_log_workqueue);\n\tdestroy_workqueue(mp->m_reclaim_workqueue);\n\tdestroy_workqueue(mp->m_cil_workqueue);\n\tdestroy_workqueue(mp->m_data_workqueue);\n\tdestroy_workqueue(mp->m_unwritten_workqueue);\n\tdestroy_workqueue(mp->m_buf_workqueue);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_destroy_mount_workqueues(\n\tstruct xfs_mount\t*mp)\n{\n\tdestroy_workqueue(mp->m_eofblocks_workqueue);\n\tdestroy_workqueue(mp->m_log_workqueue);\n\tdestroy_workqueue(mp->m_reclaim_workqueue);\n\tdestroy_workqueue(mp->m_cil_workqueue);\n\tdestroy_workqueue(mp->m_data_workqueue);\n\tdestroy_workqueue(mp->m_unwritten_workqueue);\n\tdestroy_workqueue(mp->m_buf_workqueue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_destroy_counters",
          "args": [
            "mp"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_destroy_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1578-1587",
          "snippet": "void\nxfs_icsb_destroy_counters(\n\txfs_mount_t\t*mp)\n{\n\tif (mp->m_sb_cnts) {\n\t\tunregister_hotcpu_notifier(&mp->m_icsb_notifier);\n\t\tfree_percpu(mp->m_sb_cnts);\n\t}\n\tmutex_destroy(&mp->m_icsb_mutex);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_destroy_counters(\n\txfs_mount_t\t*mp)\n{\n\tif (mp->m_sb_cnts) {\n\t\tunregister_hotcpu_notifier(&mp->m_icsb_notifier);\n\t\tfree_percpu(mp->m_sb_cnts);\n\t}\n\tmutex_destroy(&mp->m_icsb_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_freesb",
          "args": [
            "mp"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_freesb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1381-1390",
          "snippet": "void\nxfs_freesb(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\txfs_buf_lock(bp);\n\tmp->m_sb_bp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_freesb(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\txfs_buf_lock(bp);\n\tmp->m_sb_bp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "VFS_I(mp->m_rootip)"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "mp->m_rootip"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mountfs",
          "args": [
            "mp"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mountfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "629-971",
          "snippet": "int\nxfs_mountfs(\n\txfs_mount_t\t*mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\txfs_inode_t\t*rip;\n\t__uint64_t\tresblks;\n\tuint\t\tquotamount = 0;\n\tuint\t\tquotaflags = 0;\n\tint\t\terror = 0;\n\n\txfs_sb_mount_common(mp, sbp);\n\n\t/*\n\t * Check for a mismatched features2 values.  Older kernels read & wrote\n\t * into the wrong sb offset for sb_features2 on some platforms due to\n\t * xfs_sb_t not being 64bit size aligned when sb_features2 was added,\n\t * which made older superblock reading/writing routines swap it as a\n\t * 64-bit value.\n\t *\n\t * For backwards compatibility, we make both slots equal.\n\t *\n\t * If we detect a mismatched field, we OR the set bits into the existing\n\t * features2 field in case it has already been modified; we don't want\n\t * to lose any features.  We then update the bad location with the ORed\n\t * value so that older kernels will see any features2 flags. The\n\t * superblock writeback code ensures the new sb_features2 is copied to\n\t * sb_bad_features2 before it is logged or written to disk.\n\t */\n\tif (xfs_sb_has_mismatched_features2(sbp)) {\n\t\txfs_warn(mp, \"correcting sb_features alignment problem\");\n\t\tsbp->sb_features2 |= sbp->sb_bad_features2;\n\t\tmp->m_update_sb = true;\n\n\t\t/*\n\t\t * Re-check for ATTR2 in case it was found in bad_features2\n\t\t * slot.\n\t\t */\n\t\tif (xfs_sb_version_hasattr2(&mp->m_sb) &&\n\t\t   !(mp->m_flags & XFS_MOUNT_NOATTR2))\n\t\t\tmp->m_flags |= XFS_MOUNT_ATTR2;\n\t}\n\n\tif (xfs_sb_version_hasattr2(&mp->m_sb) &&\n\t   (mp->m_flags & XFS_MOUNT_NOATTR2)) {\n\t\txfs_sb_version_removeattr2(&mp->m_sb);\n\t\tmp->m_update_sb = true;\n\n\t\t/* update sb_versionnum for the clearing of the morebits */\n\t\tif (!sbp->sb_features2)\n\t\t\tmp->m_update_sb = true;\n\t}\n\n\t/* always use v2 inodes by default now */\n\tif (!(mp->m_sb.sb_versionnum & XFS_SB_VERSION_NLINKBIT)) {\n\t\tmp->m_sb.sb_versionnum |= XFS_SB_VERSION_NLINKBIT;\n\t\tmp->m_update_sb = true;\n\t}\n\n\t/*\n\t * Check if sb_agblocks is aligned at stripe boundary\n\t * If sb_agblocks is NOT aligned turn off m_dalign since\n\t * allocator alignment is within an ag, therefore ag has\n\t * to be aligned at stripe boundary.\n\t */\n\terror = xfs_update_alignment(mp);\n\tif (error)\n\t\tgoto out;\n\n\txfs_alloc_compute_maxlevels(mp);\n\txfs_bmap_compute_maxlevels(mp, XFS_DATA_FORK);\n\txfs_bmap_compute_maxlevels(mp, XFS_ATTR_FORK);\n\txfs_ialloc_compute_maxlevels(mp);\n\n\txfs_set_maxicount(mp);\n\n\terror = xfs_sysfs_init(&mp->m_kobj, &xfs_mp_ktype, NULL, mp->m_fsname);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_uuid_mount(mp);\n\tif (error)\n\t\tgoto out_remove_sysfs;\n\n\t/*\n\t * Set the minimum read and write sizes\n\t */\n\txfs_set_rw_sizes(mp);\n\n\t/* set the low space thresholds for dynamic preallocation */\n\txfs_set_low_space_thresholds(mp);\n\n\t/*\n\t * Set the inode cluster size.\n\t * This may still be overridden by the file system\n\t * block size if it is larger than the chosen cluster size.\n\t *\n\t * For v5 filesystems, scale the cluster size with the inode size to\n\t * keep a constant ratio of inode per cluster buffer, but only if mkfs\n\t * has set the inode alignment value appropriately for larger cluster\n\t * sizes.\n\t */\n\tmp->m_inode_cluster_size = XFS_INODE_BIG_CLUSTER_SIZE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint\tnew_size = mp->m_inode_cluster_size;\n\n\t\tnew_size *= mp->m_sb.sb_inodesize / XFS_DINODE_MIN_SIZE;\n\t\tif (mp->m_sb.sb_inoalignmt >= XFS_B_TO_FSBT(mp, new_size))\n\t\t\tmp->m_inode_cluster_size = new_size;\n\t}\n\n\t/*\n\t * Set inode alignment fields\n\t */\n\txfs_set_inoalignment(mp);\n\n\t/*\n\t * Check that the data (and log if separate) is an ok size.\n\t */\n\terror = xfs_check_sizes(mp);\n\tif (error)\n\t\tgoto out_remove_uuid;\n\n\t/*\n\t * Initialize realtime fields in the mount structure\n\t */\n\terror = xfs_rtmount_init(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"RT mount failed\");\n\t\tgoto out_remove_uuid;\n\t}\n\n\t/*\n\t *  Copies the low order bits of the timestamp and the randomly\n\t *  set \"sequence\" number out of a UUID.\n\t */\n\tuuid_getnodeuniq(&sbp->sb_uuid, mp->m_fixedfsid);\n\n\tmp->m_dmevmask = 0;\t/* not persistent; set after each mount */\n\n\terror = xfs_da_mount(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"Failed dir/attr init: %d\", error);\n\t\tgoto out_remove_uuid;\n\t}\n\n\t/*\n\t * Initialize the precomputed transaction reservations values.\n\t */\n\txfs_trans_init(mp);\n\n\t/*\n\t * Allocate and initialize the per-ag data.\n\t */\n\tspin_lock_init(&mp->m_perag_lock);\n\tINIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);\n\terror = xfs_initialize_perag(mp, sbp->sb_agcount, &mp->m_maxagi);\n\tif (error) {\n\t\txfs_warn(mp, \"Failed per-ag init: %d\", error);\n\t\tgoto out_free_dir;\n\t}\n\n\tif (!sbp->sb_logblocks) {\n\t\txfs_warn(mp, \"no log defined\");\n\t\tXFS_ERROR_REPORT(\"xfs_mountfs\", XFS_ERRLEVEL_LOW, mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_free_perag;\n\t}\n\n\t/*\n\t * log's mount-time initialization. Perform 1st part recovery if needed\n\t */\n\terror = xfs_log_mount(mp, mp->m_logdev_targp,\n\t\t\t      XFS_FSB_TO_DADDR(mp, sbp->sb_logstart),\n\t\t\t      XFS_FSB_TO_BB(mp, sbp->sb_logblocks));\n\tif (error) {\n\t\txfs_warn(mp, \"log mount failed\");\n\t\tgoto out_fail_wait;\n\t}\n\n\t/*\n\t * Now the log is mounted, we know if it was an unclean shutdown or\n\t * not. If it was, with the first phase of recovery has completed, we\n\t * have consistent AG blocks on disk. We have not recovered EFIs yet,\n\t * but they are recovered transactionally in the second recovery phase\n\t * later.\n\t *\n\t * Hence we can safely re-initialise incore superblock counters from\n\t * the per-ag data. These may not be correct if the filesystem was not\n\t * cleanly unmounted, so we need to wait for recovery to finish before\n\t * doing this.\n\t *\n\t * If the filesystem was cleanly unmounted, then we can trust the\n\t * values in the superblock to be correct and we don't need to do\n\t * anything here.\n\t *\n\t * If we are currently making the filesystem, the initialisation will\n\t * fail as the perag data is in an undefined state.\n\t */\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    !XFS_LAST_UNMOUNT_WAS_CLEAN(mp) &&\n\t     !mp->m_sb.sb_inprogress) {\n\t\terror = xfs_initialize_perag_data(mp, sbp->sb_agcount);\n\t\tif (error)\n\t\t\tgoto out_log_dealloc;\n\t}\n\n\t/*\n\t * Get and sanity-check the root inode.\n\t * Save the pointer to it in the mount structure.\n\t */\n\terror = xfs_iget(mp, NULL, sbp->sb_rootino, 0, XFS_ILOCK_EXCL, &rip);\n\tif (error) {\n\t\txfs_warn(mp, \"failed to read root inode\");\n\t\tgoto out_log_dealloc;\n\t}\n\n\tASSERT(rip != NULL);\n\n\tif (unlikely(!S_ISDIR(rip->i_d.di_mode))) {\n\t\txfs_warn(mp, \"corrupted root inode %llu: not a directory\",\n\t\t\t(unsigned long long)rip->i_ino);\n\t\txfs_iunlock(rip, XFS_ILOCK_EXCL);\n\t\tXFS_ERROR_REPORT(\"xfs_mountfs_int(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_rele_rip;\n\t}\n\tmp->m_rootip = rip;\t/* save it */\n\n\txfs_iunlock(rip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Initialize realtime inode pointers in the mount structure\n\t */\n\terror = xfs_rtmount_inodes(mp);\n\tif (error) {\n\t\t/*\n\t\t * Free up the root inode.\n\t\t */\n\t\txfs_warn(mp, \"failed to read RT inodes\");\n\t\tgoto out_rele_rip;\n\t}\n\n\t/*\n\t * If this is a read-only mount defer the superblock updates until\n\t * the next remount into writeable mode.  Otherwise we would never\n\t * perform the update e.g. for the root filesystem.\n\t */\n\tif (mp->m_update_sb && !(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\terror = xfs_sync_sb(mp, false);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"failed to write sb changes\");\n\t\t\tgoto out_rtunmount;\n\t\t}\n\t}\n\n\t/*\n\t * Initialise the XFS quota management subsystem for this mount\n\t */\n\tif (XFS_IS_QUOTA_RUNNING(mp)) {\n\t\terror = xfs_qm_newmount(mp, &quotamount, &quotaflags);\n\t\tif (error)\n\t\t\tgoto out_rtunmount;\n\t} else {\n\t\tASSERT(!XFS_IS_QUOTA_ON(mp));\n\n\t\t/*\n\t\t * If a file system had quotas running earlier, but decided to\n\t\t * mount without -o uquota/pquota/gquota options, revoke the\n\t\t * quotachecked license.\n\t\t */\n\t\tif (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_ACCT) {\n\t\t\txfs_notice(mp, \"resetting quota flags\");\n\t\t\terror = xfs_mount_reset_sbqflags(mp);\n\t\t\tif (error)\n\t\t\t\tgoto out_rtunmount;\n\t\t}\n\t}\n\n\t/*\n\t * Finish recovering the file system.  This part needed to be\n\t * delayed until after the root and real-time bitmap inodes\n\t * were consistently read in.\n\t */\n\terror = xfs_log_mount_finish(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"log mount finish failed\");\n\t\tgoto out_rtunmount;\n\t}\n\n\t/*\n\t * Complete the quota initialisation, post-log-replay component.\n\t */\n\tif (quotamount) {\n\t\tASSERT(mp->m_qflags == 0);\n\t\tmp->m_qflags = quotaflags;\n\n\t\txfs_qm_mount_quotas(mp);\n\t}\n\n\t/*\n\t * Now we are mounted, reserve a small amount of unused space for\n\t * privileged transactions. This is needed so that transaction\n\t * space required for critical operations can dip into this pool\n\t * when at ENOSPC. This is needed for operations like create with\n\t * attr, unwritten extent conversion at ENOSPC, etc. Data allocations\n\t * are not allowed to use this reserved space.\n\t *\n\t * This may drive us straight to ENOSPC on mount, but that implies\n\t * we were already there on the last unmount. Warn if this occurs.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\tresblks = xfs_default_resblks(mp);\n\t\terror = xfs_reserve_blocks(mp, &resblks, NULL);\n\t\tif (error)\n\t\t\txfs_warn(mp,\n\t\"Unable to allocate reserve blocks. Continuing without reserve pool.\");\n\t}\n\n\treturn 0;\n\n out_rtunmount:\n\txfs_rtunmount_inodes(mp);\n out_rele_rip:\n\tIRELE(rip);\n out_log_dealloc:\n\txfs_log_unmount(mp);\n out_fail_wait:\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp)\n\t\txfs_wait_buftarg(mp->m_logdev_targp);\n\txfs_wait_buftarg(mp->m_ddev_targp);\n out_free_perag:\n\txfs_free_perag(mp);\n out_free_dir:\n\txfs_da_unmount(mp);\n out_remove_uuid:\n\txfs_uuid_unmount(mp);\n out_remove_sysfs:\n\txfs_sysfs_del(&mp->m_kobj);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_mountfs(\n\txfs_mount_t\t*mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\txfs_inode_t\t*rip;\n\t__uint64_t\tresblks;\n\tuint\t\tquotamount = 0;\n\tuint\t\tquotaflags = 0;\n\tint\t\terror = 0;\n\n\txfs_sb_mount_common(mp, sbp);\n\n\t/*\n\t * Check for a mismatched features2 values.  Older kernels read & wrote\n\t * into the wrong sb offset for sb_features2 on some platforms due to\n\t * xfs_sb_t not being 64bit size aligned when sb_features2 was added,\n\t * which made older superblock reading/writing routines swap it as a\n\t * 64-bit value.\n\t *\n\t * For backwards compatibility, we make both slots equal.\n\t *\n\t * If we detect a mismatched field, we OR the set bits into the existing\n\t * features2 field in case it has already been modified; we don't want\n\t * to lose any features.  We then update the bad location with the ORed\n\t * value so that older kernels will see any features2 flags. The\n\t * superblock writeback code ensures the new sb_features2 is copied to\n\t * sb_bad_features2 before it is logged or written to disk.\n\t */\n\tif (xfs_sb_has_mismatched_features2(sbp)) {\n\t\txfs_warn(mp, \"correcting sb_features alignment problem\");\n\t\tsbp->sb_features2 |= sbp->sb_bad_features2;\n\t\tmp->m_update_sb = true;\n\n\t\t/*\n\t\t * Re-check for ATTR2 in case it was found in bad_features2\n\t\t * slot.\n\t\t */\n\t\tif (xfs_sb_version_hasattr2(&mp->m_sb) &&\n\t\t   !(mp->m_flags & XFS_MOUNT_NOATTR2))\n\t\t\tmp->m_flags |= XFS_MOUNT_ATTR2;\n\t}\n\n\tif (xfs_sb_version_hasattr2(&mp->m_sb) &&\n\t   (mp->m_flags & XFS_MOUNT_NOATTR2)) {\n\t\txfs_sb_version_removeattr2(&mp->m_sb);\n\t\tmp->m_update_sb = true;\n\n\t\t/* update sb_versionnum for the clearing of the morebits */\n\t\tif (!sbp->sb_features2)\n\t\t\tmp->m_update_sb = true;\n\t}\n\n\t/* always use v2 inodes by default now */\n\tif (!(mp->m_sb.sb_versionnum & XFS_SB_VERSION_NLINKBIT)) {\n\t\tmp->m_sb.sb_versionnum |= XFS_SB_VERSION_NLINKBIT;\n\t\tmp->m_update_sb = true;\n\t}\n\n\t/*\n\t * Check if sb_agblocks is aligned at stripe boundary\n\t * If sb_agblocks is NOT aligned turn off m_dalign since\n\t * allocator alignment is within an ag, therefore ag has\n\t * to be aligned at stripe boundary.\n\t */\n\terror = xfs_update_alignment(mp);\n\tif (error)\n\t\tgoto out;\n\n\txfs_alloc_compute_maxlevels(mp);\n\txfs_bmap_compute_maxlevels(mp, XFS_DATA_FORK);\n\txfs_bmap_compute_maxlevels(mp, XFS_ATTR_FORK);\n\txfs_ialloc_compute_maxlevels(mp);\n\n\txfs_set_maxicount(mp);\n\n\terror = xfs_sysfs_init(&mp->m_kobj, &xfs_mp_ktype, NULL, mp->m_fsname);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_uuid_mount(mp);\n\tif (error)\n\t\tgoto out_remove_sysfs;\n\n\t/*\n\t * Set the minimum read and write sizes\n\t */\n\txfs_set_rw_sizes(mp);\n\n\t/* set the low space thresholds for dynamic preallocation */\n\txfs_set_low_space_thresholds(mp);\n\n\t/*\n\t * Set the inode cluster size.\n\t * This may still be overridden by the file system\n\t * block size if it is larger than the chosen cluster size.\n\t *\n\t * For v5 filesystems, scale the cluster size with the inode size to\n\t * keep a constant ratio of inode per cluster buffer, but only if mkfs\n\t * has set the inode alignment value appropriately for larger cluster\n\t * sizes.\n\t */\n\tmp->m_inode_cluster_size = XFS_INODE_BIG_CLUSTER_SIZE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint\tnew_size = mp->m_inode_cluster_size;\n\n\t\tnew_size *= mp->m_sb.sb_inodesize / XFS_DINODE_MIN_SIZE;\n\t\tif (mp->m_sb.sb_inoalignmt >= XFS_B_TO_FSBT(mp, new_size))\n\t\t\tmp->m_inode_cluster_size = new_size;\n\t}\n\n\t/*\n\t * Set inode alignment fields\n\t */\n\txfs_set_inoalignment(mp);\n\n\t/*\n\t * Check that the data (and log if separate) is an ok size.\n\t */\n\terror = xfs_check_sizes(mp);\n\tif (error)\n\t\tgoto out_remove_uuid;\n\n\t/*\n\t * Initialize realtime fields in the mount structure\n\t */\n\terror = xfs_rtmount_init(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"RT mount failed\");\n\t\tgoto out_remove_uuid;\n\t}\n\n\t/*\n\t *  Copies the low order bits of the timestamp and the randomly\n\t *  set \"sequence\" number out of a UUID.\n\t */\n\tuuid_getnodeuniq(&sbp->sb_uuid, mp->m_fixedfsid);\n\n\tmp->m_dmevmask = 0;\t/* not persistent; set after each mount */\n\n\terror = xfs_da_mount(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"Failed dir/attr init: %d\", error);\n\t\tgoto out_remove_uuid;\n\t}\n\n\t/*\n\t * Initialize the precomputed transaction reservations values.\n\t */\n\txfs_trans_init(mp);\n\n\t/*\n\t * Allocate and initialize the per-ag data.\n\t */\n\tspin_lock_init(&mp->m_perag_lock);\n\tINIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);\n\terror = xfs_initialize_perag(mp, sbp->sb_agcount, &mp->m_maxagi);\n\tif (error) {\n\t\txfs_warn(mp, \"Failed per-ag init: %d\", error);\n\t\tgoto out_free_dir;\n\t}\n\n\tif (!sbp->sb_logblocks) {\n\t\txfs_warn(mp, \"no log defined\");\n\t\tXFS_ERROR_REPORT(\"xfs_mountfs\", XFS_ERRLEVEL_LOW, mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_free_perag;\n\t}\n\n\t/*\n\t * log's mount-time initialization. Perform 1st part recovery if needed\n\t */\n\terror = xfs_log_mount(mp, mp->m_logdev_targp,\n\t\t\t      XFS_FSB_TO_DADDR(mp, sbp->sb_logstart),\n\t\t\t      XFS_FSB_TO_BB(mp, sbp->sb_logblocks));\n\tif (error) {\n\t\txfs_warn(mp, \"log mount failed\");\n\t\tgoto out_fail_wait;\n\t}\n\n\t/*\n\t * Now the log is mounted, we know if it was an unclean shutdown or\n\t * not. If it was, with the first phase of recovery has completed, we\n\t * have consistent AG blocks on disk. We have not recovered EFIs yet,\n\t * but they are recovered transactionally in the second recovery phase\n\t * later.\n\t *\n\t * Hence we can safely re-initialise incore superblock counters from\n\t * the per-ag data. These may not be correct if the filesystem was not\n\t * cleanly unmounted, so we need to wait for recovery to finish before\n\t * doing this.\n\t *\n\t * If the filesystem was cleanly unmounted, then we can trust the\n\t * values in the superblock to be correct and we don't need to do\n\t * anything here.\n\t *\n\t * If we are currently making the filesystem, the initialisation will\n\t * fail as the perag data is in an undefined state.\n\t */\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    !XFS_LAST_UNMOUNT_WAS_CLEAN(mp) &&\n\t     !mp->m_sb.sb_inprogress) {\n\t\terror = xfs_initialize_perag_data(mp, sbp->sb_agcount);\n\t\tif (error)\n\t\t\tgoto out_log_dealloc;\n\t}\n\n\t/*\n\t * Get and sanity-check the root inode.\n\t * Save the pointer to it in the mount structure.\n\t */\n\terror = xfs_iget(mp, NULL, sbp->sb_rootino, 0, XFS_ILOCK_EXCL, &rip);\n\tif (error) {\n\t\txfs_warn(mp, \"failed to read root inode\");\n\t\tgoto out_log_dealloc;\n\t}\n\n\tASSERT(rip != NULL);\n\n\tif (unlikely(!S_ISDIR(rip->i_d.di_mode))) {\n\t\txfs_warn(mp, \"corrupted root inode %llu: not a directory\",\n\t\t\t(unsigned long long)rip->i_ino);\n\t\txfs_iunlock(rip, XFS_ILOCK_EXCL);\n\t\tXFS_ERROR_REPORT(\"xfs_mountfs_int(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_rele_rip;\n\t}\n\tmp->m_rootip = rip;\t/* save it */\n\n\txfs_iunlock(rip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Initialize realtime inode pointers in the mount structure\n\t */\n\terror = xfs_rtmount_inodes(mp);\n\tif (error) {\n\t\t/*\n\t\t * Free up the root inode.\n\t\t */\n\t\txfs_warn(mp, \"failed to read RT inodes\");\n\t\tgoto out_rele_rip;\n\t}\n\n\t/*\n\t * If this is a read-only mount defer the superblock updates until\n\t * the next remount into writeable mode.  Otherwise we would never\n\t * perform the update e.g. for the root filesystem.\n\t */\n\tif (mp->m_update_sb && !(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\terror = xfs_sync_sb(mp, false);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"failed to write sb changes\");\n\t\t\tgoto out_rtunmount;\n\t\t}\n\t}\n\n\t/*\n\t * Initialise the XFS quota management subsystem for this mount\n\t */\n\tif (XFS_IS_QUOTA_RUNNING(mp)) {\n\t\terror = xfs_qm_newmount(mp, &quotamount, &quotaflags);\n\t\tif (error)\n\t\t\tgoto out_rtunmount;\n\t} else {\n\t\tASSERT(!XFS_IS_QUOTA_ON(mp));\n\n\t\t/*\n\t\t * If a file system had quotas running earlier, but decided to\n\t\t * mount without -o uquota/pquota/gquota options, revoke the\n\t\t * quotachecked license.\n\t\t */\n\t\tif (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_ACCT) {\n\t\t\txfs_notice(mp, \"resetting quota flags\");\n\t\t\terror = xfs_mount_reset_sbqflags(mp);\n\t\t\tif (error)\n\t\t\t\tgoto out_rtunmount;\n\t\t}\n\t}\n\n\t/*\n\t * Finish recovering the file system.  This part needed to be\n\t * delayed until after the root and real-time bitmap inodes\n\t * were consistently read in.\n\t */\n\terror = xfs_log_mount_finish(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"log mount finish failed\");\n\t\tgoto out_rtunmount;\n\t}\n\n\t/*\n\t * Complete the quota initialisation, post-log-replay component.\n\t */\n\tif (quotamount) {\n\t\tASSERT(mp->m_qflags == 0);\n\t\tmp->m_qflags = quotaflags;\n\n\t\txfs_qm_mount_quotas(mp);\n\t}\n\n\t/*\n\t * Now we are mounted, reserve a small amount of unused space for\n\t * privileged transactions. This is needed so that transaction\n\t * space required for critical operations can dip into this pool\n\t * when at ENOSPC. This is needed for operations like create with\n\t * attr, unwritten extent conversion at ENOSPC, etc. Data allocations\n\t * are not allowed to use this reserved space.\n\t *\n\t * This may drive us straight to ENOSPC on mount, but that implies\n\t * we were already there on the last unmount. Warn if this occurs.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\tresblks = xfs_default_resblks(mp);\n\t\terror = xfs_reserve_blocks(mp, &resblks, NULL);\n\t\tif (error)\n\t\t\txfs_warn(mp,\n\t\"Unable to allocate reserve blocks. Continuing without reserve pool.\");\n\t}\n\n\treturn 0;\n\n out_rtunmount:\n\txfs_rtunmount_inodes(mp);\n out_rele_rip:\n\tIRELE(rip);\n out_log_dealloc:\n\txfs_log_unmount(mp);\n out_fail_wait:\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp)\n\t\txfs_wait_buftarg(mp->m_logdev_targp);\n\txfs_wait_buftarg(mp->m_ddev_targp);\n out_free_perag:\n\txfs_free_perag(mp);\n out_free_dir:\n\txfs_da_unmount(mp);\n out_remove_uuid:\n\txfs_uuid_unmount(mp);\n out_remove_sysfs:\n\txfs_sysfs_del(&mp->m_kobj);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_SB_VERSION_NUM",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_posix_acl_flag",
          "args": [
            "sb"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_max_file_offset",
          "args": [
            "sb->s_blocksize_bits"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_max_file_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "561-593",
          "snippet": "__uint64_t\nxfs_max_file_offset(\n\tunsigned int\t\tblockshift)\n{\n\tunsigned int\t\tpagefactor = 1;\n\tunsigned int\t\tbitshift = BITS_PER_LONG - 1;\n\n\t/* Figure out maximum filesize, on Linux this can depend on\n\t * the filesystem blocksize (on 32 bit platforms).\n\t * __block_write_begin does this in an [unsigned] long...\n\t *      page->index << (PAGE_CACHE_SHIFT - bbits)\n\t * So, for page sized blocks (4K on 32 bit platforms),\n\t * this wraps at around 8Tb (hence MAX_LFS_FILESIZE which is\n\t *      (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)\n\t * but for smaller blocksizes it is less (bbits = log2 bsize).\n\t * Note1: get_block_t takes a long (implicit cast from above)\n\t * Note2: The Large Block Device (LBD and HAVE_SECTOR_T) patch\n\t * can optionally convert the [unsigned] long from above into\n\t * an [unsigned] long long.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tASSERT(sizeof(sector_t) == 8);\n\tpagefactor = PAGE_CACHE_SIZE;\n\tbitshift = BITS_PER_LONG;\n# else\n\tpagefactor = PAGE_CACHE_SIZE >> (PAGE_CACHE_SHIFT - blockshift);\n# endif\n#endif\n\n\treturn (((__uint64_t)pagefactor) << bitshift) - 1;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n__uint64_t\nxfs_max_file_offset(\n\tunsigned int\t\tblockshift)\n{\n\tunsigned int\t\tpagefactor = 1;\n\tunsigned int\t\tbitshift = BITS_PER_LONG - 1;\n\n\t/* Figure out maximum filesize, on Linux this can depend on\n\t * the filesystem blocksize (on 32 bit platforms).\n\t * __block_write_begin does this in an [unsigned] long...\n\t *      page->index << (PAGE_CACHE_SHIFT - bbits)\n\t * So, for page sized blocks (4K on 32 bit platforms),\n\t * this wraps at around 8Tb (hence MAX_LFS_FILESIZE which is\n\t *      (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)\n\t * but for smaller blocksizes it is less (bbits = log2 bsize).\n\t * Note1: get_block_t takes a long (implicit cast from above)\n\t * Note2: The Large Block Device (LBD and HAVE_SECTOR_T) patch\n\t * can optionally convert the [unsigned] long from above into\n\t * an [unsigned] long long.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tASSERT(sizeof(sector_t) == 8);\n\tpagefactor = PAGE_CACHE_SIZE;\n\tbitshift = BITS_PER_LONG;\n# else\n\tpagefactor = PAGE_CACHE_SIZE >> (PAGE_CACHE_SHIFT - blockshift);\n# endif\n#endif\n\n\treturn (((__uint64_t)pagefactor) << bitshift) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_filestream_mount",
          "args": [
            "mp"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "411-424",
          "snippet": "int\nxfs_filestream_mount(\n\txfs_mount_t\t*mp)\n{\n\t/*\n\t * The filestream timer tunable is currently fixed within the range of\n\t * one second to four minutes, with five seconds being the default.  The\n\t * group count is somewhat arbitrary, but it'd be nice to adhere to the\n\t * timer tunable to within about 10 percent.  This requires at least 10\n\t * groups.\n\t */\n\treturn xfs_mru_cache_create(&mp->m_filestream, xfs_fstrm_centisecs * 10,\n\t\t\t\t    10, xfs_fstrm_free_func);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_filestream_mount(\n\txfs_mount_t\t*mp)\n{\n\t/*\n\t * The filestream timer tunable is currently fixed within the range of\n\t * one second to four minutes, with five seconds being the default.  The\n\t * group count is somewhat arbitrary, but it'd be nice to adhere to the\n\t * timer tunable to within about 10 percent.  This requires at least 10\n\t * groups.\n\t */\n\treturn xfs_mru_cache_create(&mp->m_filestream, xfs_fstrm_centisecs * 10,\n\t\t\t\t    10, xfs_fstrm_free_func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_setup_devices",
          "args": [
            "mp"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setup_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "807-835",
          "snippet": "STATIC int\nxfs_setup_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror;\n\n\terror = xfs_setsize_buftarg(mp->m_ddev_targp, mp->m_sb.sb_sectsize);\n\tif (error)\n\t\treturn error;\n\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\tunsigned int\tlog_sector_size = BBSIZE;\n\n\t\tif (xfs_sb_version_hassector(&mp->m_sb))\n\t\t\tlog_sector_size = mp->m_sb.sb_logsectsize;\n\t\terror = xfs_setsize_buftarg(mp->m_logdev_targp,\n\t\t\t\t\t    log_sector_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (mp->m_rtdev_targp) {\n\t\terror = xfs_setsize_buftarg(mp->m_rtdev_targp,\n\t\t\t\t\t    mp->m_sb.sb_sectsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_setup_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror;\n\n\terror = xfs_setsize_buftarg(mp->m_ddev_targp, mp->m_sb.sb_sectsize);\n\tif (error)\n\t\treturn error;\n\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\tunsigned int\tlog_sector_size = BBSIZE;\n\n\t\tif (xfs_sb_version_hassector(&mp->m_sb))\n\t\t\tlog_sector_size = mp->m_sb.sb_logsectsize;\n\t\terror = xfs_setsize_buftarg(mp->m_logdev_targp,\n\t\t\t\t\t    log_sector_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (mp->m_rtdev_targp) {\n\t\terror = xfs_setsize_buftarg(mp->m_rtdev_targp,\n\t\t\t\t\t    mp->m_sb.sb_sectsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_finish_flags",
          "args": [
            "mp"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_finish_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1339-1402",
          "snippet": "STATIC int\nxfs_finish_flags(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\tronly = (mp->m_flags & XFS_MOUNT_RDONLY);\n\n\t/* Fail a mount where the logbuf is smaller than the log stripe */\n\tif (xfs_sb_version_haslogv2(&mp->m_sb)) {\n\t\tif (mp->m_logbsize <= 0 &&\n\t\t    mp->m_sb.sb_logsunit > XLOG_BIG_RECORD_BSIZE) {\n\t\t\tmp->m_logbsize = mp->m_sb.sb_logsunit;\n\t\t} else if (mp->m_logbsize > 0 &&\n\t\t\t   mp->m_logbsize < mp->m_sb.sb_logsunit) {\n\t\t\txfs_warn(mp,\n\t\t\"logbuf size must be greater than or equal to log stripe size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t/* Fail a mount if the logbuf is larger than 32K */\n\t\tif (mp->m_logbsize > XLOG_BIG_RECORD_BSIZE) {\n\t\t\txfs_warn(mp,\n\t\t\"logbuf size for version 1 logs must be 16K or 32K\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * V5 filesystems always use attr2 format for attributes.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    (mp->m_flags & XFS_MOUNT_NOATTR2)) {\n\t\txfs_warn(mp,\n\"Cannot mount a V5 filesystem as %s. %s is always enabled for V5 filesystems.\",\n\t\t\tMNTOPT_NOATTR2, MNTOPT_ATTR2);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * mkfs'ed attr2 will turn on attr2 mount unless explicitly\n\t * told by noattr2 to turn it off\n\t */\n\tif (xfs_sb_version_hasattr2(&mp->m_sb) &&\n\t    !(mp->m_flags & XFS_MOUNT_NOATTR2))\n\t\tmp->m_flags |= XFS_MOUNT_ATTR2;\n\n\t/*\n\t * prohibit r/w mounts of read-only filesystems\n\t */\n\tif ((mp->m_sb.sb_flags & XFS_SBF_READONLY) && !ronly) {\n\t\txfs_warn(mp,\n\t\t\t\"cannot mount a read-only filesystem as read-write\");\n\t\treturn -EROFS;\n\t}\n\n\tif ((mp->m_qflags & (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE)) &&\n\t    (mp->m_qflags & (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE)) &&\n\t    !xfs_sb_version_has_pquotino(&mp->m_sb)) {\n\t\txfs_warn(mp,\n\t\t  \"Super block does not support project and group quota together\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define MNTOPT_NOATTR2\t\"noattr2\"\t/* do not use attr2 attribute format */",
            "#define MNTOPT_ATTR2\t\"attr2\"\t\t/* do use attr2 attribute format */"
          ],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n#define MNTOPT_NOATTR2\t\"noattr2\"\t/* do not use attr2 attribute format */\n#define MNTOPT_ATTR2\t\"attr2\"\t\t/* do use attr2 attribute format */\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_finish_flags(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\tronly = (mp->m_flags & XFS_MOUNT_RDONLY);\n\n\t/* Fail a mount where the logbuf is smaller than the log stripe */\n\tif (xfs_sb_version_haslogv2(&mp->m_sb)) {\n\t\tif (mp->m_logbsize <= 0 &&\n\t\t    mp->m_sb.sb_logsunit > XLOG_BIG_RECORD_BSIZE) {\n\t\t\tmp->m_logbsize = mp->m_sb.sb_logsunit;\n\t\t} else if (mp->m_logbsize > 0 &&\n\t\t\t   mp->m_logbsize < mp->m_sb.sb_logsunit) {\n\t\t\txfs_warn(mp,\n\t\t\"logbuf size must be greater than or equal to log stripe size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t/* Fail a mount if the logbuf is larger than 32K */\n\t\tif (mp->m_logbsize > XLOG_BIG_RECORD_BSIZE) {\n\t\t\txfs_warn(mp,\n\t\t\"logbuf size for version 1 logs must be 16K or 32K\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * V5 filesystems always use attr2 format for attributes.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    (mp->m_flags & XFS_MOUNT_NOATTR2)) {\n\t\txfs_warn(mp,\n\"Cannot mount a V5 filesystem as %s. %s is always enabled for V5 filesystems.\",\n\t\t\tMNTOPT_NOATTR2, MNTOPT_ATTR2);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * mkfs'ed attr2 will turn on attr2 mount unless explicitly\n\t * told by noattr2 to turn it off\n\t */\n\tif (xfs_sb_version_hasattr2(&mp->m_sb) &&\n\t    !(mp->m_flags & XFS_MOUNT_NOATTR2))\n\t\tmp->m_flags |= XFS_MOUNT_ATTR2;\n\n\t/*\n\t * prohibit r/w mounts of read-only filesystems\n\t */\n\tif ((mp->m_sb.sb_flags & XFS_SBF_READONLY) && !ronly) {\n\t\txfs_warn(mp,\n\t\t\t\"cannot mount a read-only filesystem as read-write\");\n\t\treturn -EROFS;\n\t}\n\n\tif ((mp->m_qflags & (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE)) &&\n\t    (mp->m_qflags & (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE)) &&\n\t    !xfs_sb_version_has_pquotino(&mp->m_sb)) {\n\t\txfs_warn(mp,\n\t\t  \"Super block does not support project and group quota together\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_readsb",
          "args": [
            "mp",
            "flags"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_readsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "270-363",
          "snippet": "int\nxfs_readsb(\n\tstruct xfs_mount *mp,\n\tint\t\tflags)\n{\n\tunsigned int\tsector_size;\n\tstruct xfs_buf\t*bp;\n\tstruct xfs_sb\t*sbp = &mp->m_sb;\n\tint\t\terror;\n\tint\t\tloud = !(flags & XFS_MFSI_QUIET);\n\tconst struct xfs_buf_ops *buf_ops;\n\n\tASSERT(mp->m_sb_bp == NULL);\n\tASSERT(mp->m_ddev_targp != NULL);\n\n\t/*\n\t * For the initial read, we must guess at the sector\n\t * size based on the block device.  It's enough to\n\t * get the sb_sectsize out of the superblock and\n\t * then reread with the proper length.\n\t * We don't verify it yet, because it may not be complete.\n\t */\n\tsector_size = xfs_getsize_buftarg(mp->m_ddev_targp);\n\tbuf_ops = NULL;\n\n\t/*\n\t * Allocate a (locked) buffer to hold the superblock.\n\t * This will be kept around at all times to optimize\n\t * access to the superblock.\n\t */\nreread:\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp, XFS_SB_DADDR,\n\t\t\t\t   BTOBB(sector_size), 0, &bp, buf_ops);\n\tif (error) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"SB validate failed with error %d.\", error);\n\t\t/* bad CRC means corrupted metadata */\n\t\tif (error == -EFSBADCRC)\n\t\t\terror = -EFSCORRUPTED;\n\t\treturn error;\n\t}\n\n\t/*\n\t * Initialize the mount structure from the superblock.\n\t */\n\txfs_sb_from_disk(sbp, XFS_BUF_TO_SBP(bp));\n\n\t/*\n\t * If we haven't validated the superblock, do so now before we try\n\t * to check the sector size and reread the superblock appropriately.\n\t */\n\tif (sbp->sb_magicnum != XFS_SB_MAGIC) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"Invalid superblock magic number\");\n\t\terror = -EINVAL;\n\t\tgoto release_buf;\n\t}\n\n\t/*\n\t * We must be able to do sector-sized and sector-aligned IO.\n\t */\n\tif (sector_size > sbp->sb_sectsize) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"device supports %u byte sectors (not %u)\",\n\t\t\t\tsector_size, sbp->sb_sectsize);\n\t\terror = -ENOSYS;\n\t\tgoto release_buf;\n\t}\n\n\tif (buf_ops == NULL) {\n\t\t/*\n\t\t * Re-read the superblock so the buffer is correctly sized,\n\t\t * and properly verified.\n\t\t */\n\t\txfs_buf_relse(bp);\n\t\tsector_size = sbp->sb_sectsize;\n\t\tbuf_ops = loud ? &xfs_sb_buf_ops : &xfs_sb_quiet_buf_ops;\n\t\tgoto reread;\n\t}\n\n\t/* Initialize per-cpu counters */\n\txfs_icsb_reinit_counters(mp);\n\n\t/* no need to be quiet anymore, so reset the buf ops */\n\tbp->b_ops = &xfs_sb_buf_ops;\n\n\tmp->m_sb_bp = bp;\n\txfs_buf_unlock(bp);\n\treturn 0;\n\nrelease_buf:\n\txfs_buf_relse(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_readsb(\n\tstruct xfs_mount *mp,\n\tint\t\tflags)\n{\n\tunsigned int\tsector_size;\n\tstruct xfs_buf\t*bp;\n\tstruct xfs_sb\t*sbp = &mp->m_sb;\n\tint\t\terror;\n\tint\t\tloud = !(flags & XFS_MFSI_QUIET);\n\tconst struct xfs_buf_ops *buf_ops;\n\n\tASSERT(mp->m_sb_bp == NULL);\n\tASSERT(mp->m_ddev_targp != NULL);\n\n\t/*\n\t * For the initial read, we must guess at the sector\n\t * size based on the block device.  It's enough to\n\t * get the sb_sectsize out of the superblock and\n\t * then reread with the proper length.\n\t * We don't verify it yet, because it may not be complete.\n\t */\n\tsector_size = xfs_getsize_buftarg(mp->m_ddev_targp);\n\tbuf_ops = NULL;\n\n\t/*\n\t * Allocate a (locked) buffer to hold the superblock.\n\t * This will be kept around at all times to optimize\n\t * access to the superblock.\n\t */\nreread:\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp, XFS_SB_DADDR,\n\t\t\t\t   BTOBB(sector_size), 0, &bp, buf_ops);\n\tif (error) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"SB validate failed with error %d.\", error);\n\t\t/* bad CRC means corrupted metadata */\n\t\tif (error == -EFSBADCRC)\n\t\t\terror = -EFSCORRUPTED;\n\t\treturn error;\n\t}\n\n\t/*\n\t * Initialize the mount structure from the superblock.\n\t */\n\txfs_sb_from_disk(sbp, XFS_BUF_TO_SBP(bp));\n\n\t/*\n\t * If we haven't validated the superblock, do so now before we try\n\t * to check the sector size and reread the superblock appropriately.\n\t */\n\tif (sbp->sb_magicnum != XFS_SB_MAGIC) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"Invalid superblock magic number\");\n\t\terror = -EINVAL;\n\t\tgoto release_buf;\n\t}\n\n\t/*\n\t * We must be able to do sector-sized and sector-aligned IO.\n\t */\n\tif (sector_size > sbp->sb_sectsize) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"device supports %u byte sectors (not %u)\",\n\t\t\t\tsector_size, sbp->sb_sectsize);\n\t\terror = -ENOSYS;\n\t\tgoto release_buf;\n\t}\n\n\tif (buf_ops == NULL) {\n\t\t/*\n\t\t * Re-read the superblock so the buffer is correctly sized,\n\t\t * and properly verified.\n\t\t */\n\t\txfs_buf_relse(bp);\n\t\tsector_size = sbp->sb_sectsize;\n\t\tbuf_ops = loud ? &xfs_sb_buf_ops : &xfs_sb_quiet_buf_ops;\n\t\tgoto reread;\n\t}\n\n\t/* Initialize per-cpu counters */\n\txfs_icsb_reinit_counters(mp);\n\n\t/* no need to be quiet anymore, so reset the buf ops */\n\tbp->b_ops = &xfs_sb_buf_ops;\n\n\tmp->m_sb_bp = bp;\n\txfs_buf_unlock(bp);\n\treturn 0;\n\nrelease_buf:\n\txfs_buf_relse(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_init_counters",
          "args": [
            "mp"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_init_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1529-1560",
          "snippet": "int\nxfs_icsb_init_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tmp->m_sb_cnts = alloc_percpu(xfs_icsb_cnts_t);\n\tif (mp->m_sb_cnts == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tmemset(cntp, 0, sizeof(xfs_icsb_cnts_t));\n\t}\n\n\tmutex_init(&mp->m_icsb_mutex);\n\n\t/*\n\t * start with all counters disabled so that the\n\t * initial balance kicks us off correctly\n\t */\n\tmp->m_icsb_counters = -1;\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tmp->m_icsb_notifier.notifier_call = xfs_icsb_cpu_notify;\n\tmp->m_icsb_notifier.priority = 0;\n\tregister_hotcpu_notifier(&mp->m_icsb_notifier);\n#endif /* CONFIG_HOTPLUG_CPU */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icsb_init_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tmp->m_sb_cnts = alloc_percpu(xfs_icsb_cnts_t);\n\tif (mp->m_sb_cnts == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tmemset(cntp, 0, sizeof(xfs_icsb_cnts_t));\n\t}\n\n\tmutex_init(&mp->m_icsb_mutex);\n\n\t/*\n\t * start with all counters disabled so that the\n\t * initial balance kicks us off correctly\n\t */\n\tmp->m_icsb_counters = -1;\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tmp->m_icsb_notifier.notifier_call = xfs_icsb_cpu_notify;\n\tmp->m_icsb_notifier.priority = 0;\n\tregister_hotcpu_notifier(&mp->m_icsb_notifier);\n#endif /* CONFIG_HOTPLUG_CPU */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_init_mount_workqueues",
          "args": [
            "mp"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_init_mount_workqueues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "837-892",
          "snippet": "STATIC int\nxfs_init_mount_workqueues(\n\tstruct xfs_mount\t*mp)\n{\n\tmp->m_buf_workqueue = alloc_workqueue(\"xfs-buf/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 1, mp->m_fsname);\n\tif (!mp->m_buf_workqueue)\n\t\tgoto out;\n\n\tmp->m_data_workqueue = alloc_workqueue(\"xfs-data/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_data_workqueue)\n\t\tgoto out_destroy_buf;\n\n\tmp->m_unwritten_workqueue = alloc_workqueue(\"xfs-conv/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_unwritten_workqueue)\n\t\tgoto out_destroy_data_iodone_queue;\n\n\tmp->m_cil_workqueue = alloc_workqueue(\"xfs-cil/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_cil_workqueue)\n\t\tgoto out_destroy_unwritten;\n\n\tmp->m_reclaim_workqueue = alloc_workqueue(\"xfs-reclaim/%s\",\n\t\t\tWQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_reclaim_workqueue)\n\t\tgoto out_destroy_cil;\n\n\tmp->m_log_workqueue = alloc_workqueue(\"xfs-log/%s\",\n\t\t\tWQ_FREEZABLE|WQ_HIGHPRI, 0, mp->m_fsname);\n\tif (!mp->m_log_workqueue)\n\t\tgoto out_destroy_reclaim;\n\n\tmp->m_eofblocks_workqueue = alloc_workqueue(\"xfs-eofblocks/%s\",\n\t\t\tWQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_eofblocks_workqueue)\n\t\tgoto out_destroy_log;\n\n\treturn 0;\n\nout_destroy_log:\n\tdestroy_workqueue(mp->m_log_workqueue);\nout_destroy_reclaim:\n\tdestroy_workqueue(mp->m_reclaim_workqueue);\nout_destroy_cil:\n\tdestroy_workqueue(mp->m_cil_workqueue);\nout_destroy_unwritten:\n\tdestroy_workqueue(mp->m_unwritten_workqueue);\nout_destroy_data_iodone_queue:\n\tdestroy_workqueue(mp->m_data_workqueue);\nout_destroy_buf:\n\tdestroy_workqueue(mp->m_buf_workqueue);\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_init_mount_workqueues(\n\tstruct xfs_mount\t*mp)\n{\n\tmp->m_buf_workqueue = alloc_workqueue(\"xfs-buf/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 1, mp->m_fsname);\n\tif (!mp->m_buf_workqueue)\n\t\tgoto out;\n\n\tmp->m_data_workqueue = alloc_workqueue(\"xfs-data/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_data_workqueue)\n\t\tgoto out_destroy_buf;\n\n\tmp->m_unwritten_workqueue = alloc_workqueue(\"xfs-conv/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_unwritten_workqueue)\n\t\tgoto out_destroy_data_iodone_queue;\n\n\tmp->m_cil_workqueue = alloc_workqueue(\"xfs-cil/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_cil_workqueue)\n\t\tgoto out_destroy_unwritten;\n\n\tmp->m_reclaim_workqueue = alloc_workqueue(\"xfs-reclaim/%s\",\n\t\t\tWQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_reclaim_workqueue)\n\t\tgoto out_destroy_cil;\n\n\tmp->m_log_workqueue = alloc_workqueue(\"xfs-log/%s\",\n\t\t\tWQ_FREEZABLE|WQ_HIGHPRI, 0, mp->m_fsname);\n\tif (!mp->m_log_workqueue)\n\t\tgoto out_destroy_reclaim;\n\n\tmp->m_eofblocks_workqueue = alloc_workqueue(\"xfs-eofblocks/%s\",\n\t\t\tWQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_eofblocks_workqueue)\n\t\tgoto out_destroy_log;\n\n\treturn 0;\n\nout_destroy_log:\n\tdestroy_workqueue(mp->m_log_workqueue);\nout_destroy_reclaim:\n\tdestroy_workqueue(mp->m_reclaim_workqueue);\nout_destroy_cil:\n\tdestroy_workqueue(mp->m_cil_workqueue);\nout_destroy_unwritten:\n\tdestroy_workqueue(mp->m_unwritten_workqueue);\nout_destroy_data_iodone_queue:\n\tdestroy_workqueue(mp->m_data_workqueue);\nout_destroy_buf:\n\tdestroy_workqueue(mp->m_buf_workqueue);\nout:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_open_devices",
          "args": [
            "mp"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_open_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "736-802",
          "snippet": "STATIC int\nxfs_open_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct block_device\t*ddev = mp->m_super->s_bdev;\n\tstruct block_device\t*logdev = NULL, *rtdev = NULL;\n\tint\t\t\terror;\n\n\t/*\n\t * Open real time and log devices - order is important.\n\t */\n\tif (mp->m_logname) {\n\t\terror = xfs_blkdev_get(mp, mp->m_logname, &logdev);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (mp->m_rtname) {\n\t\terror = xfs_blkdev_get(mp, mp->m_rtname, &rtdev);\n\t\tif (error)\n\t\t\tgoto out_close_logdev;\n\n\t\tif (rtdev == ddev || rtdev == logdev) {\n\t\t\txfs_warn(mp,\n\t\"Cannot mount filesystem with identical rtdev and ddev/logdev.\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_close_rtdev;\n\t\t}\n\t}\n\n\t/*\n\t * Setup xfs_mount buffer target pointers\n\t */\n\terror = -ENOMEM;\n\tmp->m_ddev_targp = xfs_alloc_buftarg(mp, ddev);\n\tif (!mp->m_ddev_targp)\n\t\tgoto out_close_rtdev;\n\n\tif (rtdev) {\n\t\tmp->m_rtdev_targp = xfs_alloc_buftarg(mp, rtdev);\n\t\tif (!mp->m_rtdev_targp)\n\t\t\tgoto out_free_ddev_targ;\n\t}\n\n\tif (logdev && logdev != ddev) {\n\t\tmp->m_logdev_targp = xfs_alloc_buftarg(mp, logdev);\n\t\tif (!mp->m_logdev_targp)\n\t\t\tgoto out_free_rtdev_targ;\n\t} else {\n\t\tmp->m_logdev_targp = mp->m_ddev_targp;\n\t}\n\n\treturn 0;\n\n out_free_rtdev_targ:\n\tif (mp->m_rtdev_targp)\n\t\txfs_free_buftarg(mp, mp->m_rtdev_targp);\n out_free_ddev_targ:\n\txfs_free_buftarg(mp, mp->m_ddev_targp);\n out_close_rtdev:\n\txfs_blkdev_put(rtdev);\n out_close_logdev:\n\tif (logdev && logdev != ddev)\n\t\txfs_blkdev_put(logdev);\n out:\n\treturn error;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_open_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct block_device\t*ddev = mp->m_super->s_bdev;\n\tstruct block_device\t*logdev = NULL, *rtdev = NULL;\n\tint\t\t\terror;\n\n\t/*\n\t * Open real time and log devices - order is important.\n\t */\n\tif (mp->m_logname) {\n\t\terror = xfs_blkdev_get(mp, mp->m_logname, &logdev);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (mp->m_rtname) {\n\t\terror = xfs_blkdev_get(mp, mp->m_rtname, &rtdev);\n\t\tif (error)\n\t\t\tgoto out_close_logdev;\n\n\t\tif (rtdev == ddev || rtdev == logdev) {\n\t\t\txfs_warn(mp,\n\t\"Cannot mount filesystem with identical rtdev and ddev/logdev.\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_close_rtdev;\n\t\t}\n\t}\n\n\t/*\n\t * Setup xfs_mount buffer target pointers\n\t */\n\terror = -ENOMEM;\n\tmp->m_ddev_targp = xfs_alloc_buftarg(mp, ddev);\n\tif (!mp->m_ddev_targp)\n\t\tgoto out_close_rtdev;\n\n\tif (rtdev) {\n\t\tmp->m_rtdev_targp = xfs_alloc_buftarg(mp, rtdev);\n\t\tif (!mp->m_rtdev_targp)\n\t\t\tgoto out_free_ddev_targ;\n\t}\n\n\tif (logdev && logdev != ddev) {\n\t\tmp->m_logdev_targp = xfs_alloc_buftarg(mp, logdev);\n\t\tif (!mp->m_logdev_targp)\n\t\t\tgoto out_free_rtdev_targ;\n\t} else {\n\t\tmp->m_logdev_targp = mp->m_ddev_targp;\n\t}\n\n\treturn 0;\n\n out_free_rtdev_targ:\n\tif (mp->m_rtdev_targp)\n\t\txfs_free_buftarg(mp, mp->m_rtdev_targp);\n out_free_ddev_targ:\n\txfs_free_buftarg(mp, mp->m_ddev_targp);\n out_close_rtdev:\n\txfs_blkdev_put(rtdev);\n out_close_logdev:\n\tif (logdev && logdev != ddev)\n\t\txfs_blkdev_put(logdev);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sb",
            "BBSIZE"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_parseargs",
          "args": [
            "mp",
            "(char *)data"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_parseargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "173-472",
          "snippet": "STATIC int\nxfs_parseargs(\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t*options)\n{\n\tstruct super_block\t*sb = mp->m_super;\n\tchar\t\t\t*this_char, *value;\n\tint\t\t\tdsunit = 0;\n\tint\t\t\tdswidth = 0;\n\tint\t\t\tiosize = 0;\n\t__uint8_t\t\tiosizelog = 0;\n\n\t/*\n\t * set up the mount name first so all the errors will refer to the\n\t * correct device.\n\t */\n\tmp->m_fsname = kstrndup(sb->s_id, MAXNAMELEN, GFP_KERNEL);\n\tif (!mp->m_fsname)\n\t\treturn -ENOMEM;\n\tmp->m_fsname_len = strlen(mp->m_fsname) + 1;\n\n\t/*\n\t * Copy binary VFS mount flags we are interested in.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\tmp->m_flags |= XFS_MOUNT_RDONLY;\n\tif (sb->s_flags & MS_DIRSYNC)\n\t\tmp->m_flags |= XFS_MOUNT_DIRSYNC;\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tmp->m_flags |= XFS_MOUNT_WSYNC;\n\n\t/*\n\t * Set some default flags that could be cleared by the mount option\n\t * parsing.\n\t */\n\tmp->m_flags |= XFS_MOUNT_BARRIER;\n\tmp->m_flags |= XFS_MOUNT_COMPAT_IOSIZE;\n\n\t/*\n\t * These can be overridden by the mount option parsing.\n\t */\n\tmp->m_logbufs = -1;\n\tmp->m_logbsize = -1;\n\n\tif (!options)\n\t\tgoto done;\n\n\twhile ((this_char = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_char)\n\t\t\tcontinue;\n\t\tif ((value = strchr(this_char, '=')) != NULL)\n\t\t\t*value++ = 0;\n\n\t\tif (!strcmp(this_char, MNTOPT_LOGBUFS)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &mp->m_logbufs))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_LOGBSIZE)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (suffix_kstrtoint(value, 10, &mp->m_logbsize))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_LOGDEV)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmp->m_logname = kstrndup(value, MAXNAMELEN, GFP_KERNEL);\n\t\t\tif (!mp->m_logname)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!strcmp(this_char, MNTOPT_MTPT)) {\n\t\t\txfs_warn(mp, \"%s option not allowed on this system\",\n\t\t\t\tthis_char);\n\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_RTDEV)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmp->m_rtname = kstrndup(value, MAXNAMELEN, GFP_KERNEL);\n\t\t\tif (!mp->m_rtname)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!strcmp(this_char, MNTOPT_BIOSIZE)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &iosize))\n\t\t\t\treturn -EINVAL;\n\t\t\tiosizelog = ffs(iosize) - 1;\n\t\t} else if (!strcmp(this_char, MNTOPT_ALLOCSIZE)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (suffix_kstrtoint(value, 10, &iosize))\n\t\t\t\treturn -EINVAL;\n\t\t\tiosizelog = ffs(iosize) - 1;\n\t\t} else if (!strcmp(this_char, MNTOPT_GRPID) ||\n\t\t\t   !strcmp(this_char, MNTOPT_BSDGROUPS)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_GRPID;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOGRPID) ||\n\t\t\t   !strcmp(this_char, MNTOPT_SYSVGROUPS)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_GRPID;\n\t\t} else if (!strcmp(this_char, MNTOPT_WSYNC)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_WSYNC;\n\t\t} else if (!strcmp(this_char, MNTOPT_NORECOVERY)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_NORECOVERY;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOALIGN)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_NOALIGN;\n\t\t} else if (!strcmp(this_char, MNTOPT_SWALLOC)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_SWALLOC;\n\t\t} else if (!strcmp(this_char, MNTOPT_SUNIT)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &dsunit))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_SWIDTH)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &dswidth))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_32BITINODE)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_SMALL_INUMS;\n\t\t} else if (!strcmp(this_char, MNTOPT_64BITINODE)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOUUID)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_NOUUID;\n\t\t} else if (!strcmp(this_char, MNTOPT_BARRIER)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_BARRIER;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOBARRIER)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_BARRIER;\n\t\t} else if (!strcmp(this_char, MNTOPT_IKEEP)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_IKEEP;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOIKEEP)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_IKEEP;\n\t\t} else if (!strcmp(this_char, MNTOPT_LARGEIO)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_COMPAT_IOSIZE;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOLARGEIO)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_COMPAT_IOSIZE;\n\t\t} else if (!strcmp(this_char, MNTOPT_ATTR2)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_ATTR2;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOATTR2)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_ATTR2;\n\t\t\tmp->m_flags |= XFS_MOUNT_NOATTR2;\n\t\t} else if (!strcmp(this_char, MNTOPT_FILESTREAM)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_FILESTREAMS;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOQUOTA)) {\n\t\t\tmp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;\n\t\t\tmp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;\n\t\t\tmp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;\n\t\t} else if (!strcmp(this_char, MNTOPT_QUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_UQUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_USRQUOTA)) {\n\t\t\tmp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |\n\t\t\t\t\t XFS_UQUOTA_ENFD);\n\t\t} else if (!strcmp(this_char, MNTOPT_QUOTANOENF) ||\n\t\t\t   !strcmp(this_char, MNTOPT_UQUOTANOENF)) {\n\t\t\tmp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);\n\t\t\tmp->m_qflags &= ~XFS_UQUOTA_ENFD;\n\t\t} else if (!strcmp(this_char, MNTOPT_PQUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_PRJQUOTA)) {\n\t\t\tmp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |\n\t\t\t\t\t XFS_PQUOTA_ENFD);\n\t\t} else if (!strcmp(this_char, MNTOPT_PQUOTANOENF)) {\n\t\t\tmp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);\n\t\t\tmp->m_qflags &= ~XFS_PQUOTA_ENFD;\n\t\t} else if (!strcmp(this_char, MNTOPT_GQUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_GRPQUOTA)) {\n\t\t\tmp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |\n\t\t\t\t\t XFS_GQUOTA_ENFD);\n\t\t} else if (!strcmp(this_char, MNTOPT_GQUOTANOENF)) {\n\t\t\tmp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);\n\t\t\tmp->m_qflags &= ~XFS_GQUOTA_ENFD;\n\t\t} else if (!strcmp(this_char, MNTOPT_DELAYLOG)) {\n\t\t\txfs_warn(mp,\n\t\"delaylog is the default now, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, MNTOPT_NODELAYLOG)) {\n\t\t\txfs_warn(mp,\n\t\"nodelaylog support has been removed, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, MNTOPT_DISCARD)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_DISCARD;\n\t\t} else if (!strcmp(this_char, MNTOPT_NODISCARD)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_DISCARD;\n\t\t} else if (!strcmp(this_char, \"ihashsize\")) {\n\t\t\txfs_warn(mp,\n\t\"ihashsize no longer used, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, \"osyncisdsync\")) {\n\t\t\txfs_warn(mp,\n\t\"osyncisdsync has no effect, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, \"osyncisosync\")) {\n\t\t\txfs_warn(mp,\n\t\"osyncisosync has no effect, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, \"irixsgid\")) {\n\t\t\txfs_warn(mp,\n\t\"irixsgid is now a sysctl(2) variable, option is deprecated.\");\n\t\t} else {\n\t\t\txfs_warn(mp, \"unknown mount option [%s].\", this_char);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * no recovery flag requires a read-only mount\n\t */\n\tif ((mp->m_flags & XFS_MOUNT_NORECOVERY) &&\n\t    !(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\txfs_warn(mp, \"no-recovery mounts must be read-only.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((mp->m_flags & XFS_MOUNT_NOALIGN) && (dsunit || dswidth)) {\n\t\txfs_warn(mp,\n\t\"sunit and swidth options incompatible with the noalign option\");\n\t\treturn -EINVAL;\n\t}\n\n#ifndef CONFIG_XFS_QUOTA\n\tif (XFS_IS_QUOTA_RUNNING(mp)) {\n\t\txfs_warn(mp, \"quota support not available in this kernel.\");\n\t\treturn -EINVAL;\n\t}\n#endif\n\n\tif ((dsunit && !dswidth) || (!dsunit && dswidth)) {\n\t\txfs_warn(mp, \"sunit and swidth must be specified together\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dsunit && (dswidth % dsunit != 0)) {\n\t\txfs_warn(mp,\n\t\"stripe width (%d) must be a multiple of the stripe unit (%d)\",\n\t\t\tdswidth, dsunit);\n\t\treturn -EINVAL;\n\t}\n\ndone:\n\tif (dsunit && !(mp->m_flags & XFS_MOUNT_NOALIGN)) {\n\t\t/*\n\t\t * At this point the superblock has not been read\n\t\t * in, therefore we do not know the block size.\n\t\t * Before the mount call ends we will convert\n\t\t * these to FSBs.\n\t\t */\n\t\tmp->m_dalign = dsunit;\n\t\tmp->m_swidth = dswidth;\n\t}\n\n\tif (mp->m_logbufs != -1 &&\n\t    mp->m_logbufs != 0 &&\n\t    (mp->m_logbufs < XLOG_MIN_ICLOGS ||\n\t     mp->m_logbufs > XLOG_MAX_ICLOGS)) {\n\t\txfs_warn(mp, \"invalid logbufs value: %d [not %d-%d]\",\n\t\t\tmp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);\n\t\treturn -EINVAL;\n\t}\n\tif (mp->m_logbsize != -1 &&\n\t    mp->m_logbsize !=  0 &&\n\t    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||\n\t     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||\n\t     !is_power_of_2(mp->m_logbsize))) {\n\t\txfs_warn(mp,\n\t\t\t\"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]\",\n\t\t\tmp->m_logbsize);\n\t\treturn -EINVAL;\n\t}\n\n\tif (iosizelog) {\n\t\tif (iosizelog > XFS_MAX_IO_LOG ||\n\t\t    iosizelog < XFS_MIN_IO_LOG) {\n\t\t\txfs_warn(mp, \"invalid log iosize: %d [not %d-%d]\",\n\t\t\t\tiosizelog, XFS_MIN_IO_LOG,\n\t\t\t\tXFS_MAX_IO_LOG);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmp->m_flags |= XFS_MOUNT_DFLT_IOSIZE;\n\t\tmp->m_readio_log = iosizelog;\n\t\tmp->m_writeio_log = iosizelog;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define MNTOPT_NODISCARD   \"nodiscard\"\t/* Do not discard unused blocks */",
            "#define MNTOPT_DISCARD\t   \"discard\"\t/* Discard unused blocks */",
            "#define MNTOPT_NODELAYLOG  \"nodelaylog\"\t/* Delayed logging disabled */",
            "#define MNTOPT_DELAYLOG    \"delaylog\"\t/* Delayed logging enabled */",
            "#define MNTOPT_QUOTANOENF  \"qnoenforce\"\t/* same as uqnoenforce */",
            "#define MNTOPT_PQUOTANOENF \"pqnoenforce\"/* project quota limit enforcement */",
            "#define MNTOPT_GQUOTANOENF \"gqnoenforce\"/* group quota limit enforcement */",
            "#define MNTOPT_UQUOTANOENF \"uqnoenforce\"/* user quota limit enforcement */",
            "#define MNTOPT_PQUOTA\t\"pquota\"\t/* project quota (IRIX variant) */",
            "#define MNTOPT_GQUOTA\t\"gquota\"\t/* group quota (IRIX variant) */",
            "#define MNTOPT_UQUOTA\t\"uquota\"\t/* user quota (IRIX variant) */",
            "#define MNTOPT_PRJQUOTA\t\"prjquota\"\t/* project quota enabled */",
            "#define MNTOPT_GRPQUOTA\t\"grpquota\"\t/* group quota enabled */",
            "#define MNTOPT_USRQUOTA\t\"usrquota\"\t/* user quota enabled */",
            "#define MNTOPT_NOQUOTA\t\"noquota\"\t/* no quotas */",
            "#define MNTOPT_QUOTA\t\"quota\"\t\t/* disk quotas (user) */",
            "#define MNTOPT_FILESTREAM  \"filestreams\" /* use filestreams allocator */",
            "#define MNTOPT_NOATTR2\t\"noattr2\"\t/* do not use attr2 attribute format */",
            "#define MNTOPT_ATTR2\t\"attr2\"\t\t/* do use attr2 attribute format */",
            "#define MNTOPT_NOLARGEIO   \"nolargeio\"\t/* do not report large I/O sizes\n\t\t\t\t\t * in stat(). */",
            "#define MNTOPT_LARGEIO\t   \"largeio\"\t/* report large I/O sizes in stat() */",
            "#define MNTOPT_NOIKEEP\t\"noikeep\"\t/* free empty inode clusters */",
            "#define MNTOPT_IKEEP\t\"ikeep\"\t\t/* do not free empty inode clusters */",
            "#define MNTOPT_32BITINODE   \"inode32\"\t/* inode allocation limited to\n\t\t\t\t\t * XFS_MAXINUMBER_32 */",
            "#define MNTOPT_64BITINODE   \"inode64\"\t/* inodes can be allocated anywhere */",
            "#define MNTOPT_NOBARRIER \"nobarrier\"\t/* .. disable */",
            "#define MNTOPT_BARRIER\t\"barrier\"\t/* use writer barriers for log write and\n\t\t\t\t\t * unwritten extent conversion */",
            "#define MNTOPT_NORECOVERY   \"norecovery\"   /* don't run XFS recovery */",
            "#define MNTOPT_ALLOCSIZE    \"allocsize\"    /* preferred allocation size */",
            "#define MNTOPT_SYSVGROUPS   \"sysvgroups\"   /* group-ID from current process */",
            "#define MNTOPT_BSDGROUPS    \"bsdgroups\"    /* group-ID from parent directory */",
            "#define MNTOPT_NOGRPID\t\"nogrpid\"\t/* group-ID from current process */",
            "#define MNTOPT_GRPID\t\"grpid\"\t\t/* group-ID from parent directory */",
            "#define MNTOPT_MTPT\t\"mtpt\"\t\t/* filesystem mount point */",
            "#define MNTOPT_NOUUID\t\"nouuid\"\t/* ignore filesystem UUID */",
            "#define MNTOPT_SWIDTH\t\"swidth\"\t/* data volume stripe width */",
            "#define MNTOPT_SUNIT\t\"sunit\"\t\t/* data volume stripe unit */",
            "#define MNTOPT_SWALLOC\t\"swalloc\"\t/* turn on stripe width allocation */",
            "#define MNTOPT_NOALIGN\t\"noalign\"\t/* turn off stripe alignment */",
            "#define MNTOPT_WSYNC\t\"wsync\"\t\t/* safe-mode nfs compatible mount */",
            "#define MNTOPT_BIOSIZE\t\"biosize\"\t/* log2 of preferred buffered io size */",
            "#define MNTOPT_RTDEV\t\"rtdev\"\t\t/* realtime I/O device */",
            "#define MNTOPT_LOGDEV\t\"logdev\"\t/* log device */",
            "#define MNTOPT_LOGBSIZE\t\"logbsize\"\t/* size of XFS log buffers */",
            "#define MNTOPT_LOGBUFS\t\"logbufs\"\t/* number of XFS log buffers */"
          ],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n#define MNTOPT_NODISCARD   \"nodiscard\"\t/* Do not discard unused blocks */\n#define MNTOPT_DISCARD\t   \"discard\"\t/* Discard unused blocks */\n#define MNTOPT_NODELAYLOG  \"nodelaylog\"\t/* Delayed logging disabled */\n#define MNTOPT_DELAYLOG    \"delaylog\"\t/* Delayed logging enabled */\n#define MNTOPT_QUOTANOENF  \"qnoenforce\"\t/* same as uqnoenforce */\n#define MNTOPT_PQUOTANOENF \"pqnoenforce\"/* project quota limit enforcement */\n#define MNTOPT_GQUOTANOENF \"gqnoenforce\"/* group quota limit enforcement */\n#define MNTOPT_UQUOTANOENF \"uqnoenforce\"/* user quota limit enforcement */\n#define MNTOPT_PQUOTA\t\"pquota\"\t/* project quota (IRIX variant) */\n#define MNTOPT_GQUOTA\t\"gquota\"\t/* group quota (IRIX variant) */\n#define MNTOPT_UQUOTA\t\"uquota\"\t/* user quota (IRIX variant) */\n#define MNTOPT_PRJQUOTA\t\"prjquota\"\t/* project quota enabled */\n#define MNTOPT_GRPQUOTA\t\"grpquota\"\t/* group quota enabled */\n#define MNTOPT_USRQUOTA\t\"usrquota\"\t/* user quota enabled */\n#define MNTOPT_NOQUOTA\t\"noquota\"\t/* no quotas */\n#define MNTOPT_QUOTA\t\"quota\"\t\t/* disk quotas (user) */\n#define MNTOPT_FILESTREAM  \"filestreams\" /* use filestreams allocator */\n#define MNTOPT_NOATTR2\t\"noattr2\"\t/* do not use attr2 attribute format */\n#define MNTOPT_ATTR2\t\"attr2\"\t\t/* do use attr2 attribute format */\n#define MNTOPT_NOLARGEIO   \"nolargeio\"\t/* do not report large I/O sizes\n\t\t\t\t\t * in stat(). */\n#define MNTOPT_LARGEIO\t   \"largeio\"\t/* report large I/O sizes in stat() */\n#define MNTOPT_NOIKEEP\t\"noikeep\"\t/* free empty inode clusters */\n#define MNTOPT_IKEEP\t\"ikeep\"\t\t/* do not free empty inode clusters */\n#define MNTOPT_32BITINODE   \"inode32\"\t/* inode allocation limited to\n\t\t\t\t\t * XFS_MAXINUMBER_32 */\n#define MNTOPT_64BITINODE   \"inode64\"\t/* inodes can be allocated anywhere */\n#define MNTOPT_NOBARRIER \"nobarrier\"\t/* .. disable */\n#define MNTOPT_BARRIER\t\"barrier\"\t/* use writer barriers for log write and\n\t\t\t\t\t * unwritten extent conversion */\n#define MNTOPT_NORECOVERY   \"norecovery\"   /* don't run XFS recovery */\n#define MNTOPT_ALLOCSIZE    \"allocsize\"    /* preferred allocation size */\n#define MNTOPT_SYSVGROUPS   \"sysvgroups\"   /* group-ID from current process */\n#define MNTOPT_BSDGROUPS    \"bsdgroups\"    /* group-ID from parent directory */\n#define MNTOPT_NOGRPID\t\"nogrpid\"\t/* group-ID from current process */\n#define MNTOPT_GRPID\t\"grpid\"\t\t/* group-ID from parent directory */\n#define MNTOPT_MTPT\t\"mtpt\"\t\t/* filesystem mount point */\n#define MNTOPT_NOUUID\t\"nouuid\"\t/* ignore filesystem UUID */\n#define MNTOPT_SWIDTH\t\"swidth\"\t/* data volume stripe width */\n#define MNTOPT_SUNIT\t\"sunit\"\t\t/* data volume stripe unit */\n#define MNTOPT_SWALLOC\t\"swalloc\"\t/* turn on stripe width allocation */\n#define MNTOPT_NOALIGN\t\"noalign\"\t/* turn off stripe alignment */\n#define MNTOPT_WSYNC\t\"wsync\"\t\t/* safe-mode nfs compatible mount */\n#define MNTOPT_BIOSIZE\t\"biosize\"\t/* log2 of preferred buffered io size */\n#define MNTOPT_RTDEV\t\"rtdev\"\t\t/* realtime I/O device */\n#define MNTOPT_LOGDEV\t\"logdev\"\t/* log device */\n#define MNTOPT_LOGBSIZE\t\"logbsize\"\t/* size of XFS log buffers */\n#define MNTOPT_LOGBUFS\t\"logbufs\"\t/* number of XFS log buffers */\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_parseargs(\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t*options)\n{\n\tstruct super_block\t*sb = mp->m_super;\n\tchar\t\t\t*this_char, *value;\n\tint\t\t\tdsunit = 0;\n\tint\t\t\tdswidth = 0;\n\tint\t\t\tiosize = 0;\n\t__uint8_t\t\tiosizelog = 0;\n\n\t/*\n\t * set up the mount name first so all the errors will refer to the\n\t * correct device.\n\t */\n\tmp->m_fsname = kstrndup(sb->s_id, MAXNAMELEN, GFP_KERNEL);\n\tif (!mp->m_fsname)\n\t\treturn -ENOMEM;\n\tmp->m_fsname_len = strlen(mp->m_fsname) + 1;\n\n\t/*\n\t * Copy binary VFS mount flags we are interested in.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\tmp->m_flags |= XFS_MOUNT_RDONLY;\n\tif (sb->s_flags & MS_DIRSYNC)\n\t\tmp->m_flags |= XFS_MOUNT_DIRSYNC;\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tmp->m_flags |= XFS_MOUNT_WSYNC;\n\n\t/*\n\t * Set some default flags that could be cleared by the mount option\n\t * parsing.\n\t */\n\tmp->m_flags |= XFS_MOUNT_BARRIER;\n\tmp->m_flags |= XFS_MOUNT_COMPAT_IOSIZE;\n\n\t/*\n\t * These can be overridden by the mount option parsing.\n\t */\n\tmp->m_logbufs = -1;\n\tmp->m_logbsize = -1;\n\n\tif (!options)\n\t\tgoto done;\n\n\twhile ((this_char = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_char)\n\t\t\tcontinue;\n\t\tif ((value = strchr(this_char, '=')) != NULL)\n\t\t\t*value++ = 0;\n\n\t\tif (!strcmp(this_char, MNTOPT_LOGBUFS)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &mp->m_logbufs))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_LOGBSIZE)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (suffix_kstrtoint(value, 10, &mp->m_logbsize))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_LOGDEV)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmp->m_logname = kstrndup(value, MAXNAMELEN, GFP_KERNEL);\n\t\t\tif (!mp->m_logname)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!strcmp(this_char, MNTOPT_MTPT)) {\n\t\t\txfs_warn(mp, \"%s option not allowed on this system\",\n\t\t\t\tthis_char);\n\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_RTDEV)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmp->m_rtname = kstrndup(value, MAXNAMELEN, GFP_KERNEL);\n\t\t\tif (!mp->m_rtname)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!strcmp(this_char, MNTOPT_BIOSIZE)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &iosize))\n\t\t\t\treturn -EINVAL;\n\t\t\tiosizelog = ffs(iosize) - 1;\n\t\t} else if (!strcmp(this_char, MNTOPT_ALLOCSIZE)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (suffix_kstrtoint(value, 10, &iosize))\n\t\t\t\treturn -EINVAL;\n\t\t\tiosizelog = ffs(iosize) - 1;\n\t\t} else if (!strcmp(this_char, MNTOPT_GRPID) ||\n\t\t\t   !strcmp(this_char, MNTOPT_BSDGROUPS)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_GRPID;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOGRPID) ||\n\t\t\t   !strcmp(this_char, MNTOPT_SYSVGROUPS)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_GRPID;\n\t\t} else if (!strcmp(this_char, MNTOPT_WSYNC)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_WSYNC;\n\t\t} else if (!strcmp(this_char, MNTOPT_NORECOVERY)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_NORECOVERY;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOALIGN)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_NOALIGN;\n\t\t} else if (!strcmp(this_char, MNTOPT_SWALLOC)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_SWALLOC;\n\t\t} else if (!strcmp(this_char, MNTOPT_SUNIT)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &dsunit))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_SWIDTH)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &dswidth))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_32BITINODE)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_SMALL_INUMS;\n\t\t} else if (!strcmp(this_char, MNTOPT_64BITINODE)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOUUID)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_NOUUID;\n\t\t} else if (!strcmp(this_char, MNTOPT_BARRIER)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_BARRIER;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOBARRIER)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_BARRIER;\n\t\t} else if (!strcmp(this_char, MNTOPT_IKEEP)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_IKEEP;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOIKEEP)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_IKEEP;\n\t\t} else if (!strcmp(this_char, MNTOPT_LARGEIO)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_COMPAT_IOSIZE;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOLARGEIO)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_COMPAT_IOSIZE;\n\t\t} else if (!strcmp(this_char, MNTOPT_ATTR2)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_ATTR2;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOATTR2)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_ATTR2;\n\t\t\tmp->m_flags |= XFS_MOUNT_NOATTR2;\n\t\t} else if (!strcmp(this_char, MNTOPT_FILESTREAM)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_FILESTREAMS;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOQUOTA)) {\n\t\t\tmp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;\n\t\t\tmp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;\n\t\t\tmp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;\n\t\t} else if (!strcmp(this_char, MNTOPT_QUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_UQUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_USRQUOTA)) {\n\t\t\tmp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |\n\t\t\t\t\t XFS_UQUOTA_ENFD);\n\t\t} else if (!strcmp(this_char, MNTOPT_QUOTANOENF) ||\n\t\t\t   !strcmp(this_char, MNTOPT_UQUOTANOENF)) {\n\t\t\tmp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);\n\t\t\tmp->m_qflags &= ~XFS_UQUOTA_ENFD;\n\t\t} else if (!strcmp(this_char, MNTOPT_PQUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_PRJQUOTA)) {\n\t\t\tmp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |\n\t\t\t\t\t XFS_PQUOTA_ENFD);\n\t\t} else if (!strcmp(this_char, MNTOPT_PQUOTANOENF)) {\n\t\t\tmp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);\n\t\t\tmp->m_qflags &= ~XFS_PQUOTA_ENFD;\n\t\t} else if (!strcmp(this_char, MNTOPT_GQUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_GRPQUOTA)) {\n\t\t\tmp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |\n\t\t\t\t\t XFS_GQUOTA_ENFD);\n\t\t} else if (!strcmp(this_char, MNTOPT_GQUOTANOENF)) {\n\t\t\tmp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);\n\t\t\tmp->m_qflags &= ~XFS_GQUOTA_ENFD;\n\t\t} else if (!strcmp(this_char, MNTOPT_DELAYLOG)) {\n\t\t\txfs_warn(mp,\n\t\"delaylog is the default now, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, MNTOPT_NODELAYLOG)) {\n\t\t\txfs_warn(mp,\n\t\"nodelaylog support has been removed, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, MNTOPT_DISCARD)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_DISCARD;\n\t\t} else if (!strcmp(this_char, MNTOPT_NODISCARD)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_DISCARD;\n\t\t} else if (!strcmp(this_char, \"ihashsize\")) {\n\t\t\txfs_warn(mp,\n\t\"ihashsize no longer used, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, \"osyncisdsync\")) {\n\t\t\txfs_warn(mp,\n\t\"osyncisdsync has no effect, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, \"osyncisosync\")) {\n\t\t\txfs_warn(mp,\n\t\"osyncisosync has no effect, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, \"irixsgid\")) {\n\t\t\txfs_warn(mp,\n\t\"irixsgid is now a sysctl(2) variable, option is deprecated.\");\n\t\t} else {\n\t\t\txfs_warn(mp, \"unknown mount option [%s].\", this_char);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * no recovery flag requires a read-only mount\n\t */\n\tif ((mp->m_flags & XFS_MOUNT_NORECOVERY) &&\n\t    !(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\txfs_warn(mp, \"no-recovery mounts must be read-only.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((mp->m_flags & XFS_MOUNT_NOALIGN) && (dsunit || dswidth)) {\n\t\txfs_warn(mp,\n\t\"sunit and swidth options incompatible with the noalign option\");\n\t\treturn -EINVAL;\n\t}\n\n#ifndef CONFIG_XFS_QUOTA\n\tif (XFS_IS_QUOTA_RUNNING(mp)) {\n\t\txfs_warn(mp, \"quota support not available in this kernel.\");\n\t\treturn -EINVAL;\n\t}\n#endif\n\n\tif ((dsunit && !dswidth) || (!dsunit && dswidth)) {\n\t\txfs_warn(mp, \"sunit and swidth must be specified together\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dsunit && (dswidth % dsunit != 0)) {\n\t\txfs_warn(mp,\n\t\"stripe width (%d) must be a multiple of the stripe unit (%d)\",\n\t\t\tdswidth, dsunit);\n\t\treturn -EINVAL;\n\t}\n\ndone:\n\tif (dsunit && !(mp->m_flags & XFS_MOUNT_NOALIGN)) {\n\t\t/*\n\t\t * At this point the superblock has not been read\n\t\t * in, therefore we do not know the block size.\n\t\t * Before the mount call ends we will convert\n\t\t * these to FSBs.\n\t\t */\n\t\tmp->m_dalign = dsunit;\n\t\tmp->m_swidth = dswidth;\n\t}\n\n\tif (mp->m_logbufs != -1 &&\n\t    mp->m_logbufs != 0 &&\n\t    (mp->m_logbufs < XLOG_MIN_ICLOGS ||\n\t     mp->m_logbufs > XLOG_MAX_ICLOGS)) {\n\t\txfs_warn(mp, \"invalid logbufs value: %d [not %d-%d]\",\n\t\t\tmp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);\n\t\treturn -EINVAL;\n\t}\n\tif (mp->m_logbsize != -1 &&\n\t    mp->m_logbsize !=  0 &&\n\t    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||\n\t     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||\n\t     !is_power_of_2(mp->m_logbsize))) {\n\t\txfs_warn(mp,\n\t\t\t\"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]\",\n\t\t\tmp->m_logbsize);\n\t\treturn -EINVAL;\n\t}\n\n\tif (iosizelog) {\n\t\tif (iosizelog > XFS_MAX_IO_LOG ||\n\t\t    iosizelog < XFS_MIN_IO_LOG) {\n\t\t\txfs_warn(mp, \"invalid log iosize: %d [not %d-%d]\",\n\t\t\t\tiosizelog, XFS_MIN_IO_LOG,\n\t\t\t\tXFS_MAX_IO_LOG);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmp->m_flags |= XFS_MOUNT_DFLT_IOSIZE;\n\t\tmp->m_readio_log = iosizelog;\n\t\tmp->m_writeio_log = iosizelog;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&mp->m_eofblocks_work",
            "xfs_eofblocks_worker"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&mp->m_reclaim_work",
            "xfs_reclaim_worker"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&mp->m_active_trans",
            "0"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&mp->m_growlock"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct xfs_mount)",
            "GFP_KERNEL"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nstatic const struct super_operations xfs_super_operations;\nstatic struct kset *xfs_kset;\nSTATIC struct;\nSTATIC struct;\nstatic const struct super_operations xfs_super_operations = {\n\t.alloc_inode\t\t= xfs_fs_alloc_inode,\n\t.destroy_inode\t\t= xfs_fs_destroy_inode,\n\t.evict_inode\t\t= xfs_fs_evict_inode,\n\t.drop_inode\t\t= xfs_fs_drop_inode,\n\t.put_super\t\t= xfs_fs_put_super,\n\t.sync_fs\t\t= xfs_fs_sync_fs,\n\t.freeze_fs\t\t= xfs_fs_freeze,\n\t.unfreeze_fs\t\t= xfs_fs_unfreeze,\n\t.statfs\t\t\t= xfs_fs_statfs,\n\t.remount_fs\t\t= xfs_fs_remount,\n\t.show_options\t\t= xfs_fs_show_options,\n\t.nr_cached_objects\t= xfs_fs_nr_cached_objects,\n\t.free_cached_objects\t= xfs_fs_free_cached_objects,\n};\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_fs_fill_super(\n\tstruct super_block\t*sb,\n\tvoid\t\t\t*data,\n\tint\t\t\tsilent)\n{\n\tstruct inode\t\t*root;\n\tstruct xfs_mount\t*mp = NULL;\n\tint\t\t\tflags = 0, error = -ENOMEM;\n\n\tmp = kzalloc(sizeof(struct xfs_mount), GFP_KERNEL);\n\tif (!mp)\n\t\tgoto out;\n\n\tspin_lock_init(&mp->m_sb_lock);\n\tmutex_init(&mp->m_growlock);\n\tatomic_set(&mp->m_active_trans, 0);\n\tINIT_DELAYED_WORK(&mp->m_reclaim_work, xfs_reclaim_worker);\n\tINIT_DELAYED_WORK(&mp->m_eofblocks_work, xfs_eofblocks_worker);\n\tmp->m_kobj.kobject.kset = xfs_kset;\n\n\tmp->m_super = sb;\n\tsb->s_fs_info = mp;\n\n\terror = xfs_parseargs(mp, (char *)data);\n\tif (error)\n\t\tgoto out_free_fsname;\n\n\tsb_min_blocksize(sb, BBSIZE);\n\tsb->s_xattr = xfs_xattr_handlers;\n\tsb->s_export_op = &xfs_export_operations;\n#ifdef CONFIG_XFS_QUOTA\n\tsb->s_qcop = &xfs_quotactl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tsb->s_op = &xfs_super_operations;\n\n\tif (silent)\n\t\tflags |= XFS_MFSI_QUIET;\n\n\terror = xfs_open_devices(mp);\n\tif (error)\n\t\tgoto out_free_fsname;\n\n\terror = xfs_init_mount_workqueues(mp);\n\tif (error)\n\t\tgoto out_close_devices;\n\n\terror = xfs_icsb_init_counters(mp);\n\tif (error)\n\t\tgoto out_destroy_workqueues;\n\n\terror = xfs_readsb(mp, flags);\n\tif (error)\n\t\tgoto out_destroy_counters;\n\n\terror = xfs_finish_flags(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\terror = xfs_setup_devices(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\terror = xfs_filestream_mount(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\t/*\n\t * we must configure the block size in the superblock before we run the\n\t * full mount process as the mount process can lookup and cache inodes.\n\t */\n\tsb->s_magic = XFS_SB_MAGIC;\n\tsb->s_blocksize = mp->m_sb.sb_blocksize;\n\tsb->s_blocksize_bits = ffs(sb->s_blocksize) - 1;\n\tsb->s_maxbytes = xfs_max_file_offset(sb->s_blocksize_bits);\n\tsb->s_max_links = XFS_MAXLINK;\n\tsb->s_time_gran = 1;\n\tset_posix_acl_flag(sb);\n\n\t/* version 5 superblocks support inode version counters. */\n\tif (XFS_SB_VERSION_NUM(&mp->m_sb) == XFS_SB_VERSION_5)\n\t\tsb->s_flags |= MS_I_VERSION;\n\n\terror = xfs_mountfs(mp);\n\tif (error)\n\t\tgoto out_filestream_unmount;\n\n\troot = igrab(VFS_I(mp->m_rootip));\n\tif (!root) {\n\t\terror = -ENOENT;\n\t\tgoto out_unmount;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terror = -ENOMEM;\n\t\tgoto out_unmount;\n\t}\n\n\treturn 0;\n\n out_filestream_unmount:\n\txfs_filestream_unmount(mp);\n out_free_sb:\n\txfs_freesb(mp);\n out_destroy_counters:\n\txfs_icsb_destroy_counters(mp);\nout_destroy_workqueues:\n\txfs_destroy_mount_workqueues(mp);\n out_close_devices:\n\txfs_close_devices(mp);\n out_free_fsname:\n\txfs_free_fsname(mp);\n\tkfree(mp);\n out:\n\treturn error;\n\n out_unmount:\n\txfs_filestream_unmount(mp);\n\txfs_unmountfs(mp);\n\tgoto out_free_sb;\n}"
  },
  {
    "function_name": "xfs_finish_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1339-1402",
    "snippet": "STATIC int\nxfs_finish_flags(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\tronly = (mp->m_flags & XFS_MOUNT_RDONLY);\n\n\t/* Fail a mount where the logbuf is smaller than the log stripe */\n\tif (xfs_sb_version_haslogv2(&mp->m_sb)) {\n\t\tif (mp->m_logbsize <= 0 &&\n\t\t    mp->m_sb.sb_logsunit > XLOG_BIG_RECORD_BSIZE) {\n\t\t\tmp->m_logbsize = mp->m_sb.sb_logsunit;\n\t\t} else if (mp->m_logbsize > 0 &&\n\t\t\t   mp->m_logbsize < mp->m_sb.sb_logsunit) {\n\t\t\txfs_warn(mp,\n\t\t\"logbuf size must be greater than or equal to log stripe size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t/* Fail a mount if the logbuf is larger than 32K */\n\t\tif (mp->m_logbsize > XLOG_BIG_RECORD_BSIZE) {\n\t\t\txfs_warn(mp,\n\t\t\"logbuf size for version 1 logs must be 16K or 32K\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * V5 filesystems always use attr2 format for attributes.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    (mp->m_flags & XFS_MOUNT_NOATTR2)) {\n\t\txfs_warn(mp,\n\"Cannot mount a V5 filesystem as %s. %s is always enabled for V5 filesystems.\",\n\t\t\tMNTOPT_NOATTR2, MNTOPT_ATTR2);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * mkfs'ed attr2 will turn on attr2 mount unless explicitly\n\t * told by noattr2 to turn it off\n\t */\n\tif (xfs_sb_version_hasattr2(&mp->m_sb) &&\n\t    !(mp->m_flags & XFS_MOUNT_NOATTR2))\n\t\tmp->m_flags |= XFS_MOUNT_ATTR2;\n\n\t/*\n\t * prohibit r/w mounts of read-only filesystems\n\t */\n\tif ((mp->m_sb.sb_flags & XFS_SBF_READONLY) && !ronly) {\n\t\txfs_warn(mp,\n\t\t\t\"cannot mount a read-only filesystem as read-write\");\n\t\treturn -EROFS;\n\t}\n\n\tif ((mp->m_qflags & (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE)) &&\n\t    (mp->m_qflags & (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE)) &&\n\t    !xfs_sb_version_has_pquotino(&mp->m_sb)) {\n\t\txfs_warn(mp,\n\t\t  \"Super block does not support project and group quota together\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define MNTOPT_NOATTR2\t\"noattr2\"\t/* do not use attr2 attribute format */",
      "#define MNTOPT_ATTR2\t\"attr2\"\t\t/* do use attr2 attribute format */"
    ],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Super block does not support project and group quota together\""
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_has_pquotino",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_has_pquotino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "552-555",
          "snippet": "static inline int xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"cannot mount a read-only filesystem as read-write\""
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasattr2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasattr2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "448-453",
          "snippet": "static inline bool xfs_sb_version_hasattr2(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasattr2(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Cannot mount a V5 filesystem as %s. %s is always enabled for V5 filesystems.\"",
            "MNTOPT_NOATTR2",
            "MNTOPT_ATTR2"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"logbuf size for version 1 logs must be 16K or 32K\""
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"logbuf size must be greater than or equal to log stripe size\""
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n#define MNTOPT_NOATTR2\t\"noattr2\"\t/* do not use attr2 attribute format */\n#define MNTOPT_ATTR2\t\"attr2\"\t\t/* do use attr2 attribute format */\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_finish_flags(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\tronly = (mp->m_flags & XFS_MOUNT_RDONLY);\n\n\t/* Fail a mount where the logbuf is smaller than the log stripe */\n\tif (xfs_sb_version_haslogv2(&mp->m_sb)) {\n\t\tif (mp->m_logbsize <= 0 &&\n\t\t    mp->m_sb.sb_logsunit > XLOG_BIG_RECORD_BSIZE) {\n\t\t\tmp->m_logbsize = mp->m_sb.sb_logsunit;\n\t\t} else if (mp->m_logbsize > 0 &&\n\t\t\t   mp->m_logbsize < mp->m_sb.sb_logsunit) {\n\t\t\txfs_warn(mp,\n\t\t\"logbuf size must be greater than or equal to log stripe size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t/* Fail a mount if the logbuf is larger than 32K */\n\t\tif (mp->m_logbsize > XLOG_BIG_RECORD_BSIZE) {\n\t\t\txfs_warn(mp,\n\t\t\"logbuf size for version 1 logs must be 16K or 32K\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * V5 filesystems always use attr2 format for attributes.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    (mp->m_flags & XFS_MOUNT_NOATTR2)) {\n\t\txfs_warn(mp,\n\"Cannot mount a V5 filesystem as %s. %s is always enabled for V5 filesystems.\",\n\t\t\tMNTOPT_NOATTR2, MNTOPT_ATTR2);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * mkfs'ed attr2 will turn on attr2 mount unless explicitly\n\t * told by noattr2 to turn it off\n\t */\n\tif (xfs_sb_version_hasattr2(&mp->m_sb) &&\n\t    !(mp->m_flags & XFS_MOUNT_NOATTR2))\n\t\tmp->m_flags |= XFS_MOUNT_ATTR2;\n\n\t/*\n\t * prohibit r/w mounts of read-only filesystems\n\t */\n\tif ((mp->m_sb.sb_flags & XFS_SBF_READONLY) && !ronly) {\n\t\txfs_warn(mp,\n\t\t\t\"cannot mount a read-only filesystem as read-write\");\n\t\treturn -EROFS;\n\t}\n\n\tif ((mp->m_qflags & (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE)) &&\n\t    (mp->m_qflags & (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE)) &&\n\t    !xfs_sb_version_has_pquotino(&mp->m_sb)) {\n\t\txfs_warn(mp,\n\t\t  \"Super block does not support project and group quota together\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_fs_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1327-1333",
    "snippet": "STATIC int\nxfs_fs_show_options(\n\tstruct seq_file\t\t*m,\n\tstruct dentry\t\t*root)\n{\n\treturn xfs_showargs(XFS_M(root->d_sb), m);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_showargs",
          "args": [
            "XFS_M(root->d_sb)",
            "m"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_showargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "479-560",
          "snippet": "STATIC int\nxfs_showargs(\n\tstruct xfs_mount\t*mp,\n\tstruct seq_file\t\t*m)\n{\n\tstatic struct proc_xfs_info xfs_info_set[] = {\n\t\t/* the few simple ones we can get from the mount struct */\n\t\t{ XFS_MOUNT_IKEEP,\t\t\",\" MNTOPT_IKEEP },\n\t\t{ XFS_MOUNT_WSYNC,\t\t\",\" MNTOPT_WSYNC },\n\t\t{ XFS_MOUNT_NOALIGN,\t\t\",\" MNTOPT_NOALIGN },\n\t\t{ XFS_MOUNT_SWALLOC,\t\t\",\" MNTOPT_SWALLOC },\n\t\t{ XFS_MOUNT_NOUUID,\t\t\",\" MNTOPT_NOUUID },\n\t\t{ XFS_MOUNT_NORECOVERY,\t\t\",\" MNTOPT_NORECOVERY },\n\t\t{ XFS_MOUNT_ATTR2,\t\t\",\" MNTOPT_ATTR2 },\n\t\t{ XFS_MOUNT_FILESTREAMS,\t\",\" MNTOPT_FILESTREAM },\n\t\t{ XFS_MOUNT_GRPID,\t\t\",\" MNTOPT_GRPID },\n\t\t{ XFS_MOUNT_DISCARD,\t\t\",\" MNTOPT_DISCARD },\n\t\t{ XFS_MOUNT_SMALL_INUMS,\t\",\" MNTOPT_32BITINODE },\n\t\t{ 0, NULL }\n\t};\n\tstatic struct proc_xfs_info xfs_info_unset[] = {\n\t\t/* the few simple ones we can get from the mount struct */\n\t\t{ XFS_MOUNT_COMPAT_IOSIZE,\t\",\" MNTOPT_LARGEIO },\n\t\t{ XFS_MOUNT_BARRIER,\t\t\",\" MNTOPT_NOBARRIER },\n\t\t{ XFS_MOUNT_SMALL_INUMS,\t\",\" MNTOPT_64BITINODE },\n\t\t{ 0, NULL }\n\t};\n\tstruct proc_xfs_info\t*xfs_infop;\n\n\tfor (xfs_infop = xfs_info_set; xfs_infop->flag; xfs_infop++) {\n\t\tif (mp->m_flags & xfs_infop->flag)\n\t\t\tseq_puts(m, xfs_infop->str);\n\t}\n\tfor (xfs_infop = xfs_info_unset; xfs_infop->flag; xfs_infop++) {\n\t\tif (!(mp->m_flags & xfs_infop->flag))\n\t\t\tseq_puts(m, xfs_infop->str);\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_DFLT_IOSIZE)\n\t\tseq_printf(m, \",\" MNTOPT_ALLOCSIZE \"=%dk\",\n\t\t\t\t(int)(1 << mp->m_writeio_log) >> 10);\n\n\tif (mp->m_logbufs > 0)\n\t\tseq_printf(m, \",\" MNTOPT_LOGBUFS \"=%d\", mp->m_logbufs);\n\tif (mp->m_logbsize > 0)\n\t\tseq_printf(m, \",\" MNTOPT_LOGBSIZE \"=%dk\", mp->m_logbsize >> 10);\n\n\tif (mp->m_logname)\n\t\tseq_printf(m, \",\" MNTOPT_LOGDEV \"=%s\", mp->m_logname);\n\tif (mp->m_rtname)\n\t\tseq_printf(m, \",\" MNTOPT_RTDEV \"=%s\", mp->m_rtname);\n\n\tif (mp->m_dalign > 0)\n\t\tseq_printf(m, \",\" MNTOPT_SUNIT \"=%d\",\n\t\t\t\t(int)XFS_FSB_TO_BB(mp, mp->m_dalign));\n\tif (mp->m_swidth > 0)\n\t\tseq_printf(m, \",\" MNTOPT_SWIDTH \"=%d\",\n\t\t\t\t(int)XFS_FSB_TO_BB(mp, mp->m_swidth));\n\n\tif (mp->m_qflags & (XFS_UQUOTA_ACCT|XFS_UQUOTA_ENFD))\n\t\tseq_puts(m, \",\" MNTOPT_USRQUOTA);\n\telse if (mp->m_qflags & XFS_UQUOTA_ACCT)\n\t\tseq_puts(m, \",\" MNTOPT_UQUOTANOENF);\n\n\tif (mp->m_qflags & XFS_PQUOTA_ACCT) {\n\t\tif (mp->m_qflags & XFS_PQUOTA_ENFD)\n\t\t\tseq_puts(m, \",\" MNTOPT_PRJQUOTA);\n\t\telse\n\t\t\tseq_puts(m, \",\" MNTOPT_PQUOTANOENF);\n\t}\n\tif (mp->m_qflags & XFS_GQUOTA_ACCT) {\n\t\tif (mp->m_qflags & XFS_GQUOTA_ENFD)\n\t\t\tseq_puts(m, \",\" MNTOPT_GRPQUOTA);\n\t\telse\n\t\t\tseq_puts(m, \",\" MNTOPT_GQUOTANOENF);\n\t}\n\n\tif (!(mp->m_qflags & XFS_ALL_QUOTA_ACCT))\n\t\tseq_puts(m, \",\" MNTOPT_NOQUOTA);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define MNTOPT_DISCARD\t   \"discard\"\t/* Discard unused blocks */",
            "#define MNTOPT_PQUOTANOENF \"pqnoenforce\"/* project quota limit enforcement */",
            "#define MNTOPT_GQUOTANOENF \"gqnoenforce\"/* group quota limit enforcement */",
            "#define MNTOPT_UQUOTANOENF \"uqnoenforce\"/* user quota limit enforcement */",
            "#define MNTOPT_PRJQUOTA\t\"prjquota\"\t/* project quota enabled */",
            "#define MNTOPT_GRPQUOTA\t\"grpquota\"\t/* group quota enabled */",
            "#define MNTOPT_USRQUOTA\t\"usrquota\"\t/* user quota enabled */",
            "#define MNTOPT_NOQUOTA\t\"noquota\"\t/* no quotas */",
            "#define MNTOPT_FILESTREAM  \"filestreams\" /* use filestreams allocator */",
            "#define MNTOPT_ATTR2\t\"attr2\"\t\t/* do use attr2 attribute format */",
            "#define MNTOPT_LARGEIO\t   \"largeio\"\t/* report large I/O sizes in stat() */",
            "#define MNTOPT_IKEEP\t\"ikeep\"\t\t/* do not free empty inode clusters */",
            "#define MNTOPT_32BITINODE   \"inode32\"\t/* inode allocation limited to\n\t\t\t\t\t * XFS_MAXINUMBER_32 */",
            "#define MNTOPT_64BITINODE   \"inode64\"\t/* inodes can be allocated anywhere */",
            "#define MNTOPT_NOBARRIER \"nobarrier\"\t/* .. disable */",
            "#define MNTOPT_NORECOVERY   \"norecovery\"   /* don't run XFS recovery */",
            "#define MNTOPT_ALLOCSIZE    \"allocsize\"    /* preferred allocation size */",
            "#define MNTOPT_GRPID\t\"grpid\"\t\t/* group-ID from parent directory */",
            "#define MNTOPT_NOUUID\t\"nouuid\"\t/* ignore filesystem UUID */",
            "#define MNTOPT_SWIDTH\t\"swidth\"\t/* data volume stripe width */",
            "#define MNTOPT_SUNIT\t\"sunit\"\t\t/* data volume stripe unit */",
            "#define MNTOPT_SWALLOC\t\"swalloc\"\t/* turn on stripe width allocation */",
            "#define MNTOPT_NOALIGN\t\"noalign\"\t/* turn off stripe alignment */",
            "#define MNTOPT_WSYNC\t\"wsync\"\t\t/* safe-mode nfs compatible mount */",
            "#define MNTOPT_RTDEV\t\"rtdev\"\t\t/* realtime I/O device */",
            "#define MNTOPT_LOGDEV\t\"logdev\"\t/* log device */",
            "#define MNTOPT_LOGBSIZE\t\"logbsize\"\t/* size of XFS log buffers */",
            "#define MNTOPT_LOGBUFS\t\"logbufs\"\t/* number of XFS log buffers */"
          ],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n#define MNTOPT_DISCARD\t   \"discard\"\t/* Discard unused blocks */\n#define MNTOPT_PQUOTANOENF \"pqnoenforce\"/* project quota limit enforcement */\n#define MNTOPT_GQUOTANOENF \"gqnoenforce\"/* group quota limit enforcement */\n#define MNTOPT_UQUOTANOENF \"uqnoenforce\"/* user quota limit enforcement */\n#define MNTOPT_PRJQUOTA\t\"prjquota\"\t/* project quota enabled */\n#define MNTOPT_GRPQUOTA\t\"grpquota\"\t/* group quota enabled */\n#define MNTOPT_USRQUOTA\t\"usrquota\"\t/* user quota enabled */\n#define MNTOPT_NOQUOTA\t\"noquota\"\t/* no quotas */\n#define MNTOPT_FILESTREAM  \"filestreams\" /* use filestreams allocator */\n#define MNTOPT_ATTR2\t\"attr2\"\t\t/* do use attr2 attribute format */\n#define MNTOPT_LARGEIO\t   \"largeio\"\t/* report large I/O sizes in stat() */\n#define MNTOPT_IKEEP\t\"ikeep\"\t\t/* do not free empty inode clusters */\n#define MNTOPT_32BITINODE   \"inode32\"\t/* inode allocation limited to\n\t\t\t\t\t * XFS_MAXINUMBER_32 */\n#define MNTOPT_64BITINODE   \"inode64\"\t/* inodes can be allocated anywhere */\n#define MNTOPT_NOBARRIER \"nobarrier\"\t/* .. disable */\n#define MNTOPT_NORECOVERY   \"norecovery\"   /* don't run XFS recovery */\n#define MNTOPT_ALLOCSIZE    \"allocsize\"    /* preferred allocation size */\n#define MNTOPT_GRPID\t\"grpid\"\t\t/* group-ID from parent directory */\n#define MNTOPT_NOUUID\t\"nouuid\"\t/* ignore filesystem UUID */\n#define MNTOPT_SWIDTH\t\"swidth\"\t/* data volume stripe width */\n#define MNTOPT_SUNIT\t\"sunit\"\t\t/* data volume stripe unit */\n#define MNTOPT_SWALLOC\t\"swalloc\"\t/* turn on stripe width allocation */\n#define MNTOPT_NOALIGN\t\"noalign\"\t/* turn off stripe alignment */\n#define MNTOPT_WSYNC\t\"wsync\"\t\t/* safe-mode nfs compatible mount */\n#define MNTOPT_RTDEV\t\"rtdev\"\t\t/* realtime I/O device */\n#define MNTOPT_LOGDEV\t\"logdev\"\t/* log device */\n#define MNTOPT_LOGBSIZE\t\"logbsize\"\t/* size of XFS log buffers */\n#define MNTOPT_LOGBUFS\t\"logbufs\"\t/* number of XFS log buffers */\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_showargs(\n\tstruct xfs_mount\t*mp,\n\tstruct seq_file\t\t*m)\n{\n\tstatic struct proc_xfs_info xfs_info_set[] = {\n\t\t/* the few simple ones we can get from the mount struct */\n\t\t{ XFS_MOUNT_IKEEP,\t\t\",\" MNTOPT_IKEEP },\n\t\t{ XFS_MOUNT_WSYNC,\t\t\",\" MNTOPT_WSYNC },\n\t\t{ XFS_MOUNT_NOALIGN,\t\t\",\" MNTOPT_NOALIGN },\n\t\t{ XFS_MOUNT_SWALLOC,\t\t\",\" MNTOPT_SWALLOC },\n\t\t{ XFS_MOUNT_NOUUID,\t\t\",\" MNTOPT_NOUUID },\n\t\t{ XFS_MOUNT_NORECOVERY,\t\t\",\" MNTOPT_NORECOVERY },\n\t\t{ XFS_MOUNT_ATTR2,\t\t\",\" MNTOPT_ATTR2 },\n\t\t{ XFS_MOUNT_FILESTREAMS,\t\",\" MNTOPT_FILESTREAM },\n\t\t{ XFS_MOUNT_GRPID,\t\t\",\" MNTOPT_GRPID },\n\t\t{ XFS_MOUNT_DISCARD,\t\t\",\" MNTOPT_DISCARD },\n\t\t{ XFS_MOUNT_SMALL_INUMS,\t\",\" MNTOPT_32BITINODE },\n\t\t{ 0, NULL }\n\t};\n\tstatic struct proc_xfs_info xfs_info_unset[] = {\n\t\t/* the few simple ones we can get from the mount struct */\n\t\t{ XFS_MOUNT_COMPAT_IOSIZE,\t\",\" MNTOPT_LARGEIO },\n\t\t{ XFS_MOUNT_BARRIER,\t\t\",\" MNTOPT_NOBARRIER },\n\t\t{ XFS_MOUNT_SMALL_INUMS,\t\",\" MNTOPT_64BITINODE },\n\t\t{ 0, NULL }\n\t};\n\tstruct proc_xfs_info\t*xfs_infop;\n\n\tfor (xfs_infop = xfs_info_set; xfs_infop->flag; xfs_infop++) {\n\t\tif (mp->m_flags & xfs_infop->flag)\n\t\t\tseq_puts(m, xfs_infop->str);\n\t}\n\tfor (xfs_infop = xfs_info_unset; xfs_infop->flag; xfs_infop++) {\n\t\tif (!(mp->m_flags & xfs_infop->flag))\n\t\t\tseq_puts(m, xfs_infop->str);\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_DFLT_IOSIZE)\n\t\tseq_printf(m, \",\" MNTOPT_ALLOCSIZE \"=%dk\",\n\t\t\t\t(int)(1 << mp->m_writeio_log) >> 10);\n\n\tif (mp->m_logbufs > 0)\n\t\tseq_printf(m, \",\" MNTOPT_LOGBUFS \"=%d\", mp->m_logbufs);\n\tif (mp->m_logbsize > 0)\n\t\tseq_printf(m, \",\" MNTOPT_LOGBSIZE \"=%dk\", mp->m_logbsize >> 10);\n\n\tif (mp->m_logname)\n\t\tseq_printf(m, \",\" MNTOPT_LOGDEV \"=%s\", mp->m_logname);\n\tif (mp->m_rtname)\n\t\tseq_printf(m, \",\" MNTOPT_RTDEV \"=%s\", mp->m_rtname);\n\n\tif (mp->m_dalign > 0)\n\t\tseq_printf(m, \",\" MNTOPT_SUNIT \"=%d\",\n\t\t\t\t(int)XFS_FSB_TO_BB(mp, mp->m_dalign));\n\tif (mp->m_swidth > 0)\n\t\tseq_printf(m, \",\" MNTOPT_SWIDTH \"=%d\",\n\t\t\t\t(int)XFS_FSB_TO_BB(mp, mp->m_swidth));\n\n\tif (mp->m_qflags & (XFS_UQUOTA_ACCT|XFS_UQUOTA_ENFD))\n\t\tseq_puts(m, \",\" MNTOPT_USRQUOTA);\n\telse if (mp->m_qflags & XFS_UQUOTA_ACCT)\n\t\tseq_puts(m, \",\" MNTOPT_UQUOTANOENF);\n\n\tif (mp->m_qflags & XFS_PQUOTA_ACCT) {\n\t\tif (mp->m_qflags & XFS_PQUOTA_ENFD)\n\t\t\tseq_puts(m, \",\" MNTOPT_PRJQUOTA);\n\t\telse\n\t\t\tseq_puts(m, \",\" MNTOPT_PQUOTANOENF);\n\t}\n\tif (mp->m_qflags & XFS_GQUOTA_ACCT) {\n\t\tif (mp->m_qflags & XFS_GQUOTA_ENFD)\n\t\t\tseq_puts(m, \",\" MNTOPT_GRPQUOTA);\n\t\telse\n\t\t\tseq_puts(m, \",\" MNTOPT_GQUOTANOENF);\n\t}\n\n\tif (!(mp->m_qflags & XFS_ALL_QUOTA_ACCT))\n\t\tseq_puts(m, \",\" MNTOPT_NOQUOTA);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "root->d_sb"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_fs_show_options(\n\tstruct seq_file\t\t*m,\n\tstruct dentry\t\t*root)\n{\n\treturn xfs_showargs(XFS_M(root->d_sb), m);\n}"
  },
  {
    "function_name": "xfs_fs_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1316-1325",
    "snippet": "STATIC int\nxfs_fs_unfreeze(\n\tstruct super_block\t*sb)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\txfs_restore_resvblks(mp);\n\txfs_log_work_queue(mp);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_log_work_queue",
          "args": [
            "mp"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1272-1278",
          "snippet": "void\nxfs_log_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\tqueue_delayed_work(mp->m_log_workqueue, &mp->m_log->l_work,\n\t\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs * 10));\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\tqueue_delayed_work(mp->m_log_workqueue, &mp->m_log->l_work,\n\t\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs * 10));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_restore_resvblks",
          "args": [
            "mp"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_restore_resvblks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1141-1153",
          "snippet": "STATIC void\nxfs_restore_resvblks(struct xfs_mount *mp)\n{\n\t__uint64_t resblks;\n\n\tif (mp->m_resblks_save) {\n\t\tresblks = mp->m_resblks_save;\n\t\tmp->m_resblks_save = 0;\n\t} else\n\t\tresblks = xfs_default_resblks(mp);\n\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_restore_resvblks(struct xfs_mount *mp)\n{\n\t__uint64_t resblks;\n\n\tif (mp->m_resblks_save) {\n\t\tresblks = mp->m_resblks_save;\n\t\tmp->m_resblks_save = 0;\n\t} else\n\t\tresblks = xfs_default_resblks(mp);\n\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_fs_unfreeze(\n\tstruct super_block\t*sb)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\txfs_restore_resvblks(mp);\n\txfs_log_work_queue(mp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_fs_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1305-1314",
    "snippet": "STATIC int\nxfs_fs_freeze(\n\tstruct super_block\t*sb)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\txfs_save_resvblks(mp);\n\txfs_quiesce_attr(mp);\n\treturn xfs_sync_sb(mp, true);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sync_sb",
          "args": [
            "mp",
            "true"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sync_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "790-809",
          "snippet": "int\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_quiesce_attr",
          "args": [
            "mp"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_quiesce_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1166-1195",
          "snippet": "static void\nxfs_quiesce_attr(\n\tstruct xfs_mount\t*mp)\n{\n\tint\terror = 0;\n\n\t/* wait for all modifications to complete */\n\twhile (atomic_read(&mp->m_active_trans) > 0)\n\t\tdelay(100);\n\n\t/* force the log to unpin objects from the now complete transactions */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/* reclaim inodes to do any IO before the freeze completes */\n\txfs_reclaim_inodes(mp, 0);\n\txfs_reclaim_inodes(mp, SYNC_WAIT);\n\n\t/* Push the superblock and write an unmount record */\n\terror = xfs_log_sbcount(mp);\n\tif (error)\n\t\txfs_warn(mp, \"xfs_attr_quiesce: failed to log sb changes. \"\n\t\t\t\t\"Frozen image may not be consistent.\");\n\t/*\n\t * Just warn here till VFS can correctly support\n\t * read-only remount without racing.\n\t */\n\tWARN_ON(atomic_read(&mp->m_active_trans) != 0);\n\n\txfs_log_quiesce(mp);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_quiesce_attr(\n\tstruct xfs_mount\t*mp)\n{\n\tint\terror = 0;\n\n\t/* wait for all modifications to complete */\n\twhile (atomic_read(&mp->m_active_trans) > 0)\n\t\tdelay(100);\n\n\t/* force the log to unpin objects from the now complete transactions */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/* reclaim inodes to do any IO before the freeze completes */\n\txfs_reclaim_inodes(mp, 0);\n\txfs_reclaim_inodes(mp, SYNC_WAIT);\n\n\t/* Push the superblock and write an unmount record */\n\terror = xfs_log_sbcount(mp);\n\tif (error)\n\t\txfs_warn(mp, \"xfs_attr_quiesce: failed to log sb changes. \"\n\t\t\t\t\"Frozen image may not be consistent.\");\n\t/*\n\t * Just warn here till VFS can correctly support\n\t * read-only remount without racing.\n\t */\n\tWARN_ON(atomic_read(&mp->m_active_trans) != 0);\n\n\txfs_log_quiesce(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_save_resvblks",
          "args": [
            "mp"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_save_resvblks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1132-1139",
          "snippet": "STATIC void\nxfs_save_resvblks(struct xfs_mount *mp)\n{\n\t__uint64_t resblks = 0;\n\n\tmp->m_resblks_save = mp->m_resblks;\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_save_resvblks(struct xfs_mount *mp)\n{\n\t__uint64_t resblks = 0;\n\n\tmp->m_resblks_save = mp->m_resblks;\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_fs_freeze(\n\tstruct super_block\t*sb)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\txfs_save_resvblks(mp);\n\txfs_quiesce_attr(mp);\n\treturn xfs_sync_sb(mp, true);\n}"
  },
  {
    "function_name": "xfs_fs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1197-1297",
    "snippet": "STATIC int\nxfs_fs_remount(\n\tstruct super_block\t*sb,\n\tint\t\t\t*flags,\n\tchar\t\t\t*options)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\txfs_sb_t\t\t*sbp = &mp->m_sb;\n\tsubstring_t\t\targs[MAX_OPT_ARGS];\n\tchar\t\t\t*p;\n\tint\t\t\terror;\n\n\tsync_filesystem(sb);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_barrier:\n\t\t\tmp->m_flags |= XFS_MOUNT_BARRIER;\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tmp->m_flags &= ~XFS_MOUNT_BARRIER;\n\t\t\tbreak;\n\t\tcase Opt_inode64:\n\t\t\tmp->m_maxagi = xfs_set_inode64(mp, sbp->sb_agcount);\n\t\t\tbreak;\n\t\tcase Opt_inode32:\n\t\t\tmp->m_maxagi = xfs_set_inode32(mp, sbp->sb_agcount);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Logically we would return an error here to prevent\n\t\t\t * users from believing they might have changed\n\t\t\t * mount options using remount which can't be changed.\n\t\t\t *\n\t\t\t * But unfortunately mount(8) adds all options from\n\t\t\t * mtab and fstab to the mount arguments in some cases\n\t\t\t * so we can't blindly reject options, but have to\n\t\t\t * check for each specified option if it actually\n\t\t\t * differs from the currently set option and only\n\t\t\t * reject it if that's the case.\n\t\t\t *\n\t\t\t * Until that is implemented we return success for\n\t\t\t * every remount request, and silently ignore all\n\t\t\t * options that we can't actually change.\n\t\t\t */\n#if 0\n\t\t\txfs_info(mp,\n\t\t\"mount option \\\"%s\\\" not supported for remount\", p);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tbreak;\n#endif\n\t\t}\n\t}\n\n\t/* ro -> rw */\n\tif ((mp->m_flags & XFS_MOUNT_RDONLY) && !(*flags & MS_RDONLY)) {\n\t\tmp->m_flags &= ~XFS_MOUNT_RDONLY;\n\n\t\t/*\n\t\t * If this is the first remount to writeable state we\n\t\t * might have some superblock changes to update.\n\t\t */\n\t\tif (mp->m_update_sb) {\n\t\t\terror = xfs_sync_sb(mp, false);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp, \"failed to write sb changes\");\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tmp->m_update_sb = false;\n\t\t}\n\n\t\t/*\n\t\t * Fill out the reserve pool if it is empty. Use the stashed\n\t\t * value if it is non-zero, otherwise go with the default.\n\t\t */\n\t\txfs_restore_resvblks(mp);\n\t\txfs_log_work_queue(mp);\n\t}\n\n\t/* rw -> ro */\n\tif (!(mp->m_flags & XFS_MOUNT_RDONLY) && (*flags & MS_RDONLY)) {\n\t\t/*\n\t\t * Before we sync the metadata, we need to free up the reserve\n\t\t * block pool so that the used block count in the superblock on\n\t\t * disk is correct at the end of the remount. Stash the current\n\t\t * reserve pool size so that if we get remounted rw, we can\n\t\t * return it to the same size.\n\t\t */\n\t\txfs_save_resvblks(mp);\n\t\txfs_quiesce_attr(mp);\n\t\tmp->m_flags |= XFS_MOUNT_RDONLY;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_inode64, \"inode64\"},\n\t{Opt_inode32, \"inode32\"},\n\t{Opt_err, NULL}\n};",
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_quiesce_attr",
          "args": [
            "mp"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_quiesce_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1166-1195",
          "snippet": "static void\nxfs_quiesce_attr(\n\tstruct xfs_mount\t*mp)\n{\n\tint\terror = 0;\n\n\t/* wait for all modifications to complete */\n\twhile (atomic_read(&mp->m_active_trans) > 0)\n\t\tdelay(100);\n\n\t/* force the log to unpin objects from the now complete transactions */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/* reclaim inodes to do any IO before the freeze completes */\n\txfs_reclaim_inodes(mp, 0);\n\txfs_reclaim_inodes(mp, SYNC_WAIT);\n\n\t/* Push the superblock and write an unmount record */\n\terror = xfs_log_sbcount(mp);\n\tif (error)\n\t\txfs_warn(mp, \"xfs_attr_quiesce: failed to log sb changes. \"\n\t\t\t\t\"Frozen image may not be consistent.\");\n\t/*\n\t * Just warn here till VFS can correctly support\n\t * read-only remount without racing.\n\t */\n\tWARN_ON(atomic_read(&mp->m_active_trans) != 0);\n\n\txfs_log_quiesce(mp);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_quiesce_attr(\n\tstruct xfs_mount\t*mp)\n{\n\tint\terror = 0;\n\n\t/* wait for all modifications to complete */\n\twhile (atomic_read(&mp->m_active_trans) > 0)\n\t\tdelay(100);\n\n\t/* force the log to unpin objects from the now complete transactions */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/* reclaim inodes to do any IO before the freeze completes */\n\txfs_reclaim_inodes(mp, 0);\n\txfs_reclaim_inodes(mp, SYNC_WAIT);\n\n\t/* Push the superblock and write an unmount record */\n\terror = xfs_log_sbcount(mp);\n\tif (error)\n\t\txfs_warn(mp, \"xfs_attr_quiesce: failed to log sb changes. \"\n\t\t\t\t\"Frozen image may not be consistent.\");\n\t/*\n\t * Just warn here till VFS can correctly support\n\t * read-only remount without racing.\n\t */\n\tWARN_ON(atomic_read(&mp->m_active_trans) != 0);\n\n\txfs_log_quiesce(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_save_resvblks",
          "args": [
            "mp"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_save_resvblks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1132-1139",
          "snippet": "STATIC void\nxfs_save_resvblks(struct xfs_mount *mp)\n{\n\t__uint64_t resblks = 0;\n\n\tmp->m_resblks_save = mp->m_resblks;\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_save_resvblks(struct xfs_mount *mp)\n{\n\t__uint64_t resblks = 0;\n\n\tmp->m_resblks_save = mp->m_resblks;\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_work_queue",
          "args": [
            "mp"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1272-1278",
          "snippet": "void\nxfs_log_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\tqueue_delayed_work(mp->m_log_workqueue, &mp->m_log->l_work,\n\t\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs * 10));\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\tqueue_delayed_work(mp->m_log_workqueue, &mp->m_log->l_work,\n\t\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs * 10));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_restore_resvblks",
          "args": [
            "mp"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_restore_resvblks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1141-1153",
          "snippet": "STATIC void\nxfs_restore_resvblks(struct xfs_mount *mp)\n{\n\t__uint64_t resblks;\n\n\tif (mp->m_resblks_save) {\n\t\tresblks = mp->m_resblks_save;\n\t\tmp->m_resblks_save = 0;\n\t} else\n\t\tresblks = xfs_default_resblks(mp);\n\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_restore_resvblks(struct xfs_mount *mp)\n{\n\t__uint64_t resblks;\n\n\tif (mp->m_resblks_save) {\n\t\tresblks = mp->m_resblks_save;\n\t\tmp->m_resblks_save = 0;\n\t} else\n\t\tresblks = xfs_default_resblks(mp);\n\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"failed to write sb changes\""
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sync_sb",
          "args": [
            "mp",
            "false"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sync_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "790-809",
          "snippet": "int\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_info",
          "args": [
            "mp",
            "\"mount option \\\"%s\\\" not supported for remount\"",
            "p"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_set_inode32",
          "args": [
            "mp",
            "sbp->sb_agcount"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_inode32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "600-650",
          "snippet": "xfs_agnumber_t\nxfs_set_inode32(struct xfs_mount *mp, xfs_agnumber_t agcount)\n{\n\txfs_agnumber_t\tindex = 0;\n\txfs_agnumber_t\tmaxagi = 0;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\txfs_agnumber_t\tmax_metadata;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\txfs_perag_t\t*pag;\n\n\t/* Calculate how much should be reserved for inodes to meet\n\t * the max inode percentage.\n\t */\n\tif (mp->m_maxicount) {\n\t\t__uint64_t\ticount;\n\n\t\ticount = sbp->sb_dblocks * sbp->sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\ticount += sbp->sb_agblocks - 1;\n\t\tdo_div(icount, sbp->sb_agblocks);\n\t\tmax_metadata = icount;\n\t} else {\n\t\tmax_metadata = agcount;\n\t}\n\n\tagino =\tXFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tino = XFS_AGINO_TO_INO(mp, index, agino);\n\n\t\tif (ino > XFS_MAXINUMBER_32) {\n\t\t\tpag = xfs_perag_get(mp, index);\n\t\t\tpag->pagi_inodeok = 0;\n\t\t\tpag->pagf_metadata = 0;\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tpag->pagi_inodeok = 1;\n\t\tmaxagi++;\n\t\tif (index < max_metadata)\n\t\t\tpag->pagf_metadata = 1;\n\t\txfs_perag_put(pag);\n\t}\n\tmp->m_flags |= (XFS_MOUNT_32BITINODES |\n\t\t\tXFS_MOUNT_SMALL_INUMS);\n\n\treturn maxagi;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_agnumber_t\nxfs_set_inode32(struct xfs_mount *mp, xfs_agnumber_t agcount)\n{\n\txfs_agnumber_t\tindex = 0;\n\txfs_agnumber_t\tmaxagi = 0;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\txfs_agnumber_t\tmax_metadata;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\txfs_perag_t\t*pag;\n\n\t/* Calculate how much should be reserved for inodes to meet\n\t * the max inode percentage.\n\t */\n\tif (mp->m_maxicount) {\n\t\t__uint64_t\ticount;\n\n\t\ticount = sbp->sb_dblocks * sbp->sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\ticount += sbp->sb_agblocks - 1;\n\t\tdo_div(icount, sbp->sb_agblocks);\n\t\tmax_metadata = icount;\n\t} else {\n\t\tmax_metadata = agcount;\n\t}\n\n\tagino =\tXFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tino = XFS_AGINO_TO_INO(mp, index, agino);\n\n\t\tif (ino > XFS_MAXINUMBER_32) {\n\t\t\tpag = xfs_perag_get(mp, index);\n\t\t\tpag->pagi_inodeok = 0;\n\t\t\tpag->pagf_metadata = 0;\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tpag->pagi_inodeok = 1;\n\t\tmaxagi++;\n\t\tif (index < max_metadata)\n\t\t\tpag->pagf_metadata = 1;\n\t\txfs_perag_put(pag);\n\t}\n\tmp->m_flags |= (XFS_MOUNT_32BITINODES |\n\t\t\tXFS_MOUNT_SMALL_INUMS);\n\n\treturn maxagi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_inode64",
          "args": [
            "mp",
            "sbp->sb_agcount"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_inode64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "652-674",
          "snippet": "xfs_agnumber_t\nxfs_set_inode64(struct xfs_mount *mp, xfs_agnumber_t agcount)\n{\n\txfs_agnumber_t index = 0;\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tstruct xfs_perag\t*pag;\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tpag->pagi_inodeok = 1;\n\t\tpag->pagf_metadata = 0;\n\t\txfs_perag_put(pag);\n\t}\n\n\t/* There is no need for lock protection on m_flags,\n\t * the rw_semaphore of the VFS superblock is locked\n\t * during mount/umount/remount operations, so this is\n\t * enough to avoid concurency on the m_flags field\n\t */\n\tmp->m_flags &= ~(XFS_MOUNT_32BITINODES |\n\t\t\t XFS_MOUNT_SMALL_INUMS);\n\treturn index;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_agnumber_t\nxfs_set_inode64(struct xfs_mount *mp, xfs_agnumber_t agcount)\n{\n\txfs_agnumber_t index = 0;\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tstruct xfs_perag\t*pag;\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tpag->pagi_inodeok = 1;\n\t\tpag->pagf_metadata = 0;\n\t\txfs_perag_put(pag);\n\t}\n\n\t/* There is no need for lock protection on m_flags,\n\t * the rw_semaphore of the VFS superblock is locked\n\t * during mount/umount/remount operations, so this is\n\t * enough to avoid concurency on the m_flags field\n\t */\n\tmp->m_flags &= ~(XFS_MOUNT_32BITINODES |\n\t\t\t XFS_MOUNT_SMALL_INUMS);\n\treturn index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nstatic const match_table_t tokens = {\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_inode64, \"inode64\"},\n\t{Opt_inode32, \"inode32\"},\n\t{Opt_err, NULL}\n};\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_fs_remount(\n\tstruct super_block\t*sb,\n\tint\t\t\t*flags,\n\tchar\t\t\t*options)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\txfs_sb_t\t\t*sbp = &mp->m_sb;\n\tsubstring_t\t\targs[MAX_OPT_ARGS];\n\tchar\t\t\t*p;\n\tint\t\t\terror;\n\n\tsync_filesystem(sb);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_barrier:\n\t\t\tmp->m_flags |= XFS_MOUNT_BARRIER;\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tmp->m_flags &= ~XFS_MOUNT_BARRIER;\n\t\t\tbreak;\n\t\tcase Opt_inode64:\n\t\t\tmp->m_maxagi = xfs_set_inode64(mp, sbp->sb_agcount);\n\t\t\tbreak;\n\t\tcase Opt_inode32:\n\t\t\tmp->m_maxagi = xfs_set_inode32(mp, sbp->sb_agcount);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Logically we would return an error here to prevent\n\t\t\t * users from believing they might have changed\n\t\t\t * mount options using remount which can't be changed.\n\t\t\t *\n\t\t\t * But unfortunately mount(8) adds all options from\n\t\t\t * mtab and fstab to the mount arguments in some cases\n\t\t\t * so we can't blindly reject options, but have to\n\t\t\t * check for each specified option if it actually\n\t\t\t * differs from the currently set option and only\n\t\t\t * reject it if that's the case.\n\t\t\t *\n\t\t\t * Until that is implemented we return success for\n\t\t\t * every remount request, and silently ignore all\n\t\t\t * options that we can't actually change.\n\t\t\t */\n#if 0\n\t\t\txfs_info(mp,\n\t\t\"mount option \\\"%s\\\" not supported for remount\", p);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tbreak;\n#endif\n\t\t}\n\t}\n\n\t/* ro -> rw */\n\tif ((mp->m_flags & XFS_MOUNT_RDONLY) && !(*flags & MS_RDONLY)) {\n\t\tmp->m_flags &= ~XFS_MOUNT_RDONLY;\n\n\t\t/*\n\t\t * If this is the first remount to writeable state we\n\t\t * might have some superblock changes to update.\n\t\t */\n\t\tif (mp->m_update_sb) {\n\t\t\terror = xfs_sync_sb(mp, false);\n\t\t\tif (error) {\n\t\t\t\txfs_warn(mp, \"failed to write sb changes\");\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tmp->m_update_sb = false;\n\t\t}\n\n\t\t/*\n\t\t * Fill out the reserve pool if it is empty. Use the stashed\n\t\t * value if it is non-zero, otherwise go with the default.\n\t\t */\n\t\txfs_restore_resvblks(mp);\n\t\txfs_log_work_queue(mp);\n\t}\n\n\t/* rw -> ro */\n\tif (!(mp->m_flags & XFS_MOUNT_RDONLY) && (*flags & MS_RDONLY)) {\n\t\t/*\n\t\t * Before we sync the metadata, we need to free up the reserve\n\t\t * block pool so that the used block count in the superblock on\n\t\t * disk is correct at the end of the remount. Stash the current\n\t\t * reserve pool size so that if we get remounted rw, we can\n\t\t * return it to the same size.\n\t\t */\n\t\txfs_save_resvblks(mp);\n\t\txfs_quiesce_attr(mp);\n\t\tmp->m_flags |= XFS_MOUNT_RDONLY;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_quiesce_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1166-1195",
    "snippet": "static void\nxfs_quiesce_attr(\n\tstruct xfs_mount\t*mp)\n{\n\tint\terror = 0;\n\n\t/* wait for all modifications to complete */\n\twhile (atomic_read(&mp->m_active_trans) > 0)\n\t\tdelay(100);\n\n\t/* force the log to unpin objects from the now complete transactions */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/* reclaim inodes to do any IO before the freeze completes */\n\txfs_reclaim_inodes(mp, 0);\n\txfs_reclaim_inodes(mp, SYNC_WAIT);\n\n\t/* Push the superblock and write an unmount record */\n\terror = xfs_log_sbcount(mp);\n\tif (error)\n\t\txfs_warn(mp, \"xfs_attr_quiesce: failed to log sb changes. \"\n\t\t\t\t\"Frozen image may not be consistent.\");\n\t/*\n\t * Just warn here till VFS can correctly support\n\t * read-only remount without racing.\n\t */\n\tWARN_ON(atomic_read(&mp->m_active_trans) != 0);\n\n\txfs_log_quiesce(mp);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_log_quiesce",
          "args": [
            "mp"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_quiesce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "919-939",
          "snippet": "void\nxfs_log_quiesce(\n\tstruct xfs_mount\t*mp)\n{\n\tcancel_delayed_work_sync(&mp->m_log->l_work);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * The superblock buffer is uncached and while xfs_ail_push_all_sync()\n\t * will push it, xfs_wait_buftarg() will not wait for it. Further,\n\t * xfs_buf_iowait() cannot be used because it was pushed with the\n\t * XBF_ASYNC flag set, so we need to use a lock/unlock pair to wait for\n\t * the IO to complete.\n\t */\n\txfs_ail_push_all_sync(mp->m_ail);\n\txfs_wait_buftarg(mp->m_ddev_targp);\n\txfs_buf_lock(mp->m_sb_bp);\n\txfs_buf_unlock(mp->m_sb_bp);\n\n\txfs_log_unmount_write(mp);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_quiesce(\n\tstruct xfs_mount\t*mp)\n{\n\tcancel_delayed_work_sync(&mp->m_log->l_work);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * The superblock buffer is uncached and while xfs_ail_push_all_sync()\n\t * will push it, xfs_wait_buftarg() will not wait for it. Further,\n\t * xfs_buf_iowait() cannot be used because it was pushed with the\n\t * XBF_ASYNC flag set, so we need to use a lock/unlock pair to wait for\n\t * the IO to complete.\n\t */\n\txfs_ail_push_all_sync(mp->m_ail);\n\txfs_wait_buftarg(mp->m_ddev_targp);\n\txfs_buf_lock(mp->m_sb_bp);\n\txfs_buf_unlock(mp->m_sb_bp);\n\n\txfs_log_unmount_write(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&mp->m_active_trans) != 0"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mp->m_active_trans"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"xfs_attr_quiesce: failed to log sb changes. \"\n\t\t\t\t\"Frozen image may not be consistent.\""
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_sbcount",
          "args": [
            "mp"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_sbcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1083-1100",
          "snippet": "int\nxfs_log_sbcount(xfs_mount_t *mp)\n{\n\t/* allow this to proceed during the freeze sequence... */\n\tif (!xfs_fs_writable(mp, SB_FREEZE_COMPLETE))\n\t\treturn 0;\n\n\txfs_icsb_sync_counters(mp, 0);\n\n\t/*\n\t * we don't need to do this if we are updating the superblock\n\t * counters on every modification.\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, true);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_log_sbcount(xfs_mount_t *mp)\n{\n\t/* allow this to proceed during the freeze sequence... */\n\tif (!xfs_fs_writable(mp, SB_FREEZE_COMPLETE))\n\t\treturn 0;\n\n\txfs_icsb_sync_counters(mp, 0);\n\n\t/*\n\t * we don't need to do this if we are updating the superblock\n\t * counters on every modification.\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_reclaim_inodes",
          "args": [
            "mp",
            "SYNC_WAIT"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reclaim_inodes_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1156-1166",
          "snippet": "long\nxfs_reclaim_inodes_nr(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tnr_to_scan)\n{\n\t/* kick background reclaimer and push the AIL */\n\txfs_reclaim_work_queue(mp);\n\txfs_ail_push_all(mp->m_ail);\n\n\treturn xfs_reclaim_inodes_ag(mp, SYNC_TRYLOCK | SYNC_WAIT, &nr_to_scan);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nlong\nxfs_reclaim_inodes_nr(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tnr_to_scan)\n{\n\t/* kick background reclaimer and push the AIL */\n\txfs_reclaim_work_queue(mp);\n\txfs_ail_push_all(mp->m_ail);\n\n\treturn xfs_reclaim_inodes_ag(mp, SYNC_TRYLOCK | SYNC_WAIT, &nr_to_scan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "mp",
            "XFS_LOG_SYNC"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "181-184",
          "snippet": "static inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mp->m_active_trans"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_quiesce_attr(\n\tstruct xfs_mount\t*mp)\n{\n\tint\terror = 0;\n\n\t/* wait for all modifications to complete */\n\twhile (atomic_read(&mp->m_active_trans) > 0)\n\t\tdelay(100);\n\n\t/* force the log to unpin objects from the now complete transactions */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/* reclaim inodes to do any IO before the freeze completes */\n\txfs_reclaim_inodes(mp, 0);\n\txfs_reclaim_inodes(mp, SYNC_WAIT);\n\n\t/* Push the superblock and write an unmount record */\n\terror = xfs_log_sbcount(mp);\n\tif (error)\n\t\txfs_warn(mp, \"xfs_attr_quiesce: failed to log sb changes. \"\n\t\t\t\t\"Frozen image may not be consistent.\");\n\t/*\n\t * Just warn here till VFS can correctly support\n\t * read-only remount without racing.\n\t */\n\tWARN_ON(atomic_read(&mp->m_active_trans) != 0);\n\n\txfs_log_quiesce(mp);\n}"
  },
  {
    "function_name": "xfs_restore_resvblks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1141-1153",
    "snippet": "STATIC void\nxfs_restore_resvblks(struct xfs_mount *mp)\n{\n\t__uint64_t resblks;\n\n\tif (mp->m_resblks_save) {\n\t\tresblks = mp->m_resblks_save;\n\t\tmp->m_resblks_save = 0;\n\t} else\n\t\tresblks = xfs_default_resblks(mp);\n\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_reserve_blocks",
          "args": [
            "mp",
            "&resblks",
            "NULL"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reserve_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "665-764",
          "snippet": "int\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\t__uint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\t__int64_t\t\tlcounter, delta, fdblks_delta;\n\t__uint64_t\t\trequest;\n\n\t/* If inval is null, report current values and return */\n\tif (inval == (__uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t/*\n\t * With per-cpu counters, this becomes an interesting\n\t * problem. we needto work out if we are freeing or allocation\n\t * blocks first, then we can do the modification as necessary.\n\t *\n\t * We do this under the m_sb_lock so that if we are near\n\t * ENOSPC, we will hold out any changes while we work out\n\t * what to do. This means that the amount of free space can\n\t * change while we do this, so we need to retry if we end up\n\t * trying to reserve more space than is available.\n\t *\n\t * We also use the xfs_mod_incore_sb() interface so that we\n\t * don't have to care about whether per cpu counter are\n\t * enabled, disabled or even compiled in....\n\t */\nretry:\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, 0);\n\n\t/*\n\t * If our previous reservation was larger than the current value,\n\t * then move any unused blocks back to the free pool.\n\t */\n\tfdblks_delta = 0;\n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t/* release unused blocks */\n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t} else {\n\t\t__int64_t\tfree;\n\n\t\tfree =  mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tif (!free)\n\t\t\tgoto out; /* ENOSPC and fdblks_delta = 0 */\n\n\t\tdelta = request - mp->m_resblks;\n\t\tlcounter = free - delta;\n\t\tif (lcounter < 0) {\n\t\t\t/* We can't satisfy the request, just get what we can */\n\t\t\tmp->m_resblks += free;\n\t\t\tmp->m_resblks_avail += free;\n\t\t\tfdblks_delta = -free;\n\t\t} else {\n\t\t\tfdblks_delta = -delta;\n\t\t\tmp->m_resblks = request;\n\t\t\tmp->m_resblks_avail += delta;\n\t\t}\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (fdblks_delta) {\n\t\t/*\n\t\t * If we are putting blocks back here, m_resblks_avail is\n\t\t * already at its max so this will put it in the free pool.\n\t\t *\n\t\t * If we need space, we'll either succeed in getting it\n\t\t * from the free block count or we'll get an enospc. If\n\t\t * we get a ENOSPC, it means things changed while we were\n\t\t * calculating fdblks_delta and so we should try again to\n\t\t * see if there is anything left to reserve.\n\t\t *\n\t\t * Don't set the reserved flag here - we don't want to reserve\n\t\t * the extra reserve blocks from the reserve.....\n\t\t */\n\t\tint error;\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t fdblks_delta, 0);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto retry;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\t__uint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\t__int64_t\t\tlcounter, delta, fdblks_delta;\n\t__uint64_t\t\trequest;\n\n\t/* If inval is null, report current values and return */\n\tif (inval == (__uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t/*\n\t * With per-cpu counters, this becomes an interesting\n\t * problem. we needto work out if we are freeing or allocation\n\t * blocks first, then we can do the modification as necessary.\n\t *\n\t * We do this under the m_sb_lock so that if we are near\n\t * ENOSPC, we will hold out any changes while we work out\n\t * what to do. This means that the amount of free space can\n\t * change while we do this, so we need to retry if we end up\n\t * trying to reserve more space than is available.\n\t *\n\t * We also use the xfs_mod_incore_sb() interface so that we\n\t * don't have to care about whether per cpu counter are\n\t * enabled, disabled or even compiled in....\n\t */\nretry:\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, 0);\n\n\t/*\n\t * If our previous reservation was larger than the current value,\n\t * then move any unused blocks back to the free pool.\n\t */\n\tfdblks_delta = 0;\n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t/* release unused blocks */\n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t} else {\n\t\t__int64_t\tfree;\n\n\t\tfree =  mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tif (!free)\n\t\t\tgoto out; /* ENOSPC and fdblks_delta = 0 */\n\n\t\tdelta = request - mp->m_resblks;\n\t\tlcounter = free - delta;\n\t\tif (lcounter < 0) {\n\t\t\t/* We can't satisfy the request, just get what we can */\n\t\t\tmp->m_resblks += free;\n\t\t\tmp->m_resblks_avail += free;\n\t\t\tfdblks_delta = -free;\n\t\t} else {\n\t\t\tfdblks_delta = -delta;\n\t\t\tmp->m_resblks = request;\n\t\t\tmp->m_resblks_avail += delta;\n\t\t}\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (fdblks_delta) {\n\t\t/*\n\t\t * If we are putting blocks back here, m_resblks_avail is\n\t\t * already at its max so this will put it in the free pool.\n\t\t *\n\t\t * If we need space, we'll either succeed in getting it\n\t\t * from the free block count or we'll get an enospc. If\n\t\t * we get a ENOSPC, it means things changed while we were\n\t\t * calculating fdblks_delta and so we should try again to\n\t\t * see if there is anything left to reserve.\n\t\t *\n\t\t * Don't set the reserved flag here - we don't want to reserve\n\t\t * the extra reserve blocks from the reserve.....\n\t\t */\n\t\tint error;\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t fdblks_delta, 0);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto retry;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_default_resblks",
          "args": [
            "mp"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_default_resblks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "601-617",
          "snippet": "__uint64_t\nxfs_default_resblks(xfs_mount_t *mp)\n{\n\t__uint64_t resblks;\n\n\t/*\n\t * We default to 5% or 8192 fsbs of space reserved, whichever is\n\t * smaller.  This is intended to cover concurrent allocation\n\t * transactions when we initially hit enospc. These each require a 4\n\t * block reservation. Hence by default we cover roughly 2000 concurrent\n\t * allocation reservations.\n\t */\n\tresblks = mp->m_sb.sb_dblocks;\n\tdo_div(resblks, 20);\n\tresblks = min_t(__uint64_t, resblks, 8192);\n\treturn resblks;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n__uint64_t\nxfs_default_resblks(xfs_mount_t *mp)\n{\n\t__uint64_t resblks;\n\n\t/*\n\t * We default to 5% or 8192 fsbs of space reserved, whichever is\n\t * smaller.  This is intended to cover concurrent allocation\n\t * transactions when we initially hit enospc. These each require a 4\n\t * block reservation. Hence by default we cover roughly 2000 concurrent\n\t * allocation reservations.\n\t */\n\tresblks = mp->m_sb.sb_dblocks;\n\tdo_div(resblks, 20);\n\tresblks = min_t(__uint64_t, resblks, 8192);\n\treturn resblks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_restore_resvblks(struct xfs_mount *mp)\n{\n\t__uint64_t resblks;\n\n\tif (mp->m_resblks_save) {\n\t\tresblks = mp->m_resblks_save;\n\t\tmp->m_resblks_save = 0;\n\t} else\n\t\tresblks = xfs_default_resblks(mp);\n\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}"
  },
  {
    "function_name": "xfs_save_resvblks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1132-1139",
    "snippet": "STATIC void\nxfs_save_resvblks(struct xfs_mount *mp)\n{\n\t__uint64_t resblks = 0;\n\n\tmp->m_resblks_save = mp->m_resblks;\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_reserve_blocks",
          "args": [
            "mp",
            "&resblks",
            "NULL"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reserve_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "665-764",
          "snippet": "int\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\t__uint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\t__int64_t\t\tlcounter, delta, fdblks_delta;\n\t__uint64_t\t\trequest;\n\n\t/* If inval is null, report current values and return */\n\tif (inval == (__uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t/*\n\t * With per-cpu counters, this becomes an interesting\n\t * problem. we needto work out if we are freeing or allocation\n\t * blocks first, then we can do the modification as necessary.\n\t *\n\t * We do this under the m_sb_lock so that if we are near\n\t * ENOSPC, we will hold out any changes while we work out\n\t * what to do. This means that the amount of free space can\n\t * change while we do this, so we need to retry if we end up\n\t * trying to reserve more space than is available.\n\t *\n\t * We also use the xfs_mod_incore_sb() interface so that we\n\t * don't have to care about whether per cpu counter are\n\t * enabled, disabled or even compiled in....\n\t */\nretry:\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, 0);\n\n\t/*\n\t * If our previous reservation was larger than the current value,\n\t * then move any unused blocks back to the free pool.\n\t */\n\tfdblks_delta = 0;\n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t/* release unused blocks */\n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t} else {\n\t\t__int64_t\tfree;\n\n\t\tfree =  mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tif (!free)\n\t\t\tgoto out; /* ENOSPC and fdblks_delta = 0 */\n\n\t\tdelta = request - mp->m_resblks;\n\t\tlcounter = free - delta;\n\t\tif (lcounter < 0) {\n\t\t\t/* We can't satisfy the request, just get what we can */\n\t\t\tmp->m_resblks += free;\n\t\t\tmp->m_resblks_avail += free;\n\t\t\tfdblks_delta = -free;\n\t\t} else {\n\t\t\tfdblks_delta = -delta;\n\t\t\tmp->m_resblks = request;\n\t\t\tmp->m_resblks_avail += delta;\n\t\t}\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (fdblks_delta) {\n\t\t/*\n\t\t * If we are putting blocks back here, m_resblks_avail is\n\t\t * already at its max so this will put it in the free pool.\n\t\t *\n\t\t * If we need space, we'll either succeed in getting it\n\t\t * from the free block count or we'll get an enospc. If\n\t\t * we get a ENOSPC, it means things changed while we were\n\t\t * calculating fdblks_delta and so we should try again to\n\t\t * see if there is anything left to reserve.\n\t\t *\n\t\t * Don't set the reserved flag here - we don't want to reserve\n\t\t * the extra reserve blocks from the reserve.....\n\t\t */\n\t\tint error;\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t fdblks_delta, 0);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto retry;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\t__uint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\t__int64_t\t\tlcounter, delta, fdblks_delta;\n\t__uint64_t\t\trequest;\n\n\t/* If inval is null, report current values and return */\n\tif (inval == (__uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t/*\n\t * With per-cpu counters, this becomes an interesting\n\t * problem. we needto work out if we are freeing or allocation\n\t * blocks first, then we can do the modification as necessary.\n\t *\n\t * We do this under the m_sb_lock so that if we are near\n\t * ENOSPC, we will hold out any changes while we work out\n\t * what to do. This means that the amount of free space can\n\t * change while we do this, so we need to retry if we end up\n\t * trying to reserve more space than is available.\n\t *\n\t * We also use the xfs_mod_incore_sb() interface so that we\n\t * don't have to care about whether per cpu counter are\n\t * enabled, disabled or even compiled in....\n\t */\nretry:\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, 0);\n\n\t/*\n\t * If our previous reservation was larger than the current value,\n\t * then move any unused blocks back to the free pool.\n\t */\n\tfdblks_delta = 0;\n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t/* release unused blocks */\n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t} else {\n\t\t__int64_t\tfree;\n\n\t\tfree =  mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tif (!free)\n\t\t\tgoto out; /* ENOSPC and fdblks_delta = 0 */\n\n\t\tdelta = request - mp->m_resblks;\n\t\tlcounter = free - delta;\n\t\tif (lcounter < 0) {\n\t\t\t/* We can't satisfy the request, just get what we can */\n\t\t\tmp->m_resblks += free;\n\t\t\tmp->m_resblks_avail += free;\n\t\t\tfdblks_delta = -free;\n\t\t} else {\n\t\t\tfdblks_delta = -delta;\n\t\t\tmp->m_resblks = request;\n\t\t\tmp->m_resblks_avail += delta;\n\t\t}\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (fdblks_delta) {\n\t\t/*\n\t\t * If we are putting blocks back here, m_resblks_avail is\n\t\t * already at its max so this will put it in the free pool.\n\t\t *\n\t\t * If we need space, we'll either succeed in getting it\n\t\t * from the free block count or we'll get an enospc. If\n\t\t * we get a ENOSPC, it means things changed while we were\n\t\t * calculating fdblks_delta and so we should try again to\n\t\t * see if there is anything left to reserve.\n\t\t *\n\t\t * Don't set the reserved flag here - we don't want to reserve\n\t\t * the extra reserve blocks from the reserve.....\n\t\t */\n\t\tint error;\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t fdblks_delta, 0);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto retry;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_save_resvblks(struct xfs_mount *mp)\n{\n\t__uint64_t resblks = 0;\n\n\tmp->m_resblks_save = mp->m_resblks;\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}"
  },
  {
    "function_name": "xfs_fs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1079-1130",
    "snippet": "STATIC int\nxfs_fs_statfs(\n\tstruct dentry\t\t*dentry,\n\tstruct kstatfs\t\t*statp)\n{\n\tstruct xfs_mount\t*mp = XFS_M(dentry->d_sb);\n\txfs_sb_t\t\t*sbp = &mp->m_sb;\n\tstruct xfs_inode\t*ip = XFS_I(dentry->d_inode);\n\t__uint64_t\t\tfakeinos, id;\n\txfs_extlen_t\t\tlsize;\n\t__int64_t\t\tffree;\n\n\tstatp->f_type = XFS_SB_MAGIC;\n\tstatp->f_namelen = MAXNAMELEN - 1;\n\n\tid = huge_encode_dev(mp->m_ddev_targp->bt_dev);\n\tstatp->f_fsid.val[0] = (u32)id;\n\tstatp->f_fsid.val[1] = (u32)(id >> 32);\n\n\txfs_icsb_sync_counters(mp, XFS_ICSB_LAZY_COUNT);\n\n\tspin_lock(&mp->m_sb_lock);\n\tstatp->f_bsize = sbp->sb_blocksize;\n\tlsize = sbp->sb_logstart ? sbp->sb_logblocks : 0;\n\tstatp->f_blocks = sbp->sb_dblocks - lsize;\n\tstatp->f_bfree = statp->f_bavail =\n\t\t\t\tsbp->sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\tfakeinos = statp->f_bfree << sbp->sb_inopblog;\n\tstatp->f_files =\n\t    MIN(sbp->sb_icount + fakeinos, (__uint64_t)XFS_MAXINUMBER);\n\tif (mp->m_maxicount)\n\t\tstatp->f_files = min_t(typeof(statp->f_files),\n\t\t\t\t\tstatp->f_files,\n\t\t\t\t\tmp->m_maxicount);\n\n\t/* If sb_icount overshot maxicount, report actual allocation */\n\tstatp->f_files = max_t(typeof(statp->f_files),\n\t\t\t\t\tstatp->f_files,\n\t\t\t\t\tsbp->sb_icount);\n\n\t/* make sure statp->f_ffree does not underflow */\n\tffree = statp->f_files - (sbp->sb_icount - sbp->sb_ifree);\n\tstatp->f_ffree = max_t(__int64_t, ffree, 0);\n\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\n\t    ((mp->m_qflags & (XFS_PQUOTA_ACCT|XFS_PQUOTA_ENFD))) ==\n\t\t\t      (XFS_PQUOTA_ACCT|XFS_PQUOTA_ENFD))\n\t\txfs_qm_statvfs(ip, statp);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_statvfs",
          "args": [
            "ip",
            "statp"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_statvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_bhv.c",
          "lines": "67-79",
          "snippet": "void\nxfs_qm_statvfs(\n\txfs_inode_t\t\t*ip,\n\tstruct kstatfs\t\t*statp)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_dquot_t\t\t*dqp;\n\n\tif (!xfs_qm_dqget(mp, NULL, xfs_get_projid(ip), XFS_DQ_PROJ, 0, &dqp)) {\n\t\txfs_fill_statvfs_from_dquot(statp, dqp);\n\t\txfs_qm_dqput(dqp);\n\t}\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_statvfs(\n\txfs_inode_t\t\t*ip,\n\tstruct kstatfs\t\t*statp)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_dquot_t\t\t*dqp;\n\n\tif (!xfs_qm_dqget(mp, NULL, xfs_get_projid(ip), XFS_DQ_PROJ, 0, &dqp)) {\n\t\txfs_fill_statvfs_from_dquot(statp, dqp);\n\t\txfs_qm_dqput(dqp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "__int64_t",
            "ffree",
            "0"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "typeof(statp->f_files)",
            "statp->f_files",
            "sbp->sb_icount"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "statp->f_files"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "typeof(statp->f_files)",
            "statp->f_files",
            "mp->m_maxicount"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "statp->f_files"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "sbp->sb_icount + fakeinos",
            "(__uint64_t)XFS_MAXINUMBER"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_SET_ASIDE",
          "args": [
            "mp"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_sync_counters",
          "args": [
            "mp",
            "XFS_ICSB_LAZY_COUNT"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_sync_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1764-1772",
          "snippet": "void\nxfs_icsb_sync_counters(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, flags);\n\tspin_unlock(&mp->m_sb_lock);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_sync_counters(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, flags);\n\tspin_unlock(&mp->m_sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "mp->m_ddev_targp->bt_dev"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "dentry->d_sb"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_fs_statfs(\n\tstruct dentry\t\t*dentry,\n\tstruct kstatfs\t\t*statp)\n{\n\tstruct xfs_mount\t*mp = XFS_M(dentry->d_sb);\n\txfs_sb_t\t\t*sbp = &mp->m_sb;\n\tstruct xfs_inode\t*ip = XFS_I(dentry->d_inode);\n\t__uint64_t\t\tfakeinos, id;\n\txfs_extlen_t\t\tlsize;\n\t__int64_t\t\tffree;\n\n\tstatp->f_type = XFS_SB_MAGIC;\n\tstatp->f_namelen = MAXNAMELEN - 1;\n\n\tid = huge_encode_dev(mp->m_ddev_targp->bt_dev);\n\tstatp->f_fsid.val[0] = (u32)id;\n\tstatp->f_fsid.val[1] = (u32)(id >> 32);\n\n\txfs_icsb_sync_counters(mp, XFS_ICSB_LAZY_COUNT);\n\n\tspin_lock(&mp->m_sb_lock);\n\tstatp->f_bsize = sbp->sb_blocksize;\n\tlsize = sbp->sb_logstart ? sbp->sb_logblocks : 0;\n\tstatp->f_blocks = sbp->sb_dblocks - lsize;\n\tstatp->f_bfree = statp->f_bavail =\n\t\t\t\tsbp->sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\tfakeinos = statp->f_bfree << sbp->sb_inopblog;\n\tstatp->f_files =\n\t    MIN(sbp->sb_icount + fakeinos, (__uint64_t)XFS_MAXINUMBER);\n\tif (mp->m_maxicount)\n\t\tstatp->f_files = min_t(typeof(statp->f_files),\n\t\t\t\t\tstatp->f_files,\n\t\t\t\t\tmp->m_maxicount);\n\n\t/* If sb_icount overshot maxicount, report actual allocation */\n\tstatp->f_files = max_t(typeof(statp->f_files),\n\t\t\t\t\tstatp->f_files,\n\t\t\t\t\tsbp->sb_icount);\n\n\t/* make sure statp->f_ffree does not underflow */\n\tffree = statp->f_files - (sbp->sb_icount - sbp->sb_ifree);\n\tstatp->f_ffree = max_t(__int64_t, ffree, 0);\n\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\n\t    ((mp->m_qflags & (XFS_PQUOTA_ACCT|XFS_PQUOTA_ENFD))) ==\n\t\t\t      (XFS_PQUOTA_ACCT|XFS_PQUOTA_ENFD))\n\t\txfs_qm_statvfs(ip, statp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_fs_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1053-1077",
    "snippet": "STATIC int\nxfs_fs_sync_fs(\n\tstruct super_block\t*sb,\n\tint\t\t\twait)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\t/*\n\t * Doing anything during the async pass would be counterproductive.\n\t */\n\tif (!wait)\n\t\treturn 0;\n\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\tif (laptop_mode) {\n\t\t/*\n\t\t * The disk must be active because we're syncing.\n\t\t * We schedule log work now (now that the disk is\n\t\t * active) instead of later (when it might not be).\n\t\t */\n\t\tflush_delayed_work(&mp->m_log->l_work);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_delayed_work",
          "args": [
            "&mp->m_log->l_work"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "mp",
            "XFS_LOG_SYNC"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_fs_sync_fs(\n\tstruct super_block\t*sb,\n\tint\t\t\twait)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\t/*\n\t * Doing anything during the async pass would be counterproductive.\n\t */\n\tif (!wait)\n\t\treturn 0;\n\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\tif (laptop_mode) {\n\t\t/*\n\t\t * The disk must be active because we're syncing.\n\t\t * We schedule log work now (now that the disk is\n\t\t * active) instead of later (when it might not be).\n\t\t */\n\t\tflush_delayed_work(&mp->m_log->l_work);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_fs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1036-1051",
    "snippet": "STATIC void\nxfs_fs_put_super(\n\tstruct super_block\t*sb)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\txfs_filestream_unmount(mp);\n\txfs_unmountfs(mp);\n\n\txfs_freesb(mp);\n\txfs_icsb_destroy_counters(mp);\n\txfs_destroy_mount_workqueues(mp);\n\txfs_close_devices(mp);\n\txfs_free_fsname(mp);\n\tkfree(mp);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mp"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_free_fsname",
          "args": [
            "mp"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_fsname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "1027-1034",
          "snippet": "STATIC void\nxfs_free_fsname(\n\tstruct xfs_mount\t*mp)\n{\n\tkfree(mp->m_fsname);\n\tkfree(mp->m_rtname);\n\tkfree(mp->m_logname);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_free_fsname(\n\tstruct xfs_mount\t*mp)\n{\n\tkfree(mp->m_fsname);\n\tkfree(mp->m_rtname);\n\tkfree(mp->m_logname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_close_devices",
          "args": [
            "mp"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_close_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "709-724",
          "snippet": "STATIC void\nxfs_close_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\tstruct block_device *logdev = mp->m_logdev_targp->bt_bdev;\n\t\txfs_free_buftarg(mp, mp->m_logdev_targp);\n\t\txfs_blkdev_put(logdev);\n\t}\n\tif (mp->m_rtdev_targp) {\n\t\tstruct block_device *rtdev = mp->m_rtdev_targp->bt_bdev;\n\t\txfs_free_buftarg(mp, mp->m_rtdev_targp);\n\t\txfs_blkdev_put(rtdev);\n\t}\n\txfs_free_buftarg(mp, mp->m_ddev_targp);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_close_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\tstruct block_device *logdev = mp->m_logdev_targp->bt_bdev;\n\t\txfs_free_buftarg(mp, mp->m_logdev_targp);\n\t\txfs_blkdev_put(logdev);\n\t}\n\tif (mp->m_rtdev_targp) {\n\t\tstruct block_device *rtdev = mp->m_rtdev_targp->bt_bdev;\n\t\txfs_free_buftarg(mp, mp->m_rtdev_targp);\n\t\txfs_blkdev_put(rtdev);\n\t}\n\txfs_free_buftarg(mp, mp->m_ddev_targp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_destroy_mount_workqueues",
          "args": [
            "mp"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_destroy_mount_workqueues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "894-905",
          "snippet": "STATIC void\nxfs_destroy_mount_workqueues(\n\tstruct xfs_mount\t*mp)\n{\n\tdestroy_workqueue(mp->m_eofblocks_workqueue);\n\tdestroy_workqueue(mp->m_log_workqueue);\n\tdestroy_workqueue(mp->m_reclaim_workqueue);\n\tdestroy_workqueue(mp->m_cil_workqueue);\n\tdestroy_workqueue(mp->m_data_workqueue);\n\tdestroy_workqueue(mp->m_unwritten_workqueue);\n\tdestroy_workqueue(mp->m_buf_workqueue);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_destroy_mount_workqueues(\n\tstruct xfs_mount\t*mp)\n{\n\tdestroy_workqueue(mp->m_eofblocks_workqueue);\n\tdestroy_workqueue(mp->m_log_workqueue);\n\tdestroy_workqueue(mp->m_reclaim_workqueue);\n\tdestroy_workqueue(mp->m_cil_workqueue);\n\tdestroy_workqueue(mp->m_data_workqueue);\n\tdestroy_workqueue(mp->m_unwritten_workqueue);\n\tdestroy_workqueue(mp->m_buf_workqueue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_destroy_counters",
          "args": [
            "mp"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_destroy_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1578-1587",
          "snippet": "void\nxfs_icsb_destroy_counters(\n\txfs_mount_t\t*mp)\n{\n\tif (mp->m_sb_cnts) {\n\t\tunregister_hotcpu_notifier(&mp->m_icsb_notifier);\n\t\tfree_percpu(mp->m_sb_cnts);\n\t}\n\tmutex_destroy(&mp->m_icsb_mutex);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_destroy_counters(\n\txfs_mount_t\t*mp)\n{\n\tif (mp->m_sb_cnts) {\n\t\tunregister_hotcpu_notifier(&mp->m_icsb_notifier);\n\t\tfree_percpu(mp->m_sb_cnts);\n\t}\n\tmutex_destroy(&mp->m_icsb_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_freesb",
          "args": [
            "mp"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_freesb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1381-1390",
          "snippet": "void\nxfs_freesb(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\txfs_buf_lock(bp);\n\tmp->m_sb_bp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_freesb(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\txfs_buf_lock(bp);\n\tmp->m_sb_bp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_unmountfs",
          "args": [
            "mp"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_unmountfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "977-1053",
          "snippet": "void\nxfs_unmountfs(\n\tstruct xfs_mount\t*mp)\n{\n\t__uint64_t\t\tresblks;\n\tint\t\t\terror;\n\n\tcancel_delayed_work_sync(&mp->m_eofblocks_work);\n\n\txfs_qm_unmount_quotas(mp);\n\txfs_rtunmount_inodes(mp);\n\tIRELE(mp->m_rootip);\n\n\t/*\n\t * We can potentially deadlock here if we have an inode cluster\n\t * that has been freed has its buffer still pinned in memory because\n\t * the transaction is still sitting in a iclog. The stale inodes\n\t * on that buffer will have their flush locks held until the\n\t * transaction hits the disk and the callbacks run. the inode\n\t * flush takes the flush lock unconditionally and with nothing to\n\t * push out the iclog we will never get that unlocked. hence we\n\t * need to force the log first.\n\t */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * Flush all pending changes from the AIL.\n\t */\n\txfs_ail_push_all_sync(mp->m_ail);\n\n\t/*\n\t * And reclaim all inodes.  At this point there should be no dirty\n\t * inodes and none should be pinned or locked, but use synchronous\n\t * reclaim just to be sure. We can stop background inode reclaim\n\t * here as well if it is still running.\n\t */\n\tcancel_delayed_work_sync(&mp->m_reclaim_work);\n\txfs_reclaim_inodes(mp, SYNC_WAIT);\n\n\txfs_qm_unmount(mp);\n\n\t/*\n\t * Unreserve any blocks we have so that when we unmount we don't account\n\t * the reserved free space as used. This is really only necessary for\n\t * lazy superblock counting because it trusts the incore superblock\n\t * counters to be absolutely correct on clean unmount.\n\t *\n\t * We don't bother correcting this elsewhere for lazy superblock\n\t * counting because on mount of an unclean filesystem we reconstruct the\n\t * correct counter value and this is irrelevant.\n\t *\n\t * For non-lazy counter filesystems, this doesn't matter at all because\n\t * we only every apply deltas to the superblock and hence the incore\n\t * value does not matter....\n\t */\n\tresblks = 0;\n\terror = xfs_reserve_blocks(mp, &resblks, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to free reserved block pool. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\n\terror = xfs_log_sbcount(mp);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to update superblock counters. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\n\txfs_log_unmount(mp);\n\txfs_da_unmount(mp);\n\txfs_uuid_unmount(mp);\n\n#if defined(DEBUG)\n\txfs_errortag_clearall(mp, 0);\n#endif\n\txfs_free_perag(mp);\n\n\txfs_sysfs_del(&mp->m_kobj);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_unmountfs(\n\tstruct xfs_mount\t*mp)\n{\n\t__uint64_t\t\tresblks;\n\tint\t\t\terror;\n\n\tcancel_delayed_work_sync(&mp->m_eofblocks_work);\n\n\txfs_qm_unmount_quotas(mp);\n\txfs_rtunmount_inodes(mp);\n\tIRELE(mp->m_rootip);\n\n\t/*\n\t * We can potentially deadlock here if we have an inode cluster\n\t * that has been freed has its buffer still pinned in memory because\n\t * the transaction is still sitting in a iclog. The stale inodes\n\t * on that buffer will have their flush locks held until the\n\t * transaction hits the disk and the callbacks run. the inode\n\t * flush takes the flush lock unconditionally and with nothing to\n\t * push out the iclog we will never get that unlocked. hence we\n\t * need to force the log first.\n\t */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * Flush all pending changes from the AIL.\n\t */\n\txfs_ail_push_all_sync(mp->m_ail);\n\n\t/*\n\t * And reclaim all inodes.  At this point there should be no dirty\n\t * inodes and none should be pinned or locked, but use synchronous\n\t * reclaim just to be sure. We can stop background inode reclaim\n\t * here as well if it is still running.\n\t */\n\tcancel_delayed_work_sync(&mp->m_reclaim_work);\n\txfs_reclaim_inodes(mp, SYNC_WAIT);\n\n\txfs_qm_unmount(mp);\n\n\t/*\n\t * Unreserve any blocks we have so that when we unmount we don't account\n\t * the reserved free space as used. This is really only necessary for\n\t * lazy superblock counting because it trusts the incore superblock\n\t * counters to be absolutely correct on clean unmount.\n\t *\n\t * We don't bother correcting this elsewhere for lazy superblock\n\t * counting because on mount of an unclean filesystem we reconstruct the\n\t * correct counter value and this is irrelevant.\n\t *\n\t * For non-lazy counter filesystems, this doesn't matter at all because\n\t * we only every apply deltas to the superblock and hence the incore\n\t * value does not matter....\n\t */\n\tresblks = 0;\n\terror = xfs_reserve_blocks(mp, &resblks, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to free reserved block pool. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\n\terror = xfs_log_sbcount(mp);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to update superblock counters. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\n\txfs_log_unmount(mp);\n\txfs_da_unmount(mp);\n\txfs_uuid_unmount(mp);\n\n#if defined(DEBUG)\n\txfs_errortag_clearall(mp, 0);\n#endif\n\txfs_free_perag(mp);\n\n\txfs_sysfs_del(&mp->m_kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_filestream_unmount",
          "args": [
            "mp"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "426-431",
          "snippet": "void\nxfs_filestream_unmount(\n\txfs_mount_t\t*mp)\n{\n\txfs_mru_cache_destroy(mp->m_filestream);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_filestream_unmount(\n\txfs_mount_t\t*mp)\n{\n\txfs_mru_cache_destroy(mp->m_filestream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_fs_put_super(\n\tstruct super_block\t*sb)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\txfs_filestream_unmount(mp);\n\txfs_unmountfs(mp);\n\n\txfs_freesb(mp);\n\txfs_icsb_destroy_counters(mp);\n\txfs_destroy_mount_workqueues(mp);\n\txfs_close_devices(mp);\n\txfs_free_fsname(mp);\n\tkfree(mp);\n}"
  },
  {
    "function_name": "xfs_free_fsname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1027-1034",
    "snippet": "STATIC void\nxfs_free_fsname(\n\tstruct xfs_mount\t*mp)\n{\n\tkfree(mp->m_fsname);\n\tkfree(mp->m_rtname);\n\tkfree(mp->m_logname);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mp->m_logname"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mp->m_rtname"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mp->m_fsname"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_free_fsname(\n\tstruct xfs_mount\t*mp)\n{\n\tkfree(mp->m_fsname);\n\tkfree(mp->m_rtname);\n\tkfree(mp->m_logname);\n}"
  },
  {
    "function_name": "xfs_fs_drop_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "1018-1025",
    "snippet": "STATIC int\nxfs_fs_drop_inode(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\treturn generic_drop_inode(inode) || (ip->i_flags & XFS_IDONTCACHE);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_drop_inode",
          "args": [
            "inode"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_fs_drop_inode(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\treturn generic_drop_inode(inode) || (ip->i_flags & XFS_IDONTCACHE);\n}"
  },
  {
    "function_name": "xfs_fs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "993-1009",
    "snippet": "STATIC void\nxfs_fs_evict_inode(\n\tstruct inode\t\t*inode)\n{\n\txfs_inode_t\t\t*ip = XFS_I(inode);\n\n\tASSERT(!rwsem_is_locked(&ip->i_iolock.mr_lock));\n\n\ttrace_xfs_evict_inode(ip);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tXFS_STATS_INC(vn_rele);\n\tXFS_STATS_INC(vn_remove);\n\n\txfs_inactive(ip);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inactive",
          "args": [
            "ip"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inactive_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_symlink.c",
          "lines": "554-598",
          "snippet": "int\nxfs_inactive_symlink(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tpathlen;\n\n\ttrace_xfs_inactive_symlink(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Zero length symlinks _can_ exist.\n\t */\n\tpathlen = (int)ip->i_d.di_size;\n\tif (!pathlen) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\treturn 0;\n\t}\n\n\tif (pathlen < 0 || pathlen > MAXPATHLEN) {\n\t\txfs_alert(mp, \"%s: inode (0x%llx) bad symlink length (%d)\",\n\t\t\t __func__, (unsigned long long)ip->i_ino, pathlen);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(0);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (ip->i_df.if_flags & XFS_IFINLINE) {\n\t\tif (ip->i_df.if_bytes > 0) \n\t\t\txfs_idata_realloc(ip, -(ip->i_df.if_bytes),\n\t\t\t\t\t  XFS_DATA_FORK);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(ip->i_df.if_bytes == 0);\n\t\treturn 0;\n\t}\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/* remove the remote symlink */\n\treturn xfs_inactive_symlink_rmt(ip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nint\nxfs_inactive_symlink(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tpathlen;\n\n\ttrace_xfs_inactive_symlink(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Zero length symlinks _can_ exist.\n\t */\n\tpathlen = (int)ip->i_d.di_size;\n\tif (!pathlen) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\treturn 0;\n\t}\n\n\tif (pathlen < 0 || pathlen > MAXPATHLEN) {\n\t\txfs_alert(mp, \"%s: inode (0x%llx) bad symlink length (%d)\",\n\t\t\t __func__, (unsigned long long)ip->i_ino, pathlen);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(0);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (ip->i_df.if_flags & XFS_IFINLINE) {\n\t\tif (ip->i_df.if_bytes > 0) \n\t\t\txfs_idata_realloc(ip, -(ip->i_df.if_bytes),\n\t\t\t\t\t  XFS_DATA_FORK);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(ip->i_df.if_bytes == 0);\n\t\treturn 0;\n\t}\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/* remove the remote symlink */\n\treturn xfs_inactive_symlink_rmt(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "vn_remove"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "vn_rele"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_evict_inode",
          "args": [
            "ip"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!rwsem_is_locked(&ip->i_iolock.mr_lock)"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&ip->i_iolock.mr_lock"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_fs_evict_inode(\n\tstruct inode\t\t*inode)\n{\n\txfs_inode_t\t\t*ip = XFS_I(inode);\n\n\tASSERT(!rwsem_is_locked(&ip->i_iolock.mr_lock));\n\n\ttrace_xfs_evict_inode(ip);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tXFS_STATS_INC(vn_rele);\n\tXFS_STATS_INC(vn_remove);\n\n\txfs_inactive(ip);\n}"
  },
  {
    "function_name": "xfs_fs_inode_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "974-991",
    "snippet": "STATIC void\nxfs_fs_inode_init_once(\n\tvoid\t\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = inode;\n\n\tmemset(ip, 0, sizeof(struct xfs_inode));\n\n\t/* vfs inode */\n\tinode_init_once(VFS_I(ip));\n\n\t/* xfs inode */\n\tatomic_set(&ip->i_pincount, 0);\n\tspin_lock_init(&ip->i_flags_lock);\n\n\tmrlock_init(&ip->i_lock, MRLOCK_ALLOW_EQUAL_PRI|MRLOCK_BARRIER,\n\t\t     \"xfsino\", ip->i_ino);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mrlock_init",
          "args": [
            "&ip->i_lock",
            "MRLOCK_ALLOW_EQUAL_PRI|MRLOCK_BARRIER",
            "\"xfsino\"",
            "ip->i_ino"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ip->i_pincount",
            "0"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "VFS_I(ip)"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fs_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "974-991",
          "snippet": "STATIC void\nxfs_fs_inode_init_once(\n\tvoid\t\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = inode;\n\n\tmemset(ip, 0, sizeof(struct xfs_inode));\n\n\t/* vfs inode */\n\tinode_init_once(VFS_I(ip));\n\n\t/* xfs inode */\n\tatomic_set(&ip->i_pincount, 0);\n\tspin_lock_init(&ip->i_flags_lock);\n\n\tmrlock_init(&ip->i_lock, MRLOCK_ALLOW_EQUAL_PRI|MRLOCK_BARRIER,\n\t\t     \"xfsino\", ip->i_ino);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ip",
            "0",
            "sizeof(struct xfs_inode)"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_fs_inode_init_once(\n\tvoid\t\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = inode;\n\n\tmemset(ip, 0, sizeof(struct xfs_inode));\n\n\t/* vfs inode */\n\tinode_init_once(VFS_I(ip));\n\n\t/* xfs inode */\n\tatomic_set(&ip->i_pincount, 0);\n\tspin_lock_init(&ip->i_flags_lock);\n\n\tmrlock_init(&ip->i_lock, MRLOCK_ALLOW_EQUAL_PRI|MRLOCK_BARRIER,\n\t\t     \"xfsino\", ip->i_ino);\n}"
  },
  {
    "function_name": "xfs_fs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "938-964",
    "snippet": "STATIC void\nxfs_fs_destroy_inode(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\ttrace_xfs_destroy_inode(ip);\n\n\tXFS_STATS_INC(vn_reclaim);\n\n\tASSERT(XFS_FORCED_SHUTDOWN(ip->i_mount) || ip->i_delayed_blks == 0);\n\n\t/*\n\t * We should never get here with one of the reclaim flags already set.\n\t */\n\tASSERT_ALWAYS(!xfs_iflags_test(ip, XFS_IRECLAIMABLE));\n\tASSERT_ALWAYS(!xfs_iflags_test(ip, XFS_IRECLAIM));\n\n\t/*\n\t * We always use background reclaim here because even if the\n\t * inode is clean, it still may be under IO and hence we have\n\t * to take the flush lock. The background reclaim path handles\n\t * this more efficiently than we can here, so simply let background\n\t * reclaim tear down all inodes.\n\t */\n\txfs_inode_set_reclaim_tag(ip);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inode_set_reclaim_tag",
          "args": [
            "ip"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_set_reclaim_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "761-776",
          "snippet": "void\nxfs_inode_set_reclaim_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_inode_set_reclaim_tag(pag, ip);\n\t__xfs_iflags_set(ip, XFS_IRECLAIMABLE);\n\tspin_unlock(&ip->i_flags_lock);\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nvoid\nxfs_inode_set_reclaim_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_inode_set_reclaim_tag(pag, ip);\n\t__xfs_iflags_set(ip, XFS_IRECLAIMABLE);\n\tspin_unlock(&ip->i_flags_lock);\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_ALWAYS",
          "args": [
            "!xfs_iflags_test(ip, XFS_IRECLAIM)"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iflags_test",
          "args": [
            "ip",
            "XFS_IRECLAIM"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_test_and_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "163-174",
          "snippet": "static inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_ALWAYS",
          "args": [
            "!xfs_iflags_test(ip, XFS_IRECLAIMABLE)"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(ip->i_mount) || ip->i_delayed_blks == 0"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "vn_reclaim"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_destroy_inode",
          "args": [
            "ip"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_fs_destroy_inode(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\ttrace_xfs_destroy_inode(ip);\n\n\tXFS_STATS_INC(vn_reclaim);\n\n\tASSERT(XFS_FORCED_SHUTDOWN(ip->i_mount) || ip->i_delayed_blks == 0);\n\n\t/*\n\t * We should never get here with one of the reclaim flags already set.\n\t */\n\tASSERT_ALWAYS(!xfs_iflags_test(ip, XFS_IRECLAIMABLE));\n\tASSERT_ALWAYS(!xfs_iflags_test(ip, XFS_IRECLAIM));\n\n\t/*\n\t * We always use background reclaim here because even if the\n\t * inode is clean, it still may be under IO and hence we have\n\t * to take the flush lock. The background reclaim path handles\n\t * this more efficiently than we can here, so simply let background\n\t * reclaim tear down all inodes.\n\t */\n\txfs_inode_set_reclaim_tag(ip);\n}"
  },
  {
    "function_name": "xfs_fs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "926-932",
    "snippet": "inode *\nxfs_fs_alloc_inode(\n\tstruct super_block\t*sb)\n{\n\tBUG();\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\ninode *\nxfs_fs_alloc_inode(\n\tstruct super_block\t*sb)\n{\n\tBUG();\n\treturn NULL;\n}"
  },
  {
    "function_name": "xfs_flush_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "913-923",
    "snippet": "void\nxfs_flush_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct super_block\t*sb = mp->m_super;\n\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tsync_inodes_sb(sb);\n\t\tup_read(&sb->s_umount);\n\t}\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_inodes_sb",
          "args": [
            "sb"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inodes_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1434-1456",
          "snippet": "void sync_inodes_sb(struct super_block *sb)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t= sb,\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_pages\t= LONG_MAX,\n\t\t.range_cyclic\t= 0,\n\t\t.done\t\t= &done,\n\t\t.reason\t\t= WB_REASON_SYNC,\n\t\t.for_sync\t= 1,\n\t};\n\n\t/* Nothing to do? */\n\tif (sb->s_bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_queue_work(sb->s_bdi, &work);\n\twait_for_completion(&done);\n\n\twait_sb_inodes(sb);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid sync_inodes_sb(struct super_block *sb)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t= sb,\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_pages\t= LONG_MAX,\n\t\t.range_cyclic\t= 0,\n\t\t.done\t\t= &done,\n\t\t.reason\t\t= WB_REASON_SYNC,\n\t\t.for_sync\t= 1,\n\t};\n\n\t/* Nothing to do? */\n\tif (sb->s_bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_queue_work(sb->s_bdi, &work);\n\twait_for_completion(&done);\n\n\twait_sb_inodes(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&sb->s_umount"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_flush_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct super_block\t*sb = mp->m_super;\n\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tsync_inodes_sb(sb);\n\t\tup_read(&sb->s_umount);\n\t}\n}"
  },
  {
    "function_name": "xfs_destroy_mount_workqueues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "894-905",
    "snippet": "STATIC void\nxfs_destroy_mount_workqueues(\n\tstruct xfs_mount\t*mp)\n{\n\tdestroy_workqueue(mp->m_eofblocks_workqueue);\n\tdestroy_workqueue(mp->m_log_workqueue);\n\tdestroy_workqueue(mp->m_reclaim_workqueue);\n\tdestroy_workqueue(mp->m_cil_workqueue);\n\tdestroy_workqueue(mp->m_data_workqueue);\n\tdestroy_workqueue(mp->m_unwritten_workqueue);\n\tdestroy_workqueue(mp->m_buf_workqueue);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "mp->m_buf_workqueue"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_destroy_mount_workqueues(\n\tstruct xfs_mount\t*mp)\n{\n\tdestroy_workqueue(mp->m_eofblocks_workqueue);\n\tdestroy_workqueue(mp->m_log_workqueue);\n\tdestroy_workqueue(mp->m_reclaim_workqueue);\n\tdestroy_workqueue(mp->m_cil_workqueue);\n\tdestroy_workqueue(mp->m_data_workqueue);\n\tdestroy_workqueue(mp->m_unwritten_workqueue);\n\tdestroy_workqueue(mp->m_buf_workqueue);\n}"
  },
  {
    "function_name": "xfs_init_mount_workqueues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "837-892",
    "snippet": "STATIC int\nxfs_init_mount_workqueues(\n\tstruct xfs_mount\t*mp)\n{\n\tmp->m_buf_workqueue = alloc_workqueue(\"xfs-buf/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 1, mp->m_fsname);\n\tif (!mp->m_buf_workqueue)\n\t\tgoto out;\n\n\tmp->m_data_workqueue = alloc_workqueue(\"xfs-data/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_data_workqueue)\n\t\tgoto out_destroy_buf;\n\n\tmp->m_unwritten_workqueue = alloc_workqueue(\"xfs-conv/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_unwritten_workqueue)\n\t\tgoto out_destroy_data_iodone_queue;\n\n\tmp->m_cil_workqueue = alloc_workqueue(\"xfs-cil/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_cil_workqueue)\n\t\tgoto out_destroy_unwritten;\n\n\tmp->m_reclaim_workqueue = alloc_workqueue(\"xfs-reclaim/%s\",\n\t\t\tWQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_reclaim_workqueue)\n\t\tgoto out_destroy_cil;\n\n\tmp->m_log_workqueue = alloc_workqueue(\"xfs-log/%s\",\n\t\t\tWQ_FREEZABLE|WQ_HIGHPRI, 0, mp->m_fsname);\n\tif (!mp->m_log_workqueue)\n\t\tgoto out_destroy_reclaim;\n\n\tmp->m_eofblocks_workqueue = alloc_workqueue(\"xfs-eofblocks/%s\",\n\t\t\tWQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_eofblocks_workqueue)\n\t\tgoto out_destroy_log;\n\n\treturn 0;\n\nout_destroy_log:\n\tdestroy_workqueue(mp->m_log_workqueue);\nout_destroy_reclaim:\n\tdestroy_workqueue(mp->m_reclaim_workqueue);\nout_destroy_cil:\n\tdestroy_workqueue(mp->m_cil_workqueue);\nout_destroy_unwritten:\n\tdestroy_workqueue(mp->m_unwritten_workqueue);\nout_destroy_data_iodone_queue:\n\tdestroy_workqueue(mp->m_data_workqueue);\nout_destroy_buf:\n\tdestroy_workqueue(mp->m_buf_workqueue);\nout:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "mp->m_buf_workqueue"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"xfs-eofblocks/%s\"",
            "WQ_FREEZABLE",
            "0",
            "mp->m_fsname"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "134-161",
          "snippet": "struct btrfs_workqueue *btrfs_alloc_workqueue(const char *name,\n\t\t\t\t\t      int flags,\n\t\t\t\t\t      int max_active,\n\t\t\t\t\t      int thresh)\n{\n\tstruct btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->normal = __btrfs_alloc_workqueue(name, flags & ~WQ_HIGHPRI,\n\t\t\t\t\t      max_active, thresh);\n\tif (!ret->normal) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tif (flags & WQ_HIGHPRI) {\n\t\tret->high = __btrfs_alloc_workqueue(name, flags, max_active,\n\t\t\t\t\t\t    thresh);\n\t\tif (!ret->high) {\n\t\t\t__btrfs_destroy_workqueue(ret->normal);\n\t\t\tkfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstruct btrfs_workqueue *btrfs_alloc_workqueue(const char *name,\n\t\t\t\t\t      int flags,\n\t\t\t\t\t      int max_active,\n\t\t\t\t\t      int thresh)\n{\n\tstruct btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->normal = __btrfs_alloc_workqueue(name, flags & ~WQ_HIGHPRI,\n\t\t\t\t\t      max_active, thresh);\n\tif (!ret->normal) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tif (flags & WQ_HIGHPRI) {\n\t\tret->high = __btrfs_alloc_workqueue(name, flags, max_active,\n\t\t\t\t\t\t    thresh);\n\t\tif (!ret->high) {\n\t\t\t__btrfs_destroy_workqueue(ret->normal);\n\t\t\tkfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_init_mount_workqueues(\n\tstruct xfs_mount\t*mp)\n{\n\tmp->m_buf_workqueue = alloc_workqueue(\"xfs-buf/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 1, mp->m_fsname);\n\tif (!mp->m_buf_workqueue)\n\t\tgoto out;\n\n\tmp->m_data_workqueue = alloc_workqueue(\"xfs-data/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_data_workqueue)\n\t\tgoto out_destroy_buf;\n\n\tmp->m_unwritten_workqueue = alloc_workqueue(\"xfs-conv/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_unwritten_workqueue)\n\t\tgoto out_destroy_data_iodone_queue;\n\n\tmp->m_cil_workqueue = alloc_workqueue(\"xfs-cil/%s\",\n\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_cil_workqueue)\n\t\tgoto out_destroy_unwritten;\n\n\tmp->m_reclaim_workqueue = alloc_workqueue(\"xfs-reclaim/%s\",\n\t\t\tWQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_reclaim_workqueue)\n\t\tgoto out_destroy_cil;\n\n\tmp->m_log_workqueue = alloc_workqueue(\"xfs-log/%s\",\n\t\t\tWQ_FREEZABLE|WQ_HIGHPRI, 0, mp->m_fsname);\n\tif (!mp->m_log_workqueue)\n\t\tgoto out_destroy_reclaim;\n\n\tmp->m_eofblocks_workqueue = alloc_workqueue(\"xfs-eofblocks/%s\",\n\t\t\tWQ_FREEZABLE, 0, mp->m_fsname);\n\tif (!mp->m_eofblocks_workqueue)\n\t\tgoto out_destroy_log;\n\n\treturn 0;\n\nout_destroy_log:\n\tdestroy_workqueue(mp->m_log_workqueue);\nout_destroy_reclaim:\n\tdestroy_workqueue(mp->m_reclaim_workqueue);\nout_destroy_cil:\n\tdestroy_workqueue(mp->m_cil_workqueue);\nout_destroy_unwritten:\n\tdestroy_workqueue(mp->m_unwritten_workqueue);\nout_destroy_data_iodone_queue:\n\tdestroy_workqueue(mp->m_data_workqueue);\nout_destroy_buf:\n\tdestroy_workqueue(mp->m_buf_workqueue);\nout:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "xfs_setup_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "807-835",
    "snippet": "STATIC int\nxfs_setup_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror;\n\n\terror = xfs_setsize_buftarg(mp->m_ddev_targp, mp->m_sb.sb_sectsize);\n\tif (error)\n\t\treturn error;\n\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\tunsigned int\tlog_sector_size = BBSIZE;\n\n\t\tif (xfs_sb_version_hassector(&mp->m_sb))\n\t\t\tlog_sector_size = mp->m_sb.sb_logsectsize;\n\t\terror = xfs_setsize_buftarg(mp->m_logdev_targp,\n\t\t\t\t\t    log_sector_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (mp->m_rtdev_targp) {\n\t\terror = xfs_setsize_buftarg(mp->m_rtdev_targp,\n\t\t\t\t\t    mp->m_sb.sb_sectsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_setsize_buftarg",
          "args": [
            "mp->m_rtdev_targp",
            "mp->m_sb.sb_sectsize"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setsize_buftarg_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1658-1664",
          "snippet": "STATIC int\nxfs_setsize_buftarg_early(\n\txfs_buftarg_t\t\t*btp,\n\tstruct block_device\t*bdev)\n{\n\treturn xfs_setsize_buftarg(btp, bdev_logical_block_size(bdev));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\nxfs_setsize_buftarg_early(\n\txfs_buftarg_t\t\t*btp,\n\tstruct block_device\t*bdev)\n{\n\treturn xfs_setsize_buftarg(btp, bdev_logical_block_size(bdev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hassector",
          "args": [
            "&mp->m_sb"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hassector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "422-425",
          "snippet": "static inline bool xfs_sb_version_hassector(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_SECTORBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_SECTORBIT\t0x0800"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_SECTORBIT\t0x0800\n\nstatic inline bool xfs_sb_version_hassector(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_SECTORBIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_setup_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror;\n\n\terror = xfs_setsize_buftarg(mp->m_ddev_targp, mp->m_sb.sb_sectsize);\n\tif (error)\n\t\treturn error;\n\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\tunsigned int\tlog_sector_size = BBSIZE;\n\n\t\tif (xfs_sb_version_hassector(&mp->m_sb))\n\t\t\tlog_sector_size = mp->m_sb.sb_logsectsize;\n\t\terror = xfs_setsize_buftarg(mp->m_logdev_targp,\n\t\t\t\t\t    log_sector_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (mp->m_rtdev_targp) {\n\t\terror = xfs_setsize_buftarg(mp->m_rtdev_targp,\n\t\t\t\t\t    mp->m_sb.sb_sectsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_open_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "736-802",
    "snippet": "STATIC int\nxfs_open_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct block_device\t*ddev = mp->m_super->s_bdev;\n\tstruct block_device\t*logdev = NULL, *rtdev = NULL;\n\tint\t\t\terror;\n\n\t/*\n\t * Open real time and log devices - order is important.\n\t */\n\tif (mp->m_logname) {\n\t\terror = xfs_blkdev_get(mp, mp->m_logname, &logdev);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (mp->m_rtname) {\n\t\terror = xfs_blkdev_get(mp, mp->m_rtname, &rtdev);\n\t\tif (error)\n\t\t\tgoto out_close_logdev;\n\n\t\tif (rtdev == ddev || rtdev == logdev) {\n\t\t\txfs_warn(mp,\n\t\"Cannot mount filesystem with identical rtdev and ddev/logdev.\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_close_rtdev;\n\t\t}\n\t}\n\n\t/*\n\t * Setup xfs_mount buffer target pointers\n\t */\n\terror = -ENOMEM;\n\tmp->m_ddev_targp = xfs_alloc_buftarg(mp, ddev);\n\tif (!mp->m_ddev_targp)\n\t\tgoto out_close_rtdev;\n\n\tif (rtdev) {\n\t\tmp->m_rtdev_targp = xfs_alloc_buftarg(mp, rtdev);\n\t\tif (!mp->m_rtdev_targp)\n\t\t\tgoto out_free_ddev_targ;\n\t}\n\n\tif (logdev && logdev != ddev) {\n\t\tmp->m_logdev_targp = xfs_alloc_buftarg(mp, logdev);\n\t\tif (!mp->m_logdev_targp)\n\t\t\tgoto out_free_rtdev_targ;\n\t} else {\n\t\tmp->m_logdev_targp = mp->m_ddev_targp;\n\t}\n\n\treturn 0;\n\n out_free_rtdev_targ:\n\tif (mp->m_rtdev_targp)\n\t\txfs_free_buftarg(mp, mp->m_rtdev_targp);\n out_free_ddev_targ:\n\txfs_free_buftarg(mp, mp->m_ddev_targp);\n out_close_rtdev:\n\txfs_blkdev_put(rtdev);\n out_close_logdev:\n\tif (logdev && logdev != ddev)\n\t\txfs_blkdev_put(logdev);\n out:\n\treturn error;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_blkdev_put",
          "args": [
            "logdev"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "694-700",
          "snippet": "STATIC void\nxfs_blkdev_put(\n\tstruct block_device\t*bdev)\n{\n\tif (bdev)\n\t\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_blkdev_put(\n\tstruct block_device\t*bdev)\n{\n\tif (bdev)\n\t\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_free_buftarg",
          "args": [
            "mp",
            "mp->m_ddev_targp"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_buftarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1612-1624",
          "snippet": "void\nxfs_free_buftarg(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*btp)\n{\n\tunregister_shrinker(&btp->bt_shrinker);\n\tlist_lru_destroy(&btp->bt_lru);\n\n\tif (mp->m_flags & XFS_MOUNT_BARRIER)\n\t\txfs_blkdev_issue_flush(btp);\n\n\tkmem_free(btp);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_free_buftarg(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*btp)\n{\n\tunregister_shrinker(&btp->bt_shrinker);\n\tlist_lru_destroy(&btp->bt_lru);\n\n\tif (mp->m_flags & XFS_MOUNT_BARRIER)\n\t\txfs_blkdev_issue_flush(btp);\n\n\tkmem_free(btp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_buftarg",
          "args": [
            "mp",
            "logdev"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_buftarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1666-1696",
          "snippet": "xfs_buftarg_t *\nxfs_alloc_buftarg(\n\tstruct xfs_mount\t*mp,\n\tstruct block_device\t*bdev)\n{\n\txfs_buftarg_t\t\t*btp;\n\n\tbtp = kmem_zalloc(sizeof(*btp), KM_SLEEP | KM_NOFS);\n\n\tbtp->bt_mount = mp;\n\tbtp->bt_dev =  bdev->bd_dev;\n\tbtp->bt_bdev = bdev;\n\tbtp->bt_bdi = blk_get_backing_dev_info(bdev);\n\n\tif (xfs_setsize_buftarg_early(btp, bdev))\n\t\tgoto error;\n\n\tif (list_lru_init(&btp->bt_lru))\n\t\tgoto error;\n\n\tbtp->bt_shrinker.count_objects = xfs_buftarg_shrink_count;\n\tbtp->bt_shrinker.scan_objects = xfs_buftarg_shrink_scan;\n\tbtp->bt_shrinker.seeks = DEFAULT_SEEKS;\n\tbtp->bt_shrinker.flags = SHRINKER_NUMA_AWARE;\n\tregister_shrinker(&btp->bt_shrinker);\n\treturn btp;\n\nerror:\n\tkmem_free(btp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_buftarg_t *\nxfs_alloc_buftarg(\n\tstruct xfs_mount\t*mp,\n\tstruct block_device\t*bdev)\n{\n\txfs_buftarg_t\t\t*btp;\n\n\tbtp = kmem_zalloc(sizeof(*btp), KM_SLEEP | KM_NOFS);\n\n\tbtp->bt_mount = mp;\n\tbtp->bt_dev =  bdev->bd_dev;\n\tbtp->bt_bdev = bdev;\n\tbtp->bt_bdi = blk_get_backing_dev_info(bdev);\n\n\tif (xfs_setsize_buftarg_early(btp, bdev))\n\t\tgoto error;\n\n\tif (list_lru_init(&btp->bt_lru))\n\t\tgoto error;\n\n\tbtp->bt_shrinker.count_objects = xfs_buftarg_shrink_count;\n\tbtp->bt_shrinker.scan_objects = xfs_buftarg_shrink_scan;\n\tbtp->bt_shrinker.seeks = DEFAULT_SEEKS;\n\tbtp->bt_shrinker.flags = SHRINKER_NUMA_AWARE;\n\tregister_shrinker(&btp->bt_shrinker);\n\treturn btp;\n\nerror:\n\tkmem_free(btp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Cannot mount filesystem with identical rtdev and ddev/logdev.\""
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_blkdev_get",
          "args": [
            "mp",
            "mp->m_rtname",
            "&rtdev"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_blkdev_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "676-692",
          "snippet": "STATIC int\nxfs_blkdev_get(\n\txfs_mount_t\t\t*mp,\n\tconst char\t\t*name,\n\tstruct block_device\t**bdevp)\n{\n\tint\t\t\terror = 0;\n\n\t*bdevp = blkdev_get_by_path(name, FMODE_READ|FMODE_WRITE|FMODE_EXCL,\n\t\t\t\t    mp);\n\tif (IS_ERR(*bdevp)) {\n\t\terror = PTR_ERR(*bdevp);\n\t\txfs_warn(mp, \"Invalid device [%s], error=%d\", name, error);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_blkdev_get(\n\txfs_mount_t\t\t*mp,\n\tconst char\t\t*name,\n\tstruct block_device\t**bdevp)\n{\n\tint\t\t\terror = 0;\n\n\t*bdevp = blkdev_get_by_path(name, FMODE_READ|FMODE_WRITE|FMODE_EXCL,\n\t\t\t\t    mp);\n\tif (IS_ERR(*bdevp)) {\n\t\terror = PTR_ERR(*bdevp);\n\t\txfs_warn(mp, \"Invalid device [%s], error=%d\", name, error);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_open_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct block_device\t*ddev = mp->m_super->s_bdev;\n\tstruct block_device\t*logdev = NULL, *rtdev = NULL;\n\tint\t\t\terror;\n\n\t/*\n\t * Open real time and log devices - order is important.\n\t */\n\tif (mp->m_logname) {\n\t\terror = xfs_blkdev_get(mp, mp->m_logname, &logdev);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (mp->m_rtname) {\n\t\terror = xfs_blkdev_get(mp, mp->m_rtname, &rtdev);\n\t\tif (error)\n\t\t\tgoto out_close_logdev;\n\n\t\tif (rtdev == ddev || rtdev == logdev) {\n\t\t\txfs_warn(mp,\n\t\"Cannot mount filesystem with identical rtdev and ddev/logdev.\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_close_rtdev;\n\t\t}\n\t}\n\n\t/*\n\t * Setup xfs_mount buffer target pointers\n\t */\n\terror = -ENOMEM;\n\tmp->m_ddev_targp = xfs_alloc_buftarg(mp, ddev);\n\tif (!mp->m_ddev_targp)\n\t\tgoto out_close_rtdev;\n\n\tif (rtdev) {\n\t\tmp->m_rtdev_targp = xfs_alloc_buftarg(mp, rtdev);\n\t\tif (!mp->m_rtdev_targp)\n\t\t\tgoto out_free_ddev_targ;\n\t}\n\n\tif (logdev && logdev != ddev) {\n\t\tmp->m_logdev_targp = xfs_alloc_buftarg(mp, logdev);\n\t\tif (!mp->m_logdev_targp)\n\t\t\tgoto out_free_rtdev_targ;\n\t} else {\n\t\tmp->m_logdev_targp = mp->m_ddev_targp;\n\t}\n\n\treturn 0;\n\n out_free_rtdev_targ:\n\tif (mp->m_rtdev_targp)\n\t\txfs_free_buftarg(mp, mp->m_rtdev_targp);\n out_free_ddev_targ:\n\txfs_free_buftarg(mp, mp->m_ddev_targp);\n out_close_rtdev:\n\txfs_blkdev_put(rtdev);\n out_close_logdev:\n\tif (logdev && logdev != ddev)\n\t\txfs_blkdev_put(logdev);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_close_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "709-724",
    "snippet": "STATIC void\nxfs_close_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\tstruct block_device *logdev = mp->m_logdev_targp->bt_bdev;\n\t\txfs_free_buftarg(mp, mp->m_logdev_targp);\n\t\txfs_blkdev_put(logdev);\n\t}\n\tif (mp->m_rtdev_targp) {\n\t\tstruct block_device *rtdev = mp->m_rtdev_targp->bt_bdev;\n\t\txfs_free_buftarg(mp, mp->m_rtdev_targp);\n\t\txfs_blkdev_put(rtdev);\n\t}\n\txfs_free_buftarg(mp, mp->m_ddev_targp);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_free_buftarg",
          "args": [
            "mp",
            "mp->m_ddev_targp"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_buftarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1612-1624",
          "snippet": "void\nxfs_free_buftarg(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*btp)\n{\n\tunregister_shrinker(&btp->bt_shrinker);\n\tlist_lru_destroy(&btp->bt_lru);\n\n\tif (mp->m_flags & XFS_MOUNT_BARRIER)\n\t\txfs_blkdev_issue_flush(btp);\n\n\tkmem_free(btp);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_free_buftarg(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*btp)\n{\n\tunregister_shrinker(&btp->bt_shrinker);\n\tlist_lru_destroy(&btp->bt_lru);\n\n\tif (mp->m_flags & XFS_MOUNT_BARRIER)\n\t\txfs_blkdev_issue_flush(btp);\n\n\tkmem_free(btp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_blkdev_put",
          "args": [
            "rtdev"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "694-700",
          "snippet": "STATIC void\nxfs_blkdev_put(\n\tstruct block_device\t*bdev)\n{\n\tif (bdev)\n\t\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_blkdev_put(\n\tstruct block_device\t*bdev)\n{\n\tif (bdev)\n\t\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_close_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\tstruct block_device *logdev = mp->m_logdev_targp->bt_bdev;\n\t\txfs_free_buftarg(mp, mp->m_logdev_targp);\n\t\txfs_blkdev_put(logdev);\n\t}\n\tif (mp->m_rtdev_targp) {\n\t\tstruct block_device *rtdev = mp->m_rtdev_targp->bt_bdev;\n\t\txfs_free_buftarg(mp, mp->m_rtdev_targp);\n\t\txfs_blkdev_put(rtdev);\n\t}\n\txfs_free_buftarg(mp, mp->m_ddev_targp);\n}"
  },
  {
    "function_name": "xfs_blkdev_issue_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "702-707",
    "snippet": "void\nxfs_blkdev_issue_flush(\n\txfs_buftarg_t\t\t*buftarg)\n{\n\tblkdev_issue_flush(buftarg->bt_bdev, GFP_NOFS, NULL);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "buftarg->bt_bdev",
            "GFP_NOFS",
            "NULL"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_blkdev_issue_flush(\n\txfs_buftarg_t\t\t*buftarg)\n{\n\tblkdev_issue_flush(buftarg->bt_bdev, GFP_NOFS, NULL);\n}"
  },
  {
    "function_name": "xfs_blkdev_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "694-700",
    "snippet": "STATIC void\nxfs_blkdev_put(\n\tstruct block_device\t*bdev)\n{\n\tif (bdev)\n\t\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "FMODE_READ|FMODE_WRITE|FMODE_EXCL"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC void\nxfs_blkdev_put(\n\tstruct block_device\t*bdev)\n{\n\tif (bdev)\n\t\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}"
  },
  {
    "function_name": "xfs_blkdev_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "676-692",
    "snippet": "STATIC int\nxfs_blkdev_get(\n\txfs_mount_t\t\t*mp,\n\tconst char\t\t*name,\n\tstruct block_device\t**bdevp)\n{\n\tint\t\t\terror = 0;\n\n\t*bdevp = blkdev_get_by_path(name, FMODE_READ|FMODE_WRITE|FMODE_EXCL,\n\t\t\t\t    mp);\n\tif (IS_ERR(*bdevp)) {\n\t\terror = PTR_ERR(*bdevp);\n\t\txfs_warn(mp, \"Invalid device [%s], error=%d\", name, error);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Invalid device [%s], error=%d\"",
            "name",
            "error"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "*bdevp"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*bdevp"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_path",
          "args": [
            "name",
            "FMODE_READ|FMODE_WRITE|FMODE_EXCL",
            "mp"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1387-1407",
          "snippet": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_blkdev_get(\n\txfs_mount_t\t\t*mp,\n\tconst char\t\t*name,\n\tstruct block_device\t**bdevp)\n{\n\tint\t\t\terror = 0;\n\n\t*bdevp = blkdev_get_by_path(name, FMODE_READ|FMODE_WRITE|FMODE_EXCL,\n\t\t\t\t    mp);\n\tif (IS_ERR(*bdevp)) {\n\t\terror = PTR_ERR(*bdevp);\n\t\txfs_warn(mp, \"Invalid device [%s], error=%d\", name, error);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_set_inode64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "652-674",
    "snippet": "xfs_agnumber_t\nxfs_set_inode64(struct xfs_mount *mp, xfs_agnumber_t agcount)\n{\n\txfs_agnumber_t index = 0;\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tstruct xfs_perag\t*pag;\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tpag->pagi_inodeok = 1;\n\t\tpag->pagf_metadata = 0;\n\t\txfs_perag_put(pag);\n\t}\n\n\t/* There is no need for lock protection on m_flags,\n\t * the rw_semaphore of the VFS superblock is locked\n\t * during mount/umount/remount operations, so this is\n\t * enough to avoid concurency on the m_flags field\n\t */\n\tmp->m_flags &= ~(XFS_MOUNT_32BITINODES |\n\t\t\t XFS_MOUNT_SMALL_INUMS);\n\treturn index;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "index"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_agnumber_t\nxfs_set_inode64(struct xfs_mount *mp, xfs_agnumber_t agcount)\n{\n\txfs_agnumber_t index = 0;\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tstruct xfs_perag\t*pag;\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tpag->pagi_inodeok = 1;\n\t\tpag->pagf_metadata = 0;\n\t\txfs_perag_put(pag);\n\t}\n\n\t/* There is no need for lock protection on m_flags,\n\t * the rw_semaphore of the VFS superblock is locked\n\t * during mount/umount/remount operations, so this is\n\t * enough to avoid concurency on the m_flags field\n\t */\n\tmp->m_flags &= ~(XFS_MOUNT_32BITINODES |\n\t\t\t XFS_MOUNT_SMALL_INUMS);\n\treturn index;\n}"
  },
  {
    "function_name": "xfs_set_inode32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "600-650",
    "snippet": "xfs_agnumber_t\nxfs_set_inode32(struct xfs_mount *mp, xfs_agnumber_t agcount)\n{\n\txfs_agnumber_t\tindex = 0;\n\txfs_agnumber_t\tmaxagi = 0;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\txfs_agnumber_t\tmax_metadata;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\txfs_perag_t\t*pag;\n\n\t/* Calculate how much should be reserved for inodes to meet\n\t * the max inode percentage.\n\t */\n\tif (mp->m_maxicount) {\n\t\t__uint64_t\ticount;\n\n\t\ticount = sbp->sb_dblocks * sbp->sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\ticount += sbp->sb_agblocks - 1;\n\t\tdo_div(icount, sbp->sb_agblocks);\n\t\tmax_metadata = icount;\n\t} else {\n\t\tmax_metadata = agcount;\n\t}\n\n\tagino =\tXFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tino = XFS_AGINO_TO_INO(mp, index, agino);\n\n\t\tif (ino > XFS_MAXINUMBER_32) {\n\t\t\tpag = xfs_perag_get(mp, index);\n\t\t\tpag->pagi_inodeok = 0;\n\t\t\tpag->pagf_metadata = 0;\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tpag->pagi_inodeok = 1;\n\t\tmaxagi++;\n\t\tif (index < max_metadata)\n\t\t\tpag->pagf_metadata = 1;\n\t\txfs_perag_put(pag);\n\t}\n\tmp->m_flags |= (XFS_MOUNT_32BITINODES |\n\t\t\tXFS_MOUNT_SMALL_INUMS);\n\n\treturn maxagi;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "index"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "index",
            "agino"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_OFFBNO_TO_AGINO",
          "args": [
            "mp",
            "sbp->sb_agblocks - 1",
            "0"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "icount",
            "sbp->sb_agblocks"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "icount",
            "100"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_agnumber_t\nxfs_set_inode32(struct xfs_mount *mp, xfs_agnumber_t agcount)\n{\n\txfs_agnumber_t\tindex = 0;\n\txfs_agnumber_t\tmaxagi = 0;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\txfs_agnumber_t\tmax_metadata;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\txfs_perag_t\t*pag;\n\n\t/* Calculate how much should be reserved for inodes to meet\n\t * the max inode percentage.\n\t */\n\tif (mp->m_maxicount) {\n\t\t__uint64_t\ticount;\n\n\t\ticount = sbp->sb_dblocks * sbp->sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\ticount += sbp->sb_agblocks - 1;\n\t\tdo_div(icount, sbp->sb_agblocks);\n\t\tmax_metadata = icount;\n\t} else {\n\t\tmax_metadata = agcount;\n\t}\n\n\tagino =\tXFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tino = XFS_AGINO_TO_INO(mp, index, agino);\n\n\t\tif (ino > XFS_MAXINUMBER_32) {\n\t\t\tpag = xfs_perag_get(mp, index);\n\t\t\tpag->pagi_inodeok = 0;\n\t\t\tpag->pagf_metadata = 0;\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tpag->pagi_inodeok = 1;\n\t\tmaxagi++;\n\t\tif (index < max_metadata)\n\t\t\tpag->pagf_metadata = 1;\n\t\txfs_perag_put(pag);\n\t}\n\tmp->m_flags |= (XFS_MOUNT_32BITINODES |\n\t\t\tXFS_MOUNT_SMALL_INUMS);\n\n\treturn maxagi;\n}"
  },
  {
    "function_name": "xfs_max_file_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "561-593",
    "snippet": "__uint64_t\nxfs_max_file_offset(\n\tunsigned int\t\tblockshift)\n{\n\tunsigned int\t\tpagefactor = 1;\n\tunsigned int\t\tbitshift = BITS_PER_LONG - 1;\n\n\t/* Figure out maximum filesize, on Linux this can depend on\n\t * the filesystem blocksize (on 32 bit platforms).\n\t * __block_write_begin does this in an [unsigned] long...\n\t *      page->index << (PAGE_CACHE_SHIFT - bbits)\n\t * So, for page sized blocks (4K on 32 bit platforms),\n\t * this wraps at around 8Tb (hence MAX_LFS_FILESIZE which is\n\t *      (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)\n\t * but for smaller blocksizes it is less (bbits = log2 bsize).\n\t * Note1: get_block_t takes a long (implicit cast from above)\n\t * Note2: The Large Block Device (LBD and HAVE_SECTOR_T) patch\n\t * can optionally convert the [unsigned] long from above into\n\t * an [unsigned] long long.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tASSERT(sizeof(sector_t) == 8);\n\tpagefactor = PAGE_CACHE_SIZE;\n\tbitshift = BITS_PER_LONG;\n# else\n\tpagefactor = PAGE_CACHE_SIZE >> (PAGE_CACHE_SHIFT - blockshift);\n# endif\n#endif\n\n\treturn (((__uint64_t)pagefactor) << bitshift) - 1;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "sizeof(sector_t) == 8"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n__uint64_t\nxfs_max_file_offset(\n\tunsigned int\t\tblockshift)\n{\n\tunsigned int\t\tpagefactor = 1;\n\tunsigned int\t\tbitshift = BITS_PER_LONG - 1;\n\n\t/* Figure out maximum filesize, on Linux this can depend on\n\t * the filesystem blocksize (on 32 bit platforms).\n\t * __block_write_begin does this in an [unsigned] long...\n\t *      page->index << (PAGE_CACHE_SHIFT - bbits)\n\t * So, for page sized blocks (4K on 32 bit platforms),\n\t * this wraps at around 8Tb (hence MAX_LFS_FILESIZE which is\n\t *      (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)\n\t * but for smaller blocksizes it is less (bbits = log2 bsize).\n\t * Note1: get_block_t takes a long (implicit cast from above)\n\t * Note2: The Large Block Device (LBD and HAVE_SECTOR_T) patch\n\t * can optionally convert the [unsigned] long from above into\n\t * an [unsigned] long long.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tASSERT(sizeof(sector_t) == 8);\n\tpagefactor = PAGE_CACHE_SIZE;\n\tbitshift = BITS_PER_LONG;\n# else\n\tpagefactor = PAGE_CACHE_SIZE >> (PAGE_CACHE_SHIFT - blockshift);\n# endif\n#endif\n\n\treturn (((__uint64_t)pagefactor) << bitshift) - 1;\n}"
  },
  {
    "function_name": "xfs_showargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "479-560",
    "snippet": "STATIC int\nxfs_showargs(\n\tstruct xfs_mount\t*mp,\n\tstruct seq_file\t\t*m)\n{\n\tstatic struct proc_xfs_info xfs_info_set[] = {\n\t\t/* the few simple ones we can get from the mount struct */\n\t\t{ XFS_MOUNT_IKEEP,\t\t\",\" MNTOPT_IKEEP },\n\t\t{ XFS_MOUNT_WSYNC,\t\t\",\" MNTOPT_WSYNC },\n\t\t{ XFS_MOUNT_NOALIGN,\t\t\",\" MNTOPT_NOALIGN },\n\t\t{ XFS_MOUNT_SWALLOC,\t\t\",\" MNTOPT_SWALLOC },\n\t\t{ XFS_MOUNT_NOUUID,\t\t\",\" MNTOPT_NOUUID },\n\t\t{ XFS_MOUNT_NORECOVERY,\t\t\",\" MNTOPT_NORECOVERY },\n\t\t{ XFS_MOUNT_ATTR2,\t\t\",\" MNTOPT_ATTR2 },\n\t\t{ XFS_MOUNT_FILESTREAMS,\t\",\" MNTOPT_FILESTREAM },\n\t\t{ XFS_MOUNT_GRPID,\t\t\",\" MNTOPT_GRPID },\n\t\t{ XFS_MOUNT_DISCARD,\t\t\",\" MNTOPT_DISCARD },\n\t\t{ XFS_MOUNT_SMALL_INUMS,\t\",\" MNTOPT_32BITINODE },\n\t\t{ 0, NULL }\n\t};\n\tstatic struct proc_xfs_info xfs_info_unset[] = {\n\t\t/* the few simple ones we can get from the mount struct */\n\t\t{ XFS_MOUNT_COMPAT_IOSIZE,\t\",\" MNTOPT_LARGEIO },\n\t\t{ XFS_MOUNT_BARRIER,\t\t\",\" MNTOPT_NOBARRIER },\n\t\t{ XFS_MOUNT_SMALL_INUMS,\t\",\" MNTOPT_64BITINODE },\n\t\t{ 0, NULL }\n\t};\n\tstruct proc_xfs_info\t*xfs_infop;\n\n\tfor (xfs_infop = xfs_info_set; xfs_infop->flag; xfs_infop++) {\n\t\tif (mp->m_flags & xfs_infop->flag)\n\t\t\tseq_puts(m, xfs_infop->str);\n\t}\n\tfor (xfs_infop = xfs_info_unset; xfs_infop->flag; xfs_infop++) {\n\t\tif (!(mp->m_flags & xfs_infop->flag))\n\t\t\tseq_puts(m, xfs_infop->str);\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_DFLT_IOSIZE)\n\t\tseq_printf(m, \",\" MNTOPT_ALLOCSIZE \"=%dk\",\n\t\t\t\t(int)(1 << mp->m_writeio_log) >> 10);\n\n\tif (mp->m_logbufs > 0)\n\t\tseq_printf(m, \",\" MNTOPT_LOGBUFS \"=%d\", mp->m_logbufs);\n\tif (mp->m_logbsize > 0)\n\t\tseq_printf(m, \",\" MNTOPT_LOGBSIZE \"=%dk\", mp->m_logbsize >> 10);\n\n\tif (mp->m_logname)\n\t\tseq_printf(m, \",\" MNTOPT_LOGDEV \"=%s\", mp->m_logname);\n\tif (mp->m_rtname)\n\t\tseq_printf(m, \",\" MNTOPT_RTDEV \"=%s\", mp->m_rtname);\n\n\tif (mp->m_dalign > 0)\n\t\tseq_printf(m, \",\" MNTOPT_SUNIT \"=%d\",\n\t\t\t\t(int)XFS_FSB_TO_BB(mp, mp->m_dalign));\n\tif (mp->m_swidth > 0)\n\t\tseq_printf(m, \",\" MNTOPT_SWIDTH \"=%d\",\n\t\t\t\t(int)XFS_FSB_TO_BB(mp, mp->m_swidth));\n\n\tif (mp->m_qflags & (XFS_UQUOTA_ACCT|XFS_UQUOTA_ENFD))\n\t\tseq_puts(m, \",\" MNTOPT_USRQUOTA);\n\telse if (mp->m_qflags & XFS_UQUOTA_ACCT)\n\t\tseq_puts(m, \",\" MNTOPT_UQUOTANOENF);\n\n\tif (mp->m_qflags & XFS_PQUOTA_ACCT) {\n\t\tif (mp->m_qflags & XFS_PQUOTA_ENFD)\n\t\t\tseq_puts(m, \",\" MNTOPT_PRJQUOTA);\n\t\telse\n\t\t\tseq_puts(m, \",\" MNTOPT_PQUOTANOENF);\n\t}\n\tif (mp->m_qflags & XFS_GQUOTA_ACCT) {\n\t\tif (mp->m_qflags & XFS_GQUOTA_ENFD)\n\t\t\tseq_puts(m, \",\" MNTOPT_GRPQUOTA);\n\t\telse\n\t\t\tseq_puts(m, \",\" MNTOPT_GQUOTANOENF);\n\t}\n\n\tif (!(mp->m_qflags & XFS_ALL_QUOTA_ACCT))\n\t\tseq_puts(m, \",\" MNTOPT_NOQUOTA);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define MNTOPT_DISCARD\t   \"discard\"\t/* Discard unused blocks */",
      "#define MNTOPT_PQUOTANOENF \"pqnoenforce\"/* project quota limit enforcement */",
      "#define MNTOPT_GQUOTANOENF \"gqnoenforce\"/* group quota limit enforcement */",
      "#define MNTOPT_UQUOTANOENF \"uqnoenforce\"/* user quota limit enforcement */",
      "#define MNTOPT_PRJQUOTA\t\"prjquota\"\t/* project quota enabled */",
      "#define MNTOPT_GRPQUOTA\t\"grpquota\"\t/* group quota enabled */",
      "#define MNTOPT_USRQUOTA\t\"usrquota\"\t/* user quota enabled */",
      "#define MNTOPT_NOQUOTA\t\"noquota\"\t/* no quotas */",
      "#define MNTOPT_FILESTREAM  \"filestreams\" /* use filestreams allocator */",
      "#define MNTOPT_ATTR2\t\"attr2\"\t\t/* do use attr2 attribute format */",
      "#define MNTOPT_LARGEIO\t   \"largeio\"\t/* report large I/O sizes in stat() */",
      "#define MNTOPT_IKEEP\t\"ikeep\"\t\t/* do not free empty inode clusters */",
      "#define MNTOPT_32BITINODE   \"inode32\"\t/* inode allocation limited to\n\t\t\t\t\t * XFS_MAXINUMBER_32 */",
      "#define MNTOPT_64BITINODE   \"inode64\"\t/* inodes can be allocated anywhere */",
      "#define MNTOPT_NOBARRIER \"nobarrier\"\t/* .. disable */",
      "#define MNTOPT_NORECOVERY   \"norecovery\"   /* don't run XFS recovery */",
      "#define MNTOPT_ALLOCSIZE    \"allocsize\"    /* preferred allocation size */",
      "#define MNTOPT_GRPID\t\"grpid\"\t\t/* group-ID from parent directory */",
      "#define MNTOPT_NOUUID\t\"nouuid\"\t/* ignore filesystem UUID */",
      "#define MNTOPT_SWIDTH\t\"swidth\"\t/* data volume stripe width */",
      "#define MNTOPT_SUNIT\t\"sunit\"\t\t/* data volume stripe unit */",
      "#define MNTOPT_SWALLOC\t\"swalloc\"\t/* turn on stripe width allocation */",
      "#define MNTOPT_NOALIGN\t\"noalign\"\t/* turn off stripe alignment */",
      "#define MNTOPT_WSYNC\t\"wsync\"\t\t/* safe-mode nfs compatible mount */",
      "#define MNTOPT_RTDEV\t\"rtdev\"\t\t/* realtime I/O device */",
      "#define MNTOPT_LOGDEV\t\"logdev\"\t/* log device */",
      "#define MNTOPT_LOGBSIZE\t\"logbsize\"\t/* size of XFS log buffers */",
      "#define MNTOPT_LOGBUFS\t\"logbufs\"\t/* number of XFS log buffers */"
    ],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\",\" MNTOPT_NOQUOTA"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",\" MNTOPT_SWIDTH \"=%d\"",
            "(int)XFS_FSB_TO_BB(mp, mp->m_swidth)"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "mp->m_swidth"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "mp->m_dalign"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n#define MNTOPT_DISCARD\t   \"discard\"\t/* Discard unused blocks */\n#define MNTOPT_PQUOTANOENF \"pqnoenforce\"/* project quota limit enforcement */\n#define MNTOPT_GQUOTANOENF \"gqnoenforce\"/* group quota limit enforcement */\n#define MNTOPT_UQUOTANOENF \"uqnoenforce\"/* user quota limit enforcement */\n#define MNTOPT_PRJQUOTA\t\"prjquota\"\t/* project quota enabled */\n#define MNTOPT_GRPQUOTA\t\"grpquota\"\t/* group quota enabled */\n#define MNTOPT_USRQUOTA\t\"usrquota\"\t/* user quota enabled */\n#define MNTOPT_NOQUOTA\t\"noquota\"\t/* no quotas */\n#define MNTOPT_FILESTREAM  \"filestreams\" /* use filestreams allocator */\n#define MNTOPT_ATTR2\t\"attr2\"\t\t/* do use attr2 attribute format */\n#define MNTOPT_LARGEIO\t   \"largeio\"\t/* report large I/O sizes in stat() */\n#define MNTOPT_IKEEP\t\"ikeep\"\t\t/* do not free empty inode clusters */\n#define MNTOPT_32BITINODE   \"inode32\"\t/* inode allocation limited to\n\t\t\t\t\t * XFS_MAXINUMBER_32 */\n#define MNTOPT_64BITINODE   \"inode64\"\t/* inodes can be allocated anywhere */\n#define MNTOPT_NOBARRIER \"nobarrier\"\t/* .. disable */\n#define MNTOPT_NORECOVERY   \"norecovery\"   /* don't run XFS recovery */\n#define MNTOPT_ALLOCSIZE    \"allocsize\"    /* preferred allocation size */\n#define MNTOPT_GRPID\t\"grpid\"\t\t/* group-ID from parent directory */\n#define MNTOPT_NOUUID\t\"nouuid\"\t/* ignore filesystem UUID */\n#define MNTOPT_SWIDTH\t\"swidth\"\t/* data volume stripe width */\n#define MNTOPT_SUNIT\t\"sunit\"\t\t/* data volume stripe unit */\n#define MNTOPT_SWALLOC\t\"swalloc\"\t/* turn on stripe width allocation */\n#define MNTOPT_NOALIGN\t\"noalign\"\t/* turn off stripe alignment */\n#define MNTOPT_WSYNC\t\"wsync\"\t\t/* safe-mode nfs compatible mount */\n#define MNTOPT_RTDEV\t\"rtdev\"\t\t/* realtime I/O device */\n#define MNTOPT_LOGDEV\t\"logdev\"\t/* log device */\n#define MNTOPT_LOGBSIZE\t\"logbsize\"\t/* size of XFS log buffers */\n#define MNTOPT_LOGBUFS\t\"logbufs\"\t/* number of XFS log buffers */\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_showargs(\n\tstruct xfs_mount\t*mp,\n\tstruct seq_file\t\t*m)\n{\n\tstatic struct proc_xfs_info xfs_info_set[] = {\n\t\t/* the few simple ones we can get from the mount struct */\n\t\t{ XFS_MOUNT_IKEEP,\t\t\",\" MNTOPT_IKEEP },\n\t\t{ XFS_MOUNT_WSYNC,\t\t\",\" MNTOPT_WSYNC },\n\t\t{ XFS_MOUNT_NOALIGN,\t\t\",\" MNTOPT_NOALIGN },\n\t\t{ XFS_MOUNT_SWALLOC,\t\t\",\" MNTOPT_SWALLOC },\n\t\t{ XFS_MOUNT_NOUUID,\t\t\",\" MNTOPT_NOUUID },\n\t\t{ XFS_MOUNT_NORECOVERY,\t\t\",\" MNTOPT_NORECOVERY },\n\t\t{ XFS_MOUNT_ATTR2,\t\t\",\" MNTOPT_ATTR2 },\n\t\t{ XFS_MOUNT_FILESTREAMS,\t\",\" MNTOPT_FILESTREAM },\n\t\t{ XFS_MOUNT_GRPID,\t\t\",\" MNTOPT_GRPID },\n\t\t{ XFS_MOUNT_DISCARD,\t\t\",\" MNTOPT_DISCARD },\n\t\t{ XFS_MOUNT_SMALL_INUMS,\t\",\" MNTOPT_32BITINODE },\n\t\t{ 0, NULL }\n\t};\n\tstatic struct proc_xfs_info xfs_info_unset[] = {\n\t\t/* the few simple ones we can get from the mount struct */\n\t\t{ XFS_MOUNT_COMPAT_IOSIZE,\t\",\" MNTOPT_LARGEIO },\n\t\t{ XFS_MOUNT_BARRIER,\t\t\",\" MNTOPT_NOBARRIER },\n\t\t{ XFS_MOUNT_SMALL_INUMS,\t\",\" MNTOPT_64BITINODE },\n\t\t{ 0, NULL }\n\t};\n\tstruct proc_xfs_info\t*xfs_infop;\n\n\tfor (xfs_infop = xfs_info_set; xfs_infop->flag; xfs_infop++) {\n\t\tif (mp->m_flags & xfs_infop->flag)\n\t\t\tseq_puts(m, xfs_infop->str);\n\t}\n\tfor (xfs_infop = xfs_info_unset; xfs_infop->flag; xfs_infop++) {\n\t\tif (!(mp->m_flags & xfs_infop->flag))\n\t\t\tseq_puts(m, xfs_infop->str);\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_DFLT_IOSIZE)\n\t\tseq_printf(m, \",\" MNTOPT_ALLOCSIZE \"=%dk\",\n\t\t\t\t(int)(1 << mp->m_writeio_log) >> 10);\n\n\tif (mp->m_logbufs > 0)\n\t\tseq_printf(m, \",\" MNTOPT_LOGBUFS \"=%d\", mp->m_logbufs);\n\tif (mp->m_logbsize > 0)\n\t\tseq_printf(m, \",\" MNTOPT_LOGBSIZE \"=%dk\", mp->m_logbsize >> 10);\n\n\tif (mp->m_logname)\n\t\tseq_printf(m, \",\" MNTOPT_LOGDEV \"=%s\", mp->m_logname);\n\tif (mp->m_rtname)\n\t\tseq_printf(m, \",\" MNTOPT_RTDEV \"=%s\", mp->m_rtname);\n\n\tif (mp->m_dalign > 0)\n\t\tseq_printf(m, \",\" MNTOPT_SUNIT \"=%d\",\n\t\t\t\t(int)XFS_FSB_TO_BB(mp, mp->m_dalign));\n\tif (mp->m_swidth > 0)\n\t\tseq_printf(m, \",\" MNTOPT_SWIDTH \"=%d\",\n\t\t\t\t(int)XFS_FSB_TO_BB(mp, mp->m_swidth));\n\n\tif (mp->m_qflags & (XFS_UQUOTA_ACCT|XFS_UQUOTA_ENFD))\n\t\tseq_puts(m, \",\" MNTOPT_USRQUOTA);\n\telse if (mp->m_qflags & XFS_UQUOTA_ACCT)\n\t\tseq_puts(m, \",\" MNTOPT_UQUOTANOENF);\n\n\tif (mp->m_qflags & XFS_PQUOTA_ACCT) {\n\t\tif (mp->m_qflags & XFS_PQUOTA_ENFD)\n\t\t\tseq_puts(m, \",\" MNTOPT_PRJQUOTA);\n\t\telse\n\t\t\tseq_puts(m, \",\" MNTOPT_PQUOTANOENF);\n\t}\n\tif (mp->m_qflags & XFS_GQUOTA_ACCT) {\n\t\tif (mp->m_qflags & XFS_GQUOTA_ENFD)\n\t\t\tseq_puts(m, \",\" MNTOPT_GRPQUOTA);\n\t\telse\n\t\t\tseq_puts(m, \",\" MNTOPT_GQUOTANOENF);\n\t}\n\n\tif (!(mp->m_qflags & XFS_ALL_QUOTA_ACCT))\n\t\tseq_puts(m, \",\" MNTOPT_NOQUOTA);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_parseargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "173-472",
    "snippet": "STATIC int\nxfs_parseargs(\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t*options)\n{\n\tstruct super_block\t*sb = mp->m_super;\n\tchar\t\t\t*this_char, *value;\n\tint\t\t\tdsunit = 0;\n\tint\t\t\tdswidth = 0;\n\tint\t\t\tiosize = 0;\n\t__uint8_t\t\tiosizelog = 0;\n\n\t/*\n\t * set up the mount name first so all the errors will refer to the\n\t * correct device.\n\t */\n\tmp->m_fsname = kstrndup(sb->s_id, MAXNAMELEN, GFP_KERNEL);\n\tif (!mp->m_fsname)\n\t\treturn -ENOMEM;\n\tmp->m_fsname_len = strlen(mp->m_fsname) + 1;\n\n\t/*\n\t * Copy binary VFS mount flags we are interested in.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\tmp->m_flags |= XFS_MOUNT_RDONLY;\n\tif (sb->s_flags & MS_DIRSYNC)\n\t\tmp->m_flags |= XFS_MOUNT_DIRSYNC;\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tmp->m_flags |= XFS_MOUNT_WSYNC;\n\n\t/*\n\t * Set some default flags that could be cleared by the mount option\n\t * parsing.\n\t */\n\tmp->m_flags |= XFS_MOUNT_BARRIER;\n\tmp->m_flags |= XFS_MOUNT_COMPAT_IOSIZE;\n\n\t/*\n\t * These can be overridden by the mount option parsing.\n\t */\n\tmp->m_logbufs = -1;\n\tmp->m_logbsize = -1;\n\n\tif (!options)\n\t\tgoto done;\n\n\twhile ((this_char = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_char)\n\t\t\tcontinue;\n\t\tif ((value = strchr(this_char, '=')) != NULL)\n\t\t\t*value++ = 0;\n\n\t\tif (!strcmp(this_char, MNTOPT_LOGBUFS)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &mp->m_logbufs))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_LOGBSIZE)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (suffix_kstrtoint(value, 10, &mp->m_logbsize))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_LOGDEV)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmp->m_logname = kstrndup(value, MAXNAMELEN, GFP_KERNEL);\n\t\t\tif (!mp->m_logname)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!strcmp(this_char, MNTOPT_MTPT)) {\n\t\t\txfs_warn(mp, \"%s option not allowed on this system\",\n\t\t\t\tthis_char);\n\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_RTDEV)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmp->m_rtname = kstrndup(value, MAXNAMELEN, GFP_KERNEL);\n\t\t\tif (!mp->m_rtname)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!strcmp(this_char, MNTOPT_BIOSIZE)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &iosize))\n\t\t\t\treturn -EINVAL;\n\t\t\tiosizelog = ffs(iosize) - 1;\n\t\t} else if (!strcmp(this_char, MNTOPT_ALLOCSIZE)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (suffix_kstrtoint(value, 10, &iosize))\n\t\t\t\treturn -EINVAL;\n\t\t\tiosizelog = ffs(iosize) - 1;\n\t\t} else if (!strcmp(this_char, MNTOPT_GRPID) ||\n\t\t\t   !strcmp(this_char, MNTOPT_BSDGROUPS)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_GRPID;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOGRPID) ||\n\t\t\t   !strcmp(this_char, MNTOPT_SYSVGROUPS)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_GRPID;\n\t\t} else if (!strcmp(this_char, MNTOPT_WSYNC)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_WSYNC;\n\t\t} else if (!strcmp(this_char, MNTOPT_NORECOVERY)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_NORECOVERY;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOALIGN)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_NOALIGN;\n\t\t} else if (!strcmp(this_char, MNTOPT_SWALLOC)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_SWALLOC;\n\t\t} else if (!strcmp(this_char, MNTOPT_SUNIT)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &dsunit))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_SWIDTH)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &dswidth))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_32BITINODE)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_SMALL_INUMS;\n\t\t} else if (!strcmp(this_char, MNTOPT_64BITINODE)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOUUID)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_NOUUID;\n\t\t} else if (!strcmp(this_char, MNTOPT_BARRIER)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_BARRIER;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOBARRIER)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_BARRIER;\n\t\t} else if (!strcmp(this_char, MNTOPT_IKEEP)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_IKEEP;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOIKEEP)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_IKEEP;\n\t\t} else if (!strcmp(this_char, MNTOPT_LARGEIO)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_COMPAT_IOSIZE;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOLARGEIO)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_COMPAT_IOSIZE;\n\t\t} else if (!strcmp(this_char, MNTOPT_ATTR2)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_ATTR2;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOATTR2)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_ATTR2;\n\t\t\tmp->m_flags |= XFS_MOUNT_NOATTR2;\n\t\t} else if (!strcmp(this_char, MNTOPT_FILESTREAM)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_FILESTREAMS;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOQUOTA)) {\n\t\t\tmp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;\n\t\t\tmp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;\n\t\t\tmp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;\n\t\t} else if (!strcmp(this_char, MNTOPT_QUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_UQUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_USRQUOTA)) {\n\t\t\tmp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |\n\t\t\t\t\t XFS_UQUOTA_ENFD);\n\t\t} else if (!strcmp(this_char, MNTOPT_QUOTANOENF) ||\n\t\t\t   !strcmp(this_char, MNTOPT_UQUOTANOENF)) {\n\t\t\tmp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);\n\t\t\tmp->m_qflags &= ~XFS_UQUOTA_ENFD;\n\t\t} else if (!strcmp(this_char, MNTOPT_PQUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_PRJQUOTA)) {\n\t\t\tmp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |\n\t\t\t\t\t XFS_PQUOTA_ENFD);\n\t\t} else if (!strcmp(this_char, MNTOPT_PQUOTANOENF)) {\n\t\t\tmp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);\n\t\t\tmp->m_qflags &= ~XFS_PQUOTA_ENFD;\n\t\t} else if (!strcmp(this_char, MNTOPT_GQUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_GRPQUOTA)) {\n\t\t\tmp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |\n\t\t\t\t\t XFS_GQUOTA_ENFD);\n\t\t} else if (!strcmp(this_char, MNTOPT_GQUOTANOENF)) {\n\t\t\tmp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);\n\t\t\tmp->m_qflags &= ~XFS_GQUOTA_ENFD;\n\t\t} else if (!strcmp(this_char, MNTOPT_DELAYLOG)) {\n\t\t\txfs_warn(mp,\n\t\"delaylog is the default now, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, MNTOPT_NODELAYLOG)) {\n\t\t\txfs_warn(mp,\n\t\"nodelaylog support has been removed, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, MNTOPT_DISCARD)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_DISCARD;\n\t\t} else if (!strcmp(this_char, MNTOPT_NODISCARD)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_DISCARD;\n\t\t} else if (!strcmp(this_char, \"ihashsize\")) {\n\t\t\txfs_warn(mp,\n\t\"ihashsize no longer used, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, \"osyncisdsync\")) {\n\t\t\txfs_warn(mp,\n\t\"osyncisdsync has no effect, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, \"osyncisosync\")) {\n\t\t\txfs_warn(mp,\n\t\"osyncisosync has no effect, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, \"irixsgid\")) {\n\t\t\txfs_warn(mp,\n\t\"irixsgid is now a sysctl(2) variable, option is deprecated.\");\n\t\t} else {\n\t\t\txfs_warn(mp, \"unknown mount option [%s].\", this_char);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * no recovery flag requires a read-only mount\n\t */\n\tif ((mp->m_flags & XFS_MOUNT_NORECOVERY) &&\n\t    !(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\txfs_warn(mp, \"no-recovery mounts must be read-only.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((mp->m_flags & XFS_MOUNT_NOALIGN) && (dsunit || dswidth)) {\n\t\txfs_warn(mp,\n\t\"sunit and swidth options incompatible with the noalign option\");\n\t\treturn -EINVAL;\n\t}\n\n#ifndef CONFIG_XFS_QUOTA\n\tif (XFS_IS_QUOTA_RUNNING(mp)) {\n\t\txfs_warn(mp, \"quota support not available in this kernel.\");\n\t\treturn -EINVAL;\n\t}\n#endif\n\n\tif ((dsunit && !dswidth) || (!dsunit && dswidth)) {\n\t\txfs_warn(mp, \"sunit and swidth must be specified together\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dsunit && (dswidth % dsunit != 0)) {\n\t\txfs_warn(mp,\n\t\"stripe width (%d) must be a multiple of the stripe unit (%d)\",\n\t\t\tdswidth, dsunit);\n\t\treturn -EINVAL;\n\t}\n\ndone:\n\tif (dsunit && !(mp->m_flags & XFS_MOUNT_NOALIGN)) {\n\t\t/*\n\t\t * At this point the superblock has not been read\n\t\t * in, therefore we do not know the block size.\n\t\t * Before the mount call ends we will convert\n\t\t * these to FSBs.\n\t\t */\n\t\tmp->m_dalign = dsunit;\n\t\tmp->m_swidth = dswidth;\n\t}\n\n\tif (mp->m_logbufs != -1 &&\n\t    mp->m_logbufs != 0 &&\n\t    (mp->m_logbufs < XLOG_MIN_ICLOGS ||\n\t     mp->m_logbufs > XLOG_MAX_ICLOGS)) {\n\t\txfs_warn(mp, \"invalid logbufs value: %d [not %d-%d]\",\n\t\t\tmp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);\n\t\treturn -EINVAL;\n\t}\n\tif (mp->m_logbsize != -1 &&\n\t    mp->m_logbsize !=  0 &&\n\t    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||\n\t     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||\n\t     !is_power_of_2(mp->m_logbsize))) {\n\t\txfs_warn(mp,\n\t\t\t\"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]\",\n\t\t\tmp->m_logbsize);\n\t\treturn -EINVAL;\n\t}\n\n\tif (iosizelog) {\n\t\tif (iosizelog > XFS_MAX_IO_LOG ||\n\t\t    iosizelog < XFS_MIN_IO_LOG) {\n\t\t\txfs_warn(mp, \"invalid log iosize: %d [not %d-%d]\",\n\t\t\t\tiosizelog, XFS_MIN_IO_LOG,\n\t\t\t\tXFS_MAX_IO_LOG);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmp->m_flags |= XFS_MOUNT_DFLT_IOSIZE;\n\t\tmp->m_readio_log = iosizelog;\n\t\tmp->m_writeio_log = iosizelog;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define MNTOPT_NODISCARD   \"nodiscard\"\t/* Do not discard unused blocks */",
      "#define MNTOPT_DISCARD\t   \"discard\"\t/* Discard unused blocks */",
      "#define MNTOPT_NODELAYLOG  \"nodelaylog\"\t/* Delayed logging disabled */",
      "#define MNTOPT_DELAYLOG    \"delaylog\"\t/* Delayed logging enabled */",
      "#define MNTOPT_QUOTANOENF  \"qnoenforce\"\t/* same as uqnoenforce */",
      "#define MNTOPT_PQUOTANOENF \"pqnoenforce\"/* project quota limit enforcement */",
      "#define MNTOPT_GQUOTANOENF \"gqnoenforce\"/* group quota limit enforcement */",
      "#define MNTOPT_UQUOTANOENF \"uqnoenforce\"/* user quota limit enforcement */",
      "#define MNTOPT_PQUOTA\t\"pquota\"\t/* project quota (IRIX variant) */",
      "#define MNTOPT_GQUOTA\t\"gquota\"\t/* group quota (IRIX variant) */",
      "#define MNTOPT_UQUOTA\t\"uquota\"\t/* user quota (IRIX variant) */",
      "#define MNTOPT_PRJQUOTA\t\"prjquota\"\t/* project quota enabled */",
      "#define MNTOPT_GRPQUOTA\t\"grpquota\"\t/* group quota enabled */",
      "#define MNTOPT_USRQUOTA\t\"usrquota\"\t/* user quota enabled */",
      "#define MNTOPT_NOQUOTA\t\"noquota\"\t/* no quotas */",
      "#define MNTOPT_QUOTA\t\"quota\"\t\t/* disk quotas (user) */",
      "#define MNTOPT_FILESTREAM  \"filestreams\" /* use filestreams allocator */",
      "#define MNTOPT_NOATTR2\t\"noattr2\"\t/* do not use attr2 attribute format */",
      "#define MNTOPT_ATTR2\t\"attr2\"\t\t/* do use attr2 attribute format */",
      "#define MNTOPT_NOLARGEIO   \"nolargeio\"\t/* do not report large I/O sizes\n\t\t\t\t\t * in stat(). */",
      "#define MNTOPT_LARGEIO\t   \"largeio\"\t/* report large I/O sizes in stat() */",
      "#define MNTOPT_NOIKEEP\t\"noikeep\"\t/* free empty inode clusters */",
      "#define MNTOPT_IKEEP\t\"ikeep\"\t\t/* do not free empty inode clusters */",
      "#define MNTOPT_32BITINODE   \"inode32\"\t/* inode allocation limited to\n\t\t\t\t\t * XFS_MAXINUMBER_32 */",
      "#define MNTOPT_64BITINODE   \"inode64\"\t/* inodes can be allocated anywhere */",
      "#define MNTOPT_NOBARRIER \"nobarrier\"\t/* .. disable */",
      "#define MNTOPT_BARRIER\t\"barrier\"\t/* use writer barriers for log write and\n\t\t\t\t\t * unwritten extent conversion */",
      "#define MNTOPT_NORECOVERY   \"norecovery\"   /* don't run XFS recovery */",
      "#define MNTOPT_ALLOCSIZE    \"allocsize\"    /* preferred allocation size */",
      "#define MNTOPT_SYSVGROUPS   \"sysvgroups\"   /* group-ID from current process */",
      "#define MNTOPT_BSDGROUPS    \"bsdgroups\"    /* group-ID from parent directory */",
      "#define MNTOPT_NOGRPID\t\"nogrpid\"\t/* group-ID from current process */",
      "#define MNTOPT_GRPID\t\"grpid\"\t\t/* group-ID from parent directory */",
      "#define MNTOPT_MTPT\t\"mtpt\"\t\t/* filesystem mount point */",
      "#define MNTOPT_NOUUID\t\"nouuid\"\t/* ignore filesystem UUID */",
      "#define MNTOPT_SWIDTH\t\"swidth\"\t/* data volume stripe width */",
      "#define MNTOPT_SUNIT\t\"sunit\"\t\t/* data volume stripe unit */",
      "#define MNTOPT_SWALLOC\t\"swalloc\"\t/* turn on stripe width allocation */",
      "#define MNTOPT_NOALIGN\t\"noalign\"\t/* turn off stripe alignment */",
      "#define MNTOPT_WSYNC\t\"wsync\"\t\t/* safe-mode nfs compatible mount */",
      "#define MNTOPT_BIOSIZE\t\"biosize\"\t/* log2 of preferred buffered io size */",
      "#define MNTOPT_RTDEV\t\"rtdev\"\t\t/* realtime I/O device */",
      "#define MNTOPT_LOGDEV\t\"logdev\"\t/* log device */",
      "#define MNTOPT_LOGBSIZE\t\"logbsize\"\t/* size of XFS log buffers */",
      "#define MNTOPT_LOGBUFS\t\"logbufs\"\t/* number of XFS log buffers */"
    ],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"invalid log iosize: %d [not %d-%d]\"",
            "iosizelog",
            "XFS_MIN_IO_LOG",
            "XFS_MAX_IO_LOG"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]\"",
            "mp->m_logbsize"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "mp->m_logbsize"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"invalid logbufs value: %d [not %d-%d]\"",
            "mp->m_logbufs",
            "XLOG_MIN_ICLOGS",
            "XLOG_MAX_ICLOGS"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"stripe width (%d) must be a multiple of the stripe unit (%d)\"",
            "dswidth",
            "dsunit"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"sunit and swidth must be specified together\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"quota support not available in this kernel.\""
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"sunit and swidth options incompatible with the noalign option\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"no-recovery mounts must be read-only.\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"unknown mount option [%s].\"",
            "this_char"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"irixsgid is now a sysctl(2) variable, option is deprecated.\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "this_char",
            "\"irixsgid\""
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"osyncisosync has no effect, option is deprecated.\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"osyncisdsync has no effect, option is deprecated.\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"ihashsize no longer used, option is deprecated.\""
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"nodelaylog support has been removed, option is deprecated.\""
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"delaylog is the default now, option is deprecated.\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "value",
            "10",
            "&dswidth"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "suffix_kstrtoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "140-164",
          "snippet": "STATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s option requires an argument\"",
            "this_char"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s option requires an argument\"",
            "this_char"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "iosize"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_max_file_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "561-593",
          "snippet": "__uint64_t\nxfs_max_file_offset(\n\tunsigned int\t\tblockshift)\n{\n\tunsigned int\t\tpagefactor = 1;\n\tunsigned int\t\tbitshift = BITS_PER_LONG - 1;\n\n\t/* Figure out maximum filesize, on Linux this can depend on\n\t * the filesystem blocksize (on 32 bit platforms).\n\t * __block_write_begin does this in an [unsigned] long...\n\t *      page->index << (PAGE_CACHE_SHIFT - bbits)\n\t * So, for page sized blocks (4K on 32 bit platforms),\n\t * this wraps at around 8Tb (hence MAX_LFS_FILESIZE which is\n\t *      (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)\n\t * but for smaller blocksizes it is less (bbits = log2 bsize).\n\t * Note1: get_block_t takes a long (implicit cast from above)\n\t * Note2: The Large Block Device (LBD and HAVE_SECTOR_T) patch\n\t * can optionally convert the [unsigned] long from above into\n\t * an [unsigned] long long.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tASSERT(sizeof(sector_t) == 8);\n\tpagefactor = PAGE_CACHE_SIZE;\n\tbitshift = BITS_PER_LONG;\n# else\n\tpagefactor = PAGE_CACHE_SIZE >> (PAGE_CACHE_SHIFT - blockshift);\n# endif\n#endif\n\n\treturn (((__uint64_t)pagefactor) << bitshift) - 1;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n__uint64_t\nxfs_max_file_offset(\n\tunsigned int\t\tblockshift)\n{\n\tunsigned int\t\tpagefactor = 1;\n\tunsigned int\t\tbitshift = BITS_PER_LONG - 1;\n\n\t/* Figure out maximum filesize, on Linux this can depend on\n\t * the filesystem blocksize (on 32 bit platforms).\n\t * __block_write_begin does this in an [unsigned] long...\n\t *      page->index << (PAGE_CACHE_SHIFT - bbits)\n\t * So, for page sized blocks (4K on 32 bit platforms),\n\t * this wraps at around 8Tb (hence MAX_LFS_FILESIZE which is\n\t *      (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)\n\t * but for smaller blocksizes it is less (bbits = log2 bsize).\n\t * Note1: get_block_t takes a long (implicit cast from above)\n\t * Note2: The Large Block Device (LBD and HAVE_SECTOR_T) patch\n\t * can optionally convert the [unsigned] long from above into\n\t * an [unsigned] long long.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tASSERT(sizeof(sector_t) == 8);\n\tpagefactor = PAGE_CACHE_SIZE;\n\tbitshift = BITS_PER_LONG;\n# else\n\tpagefactor = PAGE_CACHE_SIZE >> (PAGE_CACHE_SHIFT - blockshift);\n# endif\n#endif\n\n\treturn (((__uint64_t)pagefactor) << bitshift) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s option requires an argument\"",
            "this_char"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s option requires an argument\"",
            "this_char"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "value",
            "MAXNAMELEN",
            "GFP_KERNEL"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s option requires an argument\"",
            "this_char"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s option not allowed on this system\"",
            "this_char"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "value",
            "MAXNAMELEN",
            "GFP_KERNEL"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s option requires an argument\"",
            "this_char"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s option requires an argument\"",
            "this_char"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s option requires an argument\"",
            "this_char"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "this_char",
            "'='"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mp->m_fsname"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "sb->s_id",
            "MAXNAMELEN",
            "GFP_KERNEL"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n#define MNTOPT_NODISCARD   \"nodiscard\"\t/* Do not discard unused blocks */\n#define MNTOPT_DISCARD\t   \"discard\"\t/* Discard unused blocks */\n#define MNTOPT_NODELAYLOG  \"nodelaylog\"\t/* Delayed logging disabled */\n#define MNTOPT_DELAYLOG    \"delaylog\"\t/* Delayed logging enabled */\n#define MNTOPT_QUOTANOENF  \"qnoenforce\"\t/* same as uqnoenforce */\n#define MNTOPT_PQUOTANOENF \"pqnoenforce\"/* project quota limit enforcement */\n#define MNTOPT_GQUOTANOENF \"gqnoenforce\"/* group quota limit enforcement */\n#define MNTOPT_UQUOTANOENF \"uqnoenforce\"/* user quota limit enforcement */\n#define MNTOPT_PQUOTA\t\"pquota\"\t/* project quota (IRIX variant) */\n#define MNTOPT_GQUOTA\t\"gquota\"\t/* group quota (IRIX variant) */\n#define MNTOPT_UQUOTA\t\"uquota\"\t/* user quota (IRIX variant) */\n#define MNTOPT_PRJQUOTA\t\"prjquota\"\t/* project quota enabled */\n#define MNTOPT_GRPQUOTA\t\"grpquota\"\t/* group quota enabled */\n#define MNTOPT_USRQUOTA\t\"usrquota\"\t/* user quota enabled */\n#define MNTOPT_NOQUOTA\t\"noquota\"\t/* no quotas */\n#define MNTOPT_QUOTA\t\"quota\"\t\t/* disk quotas (user) */\n#define MNTOPT_FILESTREAM  \"filestreams\" /* use filestreams allocator */\n#define MNTOPT_NOATTR2\t\"noattr2\"\t/* do not use attr2 attribute format */\n#define MNTOPT_ATTR2\t\"attr2\"\t\t/* do use attr2 attribute format */\n#define MNTOPT_NOLARGEIO   \"nolargeio\"\t/* do not report large I/O sizes\n\t\t\t\t\t * in stat(). */\n#define MNTOPT_LARGEIO\t   \"largeio\"\t/* report large I/O sizes in stat() */\n#define MNTOPT_NOIKEEP\t\"noikeep\"\t/* free empty inode clusters */\n#define MNTOPT_IKEEP\t\"ikeep\"\t\t/* do not free empty inode clusters */\n#define MNTOPT_32BITINODE   \"inode32\"\t/* inode allocation limited to\n\t\t\t\t\t * XFS_MAXINUMBER_32 */\n#define MNTOPT_64BITINODE   \"inode64\"\t/* inodes can be allocated anywhere */\n#define MNTOPT_NOBARRIER \"nobarrier\"\t/* .. disable */\n#define MNTOPT_BARRIER\t\"barrier\"\t/* use writer barriers for log write and\n\t\t\t\t\t * unwritten extent conversion */\n#define MNTOPT_NORECOVERY   \"norecovery\"   /* don't run XFS recovery */\n#define MNTOPT_ALLOCSIZE    \"allocsize\"    /* preferred allocation size */\n#define MNTOPT_SYSVGROUPS   \"sysvgroups\"   /* group-ID from current process */\n#define MNTOPT_BSDGROUPS    \"bsdgroups\"    /* group-ID from parent directory */\n#define MNTOPT_NOGRPID\t\"nogrpid\"\t/* group-ID from current process */\n#define MNTOPT_GRPID\t\"grpid\"\t\t/* group-ID from parent directory */\n#define MNTOPT_MTPT\t\"mtpt\"\t\t/* filesystem mount point */\n#define MNTOPT_NOUUID\t\"nouuid\"\t/* ignore filesystem UUID */\n#define MNTOPT_SWIDTH\t\"swidth\"\t/* data volume stripe width */\n#define MNTOPT_SUNIT\t\"sunit\"\t\t/* data volume stripe unit */\n#define MNTOPT_SWALLOC\t\"swalloc\"\t/* turn on stripe width allocation */\n#define MNTOPT_NOALIGN\t\"noalign\"\t/* turn off stripe alignment */\n#define MNTOPT_WSYNC\t\"wsync\"\t\t/* safe-mode nfs compatible mount */\n#define MNTOPT_BIOSIZE\t\"biosize\"\t/* log2 of preferred buffered io size */\n#define MNTOPT_RTDEV\t\"rtdev\"\t\t/* realtime I/O device */\n#define MNTOPT_LOGDEV\t\"logdev\"\t/* log device */\n#define MNTOPT_LOGBSIZE\t\"logbsize\"\t/* size of XFS log buffers */\n#define MNTOPT_LOGBUFS\t\"logbufs\"\t/* number of XFS log buffers */\n\nSTATIC struct;\nSTATIC struct;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nxfs_parseargs(\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t*options)\n{\n\tstruct super_block\t*sb = mp->m_super;\n\tchar\t\t\t*this_char, *value;\n\tint\t\t\tdsunit = 0;\n\tint\t\t\tdswidth = 0;\n\tint\t\t\tiosize = 0;\n\t__uint8_t\t\tiosizelog = 0;\n\n\t/*\n\t * set up the mount name first so all the errors will refer to the\n\t * correct device.\n\t */\n\tmp->m_fsname = kstrndup(sb->s_id, MAXNAMELEN, GFP_KERNEL);\n\tif (!mp->m_fsname)\n\t\treturn -ENOMEM;\n\tmp->m_fsname_len = strlen(mp->m_fsname) + 1;\n\n\t/*\n\t * Copy binary VFS mount flags we are interested in.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\tmp->m_flags |= XFS_MOUNT_RDONLY;\n\tif (sb->s_flags & MS_DIRSYNC)\n\t\tmp->m_flags |= XFS_MOUNT_DIRSYNC;\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tmp->m_flags |= XFS_MOUNT_WSYNC;\n\n\t/*\n\t * Set some default flags that could be cleared by the mount option\n\t * parsing.\n\t */\n\tmp->m_flags |= XFS_MOUNT_BARRIER;\n\tmp->m_flags |= XFS_MOUNT_COMPAT_IOSIZE;\n\n\t/*\n\t * These can be overridden by the mount option parsing.\n\t */\n\tmp->m_logbufs = -1;\n\tmp->m_logbsize = -1;\n\n\tif (!options)\n\t\tgoto done;\n\n\twhile ((this_char = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_char)\n\t\t\tcontinue;\n\t\tif ((value = strchr(this_char, '=')) != NULL)\n\t\t\t*value++ = 0;\n\n\t\tif (!strcmp(this_char, MNTOPT_LOGBUFS)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &mp->m_logbufs))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_LOGBSIZE)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (suffix_kstrtoint(value, 10, &mp->m_logbsize))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_LOGDEV)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmp->m_logname = kstrndup(value, MAXNAMELEN, GFP_KERNEL);\n\t\t\tif (!mp->m_logname)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!strcmp(this_char, MNTOPT_MTPT)) {\n\t\t\txfs_warn(mp, \"%s option not allowed on this system\",\n\t\t\t\tthis_char);\n\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_RTDEV)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmp->m_rtname = kstrndup(value, MAXNAMELEN, GFP_KERNEL);\n\t\t\tif (!mp->m_rtname)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!strcmp(this_char, MNTOPT_BIOSIZE)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &iosize))\n\t\t\t\treturn -EINVAL;\n\t\t\tiosizelog = ffs(iosize) - 1;\n\t\t} else if (!strcmp(this_char, MNTOPT_ALLOCSIZE)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (suffix_kstrtoint(value, 10, &iosize))\n\t\t\t\treturn -EINVAL;\n\t\t\tiosizelog = ffs(iosize) - 1;\n\t\t} else if (!strcmp(this_char, MNTOPT_GRPID) ||\n\t\t\t   !strcmp(this_char, MNTOPT_BSDGROUPS)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_GRPID;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOGRPID) ||\n\t\t\t   !strcmp(this_char, MNTOPT_SYSVGROUPS)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_GRPID;\n\t\t} else if (!strcmp(this_char, MNTOPT_WSYNC)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_WSYNC;\n\t\t} else if (!strcmp(this_char, MNTOPT_NORECOVERY)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_NORECOVERY;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOALIGN)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_NOALIGN;\n\t\t} else if (!strcmp(this_char, MNTOPT_SWALLOC)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_SWALLOC;\n\t\t} else if (!strcmp(this_char, MNTOPT_SUNIT)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &dsunit))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_SWIDTH)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\txfs_warn(mp, \"%s option requires an argument\",\n\t\t\t\t\tthis_char);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (kstrtoint(value, 10, &dswidth))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(this_char, MNTOPT_32BITINODE)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_SMALL_INUMS;\n\t\t} else if (!strcmp(this_char, MNTOPT_64BITINODE)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOUUID)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_NOUUID;\n\t\t} else if (!strcmp(this_char, MNTOPT_BARRIER)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_BARRIER;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOBARRIER)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_BARRIER;\n\t\t} else if (!strcmp(this_char, MNTOPT_IKEEP)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_IKEEP;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOIKEEP)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_IKEEP;\n\t\t} else if (!strcmp(this_char, MNTOPT_LARGEIO)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_COMPAT_IOSIZE;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOLARGEIO)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_COMPAT_IOSIZE;\n\t\t} else if (!strcmp(this_char, MNTOPT_ATTR2)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_ATTR2;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOATTR2)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_ATTR2;\n\t\t\tmp->m_flags |= XFS_MOUNT_NOATTR2;\n\t\t} else if (!strcmp(this_char, MNTOPT_FILESTREAM)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_FILESTREAMS;\n\t\t} else if (!strcmp(this_char, MNTOPT_NOQUOTA)) {\n\t\t\tmp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;\n\t\t\tmp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;\n\t\t\tmp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;\n\t\t} else if (!strcmp(this_char, MNTOPT_QUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_UQUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_USRQUOTA)) {\n\t\t\tmp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |\n\t\t\t\t\t XFS_UQUOTA_ENFD);\n\t\t} else if (!strcmp(this_char, MNTOPT_QUOTANOENF) ||\n\t\t\t   !strcmp(this_char, MNTOPT_UQUOTANOENF)) {\n\t\t\tmp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);\n\t\t\tmp->m_qflags &= ~XFS_UQUOTA_ENFD;\n\t\t} else if (!strcmp(this_char, MNTOPT_PQUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_PRJQUOTA)) {\n\t\t\tmp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |\n\t\t\t\t\t XFS_PQUOTA_ENFD);\n\t\t} else if (!strcmp(this_char, MNTOPT_PQUOTANOENF)) {\n\t\t\tmp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);\n\t\t\tmp->m_qflags &= ~XFS_PQUOTA_ENFD;\n\t\t} else if (!strcmp(this_char, MNTOPT_GQUOTA) ||\n\t\t\t   !strcmp(this_char, MNTOPT_GRPQUOTA)) {\n\t\t\tmp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |\n\t\t\t\t\t XFS_GQUOTA_ENFD);\n\t\t} else if (!strcmp(this_char, MNTOPT_GQUOTANOENF)) {\n\t\t\tmp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);\n\t\t\tmp->m_qflags &= ~XFS_GQUOTA_ENFD;\n\t\t} else if (!strcmp(this_char, MNTOPT_DELAYLOG)) {\n\t\t\txfs_warn(mp,\n\t\"delaylog is the default now, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, MNTOPT_NODELAYLOG)) {\n\t\t\txfs_warn(mp,\n\t\"nodelaylog support has been removed, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, MNTOPT_DISCARD)) {\n\t\t\tmp->m_flags |= XFS_MOUNT_DISCARD;\n\t\t} else if (!strcmp(this_char, MNTOPT_NODISCARD)) {\n\t\t\tmp->m_flags &= ~XFS_MOUNT_DISCARD;\n\t\t} else if (!strcmp(this_char, \"ihashsize\")) {\n\t\t\txfs_warn(mp,\n\t\"ihashsize no longer used, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, \"osyncisdsync\")) {\n\t\t\txfs_warn(mp,\n\t\"osyncisdsync has no effect, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, \"osyncisosync\")) {\n\t\t\txfs_warn(mp,\n\t\"osyncisosync has no effect, option is deprecated.\");\n\t\t} else if (!strcmp(this_char, \"irixsgid\")) {\n\t\t\txfs_warn(mp,\n\t\"irixsgid is now a sysctl(2) variable, option is deprecated.\");\n\t\t} else {\n\t\t\txfs_warn(mp, \"unknown mount option [%s].\", this_char);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * no recovery flag requires a read-only mount\n\t */\n\tif ((mp->m_flags & XFS_MOUNT_NORECOVERY) &&\n\t    !(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\txfs_warn(mp, \"no-recovery mounts must be read-only.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((mp->m_flags & XFS_MOUNT_NOALIGN) && (dsunit || dswidth)) {\n\t\txfs_warn(mp,\n\t\"sunit and swidth options incompatible with the noalign option\");\n\t\treturn -EINVAL;\n\t}\n\n#ifndef CONFIG_XFS_QUOTA\n\tif (XFS_IS_QUOTA_RUNNING(mp)) {\n\t\txfs_warn(mp, \"quota support not available in this kernel.\");\n\t\treturn -EINVAL;\n\t}\n#endif\n\n\tif ((dsunit && !dswidth) || (!dsunit && dswidth)) {\n\t\txfs_warn(mp, \"sunit and swidth must be specified together\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dsunit && (dswidth % dsunit != 0)) {\n\t\txfs_warn(mp,\n\t\"stripe width (%d) must be a multiple of the stripe unit (%d)\",\n\t\t\tdswidth, dsunit);\n\t\treturn -EINVAL;\n\t}\n\ndone:\n\tif (dsunit && !(mp->m_flags & XFS_MOUNT_NOALIGN)) {\n\t\t/*\n\t\t * At this point the superblock has not been read\n\t\t * in, therefore we do not know the block size.\n\t\t * Before the mount call ends we will convert\n\t\t * these to FSBs.\n\t\t */\n\t\tmp->m_dalign = dsunit;\n\t\tmp->m_swidth = dswidth;\n\t}\n\n\tif (mp->m_logbufs != -1 &&\n\t    mp->m_logbufs != 0 &&\n\t    (mp->m_logbufs < XLOG_MIN_ICLOGS ||\n\t     mp->m_logbufs > XLOG_MAX_ICLOGS)) {\n\t\txfs_warn(mp, \"invalid logbufs value: %d [not %d-%d]\",\n\t\t\tmp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);\n\t\treturn -EINVAL;\n\t}\n\tif (mp->m_logbsize != -1 &&\n\t    mp->m_logbsize !=  0 &&\n\t    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||\n\t     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||\n\t     !is_power_of_2(mp->m_logbsize))) {\n\t\txfs_warn(mp,\n\t\t\t\"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]\",\n\t\t\tmp->m_logbsize);\n\t\treturn -EINVAL;\n\t}\n\n\tif (iosizelog) {\n\t\tif (iosizelog > XFS_MAX_IO_LOG ||\n\t\t    iosizelog < XFS_MIN_IO_LOG) {\n\t\t\txfs_warn(mp, \"invalid log iosize: %d [not %d-%d]\",\n\t\t\t\tiosizelog, XFS_MIN_IO_LOG,\n\t\t\t\tXFS_MAX_IO_LOG);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmp->m_flags |= XFS_MOUNT_DFLT_IOSIZE;\n\t\tmp->m_readio_log = iosizelog;\n\t\tmp->m_writeio_log = iosizelog;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "suffix_kstrtoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
    "lines": "140-164",
    "snippet": "STATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/parser.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mempool.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/namei.h>",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_icreate_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "s",
            "base",
            "&_res"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "suffix_kstrtoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "140-164",
          "snippet": "STATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}"
  }
]