[
  {
    "function_name": "fscache_update_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "1006-1018",
    "snippet": "static const struct fscache_state *fscache_update_object(struct fscache_object *object,\n\t\t\t\t\t\t\t int event)\n{\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tfscache_stat(&fscache_n_updates_run);\n\tfscache_stat(&fscache_n_cop_update_object);\n\tobject->cache->ops->update_object(object);\n\tfscache_stat_d(&fscache_n_cop_update_object);\n\n\t_leave(\"\");\n\treturn transit_to(WAIT_FOR_CMD);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WORK_STATE(UPDATE_OBJECT,\t\"UPDT\", fscache_update_object);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "WAIT_FOR_CMD"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat_d",
          "args": [
            "&fscache_n_cop_update_object"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object->cache->ops->update_object",
          "args": [
            "object"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x},%d\"",
            "object->debug_id",
            "event"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WORK_STATE(UPDATE_OBJECT,\t\"UPDT\", fscache_update_object);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *object,\n\t\t\t\t\t\t\t int event)\n{\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tfscache_stat(&fscache_n_updates_run);\n\tfscache_stat(&fscache_n_cop_update_object);\n\tobject->cache->ops->update_object(object);\n\tfscache_stat_d(&fscache_n_cop_update_object);\n\n\t_leave(\"\");\n\treturn transit_to(WAIT_FOR_CMD);\n}"
  },
  {
    "function_name": "fscache_invalidate_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "991-1001",
    "snippet": "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *object,\n\t\t\t\t\t\t\t     int event)\n{\n\tconst struct fscache_state *s;\n\n\tfscache_stat(&fscache_n_invalidates_run);\n\tfscache_stat(&fscache_n_cop_invalidate_object);\n\ts = _fscache_invalidate_object(object, event);\n\tfscache_stat_d(&fscache_n_cop_invalidate_object);\n\treturn s;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WORK_STATE(INVALIDATE_OBJECT,\t\"INVL\", fscache_invalidate_object);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_stat_d",
          "args": [
            "&fscache_n_cop_invalidate_object"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_fscache_invalidate_object",
          "args": [
            "object",
            "event"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "_fscache_invalidate_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "923-989",
          "snippet": "static const struct fscache_state *_fscache_invalidate_object(struct fscache_object *object,\n\t\t\t\t\t\t\t      int event)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_cookie *cookie = object->cookie;\n\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\t/* We're going to need the cookie.  If the cookie is not available then\n\t * retire the object instead.\n\t */\n\tif (!fscache_use_cookie(object)) {\n\t\tASSERT(object->cookie->stores.rnode == NULL);\n\t\tset_bit(FSCACHE_OBJECT_RETIRED, &object->flags);\n\t\t_leave(\" [no cookie]\");\n\t\treturn transit_to(KILL_OBJECT);\n\t}\n\n\t/* Reject any new read/write ops and abort any that are pending. */\n\tfscache_invalidate_writes(cookie);\n\tclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\n\tfscache_cancel_all_ops(object);\n\n\t/* Now we have to wait for in-progress reads and writes */\n\top = kzalloc(sizeof(*op), GFP_KERNEL);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(op, object->cache->ops->invalidate_object, NULL);\n\top->flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_EXCLUSIVE) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\tif (fscache_submit_exclusive_op(object, op) < 0)\n\t\tgoto submit_op_failed;\n\tspin_unlock(&cookie->lock);\n\tfscache_put_operation(op);\n\n\t/* Once we've completed the invalidation, we know there will be no data\n\t * stored in the cache and thus we can reinstate the data-check-skip\n\t * optimisation.\n\t */\n\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* We can allow read and write requests to come in once again.  They'll\n\t * queue up behind our exclusive invalidation operation.\n\t */\n\tif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\n\t_leave(\" [ok]\");\n\treturn transit_to(UPDATE_OBJECT);\n\nnomem:\n\tclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\n\tfscache_unuse_cookie(object);\n\t_leave(\" [ENOMEM]\");\n\treturn transit_to(KILL_OBJECT);\n\nsubmit_op_failed:\n\tclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\n\tspin_unlock(&cookie->lock);\n\tfscache_unuse_cookie(object);\n\tkfree(op);\n\t_leave(\" [EIO]\");\n\treturn transit_to(KILL_OBJECT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *_fscache_invalidate_object(struct fscache_object *object,\n\t\t\t\t\t\t\t      int event)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_cookie *cookie = object->cookie;\n\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\t/* We're going to need the cookie.  If the cookie is not available then\n\t * retire the object instead.\n\t */\n\tif (!fscache_use_cookie(object)) {\n\t\tASSERT(object->cookie->stores.rnode == NULL);\n\t\tset_bit(FSCACHE_OBJECT_RETIRED, &object->flags);\n\t\t_leave(\" [no cookie]\");\n\t\treturn transit_to(KILL_OBJECT);\n\t}\n\n\t/* Reject any new read/write ops and abort any that are pending. */\n\tfscache_invalidate_writes(cookie);\n\tclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\n\tfscache_cancel_all_ops(object);\n\n\t/* Now we have to wait for in-progress reads and writes */\n\top = kzalloc(sizeof(*op), GFP_KERNEL);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(op, object->cache->ops->invalidate_object, NULL);\n\top->flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_EXCLUSIVE) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\tif (fscache_submit_exclusive_op(object, op) < 0)\n\t\tgoto submit_op_failed;\n\tspin_unlock(&cookie->lock);\n\tfscache_put_operation(op);\n\n\t/* Once we've completed the invalidation, we know there will be no data\n\t * stored in the cache and thus we can reinstate the data-check-skip\n\t * optimisation.\n\t */\n\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* We can allow read and write requests to come in once again.  They'll\n\t * queue up behind our exclusive invalidation operation.\n\t */\n\tif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\n\t_leave(\" [ok]\");\n\treturn transit_to(UPDATE_OBJECT);\n\nnomem:\n\tclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\n\tfscache_unuse_cookie(object);\n\t_leave(\" [ENOMEM]\");\n\treturn transit_to(KILL_OBJECT);\n\nsubmit_op_failed:\n\tclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\n\tspin_unlock(&cookie->lock);\n\tfscache_unuse_cookie(object);\n\tkfree(op);\n\t_leave(\" [EIO]\");\n\treturn transit_to(KILL_OBJECT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WORK_STATE(INVALIDATE_OBJECT,\t\"INVL\", fscache_invalidate_object);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *object,\n\t\t\t\t\t\t\t     int event)\n{\n\tconst struct fscache_state *s;\n\n\tfscache_stat(&fscache_n_invalidates_run);\n\tfscache_stat(&fscache_n_cop_invalidate_object);\n\ts = _fscache_invalidate_object(object, event);\n\tfscache_stat_d(&fscache_n_cop_invalidate_object);\n\treturn s;\n}"
  },
  {
    "function_name": "_fscache_invalidate_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "923-989",
    "snippet": "static const struct fscache_state *_fscache_invalidate_object(struct fscache_object *object,\n\t\t\t\t\t\t\t      int event)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_cookie *cookie = object->cookie;\n\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\t/* We're going to need the cookie.  If the cookie is not available then\n\t * retire the object instead.\n\t */\n\tif (!fscache_use_cookie(object)) {\n\t\tASSERT(object->cookie->stores.rnode == NULL);\n\t\tset_bit(FSCACHE_OBJECT_RETIRED, &object->flags);\n\t\t_leave(\" [no cookie]\");\n\t\treturn transit_to(KILL_OBJECT);\n\t}\n\n\t/* Reject any new read/write ops and abort any that are pending. */\n\tfscache_invalidate_writes(cookie);\n\tclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\n\tfscache_cancel_all_ops(object);\n\n\t/* Now we have to wait for in-progress reads and writes */\n\top = kzalloc(sizeof(*op), GFP_KERNEL);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(op, object->cache->ops->invalidate_object, NULL);\n\top->flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_EXCLUSIVE) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\tif (fscache_submit_exclusive_op(object, op) < 0)\n\t\tgoto submit_op_failed;\n\tspin_unlock(&cookie->lock);\n\tfscache_put_operation(op);\n\n\t/* Once we've completed the invalidation, we know there will be no data\n\t * stored in the cache and thus we can reinstate the data-check-skip\n\t * optimisation.\n\t */\n\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* We can allow read and write requests to come in once again.  They'll\n\t * queue up behind our exclusive invalidation operation.\n\t */\n\tif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\n\t_leave(\" [ok]\");\n\treturn transit_to(UPDATE_OBJECT);\n\nnomem:\n\tclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\n\tfscache_unuse_cookie(object);\n\t_leave(\" [ENOMEM]\");\n\treturn transit_to(KILL_OBJECT);\n\nsubmit_op_failed:\n\tclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\n\tspin_unlock(&cookie->lock);\n\tfscache_unuse_cookie(object);\n\tkfree(op);\n\t_leave(\" [EIO]\");\n\treturn transit_to(KILL_OBJECT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "KILL_OBJECT"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [EIO]\""
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_unuse_cookie",
          "args": [
            "object"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "FSCACHE_OBJECT_IS_LIVE",
            "&object->flags"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "KILL_OBJECT"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_unuse_cookie",
          "args": [
            "object"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "UPDATE_OBJECT"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_INVALIDATING"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "FSCACHE_COOKIE_INVALIDATING",
            "&cookie->flags"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FSCACHE_COOKIE_NO_DATA_YET",
            "&cookie->flags"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_put_operation",
          "args": [
            "op"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "398-455",
          "snippet": "void fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_submit_exclusive_op",
          "args": [
            "object",
            "op"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_submit_exclusive_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "83-139",
          "snippet": "int fscache_submit_exclusive_op(struct fscache_object *object,\n\t\t\t\tstruct fscache_operation *op)\n{\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},\", object->debug_id, op->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tobject->n_exclusive++;\t/* reads and writes must wait */\n\n\t\tif (object->n_in_progress > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_in_progress, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\n\t\t/* need to issue a new write op after this */\n\t\tclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tobject->n_exclusive++;\t/* reads and writes must wait */\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else {\n\t\t/* If we're in any other state, there must have been an I/O\n\t\t * error of some nature.\n\t\t */\n\t\tASSERT(test_bit(FSCACHE_IOERROR, &object->cache->flags));\n\t\tret = -EIO;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nint fscache_submit_exclusive_op(struct fscache_object *object,\n\t\t\t\tstruct fscache_operation *op)\n{\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},\", object->debug_id, op->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tobject->n_exclusive++;\t/* reads and writes must wait */\n\n\t\tif (object->n_in_progress > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_in_progress, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\n\t\t/* need to issue a new write op after this */\n\t\tclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tobject->n_exclusive++;\t/* reads and writes must wait */\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else {\n\t\t/* If we're in any other state, there must have been an I/O\n\t\t * error of some nature.\n\t\t */\n\t\tASSERT(test_bit(FSCACHE_IOERROR, &object->cache->flags));\n\t\tret = -EIO;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_operation_init",
          "args": [
            "op",
            "object->cache->ops->invalidate_object",
            "NULL"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*op)",
            "GFP_KERNEL"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_cancel_all_ops",
          "args": [
            "object"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_cancel_all_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "333-360",
          "snippet": "void fscache_cancel_all_ops(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tspin_lock(&object->lock);\n\n\twhile (!list_empty(&object->pending_ops)) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\t\tfscache_stat(&fscache_n_op_cancelled);\n\t\tlist_del_init(&op->pend_link);\n\n\t\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\t\tobject->n_exclusive--;\n\t\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\t\tfscache_put_operation(op);\n\t\tcond_resched_lock(&object->lock);\n\t}\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_cancel_all_ops(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tspin_lock(&object->lock);\n\n\twhile (!list_empty(&object->pending_ops)) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\t\tfscache_stat(&fscache_n_op_cancelled);\n\t\tlist_del_init(&op->pend_link);\n\n\t\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\t\tobject->n_exclusive--;\n\t\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\t\tfscache_put_operation(op);\n\t\tcond_resched_lock(&object->lock);\n\t}\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_invalidate_writes",
          "args": [
            "cookie"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_invalidate_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "861-891",
          "snippet": "void fscache_invalidate_writes(struct fscache_cookie *cookie)\n{\n\tstruct page *page;\n\tvoid *results[16];\n\tint n, i;\n\n\t_enter(\"\");\n\n\tfor (;;) {\n\t\tspin_lock(&cookie->stores_lock);\n\t\tn = radix_tree_gang_lookup_tag(&cookie->stores, results, 0,\n\t\t\t\t\t       ARRAY_SIZE(results),\n\t\t\t\t\t       FSCACHE_COOKIE_PENDING_TAG);\n\t\tif (n == 0) {\n\t\t\tspin_unlock(&cookie->stores_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\tpage = results[i];\n\t\t\tradix_tree_delete(&cookie->stores, page->index);\n\t\t}\n\n\t\tspin_unlock(&cookie->stores_lock);\n\n\t\tfor (i = n - 1; i >= 0; i--)\n\t\t\tpage_cache_release(results[i]);\n\t}\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid fscache_invalidate_writes(struct fscache_cookie *cookie)\n{\n\tstruct page *page;\n\tvoid *results[16];\n\tint n, i;\n\n\t_enter(\"\");\n\n\tfor (;;) {\n\t\tspin_lock(&cookie->stores_lock);\n\t\tn = radix_tree_gang_lookup_tag(&cookie->stores, results, 0,\n\t\t\t\t\t       ARRAY_SIZE(results),\n\t\t\t\t\t       FSCACHE_COOKIE_PENDING_TAG);\n\t\tif (n == 0) {\n\t\t\tspin_unlock(&cookie->stores_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\tpage = results[i];\n\t\t\tradix_tree_delete(&cookie->stores, page->index);\n\t\t}\n\n\t\tspin_unlock(&cookie->stores_lock);\n\n\t\tfor (i = n - 1; i >= 0; i--)\n\t\t\tpage_cache_release(results[i]);\n\t}\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "KILL_OBJECT"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "object->cookie->stores.rnode == NULL"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_use_cookie",
          "args": [
            "object"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x},%d\"",
            "object->debug_id",
            "event"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *_fscache_invalidate_object(struct fscache_object *object,\n\t\t\t\t\t\t\t      int event)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_cookie *cookie = object->cookie;\n\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\t/* We're going to need the cookie.  If the cookie is not available then\n\t * retire the object instead.\n\t */\n\tif (!fscache_use_cookie(object)) {\n\t\tASSERT(object->cookie->stores.rnode == NULL);\n\t\tset_bit(FSCACHE_OBJECT_RETIRED, &object->flags);\n\t\t_leave(\" [no cookie]\");\n\t\treturn transit_to(KILL_OBJECT);\n\t}\n\n\t/* Reject any new read/write ops and abort any that are pending. */\n\tfscache_invalidate_writes(cookie);\n\tclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\n\tfscache_cancel_all_ops(object);\n\n\t/* Now we have to wait for in-progress reads and writes */\n\top = kzalloc(sizeof(*op), GFP_KERNEL);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(op, object->cache->ops->invalidate_object, NULL);\n\top->flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_EXCLUSIVE) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\tif (fscache_submit_exclusive_op(object, op) < 0)\n\t\tgoto submit_op_failed;\n\tspin_unlock(&cookie->lock);\n\tfscache_put_operation(op);\n\n\t/* Once we've completed the invalidation, we know there will be no data\n\t * stored in the cache and thus we can reinstate the data-check-skip\n\t * optimisation.\n\t */\n\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* We can allow read and write requests to come in once again.  They'll\n\t * queue up behind our exclusive invalidation operation.\n\t */\n\tif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\n\t_leave(\" [ok]\");\n\treturn transit_to(UPDATE_OBJECT);\n\nnomem:\n\tclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\n\tfscache_unuse_cookie(object);\n\t_leave(\" [ENOMEM]\");\n\treturn transit_to(KILL_OBJECT);\n\nsubmit_op_failed:\n\tclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\n\tspin_unlock(&cookie->lock);\n\tfscache_unuse_cookie(object);\n\tkfree(op);\n\t_leave(\" [EIO]\");\n\treturn transit_to(KILL_OBJECT);\n}"
  },
  {
    "function_name": "fscache_check_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "884-917",
    "snippet": "enum fscache_checkaux fscache_check_aux(struct fscache_object *object,\n\t\t\t\t\tconst void *data, uint16_t datalen)\n{\n\tenum fscache_checkaux result;\n\n\tif (!object->cookie->def->check_aux) {\n\t\tfscache_stat(&fscache_n_checkaux_none);\n\t\treturn FSCACHE_CHECKAUX_OKAY;\n\t}\n\n\tresult = object->cookie->def->check_aux(object->cookie->netfs_data,\n\t\t\t\t\t\tdata, datalen);\n\tswitch (result) {\n\t\t/* entry okay as is */\n\tcase FSCACHE_CHECKAUX_OKAY:\n\t\tfscache_stat(&fscache_n_checkaux_okay);\n\t\tbreak;\n\n\t\t/* entry requires update */\n\tcase FSCACHE_CHECKAUX_NEEDS_UPDATE:\n\t\tfscache_stat(&fscache_n_checkaux_update);\n\t\tbreak;\n\n\t\t/* entry requires deletion */\n\tcase FSCACHE_CHECKAUX_OBSOLETE:\n\t\tfscache_stat(&fscache_n_checkaux_obsolete);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_checkaux_obsolete"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object->cookie->def->check_aux",
          "args": [
            "object->cookie->netfs_data",
            "data",
            "datalen"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nenum fscache_checkaux fscache_check_aux(struct fscache_object *object,\n\t\t\t\t\tconst void *data, uint16_t datalen)\n{\n\tenum fscache_checkaux result;\n\n\tif (!object->cookie->def->check_aux) {\n\t\tfscache_stat(&fscache_n_checkaux_none);\n\t\treturn FSCACHE_CHECKAUX_OKAY;\n\t}\n\n\tresult = object->cookie->def->check_aux(object->cookie->netfs_data,\n\t\t\t\t\t\tdata, datalen);\n\tswitch (result) {\n\t\t/* entry okay as is */\n\tcase FSCACHE_CHECKAUX_OKAY:\n\t\tfscache_stat(&fscache_n_checkaux_okay);\n\t\tbreak;\n\n\t\t/* entry requires update */\n\tcase FSCACHE_CHECKAUX_NEEDS_UPDATE:\n\t\tfscache_stat(&fscache_n_checkaux_update);\n\t\tbreak;\n\n\t\t/* entry requires deletion */\n\tcase FSCACHE_CHECKAUX_OBSOLETE:\n\t\tfscache_stat(&fscache_n_checkaux_obsolete);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "fscache_dequeue_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "860-871",
    "snippet": "static void fscache_dequeue_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (!list_empty(&object->dep_link)) {\n\t\tspin_lock(&object->parent->lock);\n\t\tlist_del_init(&object->dep_link);\n\t\tspin_unlock(&object->parent->lock);\n\t}\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->parent->lock"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&object->dep_link"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&object->parent->lock"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&object->dep_link"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x}\"",
            "object->debug_id"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic void fscache_dequeue_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (!list_empty(&object->dep_link)) {\n\t\tspin_lock(&object->parent->lock);\n\t\tlist_del_init(&object->dep_link);\n\t\tspin_unlock(&object->parent->lock);\n\t}\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_enqueue_dependents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "827-855",
    "snippet": "static bool fscache_enqueue_dependents(struct fscache_object *object, int event)\n{\n\tstruct fscache_object *dep;\n\tbool ret = true;\n\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (list_empty(&object->dependents))\n\t\treturn true;\n\n\tspin_lock(&object->lock);\n\n\twhile (!list_empty(&object->dependents)) {\n\t\tdep = list_entry(object->dependents.next,\n\t\t\t\t struct fscache_object, dep_link);\n\t\tlist_del_init(&dep->dep_link);\n\n\t\tfscache_raise_event(dep, event);\n\t\tfscache_put_object(dep);\n\n\t\tif (!list_empty(&object->dependents) && need_resched()) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&object->dependents"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_put_object",
          "args": [
            "dep"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "747-752",
          "snippet": "static void fscache_put_object(struct fscache_object *object)\n{\n\tfscache_stat(&fscache_n_cop_put_object);\n\tobject->cache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic void fscache_put_object(struct fscache_object *object)\n{\n\tfscache_stat(&fscache_n_cop_put_object);\n\tobject->cache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_raise_event",
          "args": [
            "dep",
            "event"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_raise_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "299-310",
          "snippet": "static inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fscache_enqueue_object(struct fscache_object *);",
            "extern void fscache_cancel_all_ops(struct fscache_object *);",
            "extern void fscache_abort_object(struct fscache_object *);",
            "extern void fscache_start_operations(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern void fscache_enqueue_object(struct fscache_object *);\nextern void fscache_cancel_all_ops(struct fscache_object *);\nextern void fscache_abort_object(struct fscache_object *);\nextern void fscache_start_operations(struct fscache_object *);\n\nstatic inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dep->dep_link"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "object->dependents.next",
            "structfscache_object",
            "dep_link"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&object->lock"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x}\"",
            "object->debug_id"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic bool fscache_enqueue_dependents(struct fscache_object *object, int event)\n{\n\tstruct fscache_object *dep;\n\tbool ret = true;\n\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (list_empty(&object->dependents))\n\t\treturn true;\n\n\tspin_lock(&object->lock);\n\n\twhile (!list_empty(&object->dependents)) {\n\t\tdep = list_entry(object->dependents.next,\n\t\t\t\t struct fscache_object, dep_link);\n\t\tlist_del_init(&dep->dep_link);\n\n\t\tfscache_raise_event(dep, event);\n\t\tfscache_put_object(dep);\n\n\t\tif (!list_empty(&object->dependents) && need_resched()) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "fscache_object_sleep_till_congested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "803-817",
    "snippet": "bool fscache_object_sleep_till_congested(signed long *timeoutp)\n{\n\twait_queue_head_t *cong_wq = this_cpu_ptr(&fscache_object_cong_wait);\n\tDEFINE_WAIT(wait);\n\n\tif (fscache_object_congested())\n\t\treturn true;\n\n\tadd_wait_queue_exclusive(cong_wq, &wait);\n\tif (!fscache_object_congested())\n\t\t*timeoutp = schedule_timeout(*timeoutp);\n\tfinish_wait(cong_wq, &wait);\n\n\treturn fscache_object_congested();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_object_congested",
          "args": [],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_object_congested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "95-98",
          "snippet": "static inline bool fscache_object_congested(void)\n{\n\treturn workqueue_congested(WORK_CPU_UNBOUND, fscache_object_wq);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct workqueue_struct *fscache_object_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern struct workqueue_struct *fscache_object_wq;\n\nstatic inline bool fscache_object_congested(void)\n{\n\treturn workqueue_congested(WORK_CPU_UNBOUND, fscache_object_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "cong_wq",
            "&wait"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "*timeoutp"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue_exclusive",
          "args": [
            "cong_wq",
            "&wait"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&fscache_object_cong_wait"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nbool fscache_object_sleep_till_congested(signed long *timeoutp)\n{\n\twait_queue_head_t *cong_wq = this_cpu_ptr(&fscache_object_cong_wait);\n\tDEFINE_WAIT(wait);\n\n\tif (fscache_object_congested())\n\t\treturn true;\n\n\tadd_wait_queue_exclusive(cong_wq, &wait);\n\tif (!fscache_object_congested())\n\t\t*timeoutp = schedule_timeout(*timeoutp);\n\tfinish_wait(cong_wq, &wait);\n\n\treturn fscache_object_congested();\n}"
  },
  {
    "function_name": "fscache_enqueue_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "773-789",
    "snippet": "void fscache_enqueue_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (fscache_get_object(object) >= 0) {\n\t\twait_queue_head_t *cong_wq =\n\t\t\t&get_cpu_var(fscache_object_cong_wait);\n\n\t\tif (queue_work(fscache_object_wq, &object->work)) {\n\t\t\tif (fscache_object_congested())\n\t\t\t\twake_up(cong_wq);\n\t\t} else\n\t\t\tfscache_put_object(object);\n\n\t\tput_cpu_var(fscache_object_cong_wait);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "fscache_object_cong_wait"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_put_object",
          "args": [
            "object"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "747-752",
          "snippet": "static void fscache_put_object(struct fscache_object *object)\n{\n\tfscache_stat(&fscache_n_cop_put_object);\n\tobject->cache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic void fscache_put_object(struct fscache_object *object)\n{\n\tfscache_stat(&fscache_n_cop_put_object);\n\tobject->cache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "cong_wq"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_object_congested",
          "args": [],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_object_congested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "95-98",
          "snippet": "static inline bool fscache_object_congested(void)\n{\n\treturn workqueue_congested(WORK_CPU_UNBOUND, fscache_object_wq);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct workqueue_struct *fscache_object_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern struct workqueue_struct *fscache_object_wq;\n\nstatic inline bool fscache_object_congested(void)\n{\n\treturn workqueue_congested(WORK_CPU_UNBOUND, fscache_object_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "fscache_object_wq",
            "&object->work"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "fscache_object_cong_wait"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_get_object",
          "args": [
            "object"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_get_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "734-742",
          "snippet": "static int fscache_get_object(struct fscache_object *object)\n{\n\tint ret;\n\n\tfscache_stat(&fscache_n_cop_grab_object);\n\tret = object->cache->ops->grab_object(object) ? 0 : -EAGAIN;\n\tfscache_stat_d(&fscache_n_cop_grab_object);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic int fscache_get_object(struct fscache_object *object)\n{\n\tint ret;\n\n\tfscache_stat(&fscache_n_cop_grab_object);\n\tret = object->cache->ops->grab_object(object) ? 0 : -EAGAIN;\n\tfscache_stat_d(&fscache_n_cop_grab_object);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x}\"",
            "object->debug_id"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nvoid fscache_enqueue_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (fscache_get_object(object) >= 0) {\n\t\twait_queue_head_t *cong_wq =\n\t\t\t&get_cpu_var(fscache_object_cong_wait);\n\n\t\tif (queue_work(fscache_object_wq, &object->work)) {\n\t\t\tif (fscache_object_congested())\n\t\t\t\twake_up(cong_wq);\n\t\t} else\n\t\t\tfscache_put_object(object);\n\n\t\tput_cpu_var(fscache_object_cong_wait);\n\t}\n}"
  },
  {
    "function_name": "fscache_object_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "760-767",
    "snippet": "void fscache_object_destroy(struct fscache_object *object)\n{\n\tfscache_objlist_remove(object);\n\n\t/* We can get rid of the cookie now */\n\tfscache_cookie_put(object->cookie);\n\tobject->cookie = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_cookie_put",
          "args": [
            "object->cookie"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_cookie_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "315-320",
          "snippet": "static inline void fscache_cookie_put(struct fscache_cookie *cookie)\n{\n\tBUG_ON(atomic_read(&cookie->usage) <= 0);\n\tif (atomic_dec_and_test(&cookie->usage))\n\t\t__fscache_cookie_put(cookie);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct fscache_cache *fscache_select_cache_for_object(\n\tstruct fscache_cookie *);",
            "extern void __fscache_cookie_put(struct fscache_cookie *);",
            "extern int fscache_wait_for_deferred_lookup(struct fscache_cookie *);",
            "extern void fscache_invalidate_writes(struct fscache_cookie *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern struct fscache_cache *fscache_select_cache_for_object(\n\tstruct fscache_cookie *);\nextern void __fscache_cookie_put(struct fscache_cookie *);\nextern int fscache_wait_for_deferred_lookup(struct fscache_cookie *);\nextern void fscache_invalidate_writes(struct fscache_cookie *);\n\nstatic inline void fscache_cookie_put(struct fscache_cookie *cookie)\n{\n\tBUG_ON(atomic_read(&cookie->usage) <= 0);\n\tif (atomic_dec_and_test(&cookie->usage))\n\t\t__fscache_cookie_put(cookie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_objlist_remove",
          "args": [
            "object"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_objlist_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object-list.c",
          "lines": "78-89",
          "snippet": "void fscache_objlist_remove(struct fscache_object *obj)\n{\n\tif (RB_EMPTY_NODE(&obj->objlist_link))\n\t\treturn;\n\n\twrite_lock(&fscache_object_list_lock);\n\n\tBUG_ON(RB_EMPTY_ROOT(&fscache_object_list));\n\trb_erase(&obj->objlist_link, &fscache_object_list);\n\n\twrite_unlock(&fscache_object_list_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root fscache_object_list;",
            "static DEFINE_RWLOCK(fscache_object_list_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nstatic struct rb_root fscache_object_list;\nstatic DEFINE_RWLOCK(fscache_object_list_lock);\n\nvoid fscache_objlist_remove(struct fscache_object *obj)\n{\n\tif (RB_EMPTY_NODE(&obj->objlist_link))\n\t\treturn;\n\n\twrite_lock(&fscache_object_list_lock);\n\n\tBUG_ON(RB_EMPTY_ROOT(&fscache_object_list));\n\trb_erase(&obj->objlist_link, &fscache_object_list);\n\n\twrite_unlock(&fscache_object_list_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nvoid fscache_object_destroy(struct fscache_object *object)\n{\n\tfscache_objlist_remove(object);\n\n\t/* We can get rid of the cookie now */\n\tfscache_cookie_put(object->cookie);\n\tobject->cookie = NULL;\n}"
  },
  {
    "function_name": "fscache_put_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "747-752",
    "snippet": "static void fscache_put_object(struct fscache_object *object)\n{\n\tfscache_stat(&fscache_n_cop_put_object);\n\tobject->cache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_stat_d",
          "args": [
            "&fscache_n_cop_put_object"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object->cache->ops->put_object",
          "args": [
            "object"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic void fscache_put_object(struct fscache_object *object)\n{\n\tfscache_stat(&fscache_n_cop_put_object);\n\tobject->cache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\n}"
  },
  {
    "function_name": "fscache_get_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "734-742",
    "snippet": "static int fscache_get_object(struct fscache_object *object)\n{\n\tint ret;\n\n\tfscache_stat(&fscache_n_cop_grab_object);\n\tret = object->cache->ops->grab_object(object) ? 0 : -EAGAIN;\n\tfscache_stat_d(&fscache_n_cop_grab_object);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_stat_d",
          "args": [
            "&fscache_n_cop_grab_object"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object->cache->ops->grab_object",
          "args": [
            "object"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic int fscache_get_object(struct fscache_object *object)\n{\n\tint ret;\n\n\tfscache_stat(&fscache_n_cop_grab_object);\n\tret = object->cache->ops->grab_object(object) ? 0 : -EAGAIN;\n\tfscache_stat_d(&fscache_n_cop_grab_object);\n\treturn ret;\n}"
  },
  {
    "function_name": "fscache_drop_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "669-729",
    "snippet": "static const struct fscache_state *fscache_drop_object(struct fscache_object *object,\n\t\t\t\t\t\t       int event)\n{\n\tstruct fscache_object *parent = object->parent;\n\tstruct fscache_cookie *cookie = object->cookie;\n\tstruct fscache_cache *cache = object->cache;\n\tbool awaken = false;\n\n\t_enter(\"{OBJ%x,%d},%d\", object->debug_id, object->n_children, event);\n\n\tASSERT(cookie != NULL);\n\tASSERT(!hlist_unhashed(&object->cookie_link));\n\n\t/* Make sure the cookie no longer points here and that the netfs isn't\n\t * waiting for us.\n\t */\n\tspin_lock(&cookie->lock);\n\thlist_del_init(&object->cookie_link);\n\tif (hlist_empty(&cookie->backing_objects) &&\n\t    test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\n\t\tawaken = true;\n\tspin_unlock(&cookie->lock);\n\n\tif (awaken)\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\n\n\t/* Prevent a race with our last child, which has to signal EV_CLEARED\n\t * before dropping our spinlock.\n\t */\n\tspin_lock(&object->lock);\n\tspin_unlock(&object->lock);\n\n\t/* Discard from the cache's collection of objects */\n\tspin_lock(&cache->object_list_lock);\n\tlist_del_init(&object->cache_link);\n\tspin_unlock(&cache->object_list_lock);\n\n\tfscache_stat(&fscache_n_cop_drop_object);\n\tcache->ops->drop_object(object);\n\tfscache_stat_d(&fscache_n_cop_drop_object);\n\n\t/* The parent object wants to know when all it dependents have gone */\n\tif (parent) {\n\t\t_debug(\"release parent OBJ%x {%d}\",\n\t\t       parent->debug_id, parent->n_children);\n\n\t\tspin_lock(&parent->lock);\n\t\tparent->n_children--;\n\t\tif (parent->n_children == 0)\n\t\t\tfscache_raise_event(parent, FSCACHE_OBJECT_EV_CLEARED);\n\t\tspin_unlock(&parent->lock);\n\t\tobject->parent = NULL;\n\t}\n\n\t/* this just shifts the object release to the work processor */\n\tfscache_put_object(object);\n\tfscache_stat(&fscache_n_object_dead);\n\n\t_leave(\"\");\n\treturn transit_to(OBJECT_DEAD);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WORK_STATE(DROP_OBJECT,\t\t\"DROP\", fscache_drop_object);",
      "static WAIT_STATE(WAIT_FOR_CLEARANCE,\t\"?CLR\",\n\t\t  TRANSIT_TO(KILL_OBJECT,\t1 << FSCACHE_OBJECT_EV_CLEARED));",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "OBJECT_DEAD"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_object_dead"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_put_object",
          "args": [
            "object"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "747-752",
          "snippet": "static void fscache_put_object(struct fscache_object *object)\n{\n\tfscache_stat(&fscache_n_cop_put_object);\n\tobject->cache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic void fscache_put_object(struct fscache_object *object)\n{\n\tfscache_stat(&fscache_n_cop_put_object);\n\tobject->cache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&parent->lock"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_raise_event",
          "args": [
            "parent",
            "FSCACHE_OBJECT_EV_CLEARED"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_raise_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "299-310",
          "snippet": "static inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fscache_enqueue_object(struct fscache_object *);",
            "extern void fscache_cancel_all_ops(struct fscache_object *);",
            "extern void fscache_abort_object(struct fscache_object *);",
            "extern void fscache_start_operations(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern void fscache_enqueue_object(struct fscache_object *);\nextern void fscache_cancel_all_ops(struct fscache_object *);\nextern void fscache_abort_object(struct fscache_object *);\nextern void fscache_start_operations(struct fscache_object *);\n\nstatic inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&parent->lock"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"release parent OBJ%x {%d}\"",
            "parent->debug_id",
            "parent->n_children"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache->ops->drop_object",
          "args": [
            "object"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&object->cache_link"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_INVALIDATING"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "FSCACHE_COOKIE_INVALIDATING",
            "&cookie->flags"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&object->cookie_link"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!hlist_unhashed(&object->cookie_link)"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&object->cookie_link"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cookie != NULL"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x,%d},%d\"",
            "object->debug_id",
            "object->n_children",
            "event"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WORK_STATE(DROP_OBJECT,\t\t\"DROP\", fscache_drop_object);\nstatic WAIT_STATE(WAIT_FOR_CLEARANCE,\t\"?CLR\",\n\t\t  TRANSIT_TO(KILL_OBJECT,\t1 << FSCACHE_OBJECT_EV_CLEARED));\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *object,\n\t\t\t\t\t\t       int event)\n{\n\tstruct fscache_object *parent = object->parent;\n\tstruct fscache_cookie *cookie = object->cookie;\n\tstruct fscache_cache *cache = object->cache;\n\tbool awaken = false;\n\n\t_enter(\"{OBJ%x,%d},%d\", object->debug_id, object->n_children, event);\n\n\tASSERT(cookie != NULL);\n\tASSERT(!hlist_unhashed(&object->cookie_link));\n\n\t/* Make sure the cookie no longer points here and that the netfs isn't\n\t * waiting for us.\n\t */\n\tspin_lock(&cookie->lock);\n\thlist_del_init(&object->cookie_link);\n\tif (hlist_empty(&cookie->backing_objects) &&\n\t    test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\n\t\tawaken = true;\n\tspin_unlock(&cookie->lock);\n\n\tif (awaken)\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\n\n\t/* Prevent a race with our last child, which has to signal EV_CLEARED\n\t * before dropping our spinlock.\n\t */\n\tspin_lock(&object->lock);\n\tspin_unlock(&object->lock);\n\n\t/* Discard from the cache's collection of objects */\n\tspin_lock(&cache->object_list_lock);\n\tlist_del_init(&object->cache_link);\n\tspin_unlock(&cache->object_list_lock);\n\n\tfscache_stat(&fscache_n_cop_drop_object);\n\tcache->ops->drop_object(object);\n\tfscache_stat_d(&fscache_n_cop_drop_object);\n\n\t/* The parent object wants to know when all it dependents have gone */\n\tif (parent) {\n\t\t_debug(\"release parent OBJ%x {%d}\",\n\t\t       parent->debug_id, parent->n_children);\n\n\t\tspin_lock(&parent->lock);\n\t\tparent->n_children--;\n\t\tif (parent->n_children == 0)\n\t\t\tfscache_raise_event(parent, FSCACHE_OBJECT_EV_CLEARED);\n\t\tspin_unlock(&parent->lock);\n\t\tobject->parent = NULL;\n\t}\n\n\t/* this just shifts the object release to the work processor */\n\tfscache_put_object(object);\n\tfscache_stat(&fscache_n_object_dead);\n\n\t_leave(\"\");\n\treturn transit_to(OBJECT_DEAD);\n}"
  },
  {
    "function_name": "fscache_kill_dependents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "656-664",
    "snippet": "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *object,\n\t\t\t\t\t\t\t   int event)\n{\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tif (!fscache_enqueue_dependents(object, FSCACHE_OBJECT_EV_KILL))\n\t\treturn NO_TRANSIT; /* Not finished */\n\treturn transit_to(WAIT_FOR_CLEARANCE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NO_TRANSIT ((struct fscache_state *)NULL)"
    ],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WORK_STATE(KILL_DEPENDENTS,\t\"KDEP\", fscache_kill_dependents);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "WAIT_FOR_CLEARANCE"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_enqueue_dependents",
          "args": [
            "object",
            "FSCACHE_OBJECT_EV_KILL"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_enqueue_dependents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "827-855",
          "snippet": "static bool fscache_enqueue_dependents(struct fscache_object *object, int event)\n{\n\tstruct fscache_object *dep;\n\tbool ret = true;\n\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (list_empty(&object->dependents))\n\t\treturn true;\n\n\tspin_lock(&object->lock);\n\n\twhile (!list_empty(&object->dependents)) {\n\t\tdep = list_entry(object->dependents.next,\n\t\t\t\t struct fscache_object, dep_link);\n\t\tlist_del_init(&dep->dep_link);\n\n\t\tfscache_raise_event(dep, event);\n\t\tfscache_put_object(dep);\n\n\t\tif (!list_empty(&object->dependents) && need_resched()) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic bool fscache_enqueue_dependents(struct fscache_object *object, int event)\n{\n\tstruct fscache_object *dep;\n\tbool ret = true;\n\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (list_empty(&object->dependents))\n\t\treturn true;\n\n\tspin_lock(&object->lock);\n\n\twhile (!list_empty(&object->dependents)) {\n\t\tdep = list_entry(object->dependents.next,\n\t\t\t\t struct fscache_object, dep_link);\n\t\tlist_del_init(&dep->dep_link);\n\n\t\tfscache_raise_event(dep, event);\n\t\tfscache_put_object(dep);\n\n\t\tif (!list_empty(&object->dependents) && need_resched()) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x},%d\"",
            "object->debug_id",
            "event"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define NO_TRANSIT ((struct fscache_state *)NULL)\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WORK_STATE(KILL_DEPENDENTS,\t\"KDEP\", fscache_kill_dependents);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *object,\n\t\t\t\t\t\t\t   int event)\n{\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tif (!fscache_enqueue_dependents(object, FSCACHE_OBJECT_EV_KILL))\n\t\treturn NO_TRANSIT; /* Not finished */\n\treturn transit_to(WAIT_FOR_CLEARANCE);\n}"
  },
  {
    "function_name": "fscache_kill_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "626-651",
    "snippet": "static const struct fscache_state *fscache_kill_object(struct fscache_object *object,\n\t\t\t\t\t\t       int event)\n{\n\t_enter(\"{OBJ%x,%d,%d},%d\",\n\t       object->debug_id, object->n_ops, object->n_children, event);\n\n\tclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\n\tobject->oob_event_mask = 0;\n\n\tif (list_empty(&object->dependents) &&\n\t    object->n_ops == 0 &&\n\t    object->n_children == 0)\n\t\treturn transit_to(DROP_OBJECT);\n\n\tif (object->n_in_progress == 0) {\n\t\tspin_lock(&object->lock);\n\t\tif (object->n_ops > 0 && object->n_in_progress == 0)\n\t\t\tfscache_start_operations(object);\n\t\tspin_unlock(&object->lock);\n\t}\n\n\tif (!list_empty(&object->dependents))\n\t\treturn transit_to(KILL_DEPENDENTS);\n\n\treturn transit_to(WAIT_FOR_CLEARANCE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WORK_STATE(KILL_OBJECT,\t\t\"KILL\", fscache_kill_object);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "WAIT_FOR_CLEARANCE"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "KILL_DEPENDENTS"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&object->dependents"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_start_operations",
          "args": [
            "object"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_start_operations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "265-290",
          "snippet": "void fscache_start_operations(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\tbool stop = false;\n\n\twhile (!list_empty(&object->pending_ops) && !stop) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\n\t\t\tif (object->n_in_progress > 0)\n\t\t\t\tbreak;\n\t\t\tstop = true;\n\t\t}\n\t\tlist_del_init(&op->pend_link);\n\t\tfscache_run_op(object, op);\n\n\t\t/* the pending queue was holding a ref on the object */\n\t\tfscache_put_operation(op);\n\t}\n\n\tASSERTCMP(object->n_in_progress, <=, object->n_ops);\n\n\t_debug(\"woke %d ops on OBJ%x\",\n\t       object->n_in_progress, object->debug_id);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_start_operations(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\tbool stop = false;\n\n\twhile (!list_empty(&object->pending_ops) && !stop) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\n\t\t\tif (object->n_in_progress > 0)\n\t\t\t\tbreak;\n\t\t\tstop = true;\n\t\t}\n\t\tlist_del_init(&op->pend_link);\n\t\tfscache_run_op(object, op);\n\n\t\t/* the pending queue was holding a ref on the object */\n\t\tfscache_put_operation(op);\n\t}\n\n\tASSERTCMP(object->n_in_progress, <=, object->n_ops);\n\n\t_debug(\"woke %d ops on OBJ%x\",\n\t       object->n_in_progress, object->debug_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&object->lock"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "DROP_OBJECT"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "FSCACHE_OBJECT_IS_LIVE",
            "&object->flags"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x,%d,%d},%d\"",
            "object->debug_id",
            "object->n_ops",
            "object->n_children",
            "event"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WORK_STATE(KILL_OBJECT,\t\t\"KILL\", fscache_kill_object);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *object,\n\t\t\t\t\t\t       int event)\n{\n\t_enter(\"{OBJ%x,%d,%d},%d\",\n\t       object->debug_id, object->n_ops, object->n_children, event);\n\n\tclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\n\tobject->oob_event_mask = 0;\n\n\tif (list_empty(&object->dependents) &&\n\t    object->n_ops == 0 &&\n\t    object->n_children == 0)\n\t\treturn transit_to(DROP_OBJECT);\n\n\tif (object->n_in_progress == 0) {\n\t\tspin_lock(&object->lock);\n\t\tif (object->n_ops > 0 && object->n_in_progress == 0)\n\t\t\tfscache_start_operations(object);\n\t\tspin_unlock(&object->lock);\n\t}\n\n\tif (!list_empty(&object->dependents))\n\t\treturn transit_to(KILL_DEPENDENTS);\n\n\treturn transit_to(WAIT_FOR_CLEARANCE);\n}"
  },
  {
    "function_name": "fscache_lookup_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "600-620",
    "snippet": "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *object,\n\t\t\t\t\t\t\t  int event)\n{\n\tstruct fscache_cookie *cookie;\n\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tobject->oob_event_mask = 0;\n\n\tfscache_stat(&fscache_n_cop_lookup_complete);\n\tobject->cache->ops->lookup_complete(object);\n\tfscache_stat_d(&fscache_n_cop_lookup_complete);\n\n\tcookie = object->cookie;\n\tset_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\tif (test_and_clear_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags))\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\n\n\tfscache_done_parent_op(object);\n\treturn transit_to(KILL_OBJECT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WORK_STATE(LOOKUP_FAILURE,\t\"LCFL\", fscache_lookup_failure);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "KILL_OBJECT"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_done_parent_op",
          "args": [
            "object"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_done_parent_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "149-162",
          "snippet": "static inline void fscache_done_parent_op(struct fscache_object *object)\n{\n\tstruct fscache_object *parent = object->parent;\n\n\t_enter(\"OBJ%x {OBJ%x,%x}\",\n\t       object->debug_id, parent->debug_id, parent->n_ops);\n\n\tspin_lock_nested(&parent->lock, 1);\n\tparent->n_obj_ops--;\n\tparent->n_ops--;\n\tif (parent->n_ops == 0)\n\t\tfscache_raise_event(parent, FSCACHE_OBJECT_EV_CLEARED);\n\tspin_unlock(&parent->lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static WAIT_STATE(WAIT_FOR_CLEARANCE,\t\"?CLR\",\n\t\t  TRANSIT_TO(KILL_OBJECT,\t1 << FSCACHE_OBJECT_EV_CLEARED));",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WAIT_STATE(WAIT_FOR_CLEARANCE,\t\"?CLR\",\n\t\t  TRANSIT_TO(KILL_OBJECT,\t1 << FSCACHE_OBJECT_EV_CLEARED));\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic inline void fscache_done_parent_op(struct fscache_object *object)\n{\n\tstruct fscache_object *parent = object->parent;\n\n\t_enter(\"OBJ%x {OBJ%x,%x}\",\n\t       object->debug_id, parent->debug_id, parent->n_ops);\n\n\tspin_lock_nested(&parent->lock, 1);\n\tparent->n_obj_ops--;\n\tparent->n_ops--;\n\tif (parent->n_ops == 0)\n\t\tfscache_raise_event(parent, FSCACHE_OBJECT_EV_CLEARED);\n\tspin_unlock(&parent->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_LOOKING_UP"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "FSCACHE_COOKIE_LOOKING_UP",
            "&cookie->flags"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FSCACHE_COOKIE_UNAVAILABLE",
            "&cookie->flags"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat_d",
          "args": [
            "&fscache_n_cop_lookup_complete"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object->cache->ops->lookup_complete",
          "args": [
            "object"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x},%d\"",
            "object->debug_id",
            "event"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WORK_STATE(LOOKUP_FAILURE,\t\"LCFL\", fscache_lookup_failure);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *object,\n\t\t\t\t\t\t\t  int event)\n{\n\tstruct fscache_cookie *cookie;\n\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tobject->oob_event_mask = 0;\n\n\tfscache_stat(&fscache_n_cop_lookup_complete);\n\tobject->cache->ops->lookup_complete(object);\n\tfscache_stat_d(&fscache_n_cop_lookup_complete);\n\n\tcookie = object->cookie;\n\tset_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\tif (test_and_clear_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags))\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\n\n\tfscache_done_parent_op(object);\n\treturn transit_to(KILL_OBJECT);\n}"
  },
  {
    "function_name": "fscache_jumpstart_dependents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "587-595",
    "snippet": "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *object,\n\t\t\t\t\t\t\t\tint event)\n{\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tif (!fscache_enqueue_dependents(object, FSCACHE_OBJECT_EV_PARENT_READY))\n\t\treturn NO_TRANSIT; /* Not finished; requeue */\n\treturn transit_to(WAIT_FOR_CMD);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NO_TRANSIT ((struct fscache_state *)NULL)"
    ],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WORK_STATE(JUMPSTART_DEPS,\t\"JUMP\", fscache_jumpstart_dependents);",
      "static WAIT_STATE(WAIT_FOR_PARENT,\t\"?PRN\",\n\t\t  TRANSIT_TO(PARENT_READY,\t1 << FSCACHE_OBJECT_EV_PARENT_READY));",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "WAIT_FOR_CMD"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_enqueue_dependents",
          "args": [
            "object",
            "FSCACHE_OBJECT_EV_PARENT_READY"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_enqueue_dependents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "827-855",
          "snippet": "static bool fscache_enqueue_dependents(struct fscache_object *object, int event)\n{\n\tstruct fscache_object *dep;\n\tbool ret = true;\n\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (list_empty(&object->dependents))\n\t\treturn true;\n\n\tspin_lock(&object->lock);\n\n\twhile (!list_empty(&object->dependents)) {\n\t\tdep = list_entry(object->dependents.next,\n\t\t\t\t struct fscache_object, dep_link);\n\t\tlist_del_init(&dep->dep_link);\n\n\t\tfscache_raise_event(dep, event);\n\t\tfscache_put_object(dep);\n\n\t\tif (!list_empty(&object->dependents) && need_resched()) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic bool fscache_enqueue_dependents(struct fscache_object *object, int event)\n{\n\tstruct fscache_object *dep;\n\tbool ret = true;\n\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (list_empty(&object->dependents))\n\t\treturn true;\n\n\tspin_lock(&object->lock);\n\n\twhile (!list_empty(&object->dependents)) {\n\t\tdep = list_entry(object->dependents.next,\n\t\t\t\t struct fscache_object, dep_link);\n\t\tlist_del_init(&dep->dep_link);\n\n\t\tfscache_raise_event(dep, event);\n\t\tfscache_put_object(dep);\n\n\t\tif (!list_empty(&object->dependents) && need_resched()) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x},%d\"",
            "object->debug_id",
            "event"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define NO_TRANSIT ((struct fscache_state *)NULL)\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WORK_STATE(JUMPSTART_DEPS,\t\"JUMP\", fscache_jumpstart_dependents);\nstatic WAIT_STATE(WAIT_FOR_PARENT,\t\"?PRN\",\n\t\t  TRANSIT_TO(PARENT_READY,\t1 << FSCACHE_OBJECT_EV_PARENT_READY));\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *object,\n\t\t\t\t\t\t\t\tint event)\n{\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tif (!fscache_enqueue_dependents(object, FSCACHE_OBJECT_EV_PARENT_READY))\n\t\treturn NO_TRANSIT; /* Not finished; requeue */\n\treturn transit_to(WAIT_FOR_CMD);\n}"
  },
  {
    "function_name": "fscache_object_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "553-582",
    "snippet": "static const struct fscache_state *fscache_object_available(struct fscache_object *object,\n\t\t\t\t\t\t\t    int event)\n{\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tobject->oob_table = fscache_osm_run_oob;\n\n\tspin_lock(&object->lock);\n\n\tfscache_done_parent_op(object);\n\tif (object->n_in_progress == 0) {\n\t\tif (object->n_ops > 0) {\n\t\t\tASSERTCMP(object->n_ops, >=, object->n_obj_ops);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERT(list_empty(&object->pending_ops));\n\t\t}\n\t}\n\tspin_unlock(&object->lock);\n\n\tfscache_stat(&fscache_n_cop_lookup_complete);\n\tobject->cache->ops->lookup_complete(object);\n\tfscache_stat_d(&fscache_n_cop_lookup_complete);\n\n\tfscache_hist(fscache_obj_instantiate_histogram, object->lookup_jif);\n\tfscache_stat(&fscache_n_object_avail);\n\n\t_leave(\"\");\n\treturn transit_to(JUMPSTART_DEPS);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WORK_STATE(OBJECT_AVAILABLE,\t\"AVBL\", fscache_object_available);",
      "static const struct fscache_transition fscache_osm_run_oob[] = {\n\t   TRANSIT_TO(KILL_OBJECT,\n\t\t      (1 << FSCACHE_OBJECT_EV_ERROR) |\n\t\t      (1 << FSCACHE_OBJECT_EV_KILL)),\n\t   { 0, NULL }\n};",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "JUMPSTART_DEPS"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_object_avail"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_hist",
          "args": [
            "fscache_obj_instantiate_histogram",
            "object->lookup_jif"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_hist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "70-76",
          "snippet": "static inline void fscache_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object->cache->ops->lookup_complete",
          "args": [
            "object"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&object->pending_ops)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&object->pending_ops"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_start_operations",
          "args": [
            "object"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_start_operations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "265-290",
          "snippet": "void fscache_start_operations(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\tbool stop = false;\n\n\twhile (!list_empty(&object->pending_ops) && !stop) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\n\t\t\tif (object->n_in_progress > 0)\n\t\t\t\tbreak;\n\t\t\tstop = true;\n\t\t}\n\t\tlist_del_init(&op->pend_link);\n\t\tfscache_run_op(object, op);\n\n\t\t/* the pending queue was holding a ref on the object */\n\t\tfscache_put_operation(op);\n\t}\n\n\tASSERTCMP(object->n_in_progress, <=, object->n_ops);\n\n\t_debug(\"woke %d ops on OBJ%x\",\n\t       object->n_in_progress, object->debug_id);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_start_operations(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\tbool stop = false;\n\n\twhile (!list_empty(&object->pending_ops) && !stop) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\n\t\t\tif (object->n_in_progress > 0)\n\t\t\t\tbreak;\n\t\t\tstop = true;\n\t\t}\n\t\tlist_del_init(&op->pend_link);\n\t\tfscache_run_op(object, op);\n\n\t\t/* the pending queue was holding a ref on the object */\n\t\tfscache_put_operation(op);\n\t}\n\n\tASSERTCMP(object->n_in_progress, <=, object->n_ops);\n\n\t_debug(\"woke %d ops on OBJ%x\",\n\t       object->n_in_progress, object->debug_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->n_ops",
            ">=,object->n_obj_ops"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_done_parent_op",
          "args": [
            "object"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_done_parent_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "149-162",
          "snippet": "static inline void fscache_done_parent_op(struct fscache_object *object)\n{\n\tstruct fscache_object *parent = object->parent;\n\n\t_enter(\"OBJ%x {OBJ%x,%x}\",\n\t       object->debug_id, parent->debug_id, parent->n_ops);\n\n\tspin_lock_nested(&parent->lock, 1);\n\tparent->n_obj_ops--;\n\tparent->n_ops--;\n\tif (parent->n_ops == 0)\n\t\tfscache_raise_event(parent, FSCACHE_OBJECT_EV_CLEARED);\n\tspin_unlock(&parent->lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static WAIT_STATE(WAIT_FOR_CLEARANCE,\t\"?CLR\",\n\t\t  TRANSIT_TO(KILL_OBJECT,\t1 << FSCACHE_OBJECT_EV_CLEARED));",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WAIT_STATE(WAIT_FOR_CLEARANCE,\t\"?CLR\",\n\t\t  TRANSIT_TO(KILL_OBJECT,\t1 << FSCACHE_OBJECT_EV_CLEARED));\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic inline void fscache_done_parent_op(struct fscache_object *object)\n{\n\tstruct fscache_object *parent = object->parent;\n\n\t_enter(\"OBJ%x {OBJ%x,%x}\",\n\t       object->debug_id, parent->debug_id, parent->n_ops);\n\n\tspin_lock_nested(&parent->lock, 1);\n\tparent->n_obj_ops--;\n\tparent->n_ops--;\n\tif (parent->n_ops == 0)\n\t\tfscache_raise_event(parent, FSCACHE_OBJECT_EV_CLEARED);\n\tspin_unlock(&parent->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&object->lock"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x},%d\"",
            "object->debug_id",
            "event"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WORK_STATE(OBJECT_AVAILABLE,\t\"AVBL\", fscache_object_available);\nstatic const struct fscache_transition fscache_osm_run_oob[] = {\n\t   TRANSIT_TO(KILL_OBJECT,\n\t\t      (1 << FSCACHE_OBJECT_EV_ERROR) |\n\t\t      (1 << FSCACHE_OBJECT_EV_KILL)),\n\t   { 0, NULL }\n};\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *object,\n\t\t\t\t\t\t\t    int event)\n{\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tobject->oob_table = fscache_osm_run_oob;\n\n\tspin_lock(&object->lock);\n\n\tfscache_done_parent_op(object);\n\tif (object->n_in_progress == 0) {\n\t\tif (object->n_ops > 0) {\n\t\t\tASSERTCMP(object->n_ops, >=, object->n_obj_ops);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERT(list_empty(&object->pending_ops));\n\t\t}\n\t}\n\tspin_unlock(&object->lock);\n\n\tfscache_stat(&fscache_n_cop_lookup_complete);\n\tobject->cache->ops->lookup_complete(object);\n\tfscache_stat_d(&fscache_n_cop_lookup_complete);\n\n\tfscache_hist(fscache_obj_instantiate_histogram, object->lookup_jif);\n\tfscache_stat(&fscache_n_object_avail);\n\n\t_leave(\"\");\n\treturn transit_to(JUMPSTART_DEPS);\n}"
  },
  {
    "function_name": "fscache_obtained_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "521-547",
    "snippet": "void fscache_obtained_object(struct fscache_object *object)\n{\n\tstruct fscache_cookie *cookie = object->cookie;\n\n\t_enter(\"{OBJ%x,%s}\", object->debug_id, object->state->name);\n\n\t/* if we were still looking up, then we must have a positive lookup\n\t * result, in which case there may be data available */\n\tif (!test_and_set_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\tfscache_stat(&fscache_n_object_lookups_positive);\n\n\t\t/* We do (presumably) have data */\n\t\tclear_bit_unlock(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t\t/* Allow write requests to begin stacking up and read requests\n\t\t * to begin shovelling data.\n\t\t */\n\t\tclear_bit_unlock(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\n\t} else {\n\t\tfscache_stat(&fscache_n_object_created);\n\t}\n\n\tset_bit(FSCACHE_OBJECT_IS_AVAILABLE, &object->flags);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FSCACHE_OBJECT_IS_AVAILABLE",
            "&object->flags"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_object_created"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_LOOKING_UP"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "FSCACHE_COOKIE_LOOKING_UP",
            "&cookie->flags"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "FSCACHE_COOKIE_UNAVAILABLE",
            "&cookie->flags"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "FSCACHE_COOKIE_NO_DATA_YET",
            "&cookie->flags"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "FSCACHE_OBJECT_IS_LOOKED_UP",
            "&object->flags"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x,%s}\"",
            "object->debug_id",
            "object->state->name"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nvoid fscache_obtained_object(struct fscache_object *object)\n{\n\tstruct fscache_cookie *cookie = object->cookie;\n\n\t_enter(\"{OBJ%x,%s}\", object->debug_id, object->state->name);\n\n\t/* if we were still looking up, then we must have a positive lookup\n\t * result, in which case there may be data available */\n\tif (!test_and_set_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\tfscache_stat(&fscache_n_object_lookups_positive);\n\n\t\t/* We do (presumably) have data */\n\t\tclear_bit_unlock(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t\t/* Allow write requests to begin stacking up and read requests\n\t\t * to begin shovelling data.\n\t\t */\n\t\tclear_bit_unlock(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\n\t} else {\n\t\tfscache_stat(&fscache_n_object_created);\n\t}\n\n\tset_bit(FSCACHE_OBJECT_IS_AVAILABLE, &object->flags);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_object_lookup_negative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "488-508",
    "snippet": "void fscache_object_lookup_negative(struct fscache_object *object)\n{\n\tstruct fscache_cookie *cookie = object->cookie;\n\n\t_enter(\"{OBJ%x,%s}\", object->debug_id, object->state->name);\n\n\tif (!test_and_set_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\tfscache_stat(&fscache_n_object_lookups_negative);\n\n\t\t/* Allow write requests to begin stacking up and read requests to begin\n\t\t * returning ENODATA.\n\t\t */\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t\t_debug(\"wake up lookup %p\", &cookie->flags);\n\t\tclear_bit_unlock(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\n\t}\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_LOOKING_UP"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "FSCACHE_COOKIE_LOOKING_UP",
            "&cookie->flags"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"wake up lookup %p\"",
            "&cookie->flags"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "FSCACHE_COOKIE_UNAVAILABLE",
            "&cookie->flags"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FSCACHE_COOKIE_NO_DATA_YET",
            "&cookie->flags"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_object_lookups_negative"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "FSCACHE_OBJECT_IS_LOOKED_UP",
            "&object->flags"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x,%s}\"",
            "object->debug_id",
            "object->state->name"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nvoid fscache_object_lookup_negative(struct fscache_object *object)\n{\n\tstruct fscache_cookie *cookie = object->cookie;\n\n\t_enter(\"{OBJ%x,%s}\", object->debug_id, object->state->name);\n\n\tif (!test_and_set_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\tfscache_stat(&fscache_n_object_lookups_negative);\n\n\t\t/* Allow write requests to begin stacking up and read requests to begin\n\t\t * returning ENODATA.\n\t\t */\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t\t_debug(\"wake up lookup %p\", &cookie->flags);\n\t\tclear_bit_unlock(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\n\t}\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_look_up_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "429-479",
    "snippet": "static const struct fscache_state *fscache_look_up_object(struct fscache_object *object,\n\t\t\t\t\t\t\t  int event)\n{\n\tstruct fscache_cookie *cookie = object->cookie;\n\tstruct fscache_object *parent = object->parent;\n\tint ret;\n\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tobject->oob_table = fscache_osm_lookup_oob;\n\n\tASSERT(parent != NULL);\n\tASSERTCMP(parent->n_ops, >, 0);\n\tASSERTCMP(parent->n_obj_ops, >, 0);\n\n\t/* make sure the parent is still available */\n\tASSERT(fscache_object_is_available(parent));\n\n\tif (fscache_object_is_dying(parent) ||\n\t    test_bit(FSCACHE_IOERROR, &object->cache->flags) ||\n\t    !fscache_use_cookie(object)) {\n\t\t_leave(\" [unavailable]\");\n\t\treturn transit_to(LOOKUP_FAILURE);\n\t}\n\n\t_debug(\"LOOKUP \\\"%s\\\" in \\\"%s\\\"\",\n\t       cookie->def->name, object->cache->tag->name);\n\n\tfscache_stat(&fscache_n_object_lookups);\n\tfscache_stat(&fscache_n_cop_lookup_object);\n\tret = object->cache->ops->lookup_object(object);\n\tfscache_stat_d(&fscache_n_cop_lookup_object);\n\n\tfscache_unuse_cookie(object);\n\n\tif (ret == -ETIMEDOUT) {\n\t\t/* probably stuck behind another object, so move this one to\n\t\t * the back of the queue */\n\t\tfscache_stat(&fscache_n_object_lookups_timed_out);\n\t\t_leave(\" [timeout]\");\n\t\treturn NO_TRANSIT;\n\t}\n\n\tif (ret < 0) {\n\t\t_leave(\" [error]\");\n\t\treturn transit_to(LOOKUP_FAILURE);\n\t}\n\n\t_leave(\" [ok]\");\n\treturn transit_to(OBJECT_AVAILABLE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NO_TRANSIT ((struct fscache_state *)NULL)"
    ],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WORK_STATE(LOOK_UP_OBJECT,\t\"LOOK\", fscache_look_up_object);",
      "static WORK_STATE(CREATE_OBJECT,\t\"CRTO\", fscache_look_up_object);",
      "static const struct fscache_transition fscache_osm_lookup_oob[] = {\n\t   TRANSIT_TO(LOOKUP_FAILURE,\n\t\t      (1 << FSCACHE_OBJECT_EV_ERROR) |\n\t\t      (1 << FSCACHE_OBJECT_EV_KILL)),\n\t   { 0, NULL }\n};",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "OBJECT_AVAILABLE"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [ok]\""
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "LOOKUP_FAILURE"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_object_lookups_timed_out"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_unuse_cookie",
          "args": [
            "object"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object->cache->ops->lookup_object",
          "args": [
            "object"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"LOOKUP \\\"%s\\\" in \\\"%s\\\"\"",
            "cookie->def->name",
            "object->cache->tag->name"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "LOOKUP_FAILURE"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_use_cookie",
          "args": [
            "object"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_IOERROR",
            "&object->cache->flags"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_object_is_dying",
          "args": [
            "parent"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "fscache_object_is_available(parent)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_available",
          "args": [
            "parent"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "parent->n_obj_ops",
            ">,0"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "parent->n_ops",
            ">,0"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "parent != NULL"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x},%d\"",
            "object->debug_id",
            "event"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define NO_TRANSIT ((struct fscache_state *)NULL)\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WORK_STATE(LOOK_UP_OBJECT,\t\"LOOK\", fscache_look_up_object);\nstatic WORK_STATE(CREATE_OBJECT,\t\"CRTO\", fscache_look_up_object);\nstatic const struct fscache_transition fscache_osm_lookup_oob[] = {\n\t   TRANSIT_TO(LOOKUP_FAILURE,\n\t\t      (1 << FSCACHE_OBJECT_EV_ERROR) |\n\t\t      (1 << FSCACHE_OBJECT_EV_KILL)),\n\t   { 0, NULL }\n};\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *object,\n\t\t\t\t\t\t\t  int event)\n{\n\tstruct fscache_cookie *cookie = object->cookie;\n\tstruct fscache_object *parent = object->parent;\n\tint ret;\n\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tobject->oob_table = fscache_osm_lookup_oob;\n\n\tASSERT(parent != NULL);\n\tASSERTCMP(parent->n_ops, >, 0);\n\tASSERTCMP(parent->n_obj_ops, >, 0);\n\n\t/* make sure the parent is still available */\n\tASSERT(fscache_object_is_available(parent));\n\n\tif (fscache_object_is_dying(parent) ||\n\t    test_bit(FSCACHE_IOERROR, &object->cache->flags) ||\n\t    !fscache_use_cookie(object)) {\n\t\t_leave(\" [unavailable]\");\n\t\treturn transit_to(LOOKUP_FAILURE);\n\t}\n\n\t_debug(\"LOOKUP \\\"%s\\\" in \\\"%s\\\"\",\n\t       cookie->def->name, object->cache->tag->name);\n\n\tfscache_stat(&fscache_n_object_lookups);\n\tfscache_stat(&fscache_n_cop_lookup_object);\n\tret = object->cache->ops->lookup_object(object);\n\tfscache_stat_d(&fscache_n_cop_lookup_object);\n\n\tfscache_unuse_cookie(object);\n\n\tif (ret == -ETIMEDOUT) {\n\t\t/* probably stuck behind another object, so move this one to\n\t\t * the back of the queue */\n\t\tfscache_stat(&fscache_n_object_lookups_timed_out);\n\t\t_leave(\" [timeout]\");\n\t\treturn NO_TRANSIT;\n\t}\n\n\tif (ret < 0) {\n\t\t_leave(\" [error]\");\n\t\treturn transit_to(LOOKUP_FAILURE);\n\t}\n\n\t_leave(\" [ok]\");\n\treturn transit_to(OBJECT_AVAILABLE);\n}"
  },
  {
    "function_name": "fscache_parent_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "405-422",
    "snippet": "static const struct fscache_state *fscache_parent_ready(struct fscache_object *object,\n\t\t\t\t\t\t\tint event)\n{\n\tstruct fscache_object *parent = object->parent;\n\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tASSERT(parent != NULL);\n\n\tspin_lock(&parent->lock);\n\tparent->n_ops++;\n\tparent->n_obj_ops++;\n\tobject->lookup_jif = jiffies;\n\tspin_unlock(&parent->lock);\n\n\t_leave(\"\");\n\treturn transit_to(LOOK_UP_OBJECT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WORK_STATE(PARENT_READY,\t\t\"PRDY\", fscache_parent_ready);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "LOOK_UP_OBJECT"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&parent->lock"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&parent->lock"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "parent != NULL"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x},%d\"",
            "object->debug_id",
            "event"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WORK_STATE(PARENT_READY,\t\t\"PRDY\", fscache_parent_ready);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *object,\n\t\t\t\t\t\t\tint event)\n{\n\tstruct fscache_object *parent = object->parent;\n\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tASSERT(parent != NULL);\n\n\tspin_lock(&parent->lock);\n\tparent->n_ops++;\n\tparent->n_obj_ops++;\n\tobject->lookup_jif = jiffies;\n\tspin_unlock(&parent->lock);\n\n\t_leave(\"\");\n\treturn transit_to(LOOK_UP_OBJECT);\n}"
  },
  {
    "function_name": "fscache_initialise_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "350-400",
    "snippet": "static const struct fscache_state *fscache_initialise_object(struct fscache_object *object,\n\t\t\t\t\t\t\t     int event)\n{\n\tstruct fscache_object *parent;\n\tbool success;\n\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tASSERT(list_empty(&object->dep_link));\n\n\tparent = object->parent;\n\tif (!parent) {\n\t\t_leave(\" [no parent]\");\n\t\treturn transit_to(DROP_OBJECT);\n\t}\n\n\t_debug(\"parent: %s of:%lx\", parent->state->name, parent->flags);\n\n\tif (fscache_object_is_dying(parent)) {\n\t\t_leave(\" [bad parent]\");\n\t\treturn transit_to(DROP_OBJECT);\n\t}\n\n\tif (fscache_object_is_available(parent)) {\n\t\t_leave(\" [ready]\");\n\t\treturn transit_to(PARENT_READY);\n\t}\n\n\t_debug(\"wait\");\n\n\tspin_lock(&parent->lock);\n\tfscache_stat(&fscache_n_cop_grab_object);\n\tsuccess = false;\n\tif (fscache_object_is_live(parent) &&\n\t    object->cache->ops->grab_object(object)) {\n\t\tlist_add(&object->dep_link, &parent->dependents);\n\t\tsuccess = true;\n\t}\n\tfscache_stat_d(&fscache_n_cop_grab_object);\n\tspin_unlock(&parent->lock);\n\tif (!success) {\n\t\t_leave(\" [grab failed]\");\n\t\treturn transit_to(DROP_OBJECT);\n\t}\n\n\t/* fscache_acquire_non_index_cookie() uses this\n\t * to wake the chain up */\n\tfscache_raise_event(parent, FSCACHE_OBJECT_EV_NEW_CHILD);\n\t_leave(\" [wait]\");\n\treturn transit_to(WAIT_FOR_PARENT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WORK_STATE(INIT_OBJECT,\t\t\"INIT\", fscache_initialise_object);",
      "static WORK_STATE(OBJECT_DEAD,\t\t\"DEAD\", (void*)2UL);\n\nstatic WAIT_STATE(WAIT_FOR_INIT,\t\"?INI\",\n\t\t  TRANSIT_TO(INIT_OBJECT,\t1 << FSCACHE_OBJECT_EV_NEW_CHILD));",
      "static WAIT_STATE(WAIT_FOR_CMD,\t\t\"?CMD\",\n\t\t  TRANSIT_TO(INVALIDATE_OBJECT,\t1 << FSCACHE_OBJECT_EV_INVALIDATE),\n\t\t  TRANSIT_TO(UPDATE_OBJECT,\t1 << FSCACHE_OBJECT_EV_UPDATE),\n\t\t  TRANSIT_TO(JUMPSTART_DEPS,\t1 << FSCACHE_OBJECT_EV_NEW_CHILD));",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "WAIT_FOR_PARENT"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [wait]\""
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_raise_event",
          "args": [
            "parent",
            "FSCACHE_OBJECT_EV_NEW_CHILD"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_raise_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "299-310",
          "snippet": "static inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fscache_enqueue_object(struct fscache_object *);",
            "extern void fscache_cancel_all_ops(struct fscache_object *);",
            "extern void fscache_abort_object(struct fscache_object *);",
            "extern void fscache_start_operations(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern void fscache_enqueue_object(struct fscache_object *);\nextern void fscache_cancel_all_ops(struct fscache_object *);\nextern void fscache_abort_object(struct fscache_object *);\nextern void fscache_start_operations(struct fscache_object *);\n\nstatic inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "DROP_OBJECT"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&parent->lock"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat_d",
          "args": [
            "&fscache_n_cop_grab_object"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&object->dep_link",
            "&parent->dependents"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object->cache->ops->grab_object",
          "args": [
            "object"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_live",
          "args": [
            "parent"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&parent->lock"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"wait\""
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "PARENT_READY"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_available",
          "args": [
            "parent"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "DROP_OBJECT"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_dying",
          "args": [
            "parent"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"parent: %s of:%lx\"",
            "parent->state->name",
            "parent->flags"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "DROP_OBJECT"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&object->dep_link)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&object->dep_link"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x},%d\"",
            "object->debug_id",
            "event"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WORK_STATE(INIT_OBJECT,\t\t\"INIT\", fscache_initialise_object);\nstatic WORK_STATE(OBJECT_DEAD,\t\t\"DEAD\", (void*)2UL);\n\nstatic WAIT_STATE(WAIT_FOR_INIT,\t\"?INI\",\n\t\t  TRANSIT_TO(INIT_OBJECT,\t1 << FSCACHE_OBJECT_EV_NEW_CHILD));\nstatic WAIT_STATE(WAIT_FOR_CMD,\t\t\"?CMD\",\n\t\t  TRANSIT_TO(INVALIDATE_OBJECT,\t1 << FSCACHE_OBJECT_EV_INVALIDATE),\n\t\t  TRANSIT_TO(UPDATE_OBJECT,\t1 << FSCACHE_OBJECT_EV_UPDATE),\n\t\t  TRANSIT_TO(JUMPSTART_DEPS,\t1 << FSCACHE_OBJECT_EV_NEW_CHILD));\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *object,\n\t\t\t\t\t\t\t     int event)\n{\n\tstruct fscache_object *parent;\n\tbool success;\n\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tASSERT(list_empty(&object->dep_link));\n\n\tparent = object->parent;\n\tif (!parent) {\n\t\t_leave(\" [no parent]\");\n\t\treturn transit_to(DROP_OBJECT);\n\t}\n\n\t_debug(\"parent: %s of:%lx\", parent->state->name, parent->flags);\n\n\tif (fscache_object_is_dying(parent)) {\n\t\t_leave(\" [bad parent]\");\n\t\treturn transit_to(DROP_OBJECT);\n\t}\n\n\tif (fscache_object_is_available(parent)) {\n\t\t_leave(\" [ready]\");\n\t\treturn transit_to(PARENT_READY);\n\t}\n\n\t_debug(\"wait\");\n\n\tspin_lock(&parent->lock);\n\tfscache_stat(&fscache_n_cop_grab_object);\n\tsuccess = false;\n\tif (fscache_object_is_live(parent) &&\n\t    object->cache->ops->grab_object(object)) {\n\t\tlist_add(&object->dep_link, &parent->dependents);\n\t\tsuccess = true;\n\t}\n\tfscache_stat_d(&fscache_n_cop_grab_object);\n\tspin_unlock(&parent->lock);\n\tif (!success) {\n\t\t_leave(\" [grab failed]\");\n\t\treturn transit_to(DROP_OBJECT);\n\t}\n\n\t/* fscache_acquire_non_index_cookie() uses this\n\t * to wake the chain up */\n\tfscache_raise_event(parent, FSCACHE_OBJECT_EV_NEW_CHILD);\n\t_leave(\" [wait]\");\n\treturn transit_to(WAIT_FOR_PARENT);\n}"
  },
  {
    "function_name": "fscache_abort_initialisation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "333-341",
    "snippet": "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *object,\n\t\t\t\t\t\t\t\tint event)\n{\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tobject->oob_event_mask = 0;\n\tfscache_dequeue_object(object);\n\treturn transit_to(KILL_OBJECT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WORK_STATE(ABORT_INIT,\t\t\"ABRT\", fscache_abort_initialisation);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "transit_to",
          "args": [
            "KILL_OBJECT"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_dequeue_object",
          "args": [
            "object"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_dequeue_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "860-871",
          "snippet": "static void fscache_dequeue_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (!list_empty(&object->dep_link)) {\n\t\tspin_lock(&object->parent->lock);\n\t\tlist_del_init(&object->dep_link);\n\t\tspin_unlock(&object->parent->lock);\n\t}\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic void fscache_dequeue_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (!list_empty(&object->dep_link)) {\n\t\tspin_lock(&object->parent->lock);\n\t\tlist_del_init(&object->dep_link);\n\t\tspin_unlock(&object->parent->lock);\n\t}\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x},%d\"",
            "object->debug_id",
            "event"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WORK_STATE(ABORT_INIT,\t\t\"ABRT\", fscache_abort_initialisation);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *object,\n\t\t\t\t\t\t\t\tint event)\n{\n\t_enter(\"{OBJ%x},%d\", object->debug_id, event);\n\n\tobject->oob_event_mask = 0;\n\tfscache_dequeue_object(object);\n\treturn transit_to(KILL_OBJECT);\n}"
  },
  {
    "function_name": "fscache_object_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "291-327",
    "snippet": "void fscache_object_init(struct fscache_object *object,\n\t\t\t struct fscache_cookie *cookie,\n\t\t\t struct fscache_cache *cache)\n{\n\tconst struct fscache_transition *t;\n\n\tatomic_inc(&cache->object_count);\n\n\tobject->state = STATE(WAIT_FOR_INIT);\n\tobject->oob_table = fscache_osm_init_oob;\n\tobject->flags = 1 << FSCACHE_OBJECT_IS_LIVE;\n\tspin_lock_init(&object->lock);\n\tINIT_LIST_HEAD(&object->cache_link);\n\tINIT_HLIST_NODE(&object->cookie_link);\n\tINIT_WORK(&object->work, fscache_object_work_func);\n\tINIT_LIST_HEAD(&object->dependents);\n\tINIT_LIST_HEAD(&object->dep_link);\n\tINIT_LIST_HEAD(&object->pending_ops);\n\tobject->n_children = 0;\n\tobject->n_ops = object->n_in_progress = object->n_exclusive = 0;\n\tobject->events = 0;\n\tobject->store_limit = 0;\n\tobject->store_limit_l = 0;\n\tobject->cache = cache;\n\tobject->cookie = cookie;\n\tobject->parent = NULL;\n#ifdef CONFIG_FSCACHE_OBJECT_LIST\n\tRB_CLEAR_NODE(&object->objlist_link);\n#endif\n\n\tobject->oob_event_mask = 0;\n\tfor (t = object->oob_table; t->events; t++)\n\t\tobject->oob_event_mask |= t->events;\n\tobject->event_mask = object->oob_event_mask;\n\tfor (t = object->state->transitions; t->events; t++)\n\t\tobject->event_mask |= t->events;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static const struct fscache_transition fscache_osm_init_oob[] = {\n\t   TRANSIT_TO(ABORT_INIT,\n\t\t      (1 << FSCACHE_OBJECT_EV_ERROR) |\n\t\t      (1 << FSCACHE_OBJECT_EV_KILL)),\n\t   { 0, NULL }\n};",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&object->objlist_link"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&object->pending_ops"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&object->dep_link"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&object->dependents"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&object->work",
            "fscache_object_work_func"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&object->cookie_link"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&object->cache_link"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&object->lock"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATE",
          "args": [
            "WAIT_FOR_INIT"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cache->object_count"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic const struct fscache_transition fscache_osm_init_oob[] = {\n\t   TRANSIT_TO(ABORT_INIT,\n\t\t      (1 << FSCACHE_OBJECT_EV_ERROR) |\n\t\t      (1 << FSCACHE_OBJECT_EV_KILL)),\n\t   { 0, NULL }\n};\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nvoid fscache_object_init(struct fscache_object *object,\n\t\t\t struct fscache_cookie *cookie,\n\t\t\t struct fscache_cache *cache)\n{\n\tconst struct fscache_transition *t;\n\n\tatomic_inc(&cache->object_count);\n\n\tobject->state = STATE(WAIT_FOR_INIT);\n\tobject->oob_table = fscache_osm_init_oob;\n\tobject->flags = 1 << FSCACHE_OBJECT_IS_LIVE;\n\tspin_lock_init(&object->lock);\n\tINIT_LIST_HEAD(&object->cache_link);\n\tINIT_HLIST_NODE(&object->cookie_link);\n\tINIT_WORK(&object->work, fscache_object_work_func);\n\tINIT_LIST_HEAD(&object->dependents);\n\tINIT_LIST_HEAD(&object->dep_link);\n\tINIT_LIST_HEAD(&object->pending_ops);\n\tobject->n_children = 0;\n\tobject->n_ops = object->n_in_progress = object->n_exclusive = 0;\n\tobject->events = 0;\n\tobject->store_limit = 0;\n\tobject->store_limit_l = 0;\n\tobject->cache = cache;\n\tobject->cookie = cookie;\n\tobject->parent = NULL;\n#ifdef CONFIG_FSCACHE_OBJECT_LIST\n\tRB_CLEAR_NODE(&object->objlist_link);\n#endif\n\n\tobject->oob_event_mask = 0;\n\tfor (t = object->oob_table; t->events; t++)\n\t\tobject->oob_event_mask |= t->events;\n\tobject->event_mask = object->oob_event_mask;\n\tfor (t = object->state->transitions; t->events; t++)\n\t\tobject->event_mask |= t->events;\n}"
  },
  {
    "function_name": "fscache_object_work_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "266-278",
    "snippet": "static void fscache_object_work_func(struct work_struct *work)\n{\n\tstruct fscache_object *object =\n\t\tcontainer_of(work, struct fscache_object, work);\n\tunsigned long start;\n\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tstart = jiffies;\n\tfscache_object_sm_dispatcher(object);\n\tfscache_hist(fscache_objs_histogram, start);\n\tfscache_put_object(object);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_put_object",
          "args": [
            "object"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "747-752",
          "snippet": "static void fscache_put_object(struct fscache_object *object)\n{\n\tfscache_stat(&fscache_n_cop_put_object);\n\tobject->cache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic void fscache_put_object(struct fscache_object *object)\n{\n\tfscache_stat(&fscache_n_cop_put_object);\n\tobject->cache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_hist",
          "args": [
            "fscache_objs_histogram",
            "start"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_hist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "70-76",
          "snippet": "static inline void fscache_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_object_sm_dispatcher",
          "args": [
            "object"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_object_sm_dispatcher",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "167-261",
          "snippet": "static void fscache_object_sm_dispatcher(struct fscache_object *object)\n{\n\tconst struct fscache_transition *t;\n\tconst struct fscache_state *state, *new_state;\n\tunsigned long events, event_mask;\n\tint event = -1;\n\n\tASSERT(object != NULL);\n\n\t_enter(\"{OBJ%x,%s,%lx}\",\n\t       object->debug_id, object->state->name, object->events);\n\n\tevent_mask = object->event_mask;\nrestart:\n\tobject->event_mask = 0; /* Mask normal event handling */\n\tstate = object->state;\nrestart_masked:\n\tevents = object->events;\n\n\t/* Handle any out-of-band events (typically an error) */\n\tif (events & object->oob_event_mask) {\n\t\t_debug(\"{OBJ%x} oob %lx\",\n\t\t       object->debug_id, events & object->oob_event_mask);\n\t\tfor (t = object->oob_table; t->events; t++) {\n\t\t\tif (events & t->events) {\n\t\t\t\tstate = t->transit_to;\n\t\t\t\tASSERT(state->work != NULL);\n\t\t\t\tevent = fls(events & t->events) - 1;\n\t\t\t\t__clear_bit(event, &object->oob_event_mask);\n\t\t\t\tclear_bit(event, &object->events);\n\t\t\t\tgoto execute_work_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Wait states are just transition tables */\n\tif (!state->work) {\n\t\tif (events & event_mask) {\n\t\t\tfor (t = state->transitions; t->events; t++) {\n\t\t\t\tif (events & t->events) {\n\t\t\t\t\tnew_state = t->transit_to;\n\t\t\t\t\tevent = fls(events & t->events) - 1;\n\t\t\t\t\tclear_bit(event, &object->events);\n\t\t\t\t\t_debug(\"{OBJ%x} ev %d: %s -> %s\",\n\t\t\t\t\t       object->debug_id, event,\n\t\t\t\t\t       state->name, new_state->name);\n\t\t\t\t\tobject->state = state = new_state;\n\t\t\t\t\tgoto execute_work_state;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* The event mask didn't include all the tabled bits */\n\t\t\tBUG();\n\t\t}\n\t\t/* Randomly woke up */\n\t\tgoto unmask_events;\n\t}\n\nexecute_work_state:\n\t_debug(\"{OBJ%x} exec %s\", object->debug_id, state->name);\n\n\tnew_state = state->work(object, event);\n\tevent = -1;\n\tif (new_state == NO_TRANSIT) {\n\t\t_debug(\"{OBJ%x} %s notrans\", object->debug_id, state->name);\n\t\tfscache_enqueue_object(object);\n\t\tevent_mask = object->oob_event_mask;\n\t\tgoto unmask_events;\n\t}\n\n\t_debug(\"{OBJ%x} %s -> %s\",\n\t       object->debug_id, state->name, new_state->name);\n\tobject->state = state = new_state;\n\n\tif (state->work) {\n\t\tif (unlikely(state->work == ((void *)2UL))) {\n\t\t\t_leave(\" [dead]\");\n\t\t\treturn;\n\t\t}\n\t\tgoto restart_masked;\n\t}\n\n\t/* Transited to wait state */\n\tevent_mask = object->oob_event_mask;\n\tfor (t = state->transitions; t->events; t++)\n\t\tevent_mask |= t->events;\n\nunmask_events:\n\tobject->event_mask = event_mask;\n\tsmp_mb();\n\tevents = object->events;\n\tif (events & event_mask)\n\t\tgoto restart;\n\t_leave(\" [msk %lx]\", event_mask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define NO_TRANSIT ((struct fscache_state *)NULL)"
          ],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define NO_TRANSIT ((struct fscache_state *)NULL)\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic void fscache_object_sm_dispatcher(struct fscache_object *object)\n{\n\tconst struct fscache_transition *t;\n\tconst struct fscache_state *state, *new_state;\n\tunsigned long events, event_mask;\n\tint event = -1;\n\n\tASSERT(object != NULL);\n\n\t_enter(\"{OBJ%x,%s,%lx}\",\n\t       object->debug_id, object->state->name, object->events);\n\n\tevent_mask = object->event_mask;\nrestart:\n\tobject->event_mask = 0; /* Mask normal event handling */\n\tstate = object->state;\nrestart_masked:\n\tevents = object->events;\n\n\t/* Handle any out-of-band events (typically an error) */\n\tif (events & object->oob_event_mask) {\n\t\t_debug(\"{OBJ%x} oob %lx\",\n\t\t       object->debug_id, events & object->oob_event_mask);\n\t\tfor (t = object->oob_table; t->events; t++) {\n\t\t\tif (events & t->events) {\n\t\t\t\tstate = t->transit_to;\n\t\t\t\tASSERT(state->work != NULL);\n\t\t\t\tevent = fls(events & t->events) - 1;\n\t\t\t\t__clear_bit(event, &object->oob_event_mask);\n\t\t\t\tclear_bit(event, &object->events);\n\t\t\t\tgoto execute_work_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Wait states are just transition tables */\n\tif (!state->work) {\n\t\tif (events & event_mask) {\n\t\t\tfor (t = state->transitions; t->events; t++) {\n\t\t\t\tif (events & t->events) {\n\t\t\t\t\tnew_state = t->transit_to;\n\t\t\t\t\tevent = fls(events & t->events) - 1;\n\t\t\t\t\tclear_bit(event, &object->events);\n\t\t\t\t\t_debug(\"{OBJ%x} ev %d: %s -> %s\",\n\t\t\t\t\t       object->debug_id, event,\n\t\t\t\t\t       state->name, new_state->name);\n\t\t\t\t\tobject->state = state = new_state;\n\t\t\t\t\tgoto execute_work_state;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* The event mask didn't include all the tabled bits */\n\t\t\tBUG();\n\t\t}\n\t\t/* Randomly woke up */\n\t\tgoto unmask_events;\n\t}\n\nexecute_work_state:\n\t_debug(\"{OBJ%x} exec %s\", object->debug_id, state->name);\n\n\tnew_state = state->work(object, event);\n\tevent = -1;\n\tif (new_state == NO_TRANSIT) {\n\t\t_debug(\"{OBJ%x} %s notrans\", object->debug_id, state->name);\n\t\tfscache_enqueue_object(object);\n\t\tevent_mask = object->oob_event_mask;\n\t\tgoto unmask_events;\n\t}\n\n\t_debug(\"{OBJ%x} %s -> %s\",\n\t       object->debug_id, state->name, new_state->name);\n\tobject->state = state = new_state;\n\n\tif (state->work) {\n\t\tif (unlikely(state->work == ((void *)2UL))) {\n\t\t\t_leave(\" [dead]\");\n\t\t\treturn;\n\t\t}\n\t\tgoto restart_masked;\n\t}\n\n\t/* Transited to wait state */\n\tevent_mask = object->oob_event_mask;\n\tfor (t = state->transitions; t->events; t++)\n\t\tevent_mask |= t->events;\n\nunmask_events:\n\tobject->event_mask = event_mask;\n\tsmp_mb();\n\tevents = object->events;\n\tif (events & event_mask)\n\t\tgoto restart;\n\t_leave(\" [msk %lx]\", event_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x}\"",
            "object->debug_id"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structfscache_object",
            "work"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic void fscache_object_work_func(struct work_struct *work)\n{\n\tstruct fscache_object *object =\n\t\tcontainer_of(work, struct fscache_object, work);\n\tunsigned long start;\n\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tstart = jiffies;\n\tfscache_object_sm_dispatcher(object);\n\tfscache_hist(fscache_objs_histogram, start);\n\tfscache_put_object(object);\n}"
  },
  {
    "function_name": "fscache_object_sm_dispatcher",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "167-261",
    "snippet": "static void fscache_object_sm_dispatcher(struct fscache_object *object)\n{\n\tconst struct fscache_transition *t;\n\tconst struct fscache_state *state, *new_state;\n\tunsigned long events, event_mask;\n\tint event = -1;\n\n\tASSERT(object != NULL);\n\n\t_enter(\"{OBJ%x,%s,%lx}\",\n\t       object->debug_id, object->state->name, object->events);\n\n\tevent_mask = object->event_mask;\nrestart:\n\tobject->event_mask = 0; /* Mask normal event handling */\n\tstate = object->state;\nrestart_masked:\n\tevents = object->events;\n\n\t/* Handle any out-of-band events (typically an error) */\n\tif (events & object->oob_event_mask) {\n\t\t_debug(\"{OBJ%x} oob %lx\",\n\t\t       object->debug_id, events & object->oob_event_mask);\n\t\tfor (t = object->oob_table; t->events; t++) {\n\t\t\tif (events & t->events) {\n\t\t\t\tstate = t->transit_to;\n\t\t\t\tASSERT(state->work != NULL);\n\t\t\t\tevent = fls(events & t->events) - 1;\n\t\t\t\t__clear_bit(event, &object->oob_event_mask);\n\t\t\t\tclear_bit(event, &object->events);\n\t\t\t\tgoto execute_work_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Wait states are just transition tables */\n\tif (!state->work) {\n\t\tif (events & event_mask) {\n\t\t\tfor (t = state->transitions; t->events; t++) {\n\t\t\t\tif (events & t->events) {\n\t\t\t\t\tnew_state = t->transit_to;\n\t\t\t\t\tevent = fls(events & t->events) - 1;\n\t\t\t\t\tclear_bit(event, &object->events);\n\t\t\t\t\t_debug(\"{OBJ%x} ev %d: %s -> %s\",\n\t\t\t\t\t       object->debug_id, event,\n\t\t\t\t\t       state->name, new_state->name);\n\t\t\t\t\tobject->state = state = new_state;\n\t\t\t\t\tgoto execute_work_state;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* The event mask didn't include all the tabled bits */\n\t\t\tBUG();\n\t\t}\n\t\t/* Randomly woke up */\n\t\tgoto unmask_events;\n\t}\n\nexecute_work_state:\n\t_debug(\"{OBJ%x} exec %s\", object->debug_id, state->name);\n\n\tnew_state = state->work(object, event);\n\tevent = -1;\n\tif (new_state == NO_TRANSIT) {\n\t\t_debug(\"{OBJ%x} %s notrans\", object->debug_id, state->name);\n\t\tfscache_enqueue_object(object);\n\t\tevent_mask = object->oob_event_mask;\n\t\tgoto unmask_events;\n\t}\n\n\t_debug(\"{OBJ%x} %s -> %s\",\n\t       object->debug_id, state->name, new_state->name);\n\tobject->state = state = new_state;\n\n\tif (state->work) {\n\t\tif (unlikely(state->work == ((void *)2UL))) {\n\t\t\t_leave(\" [dead]\");\n\t\t\treturn;\n\t\t}\n\t\tgoto restart_masked;\n\t}\n\n\t/* Transited to wait state */\n\tevent_mask = object->oob_event_mask;\n\tfor (t = state->transitions; t->events; t++)\n\t\tevent_mask |= t->events;\n\nunmask_events:\n\tobject->event_mask = event_mask;\n\tsmp_mb();\n\tevents = object->events;\n\tif (events & event_mask)\n\t\tgoto restart;\n\t_leave(\" [msk %lx]\", event_mask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NO_TRANSIT ((struct fscache_state *)NULL)"
    ],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [msk %lx]\"",
            "event_mask"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [dead]\""
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "state->work == ((void *)2UL)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"{OBJ%x} %s -> %s\"",
            "object->debug_id",
            "state->name",
            "new_state->name"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_enqueue_object",
          "args": [
            "object"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_enqueue_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "773-789",
          "snippet": "void fscache_enqueue_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (fscache_get_object(object) >= 0) {\n\t\twait_queue_head_t *cong_wq =\n\t\t\t&get_cpu_var(fscache_object_cong_wait);\n\n\t\tif (queue_work(fscache_object_wq, &object->work)) {\n\t\t\tif (fscache_object_congested())\n\t\t\t\twake_up(cong_wq);\n\t\t} else\n\t\t\tfscache_put_object(object);\n\n\t\tput_cpu_var(fscache_object_cong_wait);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nvoid fscache_enqueue_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (fscache_get_object(object) >= 0) {\n\t\twait_queue_head_t *cong_wq =\n\t\t\t&get_cpu_var(fscache_object_cong_wait);\n\n\t\tif (queue_work(fscache_object_wq, &object->work)) {\n\t\t\tif (fscache_object_congested())\n\t\t\t\twake_up(cong_wq);\n\t\t} else\n\t\t\tfscache_put_object(object);\n\n\t\tput_cpu_var(fscache_object_cong_wait);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "state->work",
          "args": [
            "object",
            "event"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "event",
            "&object->events"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "events & t->events"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "event",
            "&object->oob_event_mask"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "events & t->events"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->work != NULL"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x,%s,%lx}\"",
            "object->debug_id",
            "object->state->name",
            "object->events"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "object != NULL"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define NO_TRANSIT ((struct fscache_state *)NULL)\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic void fscache_object_sm_dispatcher(struct fscache_object *object)\n{\n\tconst struct fscache_transition *t;\n\tconst struct fscache_state *state, *new_state;\n\tunsigned long events, event_mask;\n\tint event = -1;\n\n\tASSERT(object != NULL);\n\n\t_enter(\"{OBJ%x,%s,%lx}\",\n\t       object->debug_id, object->state->name, object->events);\n\n\tevent_mask = object->event_mask;\nrestart:\n\tobject->event_mask = 0; /* Mask normal event handling */\n\tstate = object->state;\nrestart_masked:\n\tevents = object->events;\n\n\t/* Handle any out-of-band events (typically an error) */\n\tif (events & object->oob_event_mask) {\n\t\t_debug(\"{OBJ%x} oob %lx\",\n\t\t       object->debug_id, events & object->oob_event_mask);\n\t\tfor (t = object->oob_table; t->events; t++) {\n\t\t\tif (events & t->events) {\n\t\t\t\tstate = t->transit_to;\n\t\t\t\tASSERT(state->work != NULL);\n\t\t\t\tevent = fls(events & t->events) - 1;\n\t\t\t\t__clear_bit(event, &object->oob_event_mask);\n\t\t\t\tclear_bit(event, &object->events);\n\t\t\t\tgoto execute_work_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Wait states are just transition tables */\n\tif (!state->work) {\n\t\tif (events & event_mask) {\n\t\t\tfor (t = state->transitions; t->events; t++) {\n\t\t\t\tif (events & t->events) {\n\t\t\t\t\tnew_state = t->transit_to;\n\t\t\t\t\tevent = fls(events & t->events) - 1;\n\t\t\t\t\tclear_bit(event, &object->events);\n\t\t\t\t\t_debug(\"{OBJ%x} ev %d: %s -> %s\",\n\t\t\t\t\t       object->debug_id, event,\n\t\t\t\t\t       state->name, new_state->name);\n\t\t\t\t\tobject->state = state = new_state;\n\t\t\t\t\tgoto execute_work_state;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* The event mask didn't include all the tabled bits */\n\t\t\tBUG();\n\t\t}\n\t\t/* Randomly woke up */\n\t\tgoto unmask_events;\n\t}\n\nexecute_work_state:\n\t_debug(\"{OBJ%x} exec %s\", object->debug_id, state->name);\n\n\tnew_state = state->work(object, event);\n\tevent = -1;\n\tif (new_state == NO_TRANSIT) {\n\t\t_debug(\"{OBJ%x} %s notrans\", object->debug_id, state->name);\n\t\tfscache_enqueue_object(object);\n\t\tevent_mask = object->oob_event_mask;\n\t\tgoto unmask_events;\n\t}\n\n\t_debug(\"{OBJ%x} %s -> %s\",\n\t       object->debug_id, state->name, new_state->name);\n\tobject->state = state = new_state;\n\n\tif (state->work) {\n\t\tif (unlikely(state->work == ((void *)2UL))) {\n\t\t\t_leave(\" [dead]\");\n\t\t\treturn;\n\t\t}\n\t\tgoto restart_masked;\n\t}\n\n\t/* Transited to wait state */\n\tevent_mask = object->oob_event_mask;\n\tfor (t = state->transitions; t->events; t++)\n\t\tevent_mask |= t->events;\n\nunmask_events:\n\tobject->event_mask = event_mask;\n\tsmp_mb();\n\tevents = object->events;\n\tif (events & event_mask)\n\t\tgoto restart;\n\t_leave(\" [msk %lx]\", event_mask);\n}"
  },
  {
    "function_name": "fscache_done_parent_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
    "lines": "149-162",
    "snippet": "static inline void fscache_done_parent_op(struct fscache_object *object)\n{\n\tstruct fscache_object *parent = object->parent;\n\n\t_enter(\"OBJ%x {OBJ%x,%x}\",\n\t       object->debug_id, parent->debug_id, parent->n_ops);\n\n\tspin_lock_nested(&parent->lock, 1);\n\tparent->n_obj_ops--;\n\tparent->n_ops--;\n\tif (parent->n_ops == 0)\n\t\tfscache_raise_event(parent, FSCACHE_OBJECT_EV_CLEARED);\n\tspin_unlock(&parent->lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
      "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
      "static WAIT_STATE(WAIT_FOR_CLEARANCE,\t\"?CLR\",\n\t\t  TRANSIT_TO(KILL_OBJECT,\t1 << FSCACHE_OBJECT_EV_CLEARED));",
      "static int  fscache_get_object(struct fscache_object *);",
      "static void fscache_put_object(struct fscache_object *);",
      "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
      "static void fscache_dequeue_object(struct fscache_object *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&parent->lock"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_raise_event",
          "args": [
            "parent",
            "FSCACHE_OBJECT_EV_CLEARED"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_raise_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "299-310",
          "snippet": "static inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fscache_enqueue_object(struct fscache_object *);",
            "extern void fscache_cancel_all_ops(struct fscache_object *);",
            "extern void fscache_abort_object(struct fscache_object *);",
            "extern void fscache_start_operations(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern void fscache_enqueue_object(struct fscache_object *);\nextern void fscache_cancel_all_ops(struct fscache_object *);\nextern void fscache_abort_object(struct fscache_object *);\nextern void fscache_start_operations(struct fscache_object *);\n\nstatic inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&parent->lock",
            "1"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"OBJ%x {OBJ%x,%x}\"",
            "object->debug_id",
            "parent->debug_id",
            "parent->n_ops"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic WAIT_STATE(WAIT_FOR_CLEARANCE,\t\"?CLR\",\n\t\t  TRANSIT_TO(KILL_OBJECT,\t1 << FSCACHE_OBJECT_EV_CLEARED));\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nstatic inline void fscache_done_parent_op(struct fscache_object *object)\n{\n\tstruct fscache_object *parent = object->parent;\n\n\t_enter(\"OBJ%x {OBJ%x,%x}\",\n\t       object->debug_id, parent->debug_id, parent->n_ops);\n\n\tspin_lock_nested(&parent->lock, 1);\n\tparent->n_obj_ops--;\n\tparent->n_ops--;\n\tif (parent->n_ops == 0)\n\t\tfscache_raise_event(parent, FSCACHE_OBJECT_EV_CLEARED);\n\tspin_unlock(&parent->lock);\n}"
  }
]