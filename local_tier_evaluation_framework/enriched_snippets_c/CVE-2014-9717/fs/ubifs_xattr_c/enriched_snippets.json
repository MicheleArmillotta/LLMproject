[
  {
    "function_name": "curity(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "650-664",
    "snippet": "t_security(struct inode *dentry, struct inode *inode,\n\t\t\tconst struct qstr *qstr)\n{\n\tint err;\n\n\tmutex_lock(&inode->i_mutex);\n\terr = security_inode_init_security(inode, dentry, qstr,\n\t\t\t\t\t   &init_xattrs, 0);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (err)\n\t\tubifs_err(\"cannot initialize security for inode %lu, error %d\",\n\t\t\t  inode->i_ino, err);\n\treturn err;\n}",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nnot init",
          "args": [
            "alize security for inode %lu, error %d\",\n\t\t\t  inode-",
            "err);\n\tretu",
            "er"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&inode->i_mu",
          "args": [
            "ex);\n\n\tif (err)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_init_security(inode, dentr",
          "args": [
            ", qst",
            "&in",
            "0);\n\tmutex_",
            "l"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->i_mu",
          "args": [
            "ex);\n\terr = sec"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\nt_security(struct inode *dentry, struct inode *inode,\n\t\t\tconst struct qstr *qstr)\n{\n\tint err;\n\n\tmutex_lock(&inode->i_mutex);\n\terr = security_inode_init_security(inode, dentry, qstr,\n\t\t\t\t\t   &init_xattrs, 0);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (err)\n\t\tubifs_err(\"cannot initialize security for inode %lu, error %d\",\n\t\t\t  inode->i_ino, err);\n\treturn err;\n}"
  },
  {
    "function_name": "truct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "625-648",
    "snippet": "it_xattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t      void *fs_info)\n{\n\tconst struct xattr *xattr;\n\tchar *name;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\tname = kmalloc(XATTR_SECURITY_PREFIX_LEN +\n\t\t\t       strlen(xattr->name) + 1, GFP_NOFS);\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tstrcpy(name, XATTR_SECURITY_PREFIX);\n\t\tstrcpy(name + XATTR_SECURITY_PREFIX_LEN, xattr->name);\n\t\terr = setxattr(inode, name, xattr->value, xattr->value_len, 0);\n\t\tkfree(name);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint ubifs_i",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "if",
          "args": [
            "err"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_verify_xattr(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "1283-1314",
          "snippet": "nt jffs2_verify_xattr(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tuint32_t totlen;\n\tint rc;\n\n\tdown_write(&c->xattr_sem);\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_unchecked, xindex) {\n\t\trc = do_verify_xattr_datum(c, xd);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tlist_del_init(&xd->xindex);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\t\tif (ref_flags(raw) != REF_UNCHECKED)\n\t\t\t\tcontinue;\n\t\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t\traw->flash_offset = ref_offset(raw)\n\t\t\t\t| ((xd->node == (void *)raw) ? REF_PRISTINE : REF_NORMAL);\n\t\t}\n\t\tif (xd->flags & JFFS2_XFLAGS_DEAD)\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\tup_write(&c->xattr_sem);\n\treturn list_empty(&c->xattr_unchecked) ? 1 : 0;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_verify_xattr(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tuint32_t totlen;\n\tint rc;\n\n\tdown_write(&c->xattr_sem);\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_unchecked, xindex) {\n\t\trc = do_verify_xattr_datum(c, xd);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tlist_del_init(&xd->xindex);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\t\tif (ref_flags(raw) != REF_UNCHECKED)\n\t\t\t\tcontinue;\n\t\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t\traw->flash_offset = ref_offset(raw)\n\t\t\t\t| ((xd->node == (void *)raw) ? REF_PRISTINE : REF_NORMAL);\n\t\t}\n\t\tif (xd->flags & JFFS2_XFLAGS_DEAD)\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\tup_write(&c->xattr_sem);\n\treturn list_empty(&c->xattr_unchecked) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e, name,",
          "args": [
            "xattr",
            "valu",
            "xattr->valu",
            "len, 0);\n\t\tkfree",
            "a"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XATTR",
          "args": [
            "SECURITY_PREFIX_LEN, xattr->name",
            "err = se"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XATTR_",
          "args": [
            "ECUR",
            "Y_PREFIX);\n\t\tstrcpy(n"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_SECURI",
          "args": [
            "Y_PREFIX_LEN +\n\t\t\t       strlen(xattr->name) + 1, GFP_NOFS);",
            "if (!nam"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">name)",
          "args": [
            "+ 1, GFP_NO"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\nit_xattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t      void *fs_info)\n{\n\tconst struct xattr *xattr;\n\tchar *name;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\tname = kmalloc(XATTR_SECURITY_PREFIX_LEN +\n\t\t\t       strlen(xattr->name) + 1, GFP_NOFS);\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tstrcpy(name, XATTR_SECURITY_PREFIX);\n\t\tstrcpy(name + XATTR_SECURITY_PREFIX_LEN, xattr->name);\n\t\terr = setxattr(inode, name, xattr->value, xattr->value_len, 0);\n\t\tkfree(name);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint ubifs_i"
  },
  {
    "function_name": "attr(struct dentr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "606-611",
    "snippet": "curity_setxattr(struct dentry *d, const char *name,\n\t\t\t     const void *value, size_t size, int flags,\n\t\t\t     int handler_flags)\n{\n\treturn ubifs_setxattr(d, name, value, size, flags);\n}\n\nstatic cons",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "r(d, name, val",
          "args": [
            "e",
            "size",
            "flags",
            "}",
            "atic"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\ncurity_setxattr(struct dentry *d, const char *name,\n\t\t\t     const void *value, size_t size, int flags,\n\t\t\t     int handler_flags)\n{\n\treturn ubifs_setxattr(d, name, value, size, flags);\n}\n\nstatic cons"
  },
  {
    "function_name": "attr(struct dentr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "600-604",
    "snippet": "curity_getxattr(struct dentry *d, const char *name, void *buffer,\n\t\t      size_t size, int flags)\n{\n\treturn ubifs_getxattr(d, name, buffer, size);\n}\n\nstatic int",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "r(d, name, buf",
          "args": [
            "e",
            "siz",
            ";\n}\n\ns",
            "tic"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\ncurity_getxattr(struct dentry *d, const char *name, void *buffer,\n\t\t      size_t size, int flags)\n{\n\treturn ubifs_getxattr(d, name, buffer, size);\n}\n\nstatic int"
  },
  {
    "function_name": "xattr(struct dentr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "585-598",
    "snippet": "security_listxattr(struct dentry *d, char *list, size_t list_size,\n\t\t\t\t const char *name, size_t name_len, int flags)\n{\n\tconst int prefix_len = XATTR_SECURITY_PREFIX_LEN;\n\tconst size_t total_len = prefix_len + name_len + 1;\n\n\tif (list && total_len <= list_size) {\n\t\tmemcpy(list, XATTR_SECURITY_PREFIX, prefix_len);\n\t\tmemcpy(list + prefix_len, name, name_len);\n\t\tlist[prefix_len + name_len] = '\\0';\n\t}\n\n\treturn total_len;\n}\n\nstatic int",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prefi",
          "args": [
            "_len, name, name_",
            "n);",
            "list[pre"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XATTR_",
          "args": [
            "ECUR",
            "Y_PREFIX, prefix_len)",
            "memcpy(l"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\nsecurity_listxattr(struct dentry *d, char *list, size_t list_size,\n\t\t\t\t const char *name, size_t name_len, int flags)\n{\n\tconst int prefix_len = XATTR_SECURITY_PREFIX_LEN;\n\tconst size_t total_len = prefix_len + name_len + 1;\n\n\tif (list && total_len <= list_size) {\n\t\tmemcpy(list, XATTR_SECURITY_PREFIX, prefix_len);\n\t\tmemcpy(list + prefix_len, name, name_len);\n\t\tlist[prefix_len + name_len] = '\\0';\n\t}\n\n\treturn total_len;\n}\n\nstatic int"
  },
  {
    "function_name": "attr(struct dentr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "536-583",
    "snippet": "ovexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode, *host = dentry->d_inode;\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct qstr nm = QSTR_INIT(name, strlen(name));\n\tstruct ubifs_dent_node *xent;\n\tunion ubifs_key key;\n\tint err;\n\n\tdbg_gen(\"xattr '%s', ino %lu ('%pd')\", name,\n\t\thost->i_ino, dentry);\n\tubifs_assert(mutex_is_locked(&host->i_mutex));\n\n\terr = check_namespace(&nm);\n\tif (err < 0)\n\t\treturn err;\n\n\txent = kmalloc(UBIFS_MAX_XENT_NODE_SZ, GFP_NOFS);\n\tif (!xent)\n\t\treturn -ENOMEM;\n\n\txent_key_init(c, &key, host->i_ino, &nm);\n\terr = ubifs_tnc_lookup_nm(c, &key, xent, &nm);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -ENODATA;\n\t\tgoto out_free;\n\t}\n\n\tinode = iget_xattr(c, le64_to_cpu(xent->inum));\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_free;\n\t}\n\n\tubifs_assert(inode->i_nlink == 1);\n\tclear_nlink(inode);\n\terr = remove_xattr(c, host, inode, &nm);\n\tif (err)\n\t\tset_nlink(inode, 1);\n\n\t/* If @i_nlink is 0, 'iput()' will delete the inode */\n\tiput(inode);\n\nout_free:\n\tkfree(xent);\n\treturn err;\n}\n\nstatic size",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "out",
          "args": [
            "free:"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vxattrcb_layout_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "56-65",
          "snippet": "static bool ceph_vxattrcb_layout_exists(struct ceph_inode_info *ci)\n{\n\tsize_t s;\n\tchar *p = (char *)&ci->i_layout;\n\n\tfor (s = 0; s < sizeof(ci->i_layout); s++, p++)\n\t\tif (*p)\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic bool ceph_vxattrcb_layout_exists(struct ceph_inode_info *ci)\n{\n\tsize_t s;\n\tchar *p = (char *)&ci->i_layout;\n\n\tfor (s = 0; s < sizeof(ci->i_layout); s++, p++)\n\t\tif (*p)\n\t\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "de, 1);",
          "args": [
            "/* If",
            "i"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, host, ino",
          "args": [
            "e",
            "&nm)",
            "if (",
            "r)"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\terr",
          "args": [
            "= rem"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_nli",
          "args": [
            "k == 1);\n\tclear_nli"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tgo",
          "args": [
            "o out"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "rr ="
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_c",
          "args": [
            "u",
            "ent->inum));\n\tif (IS_ER"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->inum))",
          "args": [
            "if (IS_E"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_nm(c, &key, xen",
          "args": [
            ",",
            "nm);",
            "if (",
            "r)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, hos",
          "args": [
            "-",
            "_ino",
            "&nm);\n\terr",
            "ubi"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_MAX_XE",
          "args": [
            "T_NODE_SZ, GFP_NOFS);",
            "f (!xent"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ce(&nm);\n\tif (e",
          "args": [
            "r <"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&host->i_mutex));\n\n\terr = ch"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&host->i_mut",
          "args": [
            "x));\n\n\terr = c"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r '%s',",
          "args": [
            "ino %lu ('%pd')\", name,\n\t\thos",
            ">i_i",
            "dentry);\n\tu",
            "fs_ass"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e, strlen",
          "args": [
            "name",
            ";\n\tstruct ub"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\tstr",
          "args": [
            "ct u"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\novexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode, *host = dentry->d_inode;\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct qstr nm = QSTR_INIT(name, strlen(name));\n\tstruct ubifs_dent_node *xent;\n\tunion ubifs_key key;\n\tint err;\n\n\tdbg_gen(\"xattr '%s', ino %lu ('%pd')\", name,\n\t\thost->i_ino, dentry);\n\tubifs_assert(mutex_is_locked(&host->i_mutex));\n\n\terr = check_namespace(&nm);\n\tif (err < 0)\n\t\treturn err;\n\n\txent = kmalloc(UBIFS_MAX_XENT_NODE_SZ, GFP_NOFS);\n\tif (!xent)\n\t\treturn -ENOMEM;\n\n\txent_key_init(c, &key, host->i_ino, &nm);\n\terr = ubifs_tnc_lookup_nm(c, &key, xent, &nm);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -ENODATA;\n\t\tgoto out_free;\n\t}\n\n\tinode = iget_xattr(c, le64_to_cpu(xent->inum));\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_free;\n\t}\n\n\tubifs_assert(inode->i_nlink == 1);\n\tclear_nlink(inode);\n\terr = remove_xattr(c, host, inode, &nm);\n\tif (err)\n\t\tset_nlink(inode, 1);\n\n\t/* If @i_nlink is 0, 'iput()' will delete the inode */\n\tiput(inode);\n\nout_free:\n\tkfree(xent);\n\treturn err;\n}\n\nstatic size"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "496-534",
    "snippet": "move_xattr(struct ubifs_info *c, struct inode *host,\n\t\t\tstruct inode *inode, const struct qstr *nm)\n{\n\tint err;\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_budget_req req = { .dirtied_ino = 2, .mod_dent = 1,\n\t\t\t\t.dirtied_ino_d = ALIGN(host_ui->data_len, 8) };\n\n\tubifs_assert(ui->data_len == inode->i_size);\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&host_ui->ui_mutex);\n\thost->i_ctime = ubifs_current_time(host);\n\thost_ui->xattr_cnt -= 1;\n\thost_ui->xattr_size -= CALC_DENT_SIZE(nm->len);\n\thost_ui->xattr_size -= CALC_XATTR_BYTES(ui->data_len);\n\thost_ui->xattr_names -= nm->len;\n\n\terr = ubifs_jnl_delete_xattr(c, host, inode, nm);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&host_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\treturn 0;\n\nout_cancel:\n\thost_ui->xattr_cnt += 1;\n\thost_ui->xattr_size += CALC_DENT_SIZE(nm->len);\n\thost_ui->xattr_size += CALC_XATTR_BYTES(ui->data_len);\n\tmutex_unlock(&host_ui->ui_mutex);\n\tubifs_release_budget(c, &req);\n\tmake_bad_inode(inode);\n\treturn err;\n}\n\nint ubifs_r",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e(inode);\n\tret",
          "args": [
            "rn er"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tm",
          "args": [
            "k",
            "bad_"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&host_ui->ui",
          "args": [
            "mutex);\n\tubifs_rel"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TES(ui->data_len",
          "args": [
            ";\n\tmutex_unl"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(nm->len);\n\th",
          "args": [
            "st_ui->"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tr",
          "args": [
            "t",
            "n 0;"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&host_ui->ui",
          "args": [
            "mutex);\n\n\tubifs_re"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ete_xattr(c, host, ino",
          "args": [
            "e",
            "nm);",
            "if (e",
            ")"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TES(ui->data_len",
          "args": [
            ";\n\thost_ui->"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(nm->len);\n\th",
          "args": [
            "st_ui->"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(host);\n\thost",
          "args": [
            "ui->"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost_ui->ui",
          "args": [
            "mutex);\n\thost->i_c"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->data_len",
          "args": [
            "== inode->i_size);\n\n\terr = ub"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->dat",
          "args": [
            "_len, 8) };\n\n\tubi",
            "_"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "477-529",
          "snippet": "static int ocfs2_validate_xattr_block(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_xattr_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &xb->xb_check);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Errors after here are fatal\n\t */\n\n\tif (!OCFS2_IS_VALID_XATTR_BLOCK(xb)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has bad \"\n\t\t\t    \"signature %.*s\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    xb->xb_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(xb->xb_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an \"\n\t\t\t    \"invalid xb_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(xb->xb_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(xb->xb_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an invalid \"\n\t\t\t    \"xb_fs_generation of #%u\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(xb->xb_fs_generation));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_validate_xattr_block(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_xattr_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &xb->xb_check);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Errors after here are fatal\n\t */\n\n\tif (!OCFS2_IS_VALID_XATTR_BLOCK(xb)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has bad \"\n\t\t\t    \"signature %.*s\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    xb->xb_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(xb->xb_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an \"\n\t\t\t    \"invalid xb_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(xb->xb_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(xb->xb_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an invalid \"\n\t\t\t    \"xb_fs_generation of #%u\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(xb->xb_fs_generation));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node);\n\tstr",
          "args": [
            "ct ub"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost);\n\tstru",
          "args": [
            "t ub"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\nmove_xattr(struct ubifs_info *c, struct inode *host,\n\t\t\tstruct inode *inode, const struct qstr *nm)\n{\n\tint err;\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_budget_req req = { .dirtied_ino = 2, .mod_dent = 1,\n\t\t\t\t.dirtied_ino_d = ALIGN(host_ui->data_len, 8) };\n\n\tubifs_assert(ui->data_len == inode->i_size);\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&host_ui->ui_mutex);\n\thost->i_ctime = ubifs_current_time(host);\n\thost_ui->xattr_cnt -= 1;\n\thost_ui->xattr_size -= CALC_DENT_SIZE(nm->len);\n\thost_ui->xattr_size -= CALC_XATTR_BYTES(ui->data_len);\n\thost_ui->xattr_names -= nm->len;\n\n\terr = ubifs_jnl_delete_xattr(c, host, inode, nm);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&host_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\treturn 0;\n\nout_cancel:\n\thost_ui->xattr_cnt += 1;\n\thost_ui->xattr_size += CALC_DENT_SIZE(nm->len);\n\thost_ui->xattr_size += CALC_XATTR_BYTES(ui->data_len);\n\tmutex_unlock(&host_ui->ui_mutex);\n\tubifs_release_budget(c, &req);\n\tmake_bad_inode(inode);\n\treturn err;\n}\n\nint ubifs_r"
  },
  {
    "function_name": "tr(struct dentr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "432-494",
    "snippet": "_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tunion ubifs_key key;\n\tstruct inode *host = dentry->d_inode;\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tstruct ubifs_dent_node *xent, *pxent = NULL;\n\tint err, len, written = 0;\n\tstruct qstr nm = { .name = NULL };\n\n\tdbg_gen(\"ino %lu ('%pd'), buffer size %zd\", host->i_ino,\n\t\tdentry, size);\n\n\tlen = host_ui->xattr_names + host_ui->xattr_cnt;\n\tif (!buffer)\n\t\t/*\n\t\t * We should return the minimum buffer size which will fit a\n\t\t * null-terminated list of all the extended attribute names.\n\t\t */\n\t\treturn len;\n\n\tif (len > size)\n\t\treturn -ERANGE;\n\n\tlowest_xent_key(c, &key, host->i_ino);\n\twhile (1) {\n\t\tint type;\n\n\t\txent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(xent)) {\n\t\t\terr = PTR_ERR(xent);\n\t\t\tbreak;\n\t\t}\n\n\t\tnm.name = xent->name;\n\t\tnm.len = le16_to_cpu(xent->nlen);\n\n\t\ttype = check_namespace(&nm);\n\t\tif (unlikely(type < 0)) {\n\t\t\terr = type;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Show trusted namespace only for \"power\" users */\n\t\tif (type != TRUSTED_XATTR || capable(CAP_SYS_ADMIN)) {\n\t\t\tmemcpy(buffer + written, nm.name, nm.len + 1);\n\t\t\twritten += nm.len + 1;\n\t\t}\n\n\t\tkfree(pxent);\n\t\tpxent = xent;\n\t\tkey_read(c, &xent->key, &key);\n\t}\n\n\tkfree(pxent);\n\tif (err != -ENOENT) {\n\t\tubifs_err(\"cannot find next direntry, error %d\", err);\n\t\treturn err;\n\t}\n\n\tubifs_assert(written <= size);\n\treturn written;\n}\n\nstatic int",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "written <= s",
          "args": [
            "ze);\n\treturn wr"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot find",
          "args": [
            "next direntry, error %d\", err);\n\t\tret",
            "n e"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "err !"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_verify_xattr(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "1283-1314",
          "snippet": "nt jffs2_verify_xattr(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tuint32_t totlen;\n\tint rc;\n\n\tdown_write(&c->xattr_sem);\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_unchecked, xindex) {\n\t\trc = do_verify_xattr_datum(c, xd);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tlist_del_init(&xd->xindex);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\t\tif (ref_flags(raw) != REF_UNCHECKED)\n\t\t\t\tcontinue;\n\t\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t\traw->flash_offset = ref_offset(raw)\n\t\t\t\t| ((xd->node == (void *)raw) ? REF_PRISTINE : REF_NORMAL);\n\t\t}\n\t\tif (xd->flags & JFFS2_XFLAGS_DEAD)\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\tup_write(&c->xattr_sem);\n\treturn list_empty(&c->xattr_unchecked) ? 1 : 0;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_verify_xattr(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tuint32_t totlen;\n\tint rc;\n\n\tdown_write(&c->xattr_sem);\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_unchecked, xindex) {\n\t\trc = do_verify_xattr_datum(c, xd);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tlist_del_init(&xd->xindex);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\t\tif (ref_flags(raw) != REF_UNCHECKED)\n\t\t\t\tcontinue;\n\t\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t\traw->flash_offset = ref_offset(raw)\n\t\t\t\t| ((xd->node == (void *)raw) ? REF_PRISTINE : REF_NORMAL);\n\t\t}\n\t\tif (xd->flags & JFFS2_XFLAGS_DEAD)\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\tup_write(&c->xattr_sem);\n\treturn list_empty(&c->xattr_unchecked) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xent->ke",
          "args": [
            ",",
            "key);\n\t}",
            "free"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "px",
          "args": [
            "nt ="
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "+ wri",
          "args": [
            "ten, nm.name, nm",
            "en + 1)",
            "written"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YS_ADMI",
          "args": [
            ")) {\n\t\t\tmemcp"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "< 0)) {",
          "args": [
            "err ="
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ce(&nm);\n\t\tif (",
          "args": [
            "nli"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->nlen);",
          "args": [
            "type ="
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tbr",
          "args": [
            "ak;"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{",
          "args": [
            "rr ="
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "(void)\n{\n\tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
          "lines": "225-277",
          "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
          "includes": [
            "fs.h\"\n\n/* List of a"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
        }
      },
      {
        "call_info": {
          "callee": "t_ent(c, &key, &nm",
          "args": [
            ";",
            "if",
            "S_E"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey(c, &key, hos",
          "args": [
            "-",
            "_ino",
            "while (1)"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu ('%",
          "args": [
            "d'), buffer size %zd\", host->i_ino",
            "dentry, s",
            ";\n\n\tle",
            "= ho"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost);\n\tstru",
          "args": [
            "t ub"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\n_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tunion ubifs_key key;\n\tstruct inode *host = dentry->d_inode;\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tstruct ubifs_dent_node *xent, *pxent = NULL;\n\tint err, len, written = 0;\n\tstruct qstr nm = { .name = NULL };\n\n\tdbg_gen(\"ino %lu ('%pd'), buffer size %zd\", host->i_ino,\n\t\tdentry, size);\n\n\tlen = host_ui->xattr_names + host_ui->xattr_cnt;\n\tif (!buffer)\n\t\t/*\n\t\t * We should return the minimum buffer size which will fit a\n\t\t * null-terminated list of all the extended attribute names.\n\t\t */\n\t\treturn len;\n\n\tif (len > size)\n\t\treturn -ERANGE;\n\n\tlowest_xent_key(c, &key, host->i_ino);\n\twhile (1) {\n\t\tint type;\n\n\t\txent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(xent)) {\n\t\t\terr = PTR_ERR(xent);\n\t\t\tbreak;\n\t\t}\n\n\t\tnm.name = xent->name;\n\t\tnm.len = le16_to_cpu(xent->nlen);\n\n\t\ttype = check_namespace(&nm);\n\t\tif (unlikely(type < 0)) {\n\t\t\terr = type;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Show trusted namespace only for \"power\" users */\n\t\tif (type != TRUSTED_XATTR || capable(CAP_SYS_ADMIN)) {\n\t\t\tmemcpy(buffer + written, nm.name, nm.len + 1);\n\t\t\twritten += nm.len + 1;\n\t\t}\n\n\t\tkfree(pxent);\n\t\tpxent = xent;\n\t\tkey_read(c, &xent->key, &key);\n\t}\n\n\tkfree(pxent);\n\tif (err != -ENOENT) {\n\t\tubifs_err(\"cannot find next direntry, error %d\", err);\n\t\treturn err;\n\t}\n\n\tubifs_assert(written <= size);\n\treturn written;\n}\n\nstatic int"
  },
  {
    "function_name": "r(struct dentr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "372-430",
    "snippet": "_getxattr(struct dentry *dentry, const char *name, void *buf,\n\t\t       size_t size)\n{\n\tstruct inode *inode, *host = dentry->d_inode;\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct qstr nm = QSTR_INIT(name, strlen(name));\n\tstruct ubifs_inode *ui;\n\tstruct ubifs_dent_node *xent;\n\tunion ubifs_key key;\n\tint err;\n\n\tdbg_gen(\"xattr '%s', ino %lu ('%pd'), buf size %zd\", name,\n\t\thost->i_ino, dentry, size);\n\n\terr = check_namespace(&nm);\n\tif (err < 0)\n\t\treturn err;\n\n\txent = kmalloc(UBIFS_MAX_XENT_NODE_SZ, GFP_NOFS);\n\tif (!xent)\n\t\treturn -ENOMEM;\n\n\txent_key_init(c, &key, host->i_ino, &nm);\n\terr = ubifs_tnc_lookup_nm(c, &key, xent, &nm);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -ENODATA;\n\t\tgoto out_unlock;\n\t}\n\n\tinode = iget_xattr(c, le64_to_cpu(xent->inum));\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_unlock;\n\t}\n\n\tui = ubifs_inode(inode);\n\tubifs_assert(inode->i_size == ui->data_len);\n\tubifs_assert(ubifs_inode(host)->xattr_size > ui->data_len);\n\n\tif (buf) {\n\t\t/* If @buf is %NULL we are supposed to return the length */\n\t\tif (ui->data_len > size) {\n\t\t\tubifs_err(\"buffer size %zd, xattr len %d\",\n\t\t\t\t  size, ui->data_len);\n\t\t\terr = -ERANGE;\n\t\t\tgoto out_iput;\n\t\t}\n\n\t\tmemcpy(buf, ui->data, ui->data_len);\n\t}\n\terr = ui->data_len;\n\nout_iput:\n\tiput(inode);\nout_unlock:\n\tkfree(xent);\n\treturn err;\n}\n\nssize_t ubi",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "out_",
          "args": [
            "nlock"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vxattrcb_layout_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "56-65",
          "snippet": "static bool ceph_vxattrcb_layout_exists(struct ceph_inode_info *ci)\n{\n\tsize_t s;\n\tchar *p = (char *)&ci->i_layout;\n\n\tfor (s = 0; s < sizeof(ci->i_layout); s++, p++)\n\t\tif (*p)\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic bool ceph_vxattrcb_layout_exists(struct ceph_inode_info *ci)\n{\n\tsize_t s;\n\tchar *p = (char *)&ci->i_layout;\n\n\tfor (s = 0; s < sizeof(ci->i_layout); s++, p++)\n\t\tif (*p)\n\t\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i->dat",
          "args": [
            ", u",
            ">data_le",
            ";\n\t}\n\terr ="
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffer size",
          "args": [
            "%zd, xattr len %d\",\n\t\t\t\t  size,",
            "a_le",
            ";\n\t\t\terr = -"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_inode(",
          "args": [
            "ost)->xattr_size > ui->data_len);\n\n\tif (buf)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost)->xattr",
          "args": [
            "size"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_siz",
          "args": [
            "== ui->data_len);\n\tubifs_ass"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tubi",
          "args": [
            "s_ass"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tgo",
          "args": [
            "o out"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "rr ="
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_c",
          "args": [
            "u",
            "ent->inum));\n\tif (IS_ER"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->inum))",
          "args": [
            "if (IS_E"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_nm(c, &key, xen",
          "args": [
            ",",
            "nm);",
            "if (",
            "r)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, hos",
          "args": [
            "-",
            "_ino",
            "&nm);\n\terr",
            "ubi"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_MAX_XE",
          "args": [
            "T_NODE_SZ, GFP_NOFS);",
            "f (!xent"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ce(&nm);\n\tif (e",
          "args": [
            "r <"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r '%s',",
          "args": [
            "ino %lu ('%pd'), buf size %zd\", name,\n\t\thos",
            ">i_i",
            "dentry, siz",
            ";\n\n\ter",
            "= ch"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e, strlen",
          "args": [
            "name",
            ";\n\tstruct ub"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\tstr",
          "args": [
            "ct u"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\n_getxattr(struct dentry *dentry, const char *name, void *buf,\n\t\t       size_t size)\n{\n\tstruct inode *inode, *host = dentry->d_inode;\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct qstr nm = QSTR_INIT(name, strlen(name));\n\tstruct ubifs_inode *ui;\n\tstruct ubifs_dent_node *xent;\n\tunion ubifs_key key;\n\tint err;\n\n\tdbg_gen(\"xattr '%s', ino %lu ('%pd'), buf size %zd\", name,\n\t\thost->i_ino, dentry, size);\n\n\terr = check_namespace(&nm);\n\tif (err < 0)\n\t\treturn err;\n\n\txent = kmalloc(UBIFS_MAX_XENT_NODE_SZ, GFP_NOFS);\n\tif (!xent)\n\t\treturn -ENOMEM;\n\n\txent_key_init(c, &key, host->i_ino, &nm);\n\terr = ubifs_tnc_lookup_nm(c, &key, xent, &nm);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -ENODATA;\n\t\tgoto out_unlock;\n\t}\n\n\tinode = iget_xattr(c, le64_to_cpu(xent->inum));\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_unlock;\n\t}\n\n\tui = ubifs_inode(inode);\n\tubifs_assert(inode->i_size == ui->data_len);\n\tubifs_assert(ubifs_inode(host)->xattr_size > ui->data_len);\n\n\tif (buf) {\n\t\t/* If @buf is %NULL we are supposed to return the length */\n\t\tif (ui->data_len > size) {\n\t\t\tubifs_err(\"buffer size %zd, xattr len %d\",\n\t\t\t\t  size, ui->data_len);\n\t\t\terr = -ERANGE;\n\t\t\tgoto out_iput;\n\t\t}\n\n\t\tmemcpy(buf, ui->data, ui->data_len);\n\t}\n\terr = ui->data_len;\n\nout_iput:\n\tiput(inode);\nout_unlock:\n\tkfree(xent);\n\treturn err;\n}\n\nssize_t ubi"
  },
  {
    "function_name": "r(struct dentr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "363-370",
    "snippet": "xattr(struct dentry *dentry, const char *name,\n\t\t   const void *value, size_t size, int flags)\n{\n\tdbg_gen(\"xattr '%s', host ino %lu ('%pd'), size %zd\",\n\t\tname, dentry->d_inode->i_ino, dentry, size);\n\n\treturn setxattr(dentry->d_inode, name, value, size, flags);\n}\n\nssize_t ubi",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ry->d_in",
          "args": [
            "de, name, value",
            "size",
            "flags",
            "}",
            "ize_t"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r '%s',",
          "args": [
            "host ino %lu ('%pd'), size %zd\",\n\t\tname, den",
            ">d_i",
            "de->i_ino, dentry, siz",
            ";\n\n\tre",
            "rn s"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\nxattr(struct dentry *dentry, const char *name,\n\t\t   const void *value, size_t size, int flags)\n{\n\tdbg_gen(\"xattr '%s', host ino %lu ('%pd'), size %zd\",\n\t\tname, dentry->d_inode->i_ino, dentry, size);\n\n\treturn setxattr(dentry->d_inode, name, value, size, flags);\n}\n\nssize_t ubi"
  },
  {
    "function_name": "ct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "302-361",
    "snippet": "txattr(struct inode *host, const char *name, const void *value,\n\t\t    size_t size, int flags)\n{\n\tstruct inode *inode;\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct qstr nm = QSTR_INIT(name, strlen(name));\n\tstruct ubifs_dent_node *xent;\n\tunion ubifs_key key;\n\tint err, type;\n\n\tubifs_assert(mutex_is_locked(&host->i_mutex));\n\n\tif (size > UBIFS_MAX_INO_DATA)\n\t\treturn -ERANGE;\n\n\ttype = check_namespace(&nm);\n\tif (type < 0)\n\t\treturn type;\n\n\txent = kmalloc(UBIFS_MAX_XENT_NODE_SZ, GFP_NOFS);\n\tif (!xent)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The extended attribute entries are stored in LNC, so multiple\n\t * look-ups do not involve reading the flash.\n\t */\n\txent_key_init(c, &key, host->i_ino, &nm);\n\terr = ubifs_tnc_lookup_nm(c, &key, xent, &nm);\n\tif (err) {\n\t\tif (err != -ENOENT)\n\t\t\tgoto out_free;\n\n\t\tif (flags & XATTR_REPLACE)\n\t\t\t/* We are asked not to create the xattr */\n\t\t\terr = -ENODATA;\n\t\telse\n\t\t\terr = create_xattr(c, host, &nm, value, size);\n\t\tgoto out_free;\n\t}\n\n\tif (flags & XATTR_CREATE) {\n\t\t/* We are asked not to replace the xattr */\n\t\terr = -EEXIST;\n\t\tgoto out_free;\n\t}\n\n\tinode = iget_xattr(c, le64_to_cpu(xent->inum));\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_free;\n\t}\n\n\terr = change_xattr(c, host, inode, value, size);\n\tiput(inode);\n\nout_free:\n\tkfree(xent);\n\treturn err;\n}\n\nint ubifs_s",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "out",
          "args": [
            "free:"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vxattrcb_layout_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "56-65",
          "snippet": "static bool ceph_vxattrcb_layout_exists(struct ceph_inode_info *ci)\n{\n\tsize_t s;\n\tchar *p = (char *)&ci->i_layout;\n\n\tfor (s = 0; s < sizeof(ci->i_layout); s++, p++)\n\t\tif (*p)\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic bool ceph_vxattrcb_layout_exists(struct ceph_inode_info *ci)\n{\n\tsize_t s;\n\tchar *p = (char *)&ci->i_layout;\n\n\tfor (s = 0; s < sizeof(ci->i_layout); s++, p++)\n\t\tif (*p)\n\t\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c, host, ino",
          "args": [
            "e",
            "valu",
            "size",
            "ipu",
            "inod"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tgo",
          "args": [
            "o out"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "rr ="
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_c",
          "args": [
            "u",
            "ent->inum));\n\tif (IS_ER"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->inum))",
          "args": [
            "if (IS_E"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, host, &nm",
          "args": [
            "lue,",
            "ize",
            "go",
            "out"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_nm(c, &key, xen",
          "args": [
            ",",
            "nm);",
            "if (",
            "r)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, hos",
          "args": [
            "-",
            "_ino",
            "&nm);\n\terr",
            "ubi"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_MAX_XE",
          "args": [
            "T_NODE_SZ, GFP_NOFS);",
            "f (!xent"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ce(&nm);\n\tif (t",
          "args": [
            "pe"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&host->i_mutex));\n\n\tif (size"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&host->i_mut",
          "args": [
            "x));\n\n\tif (siz"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e, strlen",
          "args": [
            "name",
            ";\n\tstruct ub"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\tstr",
          "args": [
            "ct u"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\ntxattr(struct inode *host, const char *name, const void *value,\n\t\t    size_t size, int flags)\n{\n\tstruct inode *inode;\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct qstr nm = QSTR_INIT(name, strlen(name));\n\tstruct ubifs_dent_node *xent;\n\tunion ubifs_key key;\n\tint err, type;\n\n\tubifs_assert(mutex_is_locked(&host->i_mutex));\n\n\tif (size > UBIFS_MAX_INO_DATA)\n\t\treturn -ERANGE;\n\n\ttype = check_namespace(&nm);\n\tif (type < 0)\n\t\treturn type;\n\n\txent = kmalloc(UBIFS_MAX_XENT_NODE_SZ, GFP_NOFS);\n\tif (!xent)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The extended attribute entries are stored in LNC, so multiple\n\t * look-ups do not involve reading the flash.\n\t */\n\txent_key_init(c, &key, host->i_ino, &nm);\n\terr = ubifs_tnc_lookup_nm(c, &key, xent, &nm);\n\tif (err) {\n\t\tif (err != -ENOENT)\n\t\t\tgoto out_free;\n\n\t\tif (flags & XATTR_REPLACE)\n\t\t\t/* We are asked not to create the xattr */\n\t\t\terr = -ENODATA;\n\t\telse\n\t\t\terr = create_xattr(c, host, &nm, value, size);\n\t\tgoto out_free;\n\t}\n\n\tif (flags & XATTR_CREATE) {\n\t\t/* We are asked not to replace the xattr */\n\t\terr = -EEXIST;\n\t\tgoto out_free;\n\t}\n\n\tinode = iget_xattr(c, le64_to_cpu(xent->inum));\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_free;\n\t}\n\n\terr = change_xattr(c, host, inode, value, size);\n\tiput(inode);\n\nout_free:\n\tkfree(xent);\n\treturn err;\n}\n\nint ubifs_s"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "285-300",
    "snippet": "inode *iget_xattr(struct ubifs_info *c, ino_t inum)\n{\n\tstruct inode *inode;\n\n\tinode = ubifs_iget(c->vfs_sb, inum);\n\tif (IS_ERR(inode)) {\n\t\tubifs_err(\"dead extended attribute entry, error %d\",\n\t\t\t  (int)PTR_ERR(inode));\n\t\treturn inode;\n\t}\n\tif (ubifs_inode(inode)->xattr)\n\t\treturn inode;\n\tubifs_err(\"corrupt extended attribute entry\");\n\tiput(inode);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AL);\n}",
          "args": [
            "static"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn ER"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rrupt ext",
          "args": [
            "nded attribute entry\");\n\tiput(inod"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node)->xatt",
          "args": [
            ")\n\t\tr"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad extend",
          "args": [
            "d attribute entry, error %d\",\n\t\t\t  (int)P",
            "inode));\n\t\treturn i"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "));\n\t\tr",
          "args": [
            "turn"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "bifs_"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">vfs_sb, i",
          "args": [
            "um);\n\tif",
            "S_ER"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\ninode *iget_xattr(struct ubifs_info *c, ino_t inum)\n{\n\tstruct inode *inode;\n\n\tinode = ubifs_iget(c->vfs_sb, inum);\n\tif (IS_ERR(inode)) {\n\t\tubifs_err(\"dead extended attribute entry, error %d\",\n\t\t\t  (int)PTR_ERR(inode));\n\t\treturn inode;\n\t}\n\tif (ubifs_inode(inode)->xattr)\n\t\treturn inode;\n\tubifs_err(\"corrupt extended attribute entry\");\n\tiput(inode);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int"
  },
  {
    "function_name": "ce(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "257-283",
    "snippet": "eck_namespace(const struct qstr *nm)\n{\n\tint type;\n\n\tif (nm->len > UBIFS_MAX_NLEN)\n\t\treturn -ENAMETOOLONG;\n\n\tif (!strncmp(nm->name, XATTR_TRUSTED_PREFIX,\n\t\t     XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (nm->name[sizeof(XATTR_TRUSTED_PREFIX) - 1] == '\\0')\n\t\t\treturn -EINVAL;\n\t\ttype = TRUSTED_XATTR;\n\t} else if (!strncmp(nm->name, XATTR_USER_PREFIX,\n\t\t\t\t      XATTR_USER_PREFIX_LEN)) {\n\t\tif (nm->name[XATTR_USER_PREFIX_LEN] == '\\0')\n\t\t\treturn -EINVAL;\n\t\ttype = USER_XATTR;\n\t} else if (!strncmp(nm->name, XATTR_SECURITY_PREFIX,\n\t\t\t\t     XATTR_SECURITY_PREFIX_LEN)) {\n\t\tif (nm->name[sizeof(XATTR_SECURITY_PREFIX) - 1] == '\\0')\n\t\t\treturn -EINVAL;\n\t\ttype = SECURITY_XATTR;\n\t} else\n\t\treturn -EOPNOTSUPP;\n\n\treturn type;\n}\n\nstatic stru",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ame, XA",
          "args": [
            "TR_SECUR",
            "Y_PREFIX,\n\t\t\t\t     XA",
            "Y_PREFIX_LEN)) {\n\t\tif (nm"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame, XA",
          "args": [
            "TR_USER_",
            "EFIX,\n\t\t\t\t      X",
            "EFIX_LEN)) {\n\t\tif (nm"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame, XA",
          "args": [
            "TR_TRUST",
            "_PREFIX,\n\t\t     XATT",
            "_PREFIX_LEN)) {\n\t\tif (nm"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\neck_namespace(const struct qstr *nm)\n{\n\tint type;\n\n\tif (nm->len > UBIFS_MAX_NLEN)\n\t\treturn -ENAMETOOLONG;\n\n\tif (!strncmp(nm->name, XATTR_TRUSTED_PREFIX,\n\t\t     XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (nm->name[sizeof(XATTR_TRUSTED_PREFIX) - 1] == '\\0')\n\t\t\treturn -EINVAL;\n\t\ttype = TRUSTED_XATTR;\n\t} else if (!strncmp(nm->name, XATTR_USER_PREFIX,\n\t\t\t\t      XATTR_USER_PREFIX_LEN)) {\n\t\tif (nm->name[XATTR_USER_PREFIX_LEN] == '\\0')\n\t\t\treturn -EINVAL;\n\t\ttype = USER_XATTR;\n\t} else if (!strncmp(nm->name, XATTR_SECURITY_PREFIX,\n\t\t\t\t     XATTR_SECURITY_PREFIX_LEN)) {\n\t\tif (nm->name[sizeof(XATTR_SECURITY_PREFIX) - 1] == '\\0')\n\t\t\treturn -EINVAL;\n\t\ttype = SECURITY_XATTR;\n\t} else\n\t\treturn -EOPNOTSUPP;\n\n\treturn type;\n}\n\nstatic stru"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "197-247",
    "snippet": "ange_xattr(struct ubifs_info *c, struct inode *host,\n\t\t\tstruct inode *inode, const void *value, int size)\n{\n\tint err;\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_budget_req req = { .dirtied_ino = 2,\n\t\t.dirtied_ino_d = ALIGN(size, 8) + ALIGN(host_ui->data_len, 8) };\n\n\tubifs_assert(ui->data_len == inode->i_size);\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tkfree(ui->data);\n\tui->data = kmemdup(value, size, GFP_NOFS);\n\tif (!ui->data) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tinode->i_size = ui->ui_size = size;\n\tui->data_len = size;\n\n\tmutex_lock(&host_ui->ui_mutex);\n\thost->i_ctime = ubifs_current_time(host);\n\thost_ui->xattr_size -= CALC_XATTR_BYTES(ui->data_len);\n\thost_ui->xattr_size += CALC_XATTR_BYTES(size);\n\n\t/*\n\t * It is important to write the host inode after the xattr inode\n\t * because if the host inode gets synchronized (via 'fsync()'), then\n\t * the extended attribute inode gets synchronized, because it goes\n\t * before the host inode in the write-buffer.\n\t */\n\terr = ubifs_jnl_change_xattr(c, inode, host);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&host_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\treturn 0;\n\nout_cancel:\n\thost_ui->xattr_size -= CALC_XATTR_BYTES(size);\n\thost_ui->xattr_size += CALC_XATTR_BYTES(ui->data_len);\n\tmutex_unlock(&host_ui->ui_mutex);\n\tmake_bad_inode(inode);\nout_free:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\n/**\n * chec",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tr",
          "args": [
            "t",
            "n er"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(inode);\nout_",
          "args": [
            "ree:"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&host_ui->ui",
          "args": [
            "mutex);\n\tmake_bad_"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TES(ui->data_len",
          "args": [
            ";\n\tmutex_unl"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TES(size);\n\thost",
          "args": [
            "ui->"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tr",
          "args": [
            "t",
            "n 0;"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&host_ui->ui",
          "args": [
            "mutex);\n\n\tubifs_re"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nge_xattr(c, inode, ho",
          "args": [
            "t",
            "if",
            "rr)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TES(size);\n\n\t/*",
          "args": [
            "* I"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TES(ui->data_len",
          "args": [
            ";\n\thost_ui->"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(host);\n\thost",
          "args": [
            "ui->"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost_ui->ui",
          "args": [
            "mutex);\n\thost->i_c"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", size,",
          "args": [
            "GFP_N",
            "S);",
            "f (!ui->"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a);",
          "args": [
            "i->data"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->data_len",
          "args": [
            "== inode->i_size);\n\terr = ubi"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->dat",
          "args": [
            "_len, 8) };\n\n\tubi",
            "_"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "477-529",
          "snippet": "static int ocfs2_validate_xattr_block(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_xattr_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &xb->xb_check);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Errors after here are fatal\n\t */\n\n\tif (!OCFS2_IS_VALID_XATTR_BLOCK(xb)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has bad \"\n\t\t\t    \"signature %.*s\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    xb->xb_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(xb->xb_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an \"\n\t\t\t    \"invalid xb_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(xb->xb_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(xb->xb_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an invalid \"\n\t\t\t    \"xb_fs_generation of #%u\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(xb->xb_fs_generation));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_validate_xattr_block(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_xattr_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &xb->xb_check);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Errors after here are fatal\n\t */\n\n\tif (!OCFS2_IS_VALID_XATTR_BLOCK(xb)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has bad \"\n\t\t\t    \"signature %.*s\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    xb->xb_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(xb->xb_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an \"\n\t\t\t    \"invalid xb_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(xb->xb_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(xb->xb_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an invalid \"\n\t\t\t    \"xb_fs_generation of #%u\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(xb->xb_fs_generation));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": ") + A",
          "args": [
            "IGN(",
            "s"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tstr",
          "args": [
            "ct ub"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost);\n\tstru",
          "args": [
            "t ub"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\nange_xattr(struct ubifs_info *c, struct inode *host,\n\t\t\tstruct inode *inode, const void *value, int size)\n{\n\tint err;\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_budget_req req = { .dirtied_ino = 2,\n\t\t.dirtied_ino_d = ALIGN(size, 8) + ALIGN(host_ui->data_len, 8) };\n\n\tubifs_assert(ui->data_len == inode->i_size);\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tkfree(ui->data);\n\tui->data = kmemdup(value, size, GFP_NOFS);\n\tif (!ui->data) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tinode->i_size = ui->ui_size = size;\n\tui->data_len = size;\n\n\tmutex_lock(&host_ui->ui_mutex);\n\thost->i_ctime = ubifs_current_time(host);\n\thost_ui->xattr_size -= CALC_XATTR_BYTES(ui->data_len);\n\thost_ui->xattr_size += CALC_XATTR_BYTES(size);\n\n\t/*\n\t * It is important to write the host inode after the xattr inode\n\t * because if the host inode gets synchronized (via 'fsync()'), then\n\t * the extended attribute inode gets synchronized, because it goes\n\t * before the host inode in the write-buffer.\n\t */\n\terr = ubifs_jnl_change_xattr(c, inode, host);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&host_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\treturn 0;\n\nout_cancel:\n\thost_ui->xattr_size -= CALC_XATTR_BYTES(size);\n\thost_ui->xattr_size += CALC_XATTR_BYTES(ui->data_len);\n\tmutex_unlock(&host_ui->ui_mutex);\n\tmake_bad_inode(inode);\nout_free:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\n/**\n * chec"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/xattr.c",
    "lines": "100-183",
    "snippet": "eate_xattr(struct ubifs_info *c, struct inode *host,\n\t\t\tconst struct qstr *nm, const void *value, int size)\n{\n\tint err, names_len;\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui, *host_ui = ubifs_inode(host);\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t.new_ino_d = ALIGN(size, 8), .dirtied_ino = 1,\n\t\t\t\t.dirtied_ino_d = ALIGN(host_ui->data_len, 8) };\n\n\tif (host_ui->xattr_cnt >= MAX_XATTRS_PER_INODE) {\n\t\tubifs_err(\"inode %lu already has too many xattrs (%d), cannot create more\",\n\t\t\t  host->i_ino, host_ui->xattr_cnt);\n\t\treturn -ENOSPC;\n\t}\n\t/*\n\t * Linux limits the maximum size of the extended attribute names list\n\t * to %XATTR_LIST_MAX. This means we should not allow creating more\n\t * extended attributes if the name list becomes larger. This limitation\n\t * is artificial for UBIFS, though.\n\t */\n\tnames_len = host_ui->xattr_names + host_ui->xattr_cnt + nm->len + 1;\n\tif (names_len > XATTR_LIST_MAX) {\n\t\tubifs_err(\"cannot add one more xattr name to inode %lu, total names length would become %d, max. is %d\",\n\t\t\t  host->i_ino, names_len, XATTR_LIST_MAX);\n\t\treturn -ENOSPC;\n\t}\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tinode = ubifs_new_inode(c, host, S_IFREG | S_IRWXUGO);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_budg;\n\t}\n\n\t/* Re-define all operations to be \"nothing\" */\n\tinode->i_mapping->a_ops = &empty_aops;\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &empty_fops;\n\n\tinode->i_flags |= S_SYNC | S_NOATIME | S_NOCMTIME | S_NOQUOTA;\n\tui = ubifs_inode(inode);\n\tui->xattr = 1;\n\tui->flags |= UBIFS_XATTR_FL;\n\tui->data = kmemdup(value, size, GFP_NOFS);\n\tif (!ui->data) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tinode->i_size = ui->ui_size = size;\n\tui->data_len = size;\n\n\tmutex_lock(&host_ui->ui_mutex);\n\thost->i_ctime = ubifs_current_time(host);\n\thost_ui->xattr_cnt += 1;\n\thost_ui->xattr_size += CALC_DENT_SIZE(nm->len);\n\thost_ui->xattr_size += CALC_XATTR_BYTES(size);\n\thost_ui->xattr_names += nm->len;\n\n\terr = ubifs_jnl_update(c, host, nm, inode, 0, 1);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&host_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\tinsert_inode_hash(inode);\n\tiput(inode);\n\treturn 0;\n\nout_cancel:\n\thost_ui->xattr_cnt -= 1;\n\thost_ui->xattr_size -= CALC_DENT_SIZE(nm->len);\n\thost_ui->xattr_size -= CALC_XATTR_BYTES(size);\n\tmutex_unlock(&host_ui->ui_mutex);\nout_free:\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_budg:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\n/**\n * chan",
    "includes": [
      "ux/posix_acl_xattr.h>\n\n/*\n * Limit",
      "ux/xattr.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/fs.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "struct inode_operations empty_iops;\nstatic const"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tr",
          "args": [
            "t",
            "n er"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_",
          "args": [
            "udg:"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vxattrcb_layout_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "56-65",
          "snippet": "static bool ceph_vxattrcb_layout_exists(struct ceph_inode_info *ci)\n{\n\tsize_t s;\n\tchar *p = (char *)&ci->i_layout;\n\n\tfor (s = 0; s < sizeof(ci->i_layout); s++, p++)\n\t\tif (*p)\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic bool ceph_vxattrcb_layout_exists(struct ceph_inode_info *ci)\n{\n\tsize_t s;\n\tchar *p = (char *)&ci->i_layout;\n\n\tfor (s = 0; s < sizeof(ci->i_layout); s++, p++)\n\t\tif (*p)\n\t\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e(inode);\n\tipu",
          "args": [
            "(inod"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&host_ui->ui",
          "args": [
            "mutex);\nout_free:"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TES(size);\n\tmute",
          "args": [
            "_unl"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(nm->len);\n\th",
          "args": [
            "st_ui->"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn 0;"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash(inode);\n\tipu",
          "args": [
            "(inod"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\ti",
          "args": [
            "s",
            "t_in"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&host_ui->ui",
          "args": [
            "mutex);\n\n\tubifs_re"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ate(c, host, nm,",
          "args": [
            "i",
            "de,",
            "1",
            "if",
            "r"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TES(size);\n\thost",
          "args": [
            "ui->"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(nm->len);\n\th",
          "args": [
            "st_ui->"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(host);\n\thost",
          "args": [
            "ui->"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost_ui->ui",
          "args": [
            "mutex);\n\thost->i_c"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", size,",
          "args": [
            "GFP_N",
            "S);",
            "f (!ui->"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tui-",
          "args": [
            "xattr"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tgo",
          "args": [
            "o out"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "rr ="
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, host, S_I",
          "args": [
            "R",
            "| S",
            "RWXUGO);\n\tif (IS_ER"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot add",
          "args": [
            "ne more xattr name to inode %lu, total names length would become %d, max. is %d\",\n\t\t\t  host->",
            "names_len,",
            "TTR_LIST_",
            "X);\n\t\treturn -"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode %lu a",
          "args": [
            "ready has too many xattrs (%d), cannot create more\",\n\t\t\t  host->",
            "host_ui->xa",
            "r_cnt);\n\t\treturn -"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->dat",
          "args": [
            "_len, 8) };\n\n\tif",
            "o"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "477-529",
          "snippet": "static int ocfs2_validate_xattr_block(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_xattr_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &xb->xb_check);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Errors after here are fatal\n\t */\n\n\tif (!OCFS2_IS_VALID_XATTR_BLOCK(xb)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has bad \"\n\t\t\t    \"signature %.*s\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    xb->xb_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(xb->xb_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an \"\n\t\t\t    \"invalid xb_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(xb->xb_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(xb->xb_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an invalid \"\n\t\t\t    \"xb_fs_generation of #%u\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(xb->xb_fs_generation));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_validate_xattr_block(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_xattr_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &xb->xb_check);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Errors after here are fatal\n\t */\n\n\tif (!OCFS2_IS_VALID_XATTR_BLOCK(xb)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has bad \"\n\t\t\t    \"signature %.*s\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    xb->xb_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(xb->xb_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an \"\n\t\t\t    \"invalid xb_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(xb->xb_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(xb->xb_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an invalid \"\n\t\t\t    \"xb_fs_generation of #%u\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(xb->xb_fs_generation));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "), .d",
          "args": [
            "rtie",
            "i"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost);\n\tstru",
          "args": [
            "t ub"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/posix_acl_xattr.h>\n\n/*\n * Limit\nux/xattr.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/fs.h>\n#include <lin\nfs.h\"\n#include <lin\n\nstruct inode_operations empty_iops;\nstatic const;\n\neate_xattr(struct ubifs_info *c, struct inode *host,\n\t\t\tconst struct qstr *nm, const void *value, int size)\n{\n\tint err, names_len;\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui, *host_ui = ubifs_inode(host);\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t.new_ino_d = ALIGN(size, 8), .dirtied_ino = 1,\n\t\t\t\t.dirtied_ino_d = ALIGN(host_ui->data_len, 8) };\n\n\tif (host_ui->xattr_cnt >= MAX_XATTRS_PER_INODE) {\n\t\tubifs_err(\"inode %lu already has too many xattrs (%d), cannot create more\",\n\t\t\t  host->i_ino, host_ui->xattr_cnt);\n\t\treturn -ENOSPC;\n\t}\n\t/*\n\t * Linux limits the maximum size of the extended attribute names list\n\t * to %XATTR_LIST_MAX. This means we should not allow creating more\n\t * extended attributes if the name list becomes larger. This limitation\n\t * is artificial for UBIFS, though.\n\t */\n\tnames_len = host_ui->xattr_names + host_ui->xattr_cnt + nm->len + 1;\n\tif (names_len > XATTR_LIST_MAX) {\n\t\tubifs_err(\"cannot add one more xattr name to inode %lu, total names length would become %d, max. is %d\",\n\t\t\t  host->i_ino, names_len, XATTR_LIST_MAX);\n\t\treturn -ENOSPC;\n\t}\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tinode = ubifs_new_inode(c, host, S_IFREG | S_IRWXUGO);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_budg;\n\t}\n\n\t/* Re-define all operations to be \"nothing\" */\n\tinode->i_mapping->a_ops = &empty_aops;\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &empty_fops;\n\n\tinode->i_flags |= S_SYNC | S_NOATIME | S_NOCMTIME | S_NOQUOTA;\n\tui = ubifs_inode(inode);\n\tui->xattr = 1;\n\tui->flags |= UBIFS_XATTR_FL;\n\tui->data = kmemdup(value, size, GFP_NOFS);\n\tif (!ui->data) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tinode->i_size = ui->ui_size = size;\n\tui->data_len = size;\n\n\tmutex_lock(&host_ui->ui_mutex);\n\thost->i_ctime = ubifs_current_time(host);\n\thost_ui->xattr_cnt += 1;\n\thost_ui->xattr_size += CALC_DENT_SIZE(nm->len);\n\thost_ui->xattr_size += CALC_XATTR_BYTES(size);\n\thost_ui->xattr_names += nm->len;\n\n\terr = ubifs_jnl_update(c, host, nm, inode, 0, 1);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&host_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\tinsert_inode_hash(inode);\n\tiput(inode);\n\treturn 0;\n\nout_cancel:\n\thost_ui->xattr_cnt -= 1;\n\thost_ui->xattr_size -= CALC_DENT_SIZE(nm->len);\n\thost_ui->xattr_size -= CALC_XATTR_BYTES(size);\n\tmutex_unlock(&host_ui->ui_mutex);\nout_free:\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_budg:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\n/**\n * chan"
  }
]