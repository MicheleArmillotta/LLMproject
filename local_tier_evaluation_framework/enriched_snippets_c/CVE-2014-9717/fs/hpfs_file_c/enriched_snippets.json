[
  {
    "function_name": "_hpfs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "182-185",
    "snippet": "static sector_t _hpfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,hpfs_get_block);\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "hpfs_get_block"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic sector_t _hpfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,hpfs_get_block);\n}"
  },
  {
    "function_name": "hpfs_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "164-180",
    "snippet": "static int hpfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *pagep, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint err;\n\terr = generic_write_end(file, mapping, pos, len, copied, pagep, fsdata);\n\tif (err < len)\n\t\thpfs_write_failed(mapping, pos + len);\n\tif (!(err < 0)) {\n\t\t/* make sure we write it on close, if not earlier */\n\t\thpfs_lock(inode->i_sb);\n\t\thpfs_i(inode)->i_dirty = 1;\n\t\thpfs_unlock(inode->i_sb);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "inode"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
          "lines": "134-146",
          "snippet": "static void hpfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\thpfs_lock(inode->i_sb);\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thpfs_truncate(inode);\n\t}\n\n\thpfs_unlock(inode->i_sb);\n}",
          "includes": [
            "#include <linux/mpage.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic void hpfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\thpfs_lock(inode->i_sb);\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thpfs_truncate(inode);\n\t}\n\n\thpfs_unlock(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "pagep",
            "fsdata"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2067-2104",
          "snippet": "int generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic int hpfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *pagep, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint err;\n\terr = generic_write_end(file, mapping, pos, len, copied, pagep, fsdata);\n\tif (err < len)\n\t\thpfs_write_failed(mapping, pos + len);\n\tif (!(err < 0)) {\n\t\t/* make sure we write it on close, if not earlier */\n\t\thpfs_lock(inode->i_sb);\n\t\thpfs_i(inode)->i_dirty = 1;\n\t\thpfs_unlock(inode->i_sb);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "hpfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "148-162",
    "snippet": "static int hpfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\thpfs_get_block,\n\t\t\t\t&hpfs_i(mapping->host)->mmu_private);\n\tif (unlikely(ret))\n\t\thpfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
          "lines": "134-146",
          "snippet": "static void hpfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\thpfs_lock(inode->i_sb);\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thpfs_truncate(inode);\n\t}\n\n\thpfs_unlock(inode->i_sb);\n}",
          "includes": [
            "#include <linux/mpage.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic void hpfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\thpfs_lock(inode->i_sb);\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thpfs_truncate(inode);\n\t}\n\n\thpfs_unlock(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cont_write_begin",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata",
            "hpfs_get_block",
            "&hpfs_i(mapping->host)->mmu_private"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "cont_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2352-2373",
          "snippet": "int cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "mapping->host"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic int hpfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\thpfs_get_block,\n\t\t\t\t&hpfs_i(mapping->host)->mmu_private);\n\tif (unlikely(ret))\n\t\thpfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hpfs_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "134-146",
    "snippet": "static void hpfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\thpfs_lock(inode->i_sb);\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thpfs_truncate(inode);\n\t}\n\n\thpfs_unlock(inode->i_sb);\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_truncate",
          "args": [
            "inode"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
          "lines": "63-74",
          "snippet": "void hpfs_truncate(struct inode *i)\n{\n\tif (IS_IMMUTABLE(i)) return /*-EPERM*/;\n\thpfs_lock_assert(i->i_sb);\n\n\thpfs_i(i)->i_n_secs = 0;\n\ti->i_blocks = 1 + ((i->i_size + 511) >> 9);\n\thpfs_i(i)->mmu_private = i->i_size;\n\thpfs_truncate_btree(i->i_sb, i->i_ino, 1, ((i->i_size + 511) >> 9));\n\thpfs_write_inode(i);\n\thpfs_i(i)->i_n_secs = 0;\n}",
          "includes": [
            "#include <linux/mpage.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nvoid hpfs_truncate(struct inode *i)\n{\n\tif (IS_IMMUTABLE(i)) return /*-EPERM*/;\n\thpfs_lock_assert(i->i_sb);\n\n\thpfs_i(i)->i_n_secs = 0;\n\ti->i_blocks = 1 + ((i->i_size + 511) >> 9);\n\thpfs_i(i)->mmu_private = i->i_size;\n\thpfs_truncate_btree(i->i_sb, i->i_ino, 1, ((i->i_size + 511) >> 9));\n\thpfs_write_inode(i);\n\thpfs_i(i)->i_n_secs = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic void hpfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\thpfs_lock(inode->i_sb);\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thpfs_truncate(inode);\n\t}\n\n\thpfs_unlock(inode->i_sb);\n}"
  },
  {
    "function_name": "hpfs_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "128-132",
    "snippet": "static int hpfs_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, hpfs_get_block);\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_writepages",
          "args": [
            "mapping",
            "wbc",
            "hpfs_get_block"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "675-700",
          "snippet": "int\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic int hpfs_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, hpfs_get_block);\n}"
  },
  {
    "function_name": "hpfs_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "122-126",
    "snippet": "static int hpfs_readpages(struct file *file, struct address_space *mapping,\n\t\t\t  struct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, hpfs_get_block);\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "hpfs_get_block"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic int hpfs_readpages(struct file *file, struct address_space *mapping,\n\t\t\t  struct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, hpfs_get_block);\n}"
  },
  {
    "function_name": "hpfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "117-120",
    "snippet": "static int hpfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, hpfs_get_block, wbc);\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "hpfs_get_block",
            "wbc"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic int hpfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, hpfs_get_block, wbc);\n}"
  },
  {
    "function_name": "hpfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "112-115",
    "snippet": "static int hpfs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, hpfs_get_block);\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpage",
          "args": [
            "page",
            "hpfs_get_block"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "392-406",
          "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic int hpfs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, hpfs_get_block);\n}"
  },
  {
    "function_name": "hpfs_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "76-110",
    "snippet": "static int hpfs_get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)\n{\n\tint r;\n\tsecno s;\n\tunsigned n_secs;\n\thpfs_lock(inode->i_sb);\n\ts = hpfs_bmap(inode, iblock, &n_secs);\n\tif (s) {\n\t\tif (bh_result->b_size >> 9 < n_secs)\n\t\t\tn_secs = bh_result->b_size >> 9;\n\t\tmap_bh(bh_result, inode->i_sb, s);\n\t\tbh_result->b_size = n_secs << 9;\n\t\tgoto ret_0;\n\t}\n\tif (!create) goto ret_0;\n\tif (iblock<<9 != hpfs_i(inode)->mmu_private) {\n\t\tBUG();\n\t\tr = -EIO;\n\t\tgoto ret_r;\n\t}\n\tif ((s = hpfs_add_sector_to_btree(inode->i_sb, inode->i_ino, 1, inode->i_blocks - 1)) == -1) {\n\t\thpfs_truncate_btree(inode->i_sb, inode->i_ino, 1, inode->i_blocks - 1);\n\t\tr = -ENOSPC;\n\t\tgoto ret_r;\n\t}\n\tinode->i_blocks++;\n\thpfs_i(inode)->mmu_private += 512;\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, inode->i_sb, s);\n\tret_0:\n\tr = 0;\n\tret_r:\n\thpfs_unlock(inode->i_sb);\n\treturn r;\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "s"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "inode"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_truncate_btree",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "1",
            "inode->i_blocks - 1"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_truncate_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "398-475",
          "snippet": "void hpfs_truncate_btree(struct super_block *s, secno f, int fno, unsigned secs)\n{\n\tstruct fnode *fnode;\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tstruct bplus_header *btree;\n\tanode_secno node = f;\n\tint i, j, nodes;\n\tint c1, c2 = 0;\n\tif (fno) {\n\t\tif (!(fnode = hpfs_map_fnode(s, f, &bh))) return;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, f, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\n\tif (!secs) {\n\t\thpfs_remove_btree(s, btree);\n\t\tif (fno) {\n\t\t\tbtree->n_free_nodes = 8;\n\t\t\tbtree->n_used_nodes = 0;\n\t\t\tbtree->first_free = cpu_to_le16(8);\n\t\t\tbtree->flags &= ~BP_internal;\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else hpfs_free_sectors(s, f, 1);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\twhile (bp_internal(btree)) {\n\t\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) >= secs) goto f;\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"internal btree %08x doesn't end with -1\", node);\n\t\treturn;\n\t\tf:\n\t\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\t\thpfs_ea_remove(s, le32_to_cpu(btree->u.internal[j].down), 1, 0);\n\t\tbtree->n_used_nodes = i + 1;\n\t\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\t\tbtree->first_free = cpu_to_le16(8 + 8 * btree->n_used_nodes);\n\t\tmark_buffer_dirty(bh);\n\t\tif (btree->u.internal[i].file_secno == cpu_to_le32(secs)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tnode = le32_to_cpu(btree->u.internal[i].down);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, node, &c1, &c2, \"hpfs_truncate_btree\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\t\n\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) >= secs) goto ff;\n\tbrelse(bh);\n\treturn;\n\tff:\n\tif (secs <= le32_to_cpu(btree->u.external[i].file_secno)) {\n\t\thpfs_error(s, \"there is an allocation error in file %08x, sector %08x\", f, secs);\n\t\tif (i) i--;\n\t}\n\telse if (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > secs) {\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[i].disk_secno) + secs -\n\t\t\tle32_to_cpu(btree->u.external[i].file_secno), le32_to_cpu(btree->u.external[i].length)\n\t\t\t- secs + le32_to_cpu(btree->u.external[i].file_secno)); /* I hope gcc optimizes this :-) */\n\t\tbtree->u.external[i].length = cpu_to_le32(secs - le32_to_cpu(btree->u.external[i].file_secno));\n\t}\n\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[j].disk_secno), le32_to_cpu(btree->u.external[j].length));\n\tbtree->n_used_nodes = i + 1;\n\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\tbtree->first_free = cpu_to_le16(8 + 12 * btree->n_used_nodes);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_truncate_btree(struct super_block *s, secno f, int fno, unsigned secs)\n{\n\tstruct fnode *fnode;\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tstruct bplus_header *btree;\n\tanode_secno node = f;\n\tint i, j, nodes;\n\tint c1, c2 = 0;\n\tif (fno) {\n\t\tif (!(fnode = hpfs_map_fnode(s, f, &bh))) return;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, f, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\n\tif (!secs) {\n\t\thpfs_remove_btree(s, btree);\n\t\tif (fno) {\n\t\t\tbtree->n_free_nodes = 8;\n\t\t\tbtree->n_used_nodes = 0;\n\t\t\tbtree->first_free = cpu_to_le16(8);\n\t\t\tbtree->flags &= ~BP_internal;\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else hpfs_free_sectors(s, f, 1);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\twhile (bp_internal(btree)) {\n\t\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) >= secs) goto f;\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"internal btree %08x doesn't end with -1\", node);\n\t\treturn;\n\t\tf:\n\t\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\t\thpfs_ea_remove(s, le32_to_cpu(btree->u.internal[j].down), 1, 0);\n\t\tbtree->n_used_nodes = i + 1;\n\t\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\t\tbtree->first_free = cpu_to_le16(8 + 8 * btree->n_used_nodes);\n\t\tmark_buffer_dirty(bh);\n\t\tif (btree->u.internal[i].file_secno == cpu_to_le32(secs)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tnode = le32_to_cpu(btree->u.internal[i].down);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, node, &c1, &c2, \"hpfs_truncate_btree\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\t\n\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) >= secs) goto ff;\n\tbrelse(bh);\n\treturn;\n\tff:\n\tif (secs <= le32_to_cpu(btree->u.external[i].file_secno)) {\n\t\thpfs_error(s, \"there is an allocation error in file %08x, sector %08x\", f, secs);\n\t\tif (i) i--;\n\t}\n\telse if (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > secs) {\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[i].disk_secno) + secs -\n\t\t\tle32_to_cpu(btree->u.external[i].file_secno), le32_to_cpu(btree->u.external[i].length)\n\t\t\t- secs + le32_to_cpu(btree->u.external[i].file_secno)); /* I hope gcc optimizes this :-) */\n\t\tbtree->u.external[i].length = cpu_to_le32(secs - le32_to_cpu(btree->u.external[i].file_secno));\n\t}\n\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[j].disk_secno), le32_to_cpu(btree->u.external[j].length));\n\tbtree->n_used_nodes = i + 1;\n\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\tbtree->first_free = cpu_to_le16(8 + 12 * btree->n_used_nodes);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_add_sector_to_btree",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "1",
            "inode->i_blocks - 1"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_sector_to_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "60-266",
          "snippet": "secno hpfs_add_sector_to_btree(struct super_block *s, secno node, int fnod, unsigned fsecno)\n{\n\tstruct bplus_header *btree;\n\tstruct anode *anode = NULL, *ranode = NULL;\n\tstruct fnode *fnode;\n\tanode_secno a, na = -1, ra, up = -1;\n\tsecno se;\n\tstruct buffer_head *bh, *bh1, *bh2;\n\tint n;\n\tunsigned fs;\n\tint c1, c2 = 0;\n\tif (fnod) {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) return -1;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t}\n\ta = node;\n\tgo_down:\n\tif ((n = btree->n_used_nodes - 1) < -!!fnod) {\n\t\thpfs_error(s, \"anode %08x has no entries\", a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tif (bp_internal(btree)) {\n\t\ta = le32_to_cpu(btree->u.internal[n].down);\n\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_add_sector_to_btree #1\")) return -1;\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t\tgoto go_down;\n\t}\n\tif (n >= 0) {\n\t\tif (le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length) != fsecno) {\n\t\t\thpfs_error(s, \"allocated size %08x, trying to add sector %08x, %cnode %08x\",\n\t\t\t\tle32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length), fsecno,\n\t\t\t\tfnod?'f':'a', node);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tif (hpfs_alloc_if_possible(s, se = le32_to_cpu(btree->u.external[n].disk_secno) + le32_to_cpu(btree->u.external[n].length))) {\n\t\t\tle32_add_cpu(&btree->u.external[n].length, 1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\treturn se;\n\t\t}\n\t} else {\n\t\tif (fsecno) {\n\t\t\thpfs_error(s, \"empty file %08x, trying to add sector %08x\", node, fsecno);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tse = !fnod ? node : (node + 16384) & ~16383;\n\t}\t\n\tif (!(se = hpfs_alloc_sector(s, se, 1, fsecno*ALLOC_M>ALLOC_FWD_MAX ? ALLOC_FWD_MAX : fsecno*ALLOC_M<ALLOC_FWD_MIN ? ALLOC_FWD_MIN : fsecno*ALLOC_M))) {\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfs = n < 0 ? 0 : le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length);\n\tif (!btree->n_free_nodes) {\n\t\tup = a != node ? le32_to_cpu(anode->up) : -1;\n\t\tif (!(anode = hpfs_alloc_anode(s, a, &na, &bh1))) {\n\t\t\tbrelse(bh);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (a == node && fnod) {\n\t\t\tanode->up = cpu_to_le32(node);\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\tanode->btree.n_used_nodes = btree->n_used_nodes;\n\t\t\tanode->btree.first_free = btree->first_free;\n\t\t\tanode->btree.n_free_nodes = 40 - anode->btree.n_used_nodes;\n\t\t\tmemcpy(&anode->u, &btree->u, btree->n_used_nodes * 12);\n\t\t\tbtree->flags |= BP_internal;\n\t\t\tbtree->n_free_nodes = 11;\n\t\t\tbtree->n_used_nodes = 1;\n\t\t\tbtree->first_free = cpu_to_le16((char *)&(btree->u.internal[1]) - (char *)btree);\n\t\t\tbtree->u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[0].down = cpu_to_le32(na);\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else if (!(ranode = hpfs_alloc_anode(s, /*a*/0, &ra, &bh2))) {\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh1);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\thpfs_free_sectors(s, na, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(bh);\n\t\tbh = bh1;\n\t\tbtree = &anode->btree;\n\t}\n\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\tle16_add_cpu(&btree->first_free, 12);\n\tbtree->u.external[n].disk_secno = cpu_to_le32(se);\n\tbtree->u.external[n].file_secno = cpu_to_le32(fs);\n\tbtree->u.external[n].length = cpu_to_le32(1);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tif ((a == node && fnod) || na == -1) return se;\n\tc2 = 0;\n\twhile (up != (anode_secno)-1) {\n\t\tstruct anode *new_anode;\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, up, &c1, &c2, \"hpfs_add_sector_to_btree #2\")) return -1;\n\t\tif (up != node || !fnod) {\n\t\t\tif (!(anode = hpfs_map_anode(s, up, &bh))) return -1;\n\t\t\tbtree = &anode->btree;\n\t\t} else {\n\t\t\tif (!(fnode = hpfs_map_fnode(s, up, &bh))) return -1;\n\t\t\tbtree = &fnode->btree;\n\t\t}\n\t\tif (btree->n_free_nodes) {\n\t\t\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\t\t\tle16_add_cpu(&btree->first_free, 8);\n\t\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[n].down = cpu_to_le32(na);\n\t\t\tbtree->u.internal[n-1].file_secno = cpu_to_le32(fs);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh2);\n\t\t\thpfs_free_sectors(s, ra, 1);\n\t\t\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(up);\n\t\t\t\tif (up == node && fnod)\n\t\t\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\t\telse\n\t\t\t\t\tanode->btree.flags &= ~BP_fnode_parent;\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t\treturn se;\n\t\t}\n\t\tup = up != node ? le32_to_cpu(anode->up) : -1;\n\t\tbtree->u.internal[btree->n_used_nodes - 1].file_secno = cpu_to_le32(/*fs*/-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\ta = na;\n\t\tif ((new_anode = hpfs_alloc_anode(s, a, &na, &bh))) {\n\t\t\tanode = new_anode;\n\t\t\t/*anode->up = cpu_to_le32(up != -1 ? up : ra);*/\n\t\t\tanode->btree.flags |= BP_internal;\n\t\t\tanode->btree.n_used_nodes = 1;\n\t\t\tanode->btree.n_free_nodes = 59;\n\t\t\tanode->btree.first_free = cpu_to_le16(16);\n\t\t\tanode->btree.u.internal[0].down = cpu_to_le32(a);\n\t\t\tanode->btree.u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tif ((anode = hpfs_map_anode(s, a, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(na);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t} else na = a;\n\t}\n\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\tanode->up = cpu_to_le32(node);\n\t\tif (fnod)\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tif (!fnod) {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &anode->btree;\n\t} else {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &fnode->btree;\n\t}\n\tranode->up = cpu_to_le32(node);\n\tmemcpy(&ranode->btree, btree, le16_to_cpu(btree->first_free));\n\tif (fnod)\n\t\tranode->btree.flags |= BP_fnode_parent;\n\tranode->btree.n_free_nodes = (bp_internal(&ranode->btree) ? 60 : 40) - ranode->btree.n_used_nodes;\n\tif (bp_internal(&ranode->btree)) for (n = 0; n < ranode->btree.n_used_nodes; n++) {\n\t\tstruct anode *unode;\n\t\tif ((unode = hpfs_map_anode(s, le32_to_cpu(ranode->u.internal[n].down), &bh1))) {\n\t\t\tunode->up = cpu_to_le32(ra);\n\t\t\tunode->btree.flags &= ~BP_fnode_parent;\n\t\t\tmark_buffer_dirty(bh1);\n\t\t\tbrelse(bh1);\n\t\t}\n\t}\n\tbtree->flags |= BP_internal;\n\tbtree->n_free_nodes = fnod ? 10 : 58;\n\tbtree->n_used_nodes = 2;\n\tbtree->first_free = cpu_to_le16((char *)&btree->u.internal[2] - (char *)btree);\n\tbtree->u.internal[0].file_secno = cpu_to_le32(fs);\n\tbtree->u.internal[0].down = cpu_to_le32(ra);\n\tbtree->u.internal[1].file_secno = cpu_to_le32(-1);\n\tbtree->u.internal[1].down = cpu_to_le32(na);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tmark_buffer_dirty(bh2);\n\tbrelse(bh2);\n\treturn se;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nsecno hpfs_add_sector_to_btree(struct super_block *s, secno node, int fnod, unsigned fsecno)\n{\n\tstruct bplus_header *btree;\n\tstruct anode *anode = NULL, *ranode = NULL;\n\tstruct fnode *fnode;\n\tanode_secno a, na = -1, ra, up = -1;\n\tsecno se;\n\tstruct buffer_head *bh, *bh1, *bh2;\n\tint n;\n\tunsigned fs;\n\tint c1, c2 = 0;\n\tif (fnod) {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) return -1;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t}\n\ta = node;\n\tgo_down:\n\tif ((n = btree->n_used_nodes - 1) < -!!fnod) {\n\t\thpfs_error(s, \"anode %08x has no entries\", a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tif (bp_internal(btree)) {\n\t\ta = le32_to_cpu(btree->u.internal[n].down);\n\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_add_sector_to_btree #1\")) return -1;\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t\tgoto go_down;\n\t}\n\tif (n >= 0) {\n\t\tif (le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length) != fsecno) {\n\t\t\thpfs_error(s, \"allocated size %08x, trying to add sector %08x, %cnode %08x\",\n\t\t\t\tle32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length), fsecno,\n\t\t\t\tfnod?'f':'a', node);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tif (hpfs_alloc_if_possible(s, se = le32_to_cpu(btree->u.external[n].disk_secno) + le32_to_cpu(btree->u.external[n].length))) {\n\t\t\tle32_add_cpu(&btree->u.external[n].length, 1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\treturn se;\n\t\t}\n\t} else {\n\t\tif (fsecno) {\n\t\t\thpfs_error(s, \"empty file %08x, trying to add sector %08x\", node, fsecno);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tse = !fnod ? node : (node + 16384) & ~16383;\n\t}\t\n\tif (!(se = hpfs_alloc_sector(s, se, 1, fsecno*ALLOC_M>ALLOC_FWD_MAX ? ALLOC_FWD_MAX : fsecno*ALLOC_M<ALLOC_FWD_MIN ? ALLOC_FWD_MIN : fsecno*ALLOC_M))) {\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfs = n < 0 ? 0 : le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length);\n\tif (!btree->n_free_nodes) {\n\t\tup = a != node ? le32_to_cpu(anode->up) : -1;\n\t\tif (!(anode = hpfs_alloc_anode(s, a, &na, &bh1))) {\n\t\t\tbrelse(bh);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (a == node && fnod) {\n\t\t\tanode->up = cpu_to_le32(node);\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\tanode->btree.n_used_nodes = btree->n_used_nodes;\n\t\t\tanode->btree.first_free = btree->first_free;\n\t\t\tanode->btree.n_free_nodes = 40 - anode->btree.n_used_nodes;\n\t\t\tmemcpy(&anode->u, &btree->u, btree->n_used_nodes * 12);\n\t\t\tbtree->flags |= BP_internal;\n\t\t\tbtree->n_free_nodes = 11;\n\t\t\tbtree->n_used_nodes = 1;\n\t\t\tbtree->first_free = cpu_to_le16((char *)&(btree->u.internal[1]) - (char *)btree);\n\t\t\tbtree->u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[0].down = cpu_to_le32(na);\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else if (!(ranode = hpfs_alloc_anode(s, /*a*/0, &ra, &bh2))) {\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh1);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\thpfs_free_sectors(s, na, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(bh);\n\t\tbh = bh1;\n\t\tbtree = &anode->btree;\n\t}\n\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\tle16_add_cpu(&btree->first_free, 12);\n\tbtree->u.external[n].disk_secno = cpu_to_le32(se);\n\tbtree->u.external[n].file_secno = cpu_to_le32(fs);\n\tbtree->u.external[n].length = cpu_to_le32(1);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tif ((a == node && fnod) || na == -1) return se;\n\tc2 = 0;\n\twhile (up != (anode_secno)-1) {\n\t\tstruct anode *new_anode;\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, up, &c1, &c2, \"hpfs_add_sector_to_btree #2\")) return -1;\n\t\tif (up != node || !fnod) {\n\t\t\tif (!(anode = hpfs_map_anode(s, up, &bh))) return -1;\n\t\t\tbtree = &anode->btree;\n\t\t} else {\n\t\t\tif (!(fnode = hpfs_map_fnode(s, up, &bh))) return -1;\n\t\t\tbtree = &fnode->btree;\n\t\t}\n\t\tif (btree->n_free_nodes) {\n\t\t\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\t\t\tle16_add_cpu(&btree->first_free, 8);\n\t\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[n].down = cpu_to_le32(na);\n\t\t\tbtree->u.internal[n-1].file_secno = cpu_to_le32(fs);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh2);\n\t\t\thpfs_free_sectors(s, ra, 1);\n\t\t\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(up);\n\t\t\t\tif (up == node && fnod)\n\t\t\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\t\telse\n\t\t\t\t\tanode->btree.flags &= ~BP_fnode_parent;\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t\treturn se;\n\t\t}\n\t\tup = up != node ? le32_to_cpu(anode->up) : -1;\n\t\tbtree->u.internal[btree->n_used_nodes - 1].file_secno = cpu_to_le32(/*fs*/-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\ta = na;\n\t\tif ((new_anode = hpfs_alloc_anode(s, a, &na, &bh))) {\n\t\t\tanode = new_anode;\n\t\t\t/*anode->up = cpu_to_le32(up != -1 ? up : ra);*/\n\t\t\tanode->btree.flags |= BP_internal;\n\t\t\tanode->btree.n_used_nodes = 1;\n\t\t\tanode->btree.n_free_nodes = 59;\n\t\t\tanode->btree.first_free = cpu_to_le16(16);\n\t\t\tanode->btree.u.internal[0].down = cpu_to_le32(a);\n\t\t\tanode->btree.u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tif ((anode = hpfs_map_anode(s, a, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(na);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t} else na = a;\n\t}\n\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\tanode->up = cpu_to_le32(node);\n\t\tif (fnod)\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tif (!fnod) {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &anode->btree;\n\t} else {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &fnode->btree;\n\t}\n\tranode->up = cpu_to_le32(node);\n\tmemcpy(&ranode->btree, btree, le16_to_cpu(btree->first_free));\n\tif (fnod)\n\t\tranode->btree.flags |= BP_fnode_parent;\n\tranode->btree.n_free_nodes = (bp_internal(&ranode->btree) ? 60 : 40) - ranode->btree.n_used_nodes;\n\tif (bp_internal(&ranode->btree)) for (n = 0; n < ranode->btree.n_used_nodes; n++) {\n\t\tstruct anode *unode;\n\t\tif ((unode = hpfs_map_anode(s, le32_to_cpu(ranode->u.internal[n].down), &bh1))) {\n\t\t\tunode->up = cpu_to_le32(ra);\n\t\t\tunode->btree.flags &= ~BP_fnode_parent;\n\t\t\tmark_buffer_dirty(bh1);\n\t\t\tbrelse(bh1);\n\t\t}\n\t}\n\tbtree->flags |= BP_internal;\n\tbtree->n_free_nodes = fnod ? 10 : 58;\n\tbtree->n_used_nodes = 2;\n\tbtree->first_free = cpu_to_le16((char *)&btree->u.internal[2] - (char *)btree);\n\tbtree->u.internal[0].file_secno = cpu_to_le32(fs);\n\tbtree->u.internal[0].down = cpu_to_le32(ra);\n\tbtree->u.internal[1].file_secno = cpu_to_le32(-1);\n\tbtree->u.internal[1].down = cpu_to_le32(na);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tmark_buffer_dirty(bh2);\n\tbrelse(bh2);\n\treturn se;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "s"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_bmap",
          "args": [
            "inode",
            "iblock",
            "&n_secs"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
          "lines": "38-61",
          "snippet": "static secno hpfs_bmap(struct inode *inode, unsigned file_secno, unsigned *n_secs)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tunsigned n, disk_secno;\n\tstruct fnode *fnode;\n\tstruct buffer_head *bh;\n\tif (BLOCKS(hpfs_i(inode)->mmu_private) <= file_secno) return 0;\n\tn = file_secno - hpfs_inode->i_file_sec;\n\tif (n < hpfs_inode->i_n_secs) {\n\t\t*n_secs = hpfs_inode->i_n_secs - n;\n\t\treturn hpfs_inode->i_disk_sec + n;\n\t}\n\tif (!(fnode = hpfs_map_fnode(inode->i_sb, inode->i_ino, &bh))) return 0;\n\tdisk_secno = hpfs_bplus_lookup(inode->i_sb, inode, &fnode->btree, file_secno, bh);\n\tif (disk_secno == -1) return 0;\n\tif (hpfs_chk_sectors(inode->i_sb, disk_secno, 1, \"bmap\")) return 0;\n\tn = file_secno - hpfs_inode->i_file_sec;\n\tif (n < hpfs_inode->i_n_secs) {\n\t\t*n_secs = hpfs_inode->i_n_secs - n;\n\t\treturn hpfs_inode->i_disk_sec + n;\n\t}\n\t*n_secs = 1;\n\treturn disk_secno;\n}",
          "includes": [
            "#include <linux/mpage.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic secno hpfs_bmap(struct inode *inode, unsigned file_secno, unsigned *n_secs)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tunsigned n, disk_secno;\n\tstruct fnode *fnode;\n\tstruct buffer_head *bh;\n\tif (BLOCKS(hpfs_i(inode)->mmu_private) <= file_secno) return 0;\n\tn = file_secno - hpfs_inode->i_file_sec;\n\tif (n < hpfs_inode->i_n_secs) {\n\t\t*n_secs = hpfs_inode->i_n_secs - n;\n\t\treturn hpfs_inode->i_disk_sec + n;\n\t}\n\tif (!(fnode = hpfs_map_fnode(inode->i_sb, inode->i_ino, &bh))) return 0;\n\tdisk_secno = hpfs_bplus_lookup(inode->i_sb, inode, &fnode->btree, file_secno, bh);\n\tif (disk_secno == -1) return 0;\n\tif (hpfs_chk_sectors(inode->i_sb, disk_secno, 1, \"bmap\")) return 0;\n\tn = file_secno - hpfs_inode->i_file_sec;\n\tif (n < hpfs_inode->i_n_secs) {\n\t\t*n_secs = hpfs_inode->i_n_secs - n;\n\t\treturn hpfs_inode->i_disk_sec + n;\n\t}\n\t*n_secs = 1;\n\treturn disk_secno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic int hpfs_get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)\n{\n\tint r;\n\tsecno s;\n\tunsigned n_secs;\n\thpfs_lock(inode->i_sb);\n\ts = hpfs_bmap(inode, iblock, &n_secs);\n\tif (s) {\n\t\tif (bh_result->b_size >> 9 < n_secs)\n\t\t\tn_secs = bh_result->b_size >> 9;\n\t\tmap_bh(bh_result, inode->i_sb, s);\n\t\tbh_result->b_size = n_secs << 9;\n\t\tgoto ret_0;\n\t}\n\tif (!create) goto ret_0;\n\tif (iblock<<9 != hpfs_i(inode)->mmu_private) {\n\t\tBUG();\n\t\tr = -EIO;\n\t\tgoto ret_r;\n\t}\n\tif ((s = hpfs_add_sector_to_btree(inode->i_sb, inode->i_ino, 1, inode->i_blocks - 1)) == -1) {\n\t\thpfs_truncate_btree(inode->i_sb, inode->i_ino, 1, inode->i_blocks - 1);\n\t\tr = -ENOSPC;\n\t\tgoto ret_r;\n\t}\n\tinode->i_blocks++;\n\thpfs_i(inode)->mmu_private += 512;\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, inode->i_sb, s);\n\tret_0:\n\tr = 0;\n\tret_r:\n\thpfs_unlock(inode->i_sb);\n\treturn r;\n}"
  },
  {
    "function_name": "hpfs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "63-74",
    "snippet": "void hpfs_truncate(struct inode *i)\n{\n\tif (IS_IMMUTABLE(i)) return /*-EPERM*/;\n\thpfs_lock_assert(i->i_sb);\n\n\thpfs_i(i)->i_n_secs = 0;\n\ti->i_blocks = 1 + ((i->i_size + 511) >> 9);\n\thpfs_i(i)->mmu_private = i->i_size;\n\thpfs_truncate_btree(i->i_sb, i->i_ino, 1, ((i->i_size + 511) >> 9));\n\thpfs_write_inode(i);\n\thpfs_i(i)->i_n_secs = 0;\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "i"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_write_inode",
          "args": [
            "i"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_write_inode_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "207-256",
          "snippet": "void hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_truncate_btree",
          "args": [
            "i->i_sb",
            "i->i_ino",
            "1",
            "((i->i_size + 511) >> 9)"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_truncate_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "398-475",
          "snippet": "void hpfs_truncate_btree(struct super_block *s, secno f, int fno, unsigned secs)\n{\n\tstruct fnode *fnode;\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tstruct bplus_header *btree;\n\tanode_secno node = f;\n\tint i, j, nodes;\n\tint c1, c2 = 0;\n\tif (fno) {\n\t\tif (!(fnode = hpfs_map_fnode(s, f, &bh))) return;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, f, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\n\tif (!secs) {\n\t\thpfs_remove_btree(s, btree);\n\t\tif (fno) {\n\t\t\tbtree->n_free_nodes = 8;\n\t\t\tbtree->n_used_nodes = 0;\n\t\t\tbtree->first_free = cpu_to_le16(8);\n\t\t\tbtree->flags &= ~BP_internal;\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else hpfs_free_sectors(s, f, 1);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\twhile (bp_internal(btree)) {\n\t\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) >= secs) goto f;\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"internal btree %08x doesn't end with -1\", node);\n\t\treturn;\n\t\tf:\n\t\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\t\thpfs_ea_remove(s, le32_to_cpu(btree->u.internal[j].down), 1, 0);\n\t\tbtree->n_used_nodes = i + 1;\n\t\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\t\tbtree->first_free = cpu_to_le16(8 + 8 * btree->n_used_nodes);\n\t\tmark_buffer_dirty(bh);\n\t\tif (btree->u.internal[i].file_secno == cpu_to_le32(secs)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tnode = le32_to_cpu(btree->u.internal[i].down);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, node, &c1, &c2, \"hpfs_truncate_btree\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\t\n\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) >= secs) goto ff;\n\tbrelse(bh);\n\treturn;\n\tff:\n\tif (secs <= le32_to_cpu(btree->u.external[i].file_secno)) {\n\t\thpfs_error(s, \"there is an allocation error in file %08x, sector %08x\", f, secs);\n\t\tif (i) i--;\n\t}\n\telse if (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > secs) {\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[i].disk_secno) + secs -\n\t\t\tle32_to_cpu(btree->u.external[i].file_secno), le32_to_cpu(btree->u.external[i].length)\n\t\t\t- secs + le32_to_cpu(btree->u.external[i].file_secno)); /* I hope gcc optimizes this :-) */\n\t\tbtree->u.external[i].length = cpu_to_le32(secs - le32_to_cpu(btree->u.external[i].file_secno));\n\t}\n\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[j].disk_secno), le32_to_cpu(btree->u.external[j].length));\n\tbtree->n_used_nodes = i + 1;\n\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\tbtree->first_free = cpu_to_le16(8 + 12 * btree->n_used_nodes);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_truncate_btree(struct super_block *s, secno f, int fno, unsigned secs)\n{\n\tstruct fnode *fnode;\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tstruct bplus_header *btree;\n\tanode_secno node = f;\n\tint i, j, nodes;\n\tint c1, c2 = 0;\n\tif (fno) {\n\t\tif (!(fnode = hpfs_map_fnode(s, f, &bh))) return;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, f, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\n\tif (!secs) {\n\t\thpfs_remove_btree(s, btree);\n\t\tif (fno) {\n\t\t\tbtree->n_free_nodes = 8;\n\t\t\tbtree->n_used_nodes = 0;\n\t\t\tbtree->first_free = cpu_to_le16(8);\n\t\t\tbtree->flags &= ~BP_internal;\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else hpfs_free_sectors(s, f, 1);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\twhile (bp_internal(btree)) {\n\t\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) >= secs) goto f;\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"internal btree %08x doesn't end with -1\", node);\n\t\treturn;\n\t\tf:\n\t\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\t\thpfs_ea_remove(s, le32_to_cpu(btree->u.internal[j].down), 1, 0);\n\t\tbtree->n_used_nodes = i + 1;\n\t\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\t\tbtree->first_free = cpu_to_le16(8 + 8 * btree->n_used_nodes);\n\t\tmark_buffer_dirty(bh);\n\t\tif (btree->u.internal[i].file_secno == cpu_to_le32(secs)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tnode = le32_to_cpu(btree->u.internal[i].down);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, node, &c1, &c2, \"hpfs_truncate_btree\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\t\n\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) >= secs) goto ff;\n\tbrelse(bh);\n\treturn;\n\tff:\n\tif (secs <= le32_to_cpu(btree->u.external[i].file_secno)) {\n\t\thpfs_error(s, \"there is an allocation error in file %08x, sector %08x\", f, secs);\n\t\tif (i) i--;\n\t}\n\telse if (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > secs) {\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[i].disk_secno) + secs -\n\t\t\tle32_to_cpu(btree->u.external[i].file_secno), le32_to_cpu(btree->u.external[i].length)\n\t\t\t- secs + le32_to_cpu(btree->u.external[i].file_secno)); /* I hope gcc optimizes this :-) */\n\t\tbtree->u.external[i].length = cpu_to_le32(secs - le32_to_cpu(btree->u.external[i].file_secno));\n\t}\n\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[j].disk_secno), le32_to_cpu(btree->u.external[j].length));\n\tbtree->n_used_nodes = i + 1;\n\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\tbtree->first_free = cpu_to_le16(8 + 12 * btree->n_used_nodes);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock_assert",
          "args": [
            "i->i_sb"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "i"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nvoid hpfs_truncate(struct inode *i)\n{\n\tif (IS_IMMUTABLE(i)) return /*-EPERM*/;\n\thpfs_lock_assert(i->i_sb);\n\n\thpfs_i(i)->i_n_secs = 0;\n\ti->i_blocks = 1 + ((i->i_size + 511) >> 9);\n\thpfs_i(i)->mmu_private = i->i_size;\n\thpfs_truncate_btree(i->i_sb, i->i_ino, 1, ((i->i_size + 511) >> 9));\n\thpfs_write_inode(i);\n\thpfs_i(i)->i_n_secs = 0;\n}"
  },
  {
    "function_name": "hpfs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "38-61",
    "snippet": "static secno hpfs_bmap(struct inode *inode, unsigned file_secno, unsigned *n_secs)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tunsigned n, disk_secno;\n\tstruct fnode *fnode;\n\tstruct buffer_head *bh;\n\tif (BLOCKS(hpfs_i(inode)->mmu_private) <= file_secno) return 0;\n\tn = file_secno - hpfs_inode->i_file_sec;\n\tif (n < hpfs_inode->i_n_secs) {\n\t\t*n_secs = hpfs_inode->i_n_secs - n;\n\t\treturn hpfs_inode->i_disk_sec + n;\n\t}\n\tif (!(fnode = hpfs_map_fnode(inode->i_sb, inode->i_ino, &bh))) return 0;\n\tdisk_secno = hpfs_bplus_lookup(inode->i_sb, inode, &fnode->btree, file_secno, bh);\n\tif (disk_secno == -1) return 0;\n\tif (hpfs_chk_sectors(inode->i_sb, disk_secno, 1, \"bmap\")) return 0;\n\tn = file_secno - hpfs_inode->i_file_sec;\n\tif (n < hpfs_inode->i_n_secs) {\n\t\t*n_secs = hpfs_inode->i_n_secs - n;\n\t\treturn hpfs_inode->i_disk_sec + n;\n\t}\n\t*n_secs = 1;\n\treturn disk_secno;\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_chk_sectors",
          "args": [
            "inode->i_sb",
            "disk_secno",
            "1",
            "\"bmap\""
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "99-112",
          "snippet": "int hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_bplus_lookup",
          "args": [
            "inode->i_sb",
            "inode",
            "&fnode->btree",
            "file_secno",
            "bh"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_bplus_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "13-56",
          "snippet": "secno hpfs_bplus_lookup(struct super_block *s, struct inode *inode,\n\t\t   struct bplus_header *btree, unsigned sec,\n\t\t   struct buffer_head *bh)\n{\n\tanode_secno a = -1;\n\tstruct anode *anode;\n\tint i;\n\tint c1, c2 = 0;\n\tgo_down:\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_bplus_lookup\")) return -1;\n\tif (bp_internal(btree)) {\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) > sec) {\n\t\t\t\ta = le32_to_cpu(btree->u.internal[i].down);\n\t\t\t\tbrelse(bh);\n\t\t\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\t\t\tbtree = &anode->btree;\n\t\t\t\tgoto go_down;\n\t\t\t}\n\t\thpfs_error(s, \"sector %08x not found in internal anode %08x\", sec, a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) <= sec &&\n\t\t    le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > sec) {\n\t\t\ta = le32_to_cpu(btree->u.external[i].disk_secno) + sec - le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, a, 1, \"data\")) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (inode) {\n\t\t\t\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\t\t\t\thpfs_inode->i_file_sec = le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\t\thpfs_inode->i_disk_sec = le32_to_cpu(btree->u.external[i].disk_secno);\n\t\t\t\thpfs_inode->i_n_secs = le32_to_cpu(btree->u.external[i].length);\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\treturn a;\n\t\t}\n\thpfs_error(s, \"sector %08x not found in external anode %08x\", sec, a);\n\tbrelse(bh);\n\treturn -1;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nsecno hpfs_bplus_lookup(struct super_block *s, struct inode *inode,\n\t\t   struct bplus_header *btree, unsigned sec,\n\t\t   struct buffer_head *bh)\n{\n\tanode_secno a = -1;\n\tstruct anode *anode;\n\tint i;\n\tint c1, c2 = 0;\n\tgo_down:\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_bplus_lookup\")) return -1;\n\tif (bp_internal(btree)) {\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) > sec) {\n\t\t\t\ta = le32_to_cpu(btree->u.internal[i].down);\n\t\t\t\tbrelse(bh);\n\t\t\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\t\t\tbtree = &anode->btree;\n\t\t\t\tgoto go_down;\n\t\t\t}\n\t\thpfs_error(s, \"sector %08x not found in internal anode %08x\", sec, a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) <= sec &&\n\t\t    le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > sec) {\n\t\t\ta = le32_to_cpu(btree->u.external[i].disk_secno) + sec - le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, a, 1, \"data\")) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (inode) {\n\t\t\t\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\t\t\t\thpfs_inode->i_file_sec = le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\t\thpfs_inode->i_disk_sec = le32_to_cpu(btree->u.external[i].disk_secno);\n\t\t\t\thpfs_inode->i_n_secs = le32_to_cpu(btree->u.external[i].length);\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\treturn a;\n\t\t}\n\thpfs_error(s, \"sector %08x not found in external anode %08x\", sec, a);\n\tbrelse(bh);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "&bh"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLOCKS",
          "args": [
            "hpfs_i(inode)->mmu_private"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_HAS_BLOCKS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "814-820",
          "snippet": "static inline int F2FS_HAS_BLOCKS(struct inode *inode)\n{\n\tif (F2FS_I(inode)->i_xattr_nid)\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS + 1;\n\telse\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define F2FS_DEFAULT_ALLOCATED_BLOCKS\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\n#define F2FS_DEFAULT_ALLOCATED_BLOCKS\t1\n\nstatic inline int F2FS_HAS_BLOCKS(struct inode *inode)\n{\n\tif (F2FS_I(inode)->i_xattr_nid)\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS + 1;\n\telse\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "inode"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic secno hpfs_bmap(struct inode *inode, unsigned file_secno, unsigned *n_secs)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tunsigned n, disk_secno;\n\tstruct fnode *fnode;\n\tstruct buffer_head *bh;\n\tif (BLOCKS(hpfs_i(inode)->mmu_private) <= file_secno) return 0;\n\tn = file_secno - hpfs_inode->i_file_sec;\n\tif (n < hpfs_inode->i_n_secs) {\n\t\t*n_secs = hpfs_inode->i_n_secs - n;\n\t\treturn hpfs_inode->i_disk_sec + n;\n\t}\n\tif (!(fnode = hpfs_map_fnode(inode->i_sb, inode->i_ino, &bh))) return 0;\n\tdisk_secno = hpfs_bplus_lookup(inode->i_sb, inode, &fnode->btree, file_secno, bh);\n\tif (disk_secno == -1) return 0;\n\tif (hpfs_chk_sectors(inode->i_sb, disk_secno, 1, \"bmap\")) return 0;\n\tn = file_secno - hpfs_inode->i_file_sec;\n\tif (n < hpfs_inode->i_n_secs) {\n\t\t*n_secs = hpfs_inode->i_n_secs - n;\n\t\treturn hpfs_inode->i_disk_sec + n;\n\t}\n\t*n_secs = 1;\n\treturn disk_secno;\n}"
  },
  {
    "function_name": "hpfs_file_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "22-31",
    "snippet": "int hpfs_file_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\tret = filemap_write_and_wait_range(file->f_mapping, start, end);\n\tif (ret)\n\t\treturn ret;\n\treturn sync_blockdev(inode->i_sb->s_bdev);\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "inode->i_sb->s_bdev"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "file->f_mapping",
            "start",
            "end"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_file_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\tret = filemap_write_and_wait_range(file->f_mapping, start, end);\n\tif (ret)\n\t\treturn ret;\n\treturn sync_blockdev(inode->i_sb->s_bdev);\n}"
  },
  {
    "function_name": "hpfs_file_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
    "lines": "14-20",
    "snippet": "static int hpfs_file_release(struct inode *inode, struct file *file)\n{\n\thpfs_lock(inode->i_sb);\n\thpfs_write_if_changed(inode);\n\thpfs_unlock(inode->i_sb);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/mpage.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_write_if_changed",
          "args": [
            "inode"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_write_if_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "298-304",
          "snippet": "void hpfs_write_if_changed(struct inode *inode)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\n\tif (hpfs_inode->i_dirty)\n\t\thpfs_write_inode(inode);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_write_if_changed(struct inode *inode)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\n\tif (hpfs_inode->i_dirty)\n\t\thpfs_write_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nstatic int hpfs_file_release(struct inode *inode, struct file *file)\n{\n\thpfs_lock(inode->i_sb);\n\thpfs_write_if_changed(inode);\n\thpfs_unlock(inode->i_sb);\n\treturn 0;\n}"
  }
]