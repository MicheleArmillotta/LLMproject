[
  {
    "function_name": "jfs_extendfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/resize.c",
    "lines": "62-543",
    "snippet": "int jfs_extendfs(struct super_block *sb, s64 newLVSize, int newLogSize)\n{\n\tint rc = 0;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct inode *ipbmap2;\n\tstruct inode *ipimap = sbi->ipimap;\n\tstruct jfs_log *log = sbi->log;\n\tstruct bmap *bmp = sbi->bmap;\n\ts64 newLogAddress, newFSCKAddress;\n\tint newFSCKSize;\n\ts64 newMapSize = 0, mapSize;\n\ts64 XAddress, XSize, nblocks, xoff, xaddr, t64;\n\ts64 oldLVSize;\n\ts64 newFSSize;\n\ts64 VolumeSize;\n\tint newNpages = 0, nPages, newPage, xlen, t32;\n\tint tid;\n\tint log_formatted = 0;\n\tstruct inode *iplist[1];\n\tstruct jfs_superblock *j_sb, *j_sb2;\n\ts64 old_agsize;\n\tint agsizechanged = 0;\n\tstruct buffer_head *bh, *bh2;\n\n\t/* If the volume hasn't grown, get out now */\n\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\toldLVSize = addressPXD(&sbi->logpxd) + lengthPXD(&sbi->logpxd);\n\telse\n\t\toldLVSize = addressPXD(&sbi->fsckpxd) +\n\t\t    lengthPXD(&sbi->fsckpxd);\n\n\tif (oldLVSize >= newLVSize) {\n\t\tprintk(KERN_WARNING\n\t\t       \"jfs_extendfs: volume hasn't grown, returning\\n\");\n\t\tgoto out;\n\t}\n\n\tVolumeSize = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\n\tif (VolumeSize) {\n\t\tif (newLVSize > VolumeSize) {\n\t\t\tprintk(KERN_WARNING \"jfs_extendfs: invalid size\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* check the device */\n\t\tbh = sb_bread(sb, newLVSize - 1);\n\t\tif (!bh) {\n\t\t\tprintk(KERN_WARNING \"jfs_extendfs: invalid size\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbforget(bh);\n\t}\n\n\t/* Can't extend write-protected drive */\n\n\tif (isReadOnly(ipbmap)) {\n\t\tprintk(KERN_WARNING \"jfs_extendfs: read-only file system\\n\");\n\t\trc = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\treconfigure LV spaces\n\t *\t---------------------\n\t *\n\t * validate new size, or, if not specified, determine new size\n\t */\n\n\t/*\n\t * reconfigure inline log space:\n\t */\n\tif ((sbi->mntflag & JFS_INLINELOG)) {\n\t\tif (newLogSize == 0) {\n\t\t\t/*\n\t\t\t * no size specified: default to 1/256 of aggregate\n\t\t\t * size; rounded up to a megabyte boundary;\n\t\t\t */\n\t\t\tnewLogSize = newLVSize >> 8;\n\t\t\tt32 = (1 << (20 - sbi->l2bsize)) - 1;\n\t\t\tnewLogSize = (newLogSize + t32) & ~t32;\n\t\t\tnewLogSize =\n\t\t\t    min(newLogSize, MEGABYTE32 >> sbi->l2bsize);\n\t\t} else {\n\t\t\t/*\n\t\t\t * convert the newLogSize to fs blocks.\n\t\t\t *\n\t\t\t * Since this is given in megabytes, it will always be\n\t\t\t * an even number of pages.\n\t\t\t */\n\t\t\tnewLogSize = (newLogSize * MEGABYTE) >> sbi->l2bsize;\n\t\t}\n\n\t} else\n\t\tnewLogSize = 0;\n\n\tnewLogAddress = newLVSize - newLogSize;\n\n\t/*\n\t * reconfigure fsck work space:\n\t *\n\t * configure it to the end of the logical volume regardless of\n\t * whether file system extends to the end of the aggregate;\n\t * Need enough 4k pages to cover:\n\t *  - 1 bit per block in aggregate rounded up to BPERDMAP boundary\n\t *  - 1 extra page to handle control page and intermediate level pages\n\t *  - 50 extra pages for the chkdsk service log\n\t */\n\tt64 = ((newLVSize - newLogSize + BPERDMAP - 1) >> L2BPERDMAP)\n\t    << L2BPERDMAP;\n\tt32 = DIV_ROUND_UP(t64, BITSPERPAGE) + 1 + 50;\n\tnewFSCKSize = t32 << sbi->l2nbperpage;\n\tnewFSCKAddress = newLogAddress - newFSCKSize;\n\n\t/*\n\t * compute new file system space;\n\t */\n\tnewFSSize = newLVSize - newLogSize - newFSCKSize;\n\n\t/* file system cannot be shrunk */\n\tif (newFSSize < bmp->db_mapsize) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we're expanding enough that the inline log does not overlap\n\t * the old one, we can format the new log before we quiesce the\n\t * filesystem.\n\t */\n\tif ((sbi->mntflag & JFS_INLINELOG) && (newLogAddress > oldLVSize)) {\n\t\tif ((rc = lmLogFormat(log, newLogAddress, newLogSize)))\n\t\t\tgoto out;\n\t\tlog_formatted = 1;\n\t}\n\t/*\n\t *\tquiesce file system\n\t *\n\t * (prepare to move the inline log and to prevent map update)\n\t *\n\t * block any new transactions and wait for completion of\n\t * all wip transactions and flush modified pages s.t.\n\t * on-disk file system is in consistent state and\n\t * log is not required for recovery.\n\t */\n\ttxQuiesce(sb);\n\n\t/* Reset size of direct inode */\n\tsbi->direct_inode->i_size =  sb->s_bdev->bd_inode->i_size;\n\n\tif (sbi->mntflag & JFS_INLINELOG) {\n\t\t/*\n\t\t * deactivate old inline log\n\t\t */\n\t\tlmLogShutdown(log);\n\n\t\t/*\n\t\t * mark on-disk super block for fs in transition;\n\t\t *\n\t\t * update on-disk superblock for the new space configuration\n\t\t * of inline log space and fsck work space descriptors:\n\t\t * N.B. FS descriptor is NOT updated;\n\t\t *\n\t\t * crash recovery:\n\t\t * logredo(): if FM_EXTENDFS, return to fsck() for cleanup;\n\t\t * fsck(): if FM_EXTENDFS, reformat inline log and fsck\n\t\t * workspace from superblock inline log descriptor and fsck\n\t\t * workspace descriptor;\n\t\t */\n\n\t\t/* read in superblock */\n\t\tif ((rc = readSuper(sb, &bh)))\n\t\t\tgoto error_out;\n\t\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t\t/* mark extendfs() in progress */\n\t\tj_sb->s_state |= cpu_to_le32(FM_EXTENDFS);\n\t\tj_sb->s_xsize = cpu_to_le64(newFSSize);\n\t\tPXDaddress(&j_sb->s_xfsckpxd, newFSCKAddress);\n\t\tPXDlength(&j_sb->s_xfsckpxd, newFSCKSize);\n\t\tPXDaddress(&j_sb->s_xlogpxd, newLogAddress);\n\t\tPXDlength(&j_sb->s_xlogpxd, newLogSize);\n\n\t\t/* synchronously update superblock */\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\n\t\t/*\n\t\t * format new inline log synchronously;\n\t\t *\n\t\t * crash recovery: if log move in progress,\n\t\t * reformat log and exit success;\n\t\t */\n\t\tif (!log_formatted)\n\t\t\tif ((rc = lmLogFormat(log, newLogAddress, newLogSize)))\n\t\t\t\tgoto error_out;\n\n\t\t/*\n\t\t * activate new log\n\t\t */\n\t\tlog->base = newLogAddress;\n\t\tlog->size = newLogSize >> (L2LOGPSIZE - sb->s_blocksize_bits);\n\t\tif ((rc = lmLogInit(log)))\n\t\t\tgoto error_out;\n\t}\n\n\t/*\n\t *\textend block allocation map\n\t *\t---------------------------\n\t *\n\t * extendfs() for new extension, retry after crash recovery;\n\t *\n\t * note: both logredo() and fsck() rebuild map from\n\t * the bitmap and configuration parameter from superblock\n\t * (disregarding all other control information in the map);\n\t *\n\t * superblock:\n\t *  s_size: aggregate size in physical blocks;\n\t */\n\t/*\n\t *\tcompute the new block allocation map configuration\n\t *\n\t * map dinode:\n\t *  di_size: map file size in byte;\n\t *  di_nblocks: number of blocks allocated for map file;\n\t *  di_mapsize: number of blocks in aggregate (covered by map);\n\t * map control page:\n\t *  db_mapsize: number of blocks in aggregate (covered by map);\n\t */\n\tnewMapSize = newFSSize;\n\t/* number of data pages of new bmap file:\n\t * roundup new size to full dmap page boundary and\n\t * add 1 extra dmap page for next extendfs()\n\t */\n\tt64 = (newMapSize - 1) + BPERDMAP;\n\tnewNpages = BLKTODMAPN(t64) + 1;\n\n\t/*\n\t *\textend map from current map (WITHOUT growing mapfile)\n\t *\n\t * map new extension with unmapped part of the last partial\n\t * dmap page, if applicable, and extra page(s) allocated\n\t * at end of bmap by mkfs() or previous extendfs();\n\t */\n      extendBmap:\n\t/* compute number of blocks requested to extend */\n\tmapSize = bmp->db_mapsize;\n\tXAddress = mapSize;\t/* eXtension Address */\n\tXSize = newMapSize - mapSize;\t/* eXtension Size */\n\told_agsize = bmp->db_agsize;\t/* We need to know if this changes */\n\n\t/* compute number of blocks that can be extended by current mapfile */\n\tt64 = dbMapFileSizeToMapSize(ipbmap);\n\tif (mapSize > t64) {\n\t\tprintk(KERN_ERR \"jfs_extendfs: mapSize (0x%Lx) > t64 (0x%Lx)\\n\",\n\t\t       (long long) mapSize, (long long) t64);\n\t\trc = -EIO;\n\t\tgoto error_out;\n\t}\n\tnblocks = min(t64 - mapSize, XSize);\n\n\t/*\n\t * update map pages for new extension:\n\t *\n\t * update/init dmap and bubble up the control hierarchy\n\t * incrementally fold up dmaps into upper levels;\n\t * update bmap control page;\n\t */\n\tif ((rc = dbExtendFS(ipbmap, XAddress, nblocks)))\n\t\tgoto error_out;\n\n\tagsizechanged |= (bmp->db_agsize != old_agsize);\n\n\t/*\n\t * the map now has extended to cover additional nblocks:\n\t * dn_mapsize = oldMapsize + nblocks;\n\t */\n\t/* ipbmap->i_mapsize += nblocks; */\n\tXSize -= nblocks;\n\n\t/*\n\t *\tgrow map file to cover remaining extension\n\t *\tand/or one extra dmap page for next extendfs();\n\t *\n\t * allocate new map pages and its backing blocks, and\n\t * update map file xtree\n\t */\n\t/* compute number of data pages of current bmap file */\n\tnPages = ipbmap->i_size >> L2PSIZE;\n\n\t/* need to grow map file ? */\n\tif (nPages == newNpages)\n\t\tgoto finalizeBmap;\n\n\t/*\n\t * grow bmap file for the new map pages required:\n\t *\n\t * allocate growth at the start of newly extended region;\n\t * bmap file only grows sequentially, i.e., both data pages\n\t * and possibly xtree index pages may grow in append mode,\n\t * s.t. logredo() can reconstruct pre-extension state\n\t * by washing away bmap file of pages outside s_size boundary;\n\t */\n\t/*\n\t * journal map file growth as if a regular file growth:\n\t * (note: bmap is created with di_mode = IFJOURNAL|IFREG);\n\t *\n\t * journaling of bmap file growth is not required since\n\t * logredo() do/can not use log records of bmap file growth\n\t * but it provides careful write semantics, pmap update, etc.;\n\t */\n\t/* synchronous write of data pages: bmap data pages are\n\t * cached in meta-data cache, and not written out\n\t * by txCommit();\n\t */\n\tfilemap_fdatawait(ipbmap->i_mapping);\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\tdiWriteSpecial(ipbmap, 0);\n\n\tnewPage = nPages;\t/* first new page number */\n\txoff = newPage << sbi->l2nbperpage;\n\txlen = (newNpages - nPages) << sbi->l2nbperpage;\n\txlen = min(xlen, (int) nblocks) & ~(sbi->nbperpage - 1);\n\txaddr = XAddress;\n\n\ttid = txBegin(sb, COMMIT_FORCE);\n\n\tif ((rc = xtAppend(tid, ipbmap, 0, xoff, nblocks, &xlen, &xaddr, 0))) {\n\t\ttxEnd(tid);\n\t\tgoto error_out;\n\t}\n\t/* update bmap file size */\n\tipbmap->i_size += xlen << sbi->l2bsize;\n\tinode_add_bytes(ipbmap, xlen << sbi->l2bsize);\n\n\tiplist[0] = ipbmap;\n\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\ttxEnd(tid);\n\n\tif (rc)\n\t\tgoto error_out;\n\n\t/*\n\t * map file has been grown now to cover extension to further out;\n\t * di_size = new map file size;\n\t *\n\t * if huge extension, the previous extension based on previous\n\t * map file size may not have been sufficient to cover whole extension\n\t * (it could have been used up for new map pages),\n\t * but the newly grown map file now covers lot bigger new free space\n\t * available for further extension of map;\n\t */\n\t/* any more blocks to extend ? */\n\tif (XSize)\n\t\tgoto extendBmap;\n\n      finalizeBmap:\n\t/* finalize bmap */\n\tdbFinalizeBmap(ipbmap);\n\n\t/*\n\t *\tupdate inode allocation map\n\t *\t---------------------------\n\t *\n\t * move iag lists from old to new iag;\n\t * agstart field is not updated for logredo() to reconstruct\n\t * iag lists if system crash occurs.\n\t * (computation of ag number from agstart based on agsize\n\t * will correctly identify the new ag);\n\t */\n\t/* if new AG size the same as old AG size, done! */\n\tif (agsizechanged) {\n\t\tif ((rc = diExtendFS(ipimap, ipbmap)))\n\t\t\tgoto error_out;\n\n\t\t/* finalize imap */\n\t\tif ((rc = diSync(ipimap)))\n\t\t\tgoto error_out;\n\t}\n\n\t/*\n\t *\tfinalize\n\t *\t--------\n\t *\n\t * extension is committed when on-disk super block is\n\t * updated with new descriptors: logredo will recover\n\t * crash before it to pre-extension state;\n\t */\n\n\t/* sync log to skip log replay of bmap file growth transaction; */\n\t/* lmLogSync(log, 1); */\n\n\t/*\n\t * synchronous write bmap global control page;\n\t * for crash before completion of write\n\t * logredo() will recover to pre-extendfs state;\n\t * for crash after completion of write,\n\t * logredo() will recover post-extendfs state;\n\t */\n\tif ((rc = dbSync(ipbmap)))\n\t\tgoto error_out;\n\n\t/*\n\t * copy primary bmap inode to secondary bmap inode\n\t */\n\n\tipbmap2 = diReadSpecial(sb, BMAP_I, 1);\n\tif (ipbmap2 == NULL) {\n\t\tprintk(KERN_ERR \"jfs_extendfs: diReadSpecial(bmap) failed\\n\");\n\t\tgoto error_out;\n\t}\n\tmemcpy(&JFS_IP(ipbmap2)->i_xtroot, &JFS_IP(ipbmap)->i_xtroot, 288);\n\tipbmap2->i_size = ipbmap->i_size;\n\tipbmap2->i_blocks = ipbmap->i_blocks;\n\n\tdiWriteSpecial(ipbmap2, 1);\n\tdiFreeSpecial(ipbmap2);\n\n\t/*\n\t *\tupdate superblock\n\t */\n\tif ((rc = readSuper(sb, &bh)))\n\t\tgoto error_out;\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t/* mark extendfs() completion */\n\tj_sb->s_state &= cpu_to_le32(~FM_EXTENDFS);\n\tj_sb->s_size = cpu_to_le64(bmp->db_mapsize <<\n\t\t\t\t   le16_to_cpu(j_sb->s_l2bfactor));\n\tj_sb->s_agsize = cpu_to_le32(bmp->db_agsize);\n\n\t/* update inline log space descriptor */\n\tif (sbi->mntflag & JFS_INLINELOG) {\n\t\tPXDaddress(&(j_sb->s_logpxd), newLogAddress);\n\t\tPXDlength(&(j_sb->s_logpxd), newLogSize);\n\t}\n\n\t/* record log's mount serial number */\n\tj_sb->s_logserial = cpu_to_le32(log->serial);\n\n\t/* update fsck work space descriptor */\n\tPXDaddress(&(j_sb->s_fsckpxd), newFSCKAddress);\n\tPXDlength(&(j_sb->s_fsckpxd), newFSCKSize);\n\tj_sb->s_fscklog = 1;\n\t/* sb->s_fsckloglen remains the same */\n\n\t/* Update secondary superblock */\n\tbh2 = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (bh2) {\n\t\tj_sb2 = (struct jfs_superblock *)bh2->b_data;\n\t\tmemcpy(j_sb2, j_sb, sizeof (struct jfs_superblock));\n\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh2);\n\t\tbrelse(bh2);\n\t}\n\n\t/* write primary superblock */\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\tgoto resume;\n\n      error_out:\n\tjfs_error(sb, \"\\n\");\n\n      resume:\n\t/*\n\t *\tresume file system transactions\n\t */\n\ttxResume(sb);\n\n      out:\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MEGABYTE32\t(MEGABYTE << 5)",
      "#define MEGABYTE\t(1 << L2MEGABYTE)",
      "#define BITSPERPAGE\t(PSIZE << 3)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "txResume",
          "args": [
            "sb"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "txResume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2916-2922",
          "snippet": "void txResume(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\n\tclear_bit(log_QUIESCE, &log->flag);\n\tTXN_WAKEUP(&log->syncwait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nvoid txResume(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\n\tclear_bit(log_QUIESCE, &log->flag);\n\tTXN_WAKEUP(&log->syncwait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "sb",
            "\"\\n\""
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "j_sb2",
            "j_sb",
            "sizeof (struct jfs_superblock)"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "SUPER2_OFF >> sb->s_blocksize_bits"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "&(j_sb->s_fsckpxd)",
            "newFSCKSize"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "&(j_sb->s_fsckpxd)",
            "newFSCKAddress"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "log->serial"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bmp->db_agsize"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bmp->db_mapsize <<\n\t\t\t\t   le16_to_cpu(j_sb->s_l2bfactor)"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "j_sb->s_l2bfactor"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~FM_EXTENDFS"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readSuper",
          "args": [
            "sb",
            "&bh"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "readSuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "464-477",
          "snippet": "int readSuper(struct super_block *sb, struct buffer_head **bpp)\n{\n\t/* read in primary superblock */\n\t*bpp = sb_bread(sb, SUPER1_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\t/* read in secondary/replicated superblock */\n\t*bpp = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\treturn -EIO;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint readSuper(struct super_block *sb, struct buffer_head **bpp)\n{\n\t/* read in primary superblock */\n\t*bpp = sb_bread(sb, SUPER1_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\t/* read in secondary/replicated superblock */\n\t*bpp = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diFreeSpecial",
          "args": [
            "ipbmap2"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "diFreeSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "562-571",
          "snippet": "void diFreeSpecial(struct inode *ip)\n{\n\tif (ip == NULL) {\n\t\tjfs_err(\"diFreeSpecial called with NULL ip!\");\n\t\treturn;\n\t}\n\tfilemap_write_and_wait(ip->i_mapping);\n\ttruncate_inode_pages(ip->i_mapping, 0);\n\tiput(ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nvoid diFreeSpecial(struct inode *ip)\n{\n\tif (ip == NULL) {\n\t\tjfs_err(\"diFreeSpecial called with NULL ip!\");\n\t\treturn;\n\t}\n\tfilemap_write_and_wait(ip->i_mapping);\n\ttruncate_inode_pages(ip->i_mapping, 0);\n\tiput(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diWriteSpecial",
          "args": [
            "ipbmap2",
            "1"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "diWriteSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "517-555",
          "snippet": "void diWriteSpecial(struct inode *ip, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tuint address;\n\tstruct dinode *dp;\n\tino_t inum = ip->i_ino;\n\tstruct metapage *mp;\n\n\tif (secondary)\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\telse\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\n\tASSERT(inum < INOSPEREXT);\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diWriteSpecial: failed to read aggregate inode \"\n\t\t\t\"extent!\");\n\t\treturn;\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tcopy_to_dinode(dp, ip);\n\tmemcpy(&dp->di_xtroot, &JFS_IP(ip)->i_xtroot, 288);\n\n\tif (inum == FILESYSTEM_I)\n\t\tdp->di_gengen = cpu_to_le32(sbi->gengen);\n\n\t/* write the page */\n\twrite_metapage(mp);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nvoid diWriteSpecial(struct inode *ip, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tuint address;\n\tstruct dinode *dp;\n\tino_t inum = ip->i_ino;\n\tstruct metapage *mp;\n\n\tif (secondary)\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\telse\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\n\tASSERT(inum < INOSPEREXT);\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diWriteSpecial: failed to read aggregate inode \"\n\t\t\t\"extent!\");\n\t\treturn;\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tcopy_to_dinode(dp, ip);\n\tmemcpy(&dp->di_xtroot, &JFS_IP(ip)->i_xtroot, 288);\n\n\tif (inum == FILESYSTEM_I)\n\t\tdp->di_gengen = cpu_to_le32(sbi->gengen);\n\n\t/* write the page */\n\twrite_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&JFS_IP(ipbmap2)->i_xtroot",
            "&JFS_IP(ipbmap)->i_xtroot",
            "288"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ipbmap"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"jfs_extendfs: diReadSpecial(bmap) failed\\n\""
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diReadSpecial",
          "args": [
            "sb",
            "BMAP_I",
            "1"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "diReadSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "429-503",
          "snippet": "struct inode *diReadSpecial(struct super_block *sb, ino_t inum, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tuint address;\n\tstruct dinode *dp;\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\n\tip = new_inode(sb);\n\tif (ip == NULL) {\n\t\tjfs_err(\"diReadSpecial: new_inode returned NULL!\");\n\t\treturn ip;\n\t}\n\n\tif (secondary) {\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap2;\n\t} else {\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap;\n\t}\n\n\tASSERT(inum < INOSPEREXT);\n\n\tip->i_ino = inum;\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\treturn (NULL);\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tif ((copy_from_dinode(dp, ip)) != 0) {\n\t\t/* handle bad return by returning NULL for ip */\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\t/* release the page */\n\t\trelease_metapage(mp);\n\t\treturn (NULL);\n\n\t}\n\n\tip->i_mapping->a_ops = &jfs_metapage_aops;\n\tmapping_set_gfp_mask(ip->i_mapping, GFP_NOFS);\n\n\t/* Allocations to metadata inodes should not affect quotas */\n\tip->i_flags |= S_NOQUOTA;\n\n\tif ((inum == FILESYSTEM_I) && (JFS_IP(ip)->ipimap == sbi->ipaimap)) {\n\t\tsbi->gengen = le32_to_cpu(dp->di_gengen);\n\t\tsbi->inostamp = le32_to_cpu(dp->di_inostamp);\n\t}\n\n\t/* release the page */\n\trelease_metapage(mp);\n\n\t/*\n\t * __mark_inode_dirty expects inodes to be hashed.  Since we don't\n\t * want special inodes in the fileset inode space, we make them\n\t * appear hashed, but do not put on any lists.  hlist_del()\n\t * will work fine and require no locking.\n\t */\n\thlist_add_fake(&ip->i_hash);\n\n\treturn (ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstruct inode *diReadSpecial(struct super_block *sb, ino_t inum, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tuint address;\n\tstruct dinode *dp;\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\n\tip = new_inode(sb);\n\tif (ip == NULL) {\n\t\tjfs_err(\"diReadSpecial: new_inode returned NULL!\");\n\t\treturn ip;\n\t}\n\n\tif (secondary) {\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap2;\n\t} else {\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap;\n\t}\n\n\tASSERT(inum < INOSPEREXT);\n\n\tip->i_ino = inum;\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\treturn (NULL);\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tif ((copy_from_dinode(dp, ip)) != 0) {\n\t\t/* handle bad return by returning NULL for ip */\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\t/* release the page */\n\t\trelease_metapage(mp);\n\t\treturn (NULL);\n\n\t}\n\n\tip->i_mapping->a_ops = &jfs_metapage_aops;\n\tmapping_set_gfp_mask(ip->i_mapping, GFP_NOFS);\n\n\t/* Allocations to metadata inodes should not affect quotas */\n\tip->i_flags |= S_NOQUOTA;\n\n\tif ((inum == FILESYSTEM_I) && (JFS_IP(ip)->ipimap == sbi->ipaimap)) {\n\t\tsbi->gengen = le32_to_cpu(dp->di_gengen);\n\t\tsbi->inostamp = le32_to_cpu(dp->di_inostamp);\n\t}\n\n\t/* release the page */\n\trelease_metapage(mp);\n\n\t/*\n\t * __mark_inode_dirty expects inodes to be hashed.  Since we don't\n\t * want special inodes in the fileset inode space, we make them\n\t * appear hashed, but do not put on any lists.  hlist_del()\n\t * will work fine and require no locking.\n\t */\n\thlist_add_fake(&ip->i_hash);\n\n\treturn (ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbSync",
          "args": [
            "ipbmap"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "dbSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "263-311",
          "snippet": "int dbSync(struct inode *ipbmap)\n{\n\tstruct dbmap_disk *dbmp_le;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * write bmap global control page\n\t */\n\t/* get the buffer for the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"dbSync: read_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\t/* copy the in-memory version of the bmap to the on-disk version */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tdbmp_le->dn_mapsize = cpu_to_le64(bmp->db_mapsize);\n\tdbmp_le->dn_nfree = cpu_to_le64(bmp->db_nfree);\n\tdbmp_le->dn_l2nbperpage = cpu_to_le32(bmp->db_l2nbperpage);\n\tdbmp_le->dn_numag = cpu_to_le32(bmp->db_numag);\n\tdbmp_le->dn_maxlevel = cpu_to_le32(bmp->db_maxlevel);\n\tdbmp_le->dn_maxag = cpu_to_le32(bmp->db_maxag);\n\tdbmp_le->dn_agpref = cpu_to_le32(bmp->db_agpref);\n\tdbmp_le->dn_aglevel = cpu_to_le32(bmp->db_aglevel);\n\tdbmp_le->dn_agheight = cpu_to_le32(bmp->db_agheight);\n\tdbmp_le->dn_agwidth = cpu_to_le32(bmp->db_agwidth);\n\tdbmp_le->dn_agstart = cpu_to_le32(bmp->db_agstart);\n\tdbmp_le->dn_agl2size = cpu_to_le32(bmp->db_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tdbmp_le->dn_agfree[i] = cpu_to_le64(bmp->db_agfree[i]);\n\tdbmp_le->dn_agsize = cpu_to_le64(bmp->db_agsize);\n\tdbmp_le->dn_maxfreebud = bmp->db_maxfreebud;\n\n\t/* write the buffer */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of bmap\n\t */\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\n\tdiWriteSpecial(ipbmap, 0);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nint dbSync(struct inode *ipbmap)\n{\n\tstruct dbmap_disk *dbmp_le;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * write bmap global control page\n\t */\n\t/* get the buffer for the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"dbSync: read_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\t/* copy the in-memory version of the bmap to the on-disk version */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tdbmp_le->dn_mapsize = cpu_to_le64(bmp->db_mapsize);\n\tdbmp_le->dn_nfree = cpu_to_le64(bmp->db_nfree);\n\tdbmp_le->dn_l2nbperpage = cpu_to_le32(bmp->db_l2nbperpage);\n\tdbmp_le->dn_numag = cpu_to_le32(bmp->db_numag);\n\tdbmp_le->dn_maxlevel = cpu_to_le32(bmp->db_maxlevel);\n\tdbmp_le->dn_maxag = cpu_to_le32(bmp->db_maxag);\n\tdbmp_le->dn_agpref = cpu_to_le32(bmp->db_agpref);\n\tdbmp_le->dn_aglevel = cpu_to_le32(bmp->db_aglevel);\n\tdbmp_le->dn_agheight = cpu_to_le32(bmp->db_agheight);\n\tdbmp_le->dn_agwidth = cpu_to_le32(bmp->db_agwidth);\n\tdbmp_le->dn_agstart = cpu_to_le32(bmp->db_agstart);\n\tdbmp_le->dn_agl2size = cpu_to_le32(bmp->db_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tdbmp_le->dn_agfree[i] = cpu_to_le64(bmp->db_agfree[i]);\n\tdbmp_le->dn_agsize = cpu_to_le64(bmp->db_agsize);\n\tdbmp_le->dn_maxfreebud = bmp->db_maxfreebud;\n\n\t/* write the buffer */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of bmap\n\t */\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\n\tdiWriteSpecial(ipbmap, 0);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diSync",
          "args": [
            "ipimap"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "diSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "219-268",
          "snippet": "int diSync(struct inode *ipimap)\n{\n\tstruct dinomap_disk *dinom_le;\n\tstruct inomap *imp = JFS_IP(ipimap)->i_imap;\n\tstruct metapage *mp;\n\tint index;\n\n\t/*\n\t * write imap global conrol page\n\t */\n\t/* read the on-disk inode map control structure */\n\tmp = get_metapage(ipimap,\n\t\t\t  IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t  PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diSync: get_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\n\t/* copy the in-memory version to the on-disk version */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\tdinom_le->in_freeiag = cpu_to_le32(imp->im_freeiag);\n\tdinom_le->in_nextiag = cpu_to_le32(imp->im_nextiag);\n\tdinom_le->in_numinos = cpu_to_le32(atomic_read(&imp->im_numinos));\n\tdinom_le->in_numfree = cpu_to_le32(atomic_read(&imp->im_numfree));\n\tdinom_le->in_nbperiext = cpu_to_le32(imp->im_nbperiext);\n\tdinom_le->in_l2nbperiext = cpu_to_le32(imp->im_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tdinom_le->in_agctl[index].inofree =\n\t\t    cpu_to_le32(imp->im_agctl[index].inofree);\n\t\tdinom_le->in_agctl[index].extfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].extfree);\n\t\tdinom_le->in_agctl[index].numinos =\n\t\t    cpu_to_le32(imp->im_agctl[index].numinos);\n\t\tdinom_le->in_agctl[index].numfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].numfree);\n\t}\n\n\t/* write out the control structure */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of imap\n\t */\n\tfilemap_write_and_wait(ipimap->i_mapping);\n\n\tdiWriteSpecial(ipimap, 0);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diSync(struct inode *ipimap)\n{\n\tstruct dinomap_disk *dinom_le;\n\tstruct inomap *imp = JFS_IP(ipimap)->i_imap;\n\tstruct metapage *mp;\n\tint index;\n\n\t/*\n\t * write imap global conrol page\n\t */\n\t/* read the on-disk inode map control structure */\n\tmp = get_metapage(ipimap,\n\t\t\t  IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t  PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diSync: get_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\n\t/* copy the in-memory version to the on-disk version */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\tdinom_le->in_freeiag = cpu_to_le32(imp->im_freeiag);\n\tdinom_le->in_nextiag = cpu_to_le32(imp->im_nextiag);\n\tdinom_le->in_numinos = cpu_to_le32(atomic_read(&imp->im_numinos));\n\tdinom_le->in_numfree = cpu_to_le32(atomic_read(&imp->im_numfree));\n\tdinom_le->in_nbperiext = cpu_to_le32(imp->im_nbperiext);\n\tdinom_le->in_l2nbperiext = cpu_to_le32(imp->im_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tdinom_le->in_agctl[index].inofree =\n\t\t    cpu_to_le32(imp->im_agctl[index].inofree);\n\t\tdinom_le->in_agctl[index].extfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].extfree);\n\t\tdinom_le->in_agctl[index].numinos =\n\t\t    cpu_to_le32(imp->im_agctl[index].numinos);\n\t\tdinom_le->in_agctl[index].numfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].numfree);\n\t}\n\n\t/* write out the control structure */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of imap\n\t */\n\tfilemap_write_and_wait(ipimap->i_mapping);\n\n\tdiWriteSpecial(ipimap, 0);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diExtendFS",
          "args": [
            "ipimap",
            "ipbmap"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "diExtendFS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2859-2984",
          "snippet": "int diExtendFS(struct inode *ipimap, struct inode *ipbmap)\n{\n\tint rc, rcx = 0;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\tstruct iag *iagp = NULL, *hiagp = NULL;\n\tstruct bmap *mp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *bp, *hbp;\n\tint i, n, head;\n\tint numinos, xnuminos = 0, xnumfree = 0;\n\ts64 agstart;\n\n\tjfs_info(\"diExtendFS: nextiag:%d numinos:%d numfree:%d\",\n\t\t   imap->im_nextiag, atomic_read(&imap->im_numinos),\n\t\t   atomic_read(&imap->im_numfree));\n\n\t/*\n\t *\treconstruct imap\n\t *\n\t * coalesce contiguous k (newAGSize/oldAGSize) AGs;\n\t * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;\n\t * note: new AG size = old AG size * (2**x).\n\t */\n\n\t/* init per AG control information im_agctl[] */\n\tfor (i = 0; i < MAXAG; i++) {\n\t\timap->im_agctl[i].inofree = -1;\n\t\timap->im_agctl[i].extfree = -1;\n\t\timap->im_agctl[i].numinos = 0;\t/* number of backed inodes */\n\t\timap->im_agctl[i].numfree = 0;\t/* number of free backed inodes */\n\t}\n\n\t/*\n\t *\tprocess each iag page of the map.\n\t *\n\t * rebuild AG Free Inode List, AG Free Inode Extent List;\n\t */\n\tfor (i = 0; i < imap->im_nextiag; i++) {\n\t\tif ((rc = diIAGRead(imap, i, &bp))) {\n\t\t\trcx = rc;\n\t\t\tcontinue;\n\t\t}\n\t\tiagp = (struct iag *) bp->data;\n\t\tif (le32_to_cpu(iagp->iagnum) != i) {\n\t\t\trelease_metapage(bp);\n\t\t\tjfs_error(ipimap->i_sb, \"unexpected value of iagnum\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* leave free iag in the free iag list */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\trelease_metapage(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tagstart = le64_to_cpu(iagp->agstart);\n\t\tn = agstart >> mp->db_agl2size;\n\t\tiagp->agstart = cpu_to_le64((s64)n << mp->db_agl2size);\n\n\t\t/* compute backed inodes */\n\t\tnuminos = (EXTSPERIAG - le32_to_cpu(iagp->nfreeexts))\n\t\t    << L2INOSPEREXT;\n\t\tif (numinos > 0) {\n\t\t\t/* merge AG backed inodes */\n\t\t\timap->im_agctl[n].numinos += numinos;\n\t\t\txnuminos += numinos;\n\t\t}\n\n\t\t/* if any backed free inodes, insert at AG free inode list */\n\t\tif ((int) le32_to_cpu(iagp->nfreeinos) > 0) {\n\t\t\tif ((head = imap->im_agctl[n].inofree) == -1) {\n\t\t\t\tiagp->inofreefwd = cpu_to_le32(-1);\n\t\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, head, &hbp))) {\n\t\t\t\t\trcx = rc;\n\t\t\t\t\tgoto nextiag;\n\t\t\t\t}\n\t\t\t\thiagp = (struct iag *) hbp->data;\n\t\t\t\thiagp->inofreeback = iagp->iagnum;\n\t\t\t\tiagp->inofreefwd = cpu_to_le32(head);\n\t\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\t\twrite_metapage(hbp);\n\t\t\t}\n\n\t\t\timap->im_agctl[n].inofree =\n\t\t\t    le32_to_cpu(iagp->iagnum);\n\n\t\t\t/* merge AG backed free inodes */\n\t\t\timap->im_agctl[n].numfree +=\n\t\t\t    le32_to_cpu(iagp->nfreeinos);\n\t\t\txnumfree += le32_to_cpu(iagp->nfreeinos);\n\t\t}\n\n\t\t/* if any free extents, insert at AG free extent list */\n\t\tif (le32_to_cpu(iagp->nfreeexts) > 0) {\n\t\t\tif ((head = imap->im_agctl[n].extfree) == -1) {\n\t\t\t\tiagp->extfreefwd = cpu_to_le32(-1);\n\t\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, head, &hbp))) {\n\t\t\t\t\trcx = rc;\n\t\t\t\t\tgoto nextiag;\n\t\t\t\t}\n\t\t\t\thiagp = (struct iag *) hbp->data;\n\t\t\t\thiagp->extfreeback = iagp->iagnum;\n\t\t\t\tiagp->extfreefwd = cpu_to_le32(head);\n\t\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\t\twrite_metapage(hbp);\n\t\t\t}\n\n\t\t\timap->im_agctl[n].extfree =\n\t\t\t    le32_to_cpu(iagp->iagnum);\n\t\t}\n\n\t      nextiag:\n\t\twrite_metapage(bp);\n\t}\n\n\tif (xnuminos != atomic_read(&imap->im_numinos) ||\n\t    xnumfree != atomic_read(&imap->im_numfree)) {\n\t\tjfs_error(ipimap->i_sb, \"numinos or numfree incorrect\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn rcx;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diExtendFS(struct inode *ipimap, struct inode *ipbmap)\n{\n\tint rc, rcx = 0;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\tstruct iag *iagp = NULL, *hiagp = NULL;\n\tstruct bmap *mp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *bp, *hbp;\n\tint i, n, head;\n\tint numinos, xnuminos = 0, xnumfree = 0;\n\ts64 agstart;\n\n\tjfs_info(\"diExtendFS: nextiag:%d numinos:%d numfree:%d\",\n\t\t   imap->im_nextiag, atomic_read(&imap->im_numinos),\n\t\t   atomic_read(&imap->im_numfree));\n\n\t/*\n\t *\treconstruct imap\n\t *\n\t * coalesce contiguous k (newAGSize/oldAGSize) AGs;\n\t * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;\n\t * note: new AG size = old AG size * (2**x).\n\t */\n\n\t/* init per AG control information im_agctl[] */\n\tfor (i = 0; i < MAXAG; i++) {\n\t\timap->im_agctl[i].inofree = -1;\n\t\timap->im_agctl[i].extfree = -1;\n\t\timap->im_agctl[i].numinos = 0;\t/* number of backed inodes */\n\t\timap->im_agctl[i].numfree = 0;\t/* number of free backed inodes */\n\t}\n\n\t/*\n\t *\tprocess each iag page of the map.\n\t *\n\t * rebuild AG Free Inode List, AG Free Inode Extent List;\n\t */\n\tfor (i = 0; i < imap->im_nextiag; i++) {\n\t\tif ((rc = diIAGRead(imap, i, &bp))) {\n\t\t\trcx = rc;\n\t\t\tcontinue;\n\t\t}\n\t\tiagp = (struct iag *) bp->data;\n\t\tif (le32_to_cpu(iagp->iagnum) != i) {\n\t\t\trelease_metapage(bp);\n\t\t\tjfs_error(ipimap->i_sb, \"unexpected value of iagnum\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* leave free iag in the free iag list */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\trelease_metapage(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tagstart = le64_to_cpu(iagp->agstart);\n\t\tn = agstart >> mp->db_agl2size;\n\t\tiagp->agstart = cpu_to_le64((s64)n << mp->db_agl2size);\n\n\t\t/* compute backed inodes */\n\t\tnuminos = (EXTSPERIAG - le32_to_cpu(iagp->nfreeexts))\n\t\t    << L2INOSPEREXT;\n\t\tif (numinos > 0) {\n\t\t\t/* merge AG backed inodes */\n\t\t\timap->im_agctl[n].numinos += numinos;\n\t\t\txnuminos += numinos;\n\t\t}\n\n\t\t/* if any backed free inodes, insert at AG free inode list */\n\t\tif ((int) le32_to_cpu(iagp->nfreeinos) > 0) {\n\t\t\tif ((head = imap->im_agctl[n].inofree) == -1) {\n\t\t\t\tiagp->inofreefwd = cpu_to_le32(-1);\n\t\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, head, &hbp))) {\n\t\t\t\t\trcx = rc;\n\t\t\t\t\tgoto nextiag;\n\t\t\t\t}\n\t\t\t\thiagp = (struct iag *) hbp->data;\n\t\t\t\thiagp->inofreeback = iagp->iagnum;\n\t\t\t\tiagp->inofreefwd = cpu_to_le32(head);\n\t\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\t\twrite_metapage(hbp);\n\t\t\t}\n\n\t\t\timap->im_agctl[n].inofree =\n\t\t\t    le32_to_cpu(iagp->iagnum);\n\n\t\t\t/* merge AG backed free inodes */\n\t\t\timap->im_agctl[n].numfree +=\n\t\t\t    le32_to_cpu(iagp->nfreeinos);\n\t\t\txnumfree += le32_to_cpu(iagp->nfreeinos);\n\t\t}\n\n\t\t/* if any free extents, insert at AG free extent list */\n\t\tif (le32_to_cpu(iagp->nfreeexts) > 0) {\n\t\t\tif ((head = imap->im_agctl[n].extfree) == -1) {\n\t\t\t\tiagp->extfreefwd = cpu_to_le32(-1);\n\t\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, head, &hbp))) {\n\t\t\t\t\trcx = rc;\n\t\t\t\t\tgoto nextiag;\n\t\t\t\t}\n\t\t\t\thiagp = (struct iag *) hbp->data;\n\t\t\t\thiagp->extfreeback = iagp->iagnum;\n\t\t\t\tiagp->extfreefwd = cpu_to_le32(head);\n\t\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\t\twrite_metapage(hbp);\n\t\t\t}\n\n\t\t\timap->im_agctl[n].extfree =\n\t\t\t    le32_to_cpu(iagp->iagnum);\n\t\t}\n\n\t      nextiag:\n\t\twrite_metapage(bp);\n\t}\n\n\tif (xnuminos != atomic_read(&imap->im_numinos) ||\n\t    xnumfree != atomic_read(&imap->im_numfree)) {\n\t\tjfs_error(ipimap->i_sb, \"numinos or numfree incorrect\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn rcx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbFinalizeBmap",
          "args": [
            "ipbmap"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "dbFinalizeBmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3656-3727",
          "snippet": "void dbFinalizeBmap(struct inode *ipbmap)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tint actags, inactags, l2nl;\n\ts64 ag_rem, actfree, inactfree, avgfree;\n\tint i, n;\n\n\t/*\n\t *\tfinalize bmap control page\n\t */\n//finalize:\n\t/*\n\t * compute db_agpref: preferred ag to allocate from\n\t * (the leftmost ag with average free space in it);\n\t */\n//agpref:\n\t/* get the number of active ags and inacitve ags */\n\tactags = bmp->db_maxag + 1;\n\tinactags = bmp->db_numag - actags;\n\tag_rem = bmp->db_mapsize & (bmp->db_agsize - 1);\t/* ??? */\n\n\t/* determine how many blocks are in the inactive allocation\n\t * groups. in doing this, we must account for the fact that\n\t * the rightmost group might be a partial group (i.e. file\n\t * system size is not a multiple of the group size).\n\t */\n\tinactfree = (inactags && ag_rem) ?\n\t    ((inactags - 1) << bmp->db_agl2size) + ag_rem\n\t    : inactags << bmp->db_agl2size;\n\n\t/* determine how many free blocks are in the active\n\t * allocation groups plus the average number of free blocks\n\t * within the active ags.\n\t */\n\tactfree = bmp->db_nfree - inactfree;\n\tavgfree = (u32) actfree / (u32) actags;\n\n\t/* if the preferred allocation group has not average free space.\n\t * re-establish the preferred group as the leftmost\n\t * group with average free space.\n\t */\n\tif (bmp->db_agfree[bmp->db_agpref] < avgfree) {\n\t\tfor (bmp->db_agpref = 0; bmp->db_agpref < actags;\n\t\t     bmp->db_agpref++) {\n\t\t\tif (bmp->db_agfree[bmp->db_agpref] >= avgfree)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bmp->db_agpref >= bmp->db_numag) {\n\t\t\tjfs_error(ipbmap->i_sb,\n\t\t\t\t  \"cannot find ag with average freespace\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * compute db_aglevel, db_agheight, db_width, db_agstart:\n\t * an ag is covered in aglevel dmapctl summary tree,\n\t * at agheight level height (from leaf) with agwidth number of nodes\n\t * each, which starts at agstart index node of the smmary tree node\n\t * array;\n\t */\n\tbmp->db_aglevel = BMAPSZTOLEV(bmp->db_agsize);\n\tl2nl =\n\t    bmp->db_agl2size - (L2BPERDMAP + bmp->db_aglevel * L2LPERCTL);\n\tbmp->db_agheight = l2nl >> 1;\n\tbmp->db_agwidth = 1 << (l2nl - (bmp->db_agheight << 1));\n\tfor (i = 5 - bmp->db_agheight, bmp->db_agstart = 0, n = 1; i > 0;\n\t     i--) {\n\t\tbmp->db_agstart += n;\n\t\tn <<= 2;\n\t}\n\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nvoid dbFinalizeBmap(struct inode *ipbmap)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tint actags, inactags, l2nl;\n\ts64 ag_rem, actfree, inactfree, avgfree;\n\tint i, n;\n\n\t/*\n\t *\tfinalize bmap control page\n\t */\n//finalize:\n\t/*\n\t * compute db_agpref: preferred ag to allocate from\n\t * (the leftmost ag with average free space in it);\n\t */\n//agpref:\n\t/* get the number of active ags and inacitve ags */\n\tactags = bmp->db_maxag + 1;\n\tinactags = bmp->db_numag - actags;\n\tag_rem = bmp->db_mapsize & (bmp->db_agsize - 1);\t/* ??? */\n\n\t/* determine how many blocks are in the inactive allocation\n\t * groups. in doing this, we must account for the fact that\n\t * the rightmost group might be a partial group (i.e. file\n\t * system size is not a multiple of the group size).\n\t */\n\tinactfree = (inactags && ag_rem) ?\n\t    ((inactags - 1) << bmp->db_agl2size) + ag_rem\n\t    : inactags << bmp->db_agl2size;\n\n\t/* determine how many free blocks are in the active\n\t * allocation groups plus the average number of free blocks\n\t * within the active ags.\n\t */\n\tactfree = bmp->db_nfree - inactfree;\n\tavgfree = (u32) actfree / (u32) actags;\n\n\t/* if the preferred allocation group has not average free space.\n\t * re-establish the preferred group as the leftmost\n\t * group with average free space.\n\t */\n\tif (bmp->db_agfree[bmp->db_agpref] < avgfree) {\n\t\tfor (bmp->db_agpref = 0; bmp->db_agpref < actags;\n\t\t     bmp->db_agpref++) {\n\t\t\tif (bmp->db_agfree[bmp->db_agpref] >= avgfree)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bmp->db_agpref >= bmp->db_numag) {\n\t\t\tjfs_error(ipbmap->i_sb,\n\t\t\t\t  \"cannot find ag with average freespace\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * compute db_aglevel, db_agheight, db_width, db_agstart:\n\t * an ag is covered in aglevel dmapctl summary tree,\n\t * at agheight level height (from leaf) with agwidth number of nodes\n\t * each, which starts at agstart index node of the smmary tree node\n\t * array;\n\t */\n\tbmp->db_aglevel = BMAPSZTOLEV(bmp->db_agsize);\n\tl2nl =\n\t    bmp->db_agl2size - (L2BPERDMAP + bmp->db_aglevel * L2LPERCTL);\n\tbmp->db_agheight = l2nl >> 1;\n\tbmp->db_agwidth = 1 << (l2nl - (bmp->db_agheight << 1));\n\tfor (i = 5 - bmp->db_agheight, bmp->db_agstart = 0, n = 1; i > 0;\n\t     i--) {\n\t\tbmp->db_agstart += n;\n\t\tn <<= 2;\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&iplist[0]",
            "COMMIT_FORCE"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_add_bytes",
          "args": [
            "ipbmap",
            "xlen << sbi->l2bsize"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "460-465",
          "snippet": "void inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtAppend",
          "args": [
            "tid",
            "ipbmap",
            "0",
            "xoff",
            "nblocks",
            "&xlen",
            "&xaddr",
            "0"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "xtAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "2169-2320",
          "snippet": "int xtAppend(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 maxblocks,\n\t     s32 * xlenp,\t/* (in/out) */\n\t     s64 * xaddrp,\t/* (in/out) */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn, xaddr;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tint nsplit, nblocks, xlen;\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\ts64 next;\n\n\txaddr = *xaddrp;\n\txlen = *xlenp;\n\tjfs_info(\"xtAppend: xoff:0x%lx maxblocks:%d xlen:%d xaddr:0x%lx\",\n\t\t (ulong) xoff, maxblocks, xlen, (ulong) xaddr);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp == 0) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (next)\n\t\txlen = min(xlen, (int)(next - xoff));\n//insert:\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex < le16_to_cpu(p->header.maxentry))\n\t\tgoto insertLeaf;\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t */\n\tnsplit = btstack.nsplit;\n\tsplit.pxdlist = &pxdlist;\n\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\tpxd = &pxdlist.pxd[0];\n\tnblocks = JFS_SBI(ip->i_sb)->nbperpage;\n\tfor (; nsplit > 0; nsplit--, pxd++, xaddr += nblocks, maxblocks -= nblocks) {\n\t\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) nblocks)) == 0) {\n\t\t\tPXDaddress(pxd, xaddr);\n\t\t\tPXDlength(pxd, nblocks);\n\n\t\t\tpxdlist.maxnpxd++;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* undo allocation */\n\n\t\tgoto out;\n\t}\n\n\txlen = min(xlen, maxblocks);\n\n\t/*\n\t * allocate data extent requested\n\t */\n\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) xlen)))\n\t\tgoto out;\n\n\tsplit.mp = mp;\n\tsplit.index = index;\n\tsplit.flag = xflag;\n\tsplit.off = xoff;\n\tsplit.len = xlen;\n\tsplit.addr = xaddr;\n\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t/* undo data extent allocation */\n\t\tdbFree(ip, *xaddrp, (s64) * xlenp);\n\n\t\treturn rc;\n\t}\n\n\t*xaddrp = xaddr;\n\t*xlenp = xlen;\n\treturn 0;\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n      insertLeaf:\n\t/*\n\t * allocate data extent requested\n\t */\n\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) xlen)))\n\t\tgoto out;\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\txtlck = (struct xtlock *) & tlck->lock;\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\txtlck->lwm.offset =\n\t    (xtlck->lwm.offset) ? min(index,(int) xtlck->lwm.offset) : index;\n\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t    xtlck->lwm.offset;\n\n\t*xaddrp = xaddr;\n\t*xlenp = xlen;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtAppend(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 maxblocks,\n\t     s32 * xlenp,\t/* (in/out) */\n\t     s64 * xaddrp,\t/* (in/out) */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn, xaddr;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tint nsplit, nblocks, xlen;\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\ts64 next;\n\n\txaddr = *xaddrp;\n\txlen = *xlenp;\n\tjfs_info(\"xtAppend: xoff:0x%lx maxblocks:%d xlen:%d xaddr:0x%lx\",\n\t\t (ulong) xoff, maxblocks, xlen, (ulong) xaddr);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp == 0) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (next)\n\t\txlen = min(xlen, (int)(next - xoff));\n//insert:\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex < le16_to_cpu(p->header.maxentry))\n\t\tgoto insertLeaf;\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t */\n\tnsplit = btstack.nsplit;\n\tsplit.pxdlist = &pxdlist;\n\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\tpxd = &pxdlist.pxd[0];\n\tnblocks = JFS_SBI(ip->i_sb)->nbperpage;\n\tfor (; nsplit > 0; nsplit--, pxd++, xaddr += nblocks, maxblocks -= nblocks) {\n\t\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) nblocks)) == 0) {\n\t\t\tPXDaddress(pxd, xaddr);\n\t\t\tPXDlength(pxd, nblocks);\n\n\t\t\tpxdlist.maxnpxd++;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* undo allocation */\n\n\t\tgoto out;\n\t}\n\n\txlen = min(xlen, maxblocks);\n\n\t/*\n\t * allocate data extent requested\n\t */\n\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) xlen)))\n\t\tgoto out;\n\n\tsplit.mp = mp;\n\tsplit.index = index;\n\tsplit.flag = xflag;\n\tsplit.off = xoff;\n\tsplit.len = xlen;\n\tsplit.addr = xaddr;\n\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t/* undo data extent allocation */\n\t\tdbFree(ip, *xaddrp, (s64) * xlenp);\n\n\t\treturn rc;\n\t}\n\n\t*xaddrp = xaddr;\n\t*xlenp = xlen;\n\treturn 0;\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n      insertLeaf:\n\t/*\n\t * allocate data extent requested\n\t */\n\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) xlen)))\n\t\tgoto out;\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\txtlck = (struct xtlock *) & tlck->lock;\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\txtlck->lwm.offset =\n\t    (xtlck->lwm.offset) ? min(index,(int) xtlck->lwm.offset) : index;\n\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t    xtlck->lwm.offset;\n\n\t*xaddrp = xaddr;\n\t*xlenp = xlen;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "sb",
            "COMMIT_FORCE"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "xlen",
            "(int) nblocks"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "ipbmap->i_mapping"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "ipbmap->i_mapping"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbExtendFS",
          "args": [
            "ipbmap",
            "XAddress",
            "nblocks"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "dbExtendFS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3384-3650",
          "snippet": "int dbExtendFS(struct inode *ipbmap, s64 blkno,\ts64 nblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ipbmap->i_sb);\n\tint nbperpage = sbi->nbperpage;\n\tint i, i0 = true, j, j0 = true, k, n;\n\ts64 newsize;\n\ts64 p;\n\tstruct metapage *mp, *l2mp, *l1mp = NULL, *l0mp = NULL;\n\tstruct dmapctl *l2dcp, *l1dcp, *l0dcp;\n\tstruct dmap *dp;\n\ts8 *l0leaf, *l1leaf, *l2leaf;\n\tstruct bmap *bmp = sbi->bmap;\n\tint agno, l2agsize, oldl2agsize;\n\ts64 ag_rem;\n\n\tnewsize = blkno + nblocks;\n\n\tjfs_info(\"dbExtendFS: blkno:%Ld nblocks:%Ld newsize:%Ld\",\n\t\t (long long) blkno, (long long) nblocks, (long long) newsize);\n\n\t/*\n\t *\tinitialize bmap control page.\n\t *\n\t * all the data in bmap control page should exclude\n\t * the mkfs hidden dmap page.\n\t */\n\n\t/* update mapsize */\n\tbmp->db_mapsize = newsize;\n\tbmp->db_maxlevel = BMAPSZTOLEV(bmp->db_mapsize);\n\n\t/* compute new AG size */\n\tl2agsize = dbGetL2AGSize(newsize);\n\toldl2agsize = bmp->db_agl2size;\n\n\tbmp->db_agl2size = l2agsize;\n\tbmp->db_agsize = 1 << l2agsize;\n\n\t/* compute new number of AG */\n\tagno = bmp->db_numag;\n\tbmp->db_numag = newsize >> l2agsize;\n\tbmp->db_numag += ((u32) newsize % (u32) bmp->db_agsize) ? 1 : 0;\n\n\t/*\n\t *\treconfigure db_agfree[]\n\t * from old AG configuration to new AG configuration;\n\t *\n\t * coalesce contiguous k (newAGSize/oldAGSize) AGs;\n\t * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;\n\t * note: new AG size = old AG size * (2**x).\n\t */\n\tif (l2agsize == oldl2agsize)\n\t\tgoto extend;\n\tk = 1 << (l2agsize - oldl2agsize);\n\tag_rem = bmp->db_agfree[0];\t/* save agfree[0] */\n\tfor (i = 0, n = 0; i < agno; n++) {\n\t\tbmp->db_agfree[n] = 0;\t/* init collection point */\n\n\t\t/* coalesce contiguous k AGs; */\n\t\tfor (j = 0; j < k && i < agno; j++, i++) {\n\t\t\t/* merge AGi to AGn */\n\t\t\tbmp->db_agfree[n] += bmp->db_agfree[i];\n\t\t}\n\t}\n\tbmp->db_agfree[0] += ag_rem;\t/* restore agfree[0] */\n\n\tfor (; n < MAXAG; n++)\n\t\tbmp->db_agfree[n] = 0;\n\n\t/*\n\t * update highest active ag number\n\t */\n\n\tbmp->db_maxag = bmp->db_maxag / k;\n\n\t/*\n\t *\textend bmap\n\t *\n\t * update bit maps and corresponding level control pages;\n\t * global control page db_nfree, db_agfree[agno], db_maxfreebud;\n\t */\n      extend:\n\t/* get L2 page */\n\tp = BMAPBLKNO + nbperpage;\t/* L2 page */\n\tl2mp = read_metapage(ipbmap, p, PSIZE, 0);\n\tif (!l2mp) {\n\t\tjfs_error(ipbmap->i_sb, \"L2 page could not be read\\n\");\n\t\treturn -EIO;\n\t}\n\tl2dcp = (struct dmapctl *) l2mp->data;\n\n\t/* compute start L1 */\n\tk = blkno >> L2MAXL1SIZE;\n\tl2leaf = l2dcp->stree + CTLLEAFIND + k;\n\tp = BLKTOL1(blkno, sbi->l2nbperpage);\t/* L1 page */\n\n\t/*\n\t * extend each L1 in L2\n\t */\n\tfor (; k < LPERCTL; k++, p += nbperpage) {\n\t\t/* get L1 page */\n\t\tif (j0) {\n\t\t\t/* read in L1 page: (blkno & (MAXL1SIZE - 1)) */\n\t\t\tl1mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t/* compute start L0 */\n\t\t\tj = (blkno & (MAXL1SIZE - 1)) >> L2MAXL0SIZE;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND + j;\n\t\t\tp = BLKTOL0(blkno, sbi->l2nbperpage);\n\t\t\tj0 = false;\n\t\t} else {\n\t\t\t/* assign/init L1 page */\n\t\t\tl1mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t/* compute start L0 */\n\t\t\tj = 0;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND;\n\t\t\tp += nbperpage;\t/* 1st L0 of L1.k */\n\t\t}\n\n\t\t/*\n\t\t * extend each L0 in L1\n\t\t */\n\t\tfor (; j < LPERCTL; j++) {\n\t\t\t/* get L0 page */\n\t\t\tif (i0) {\n\t\t\t\t/* read in L0 page: (blkno & (MAXL0SIZE - 1)) */\n\n\t\t\t\tl0mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t/* compute start dmap */\n\t\t\t\ti = (blkno & (MAXL0SIZE - 1)) >>\n\t\t\t\t    L2BPERDMAP;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND + i;\n\t\t\t\tp = BLKTODMAP(blkno,\n\t\t\t\t\t      sbi->l2nbperpage);\n\t\t\t\ti0 = false;\n\t\t\t} else {\n\t\t\t\t/* assign/init L0 page */\n\t\t\t\tl0mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t/* compute start dmap */\n\t\t\t\ti = 0;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND;\n\t\t\t\tp += nbperpage;\t/* 1st dmap of L0.j */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * extend each dmap in L0\n\t\t\t */\n\t\t\tfor (; i < LPERCTL; i++) {\n\t\t\t\t/*\n\t\t\t\t * reconstruct the dmap page, and\n\t\t\t\t * initialize corresponding parent L0 leaf\n\t\t\t\t */\n\t\t\t\tif ((n = blkno & (BPERDMAP - 1))) {\n\t\t\t\t\t/* read in dmap page: */\n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\t\t\t\t\tn = min(nblocks, (s64)BPERDMAP - n);\n\t\t\t\t} else {\n\t\t\t\t\t/* assign/init dmap page */\n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\n\t\t\t\t\tn = min_t(s64, nblocks, BPERDMAP);\n\t\t\t\t}\n\n\t\t\t\tdp = (struct dmap *) mp->data;\n\t\t\t\t*l0leaf = dbInitDmap(dp, blkno, n);\n\n\t\t\t\tbmp->db_nfree += n;\n\t\t\t\tagno = le64_to_cpu(dp->start) >> l2agsize;\n\t\t\t\tbmp->db_agfree[agno] += n;\n\n\t\t\t\twrite_metapage(mp);\n\n\t\t\t\tl0leaf++;\n\t\t\t\tp += nbperpage;\n\n\t\t\t\tblkno += n;\n\t\t\t\tnblocks -= n;\n\t\t\t\tif (nblocks == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\t/* for each dmap in a L0 */\n\n\t\t\t/*\n\t\t\t * build current L0 page from its leaves, and\n\t\t\t * initialize corresponding parent L1 leaf\n\t\t\t */\n\t\t\t*l1leaf = dbInitDmapCtl(l0dcp, 0, ++i);\n\t\t\twrite_metapage(l0mp);\n\t\t\tl0mp = NULL;\n\n\t\t\tif (nblocks)\n\t\t\t\tl1leaf++;\t/* continue for next L0 */\n\t\t\telse {\n\t\t\t\t/* more than 1 L0 ? */\n\t\t\t\tif (j > 0)\n\t\t\t\t\tbreak;\t/* build L1 page */\n\t\t\t\telse {\n\t\t\t\t\t/* summarize in global bmap page */\n\t\t\t\t\tbmp->db_maxfreebud = *l1leaf;\n\t\t\t\t\trelease_metapage(l1mp);\n\t\t\t\t\trelease_metapage(l2mp);\n\t\t\t\t\tgoto finalize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t/* for each L0 in a L1 */\n\n\t\t/*\n\t\t * build current L1 page from its leaves, and\n\t\t * initialize corresponding parent L2 leaf\n\t\t */\n\t\t*l2leaf = dbInitDmapCtl(l1dcp, 1, ++j);\n\t\twrite_metapage(l1mp);\n\t\tl1mp = NULL;\n\n\t\tif (nblocks)\n\t\t\tl2leaf++;\t/* continue for next L1 */\n\t\telse {\n\t\t\t/* more than 1 L1 ? */\n\t\t\tif (k > 0)\n\t\t\t\tbreak;\t/* build L2 page */\n\t\t\telse {\n\t\t\t\t/* summarize in global bmap page */\n\t\t\t\tbmp->db_maxfreebud = *l2leaf;\n\t\t\t\trelease_metapage(l2mp);\n\t\t\t\tgoto finalize;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* for each L1 in a L2 */\n\n\tjfs_error(ipbmap->i_sb, \"function has not returned as expected\\n\");\nerrout:\n\tif (l0mp)\n\t\trelease_metapage(l0mp);\n\tif (l1mp)\n\t\trelease_metapage(l1mp);\n\trelease_metapage(l2mp);\n\treturn -EIO;\n\n\t/*\n\t *\tfinalize bmap control page\n\t */\nfinalize:\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbExtendFS(struct inode *ipbmap, s64 blkno,\ts64 nblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ipbmap->i_sb);\n\tint nbperpage = sbi->nbperpage;\n\tint i, i0 = true, j, j0 = true, k, n;\n\ts64 newsize;\n\ts64 p;\n\tstruct metapage *mp, *l2mp, *l1mp = NULL, *l0mp = NULL;\n\tstruct dmapctl *l2dcp, *l1dcp, *l0dcp;\n\tstruct dmap *dp;\n\ts8 *l0leaf, *l1leaf, *l2leaf;\n\tstruct bmap *bmp = sbi->bmap;\n\tint agno, l2agsize, oldl2agsize;\n\ts64 ag_rem;\n\n\tnewsize = blkno + nblocks;\n\n\tjfs_info(\"dbExtendFS: blkno:%Ld nblocks:%Ld newsize:%Ld\",\n\t\t (long long) blkno, (long long) nblocks, (long long) newsize);\n\n\t/*\n\t *\tinitialize bmap control page.\n\t *\n\t * all the data in bmap control page should exclude\n\t * the mkfs hidden dmap page.\n\t */\n\n\t/* update mapsize */\n\tbmp->db_mapsize = newsize;\n\tbmp->db_maxlevel = BMAPSZTOLEV(bmp->db_mapsize);\n\n\t/* compute new AG size */\n\tl2agsize = dbGetL2AGSize(newsize);\n\toldl2agsize = bmp->db_agl2size;\n\n\tbmp->db_agl2size = l2agsize;\n\tbmp->db_agsize = 1 << l2agsize;\n\n\t/* compute new number of AG */\n\tagno = bmp->db_numag;\n\tbmp->db_numag = newsize >> l2agsize;\n\tbmp->db_numag += ((u32) newsize % (u32) bmp->db_agsize) ? 1 : 0;\n\n\t/*\n\t *\treconfigure db_agfree[]\n\t * from old AG configuration to new AG configuration;\n\t *\n\t * coalesce contiguous k (newAGSize/oldAGSize) AGs;\n\t * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;\n\t * note: new AG size = old AG size * (2**x).\n\t */\n\tif (l2agsize == oldl2agsize)\n\t\tgoto extend;\n\tk = 1 << (l2agsize - oldl2agsize);\n\tag_rem = bmp->db_agfree[0];\t/* save agfree[0] */\n\tfor (i = 0, n = 0; i < agno; n++) {\n\t\tbmp->db_agfree[n] = 0;\t/* init collection point */\n\n\t\t/* coalesce contiguous k AGs; */\n\t\tfor (j = 0; j < k && i < agno; j++, i++) {\n\t\t\t/* merge AGi to AGn */\n\t\t\tbmp->db_agfree[n] += bmp->db_agfree[i];\n\t\t}\n\t}\n\tbmp->db_agfree[0] += ag_rem;\t/* restore agfree[0] */\n\n\tfor (; n < MAXAG; n++)\n\t\tbmp->db_agfree[n] = 0;\n\n\t/*\n\t * update highest active ag number\n\t */\n\n\tbmp->db_maxag = bmp->db_maxag / k;\n\n\t/*\n\t *\textend bmap\n\t *\n\t * update bit maps and corresponding level control pages;\n\t * global control page db_nfree, db_agfree[agno], db_maxfreebud;\n\t */\n      extend:\n\t/* get L2 page */\n\tp = BMAPBLKNO + nbperpage;\t/* L2 page */\n\tl2mp = read_metapage(ipbmap, p, PSIZE, 0);\n\tif (!l2mp) {\n\t\tjfs_error(ipbmap->i_sb, \"L2 page could not be read\\n\");\n\t\treturn -EIO;\n\t}\n\tl2dcp = (struct dmapctl *) l2mp->data;\n\n\t/* compute start L1 */\n\tk = blkno >> L2MAXL1SIZE;\n\tl2leaf = l2dcp->stree + CTLLEAFIND + k;\n\tp = BLKTOL1(blkno, sbi->l2nbperpage);\t/* L1 page */\n\n\t/*\n\t * extend each L1 in L2\n\t */\n\tfor (; k < LPERCTL; k++, p += nbperpage) {\n\t\t/* get L1 page */\n\t\tif (j0) {\n\t\t\t/* read in L1 page: (blkno & (MAXL1SIZE - 1)) */\n\t\t\tl1mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t/* compute start L0 */\n\t\t\tj = (blkno & (MAXL1SIZE - 1)) >> L2MAXL0SIZE;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND + j;\n\t\t\tp = BLKTOL0(blkno, sbi->l2nbperpage);\n\t\t\tj0 = false;\n\t\t} else {\n\t\t\t/* assign/init L1 page */\n\t\t\tl1mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t/* compute start L0 */\n\t\t\tj = 0;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND;\n\t\t\tp += nbperpage;\t/* 1st L0 of L1.k */\n\t\t}\n\n\t\t/*\n\t\t * extend each L0 in L1\n\t\t */\n\t\tfor (; j < LPERCTL; j++) {\n\t\t\t/* get L0 page */\n\t\t\tif (i0) {\n\t\t\t\t/* read in L0 page: (blkno & (MAXL0SIZE - 1)) */\n\n\t\t\t\tl0mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t/* compute start dmap */\n\t\t\t\ti = (blkno & (MAXL0SIZE - 1)) >>\n\t\t\t\t    L2BPERDMAP;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND + i;\n\t\t\t\tp = BLKTODMAP(blkno,\n\t\t\t\t\t      sbi->l2nbperpage);\n\t\t\t\ti0 = false;\n\t\t\t} else {\n\t\t\t\t/* assign/init L0 page */\n\t\t\t\tl0mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t/* compute start dmap */\n\t\t\t\ti = 0;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND;\n\t\t\t\tp += nbperpage;\t/* 1st dmap of L0.j */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * extend each dmap in L0\n\t\t\t */\n\t\t\tfor (; i < LPERCTL; i++) {\n\t\t\t\t/*\n\t\t\t\t * reconstruct the dmap page, and\n\t\t\t\t * initialize corresponding parent L0 leaf\n\t\t\t\t */\n\t\t\t\tif ((n = blkno & (BPERDMAP - 1))) {\n\t\t\t\t\t/* read in dmap page: */\n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\t\t\t\t\tn = min(nblocks, (s64)BPERDMAP - n);\n\t\t\t\t} else {\n\t\t\t\t\t/* assign/init dmap page */\n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\n\t\t\t\t\tn = min_t(s64, nblocks, BPERDMAP);\n\t\t\t\t}\n\n\t\t\t\tdp = (struct dmap *) mp->data;\n\t\t\t\t*l0leaf = dbInitDmap(dp, blkno, n);\n\n\t\t\t\tbmp->db_nfree += n;\n\t\t\t\tagno = le64_to_cpu(dp->start) >> l2agsize;\n\t\t\t\tbmp->db_agfree[agno] += n;\n\n\t\t\t\twrite_metapage(mp);\n\n\t\t\t\tl0leaf++;\n\t\t\t\tp += nbperpage;\n\n\t\t\t\tblkno += n;\n\t\t\t\tnblocks -= n;\n\t\t\t\tif (nblocks == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\t/* for each dmap in a L0 */\n\n\t\t\t/*\n\t\t\t * build current L0 page from its leaves, and\n\t\t\t * initialize corresponding parent L1 leaf\n\t\t\t */\n\t\t\t*l1leaf = dbInitDmapCtl(l0dcp, 0, ++i);\n\t\t\twrite_metapage(l0mp);\n\t\t\tl0mp = NULL;\n\n\t\t\tif (nblocks)\n\t\t\t\tl1leaf++;\t/* continue for next L0 */\n\t\t\telse {\n\t\t\t\t/* more than 1 L0 ? */\n\t\t\t\tif (j > 0)\n\t\t\t\t\tbreak;\t/* build L1 page */\n\t\t\t\telse {\n\t\t\t\t\t/* summarize in global bmap page */\n\t\t\t\t\tbmp->db_maxfreebud = *l1leaf;\n\t\t\t\t\trelease_metapage(l1mp);\n\t\t\t\t\trelease_metapage(l2mp);\n\t\t\t\t\tgoto finalize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t/* for each L0 in a L1 */\n\n\t\t/*\n\t\t * build current L1 page from its leaves, and\n\t\t * initialize corresponding parent L2 leaf\n\t\t */\n\t\t*l2leaf = dbInitDmapCtl(l1dcp, 1, ++j);\n\t\twrite_metapage(l1mp);\n\t\tl1mp = NULL;\n\n\t\tif (nblocks)\n\t\t\tl2leaf++;\t/* continue for next L1 */\n\t\telse {\n\t\t\t/* more than 1 L1 ? */\n\t\t\tif (k > 0)\n\t\t\t\tbreak;\t/* build L2 page */\n\t\t\telse {\n\t\t\t\t/* summarize in global bmap page */\n\t\t\t\tbmp->db_maxfreebud = *l2leaf;\n\t\t\t\trelease_metapage(l2mp);\n\t\t\t\tgoto finalize;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* for each L1 in a L2 */\n\n\tjfs_error(ipbmap->i_sb, \"function has not returned as expected\\n\");\nerrout:\n\tif (l0mp)\n\t\trelease_metapage(l0mp);\n\tif (l1mp)\n\t\trelease_metapage(l1mp);\n\trelease_metapage(l2mp);\n\treturn -EIO;\n\n\t/*\n\t *\tfinalize bmap control page\n\t */\nfinalize:\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbMapFileSizeToMapSize",
          "args": [
            "ipbmap"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "dbMapFileSizeToMapSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "4052-4092",
          "snippet": "s64 dbMapFileSizeToMapSize(struct inode * ipbmap)\n{\n\tstruct super_block *sb = ipbmap->i_sb;\n\ts64 nblocks;\n\ts64 npages, ndmaps;\n\tint level, i;\n\tint complete, factor;\n\n\tnblocks = ipbmap->i_size >> JFS_SBI(sb)->l2bsize;\n\tnpages = nblocks >> JFS_SBI(sb)->l2nbperpage;\n\tlevel = BMAPPGTOLEV(npages);\n\n\t/* At each level, accumulate the number of dmap pages covered by\n\t * the number of full child levels below it;\n\t * repeat for the last incomplete child level.\n\t */\n\tndmaps = 0;\n\tnpages--;\t\t/* skip the first global control page */\n\t/* skip higher level control pages above top level covered by map */\n\tnpages -= (2 - level);\n\tnpages--;\t\t/* skip top level's control page */\n\tfor (i = level; i >= 0; i--) {\n\t\tfactor =\n\t\t    (i == 2) ? MAXL1PAGES : ((i == 1) ? MAXL0PAGES : 1);\n\t\tcomplete = (u32) npages / factor;\n\t\tndmaps += complete * ((i == 2) ? LPERCTL * LPERCTL :\n\t\t\t\t      ((i == 1) ? LPERCTL : 1));\n\n\t\t/* pages in last/incomplete child */\n\t\tnpages = (u32) npages % factor;\n\t\t/* skip incomplete child's level control page */\n\t\tnpages--;\n\t}\n\n\t/* convert the number of dmaps into the number of blocks\n\t * which can be covered by the dmaps;\n\t */\n\tnblocks = ndmaps << L2BPERDMAP;\n\n\treturn (nblocks);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAXL1PAGES\t(1 + LPERCTL * MAXL0PAGES)",
            "#define MAXL0PAGES\t(1 + LPERCTL)"
          ],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\n#define MAXL1PAGES\t(1 + LPERCTL * MAXL0PAGES)\n#define MAXL0PAGES\t(1 + LPERCTL)\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\ns64 dbMapFileSizeToMapSize(struct inode * ipbmap)\n{\n\tstruct super_block *sb = ipbmap->i_sb;\n\ts64 nblocks;\n\ts64 npages, ndmaps;\n\tint level, i;\n\tint complete, factor;\n\n\tnblocks = ipbmap->i_size >> JFS_SBI(sb)->l2bsize;\n\tnpages = nblocks >> JFS_SBI(sb)->l2nbperpage;\n\tlevel = BMAPPGTOLEV(npages);\n\n\t/* At each level, accumulate the number of dmap pages covered by\n\t * the number of full child levels below it;\n\t * repeat for the last incomplete child level.\n\t */\n\tndmaps = 0;\n\tnpages--;\t\t/* skip the first global control page */\n\t/* skip higher level control pages above top level covered by map */\n\tnpages -= (2 - level);\n\tnpages--;\t\t/* skip top level's control page */\n\tfor (i = level; i >= 0; i--) {\n\t\tfactor =\n\t\t    (i == 2) ? MAXL1PAGES : ((i == 1) ? MAXL0PAGES : 1);\n\t\tcomplete = (u32) npages / factor;\n\t\tndmaps += complete * ((i == 2) ? LPERCTL * LPERCTL :\n\t\t\t\t      ((i == 1) ? LPERCTL : 1));\n\n\t\t/* pages in last/incomplete child */\n\t\tnpages = (u32) npages % factor;\n\t\t/* skip incomplete child's level control page */\n\t\tnpages--;\n\t}\n\n\t/* convert the number of dmaps into the number of blocks\n\t * which can be covered by the dmaps;\n\t */\n\tnblocks = ndmaps << L2BPERDMAP;\n\n\treturn (nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLKTODMAPN",
          "args": [
            "t64"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLogInit",
          "args": [
            "log"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1262-1443",
          "snippet": "int lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t/* initialize the group commit serialization lock */\n\tLOGGC_LOCK_INIT(log);\n\n\t/* allocate/initialize the log write serialization lock */\n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t/*\n\t * initialize log i/o\n\t */\n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t/* check for disabled journaling to disk */\n\tif (log->no_integrity) {\n\t\t/*\n\t\t * Journal pages will still be filled.  When the time comes\n\t\t * to actually do the I/O, the write is not done, and the\n\t\t * endio routine is called directly.\n\t\t */\n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t/*\n\t\t * validate log superblock\n\t\t */\n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* logredo() should have been run successfully. */\n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* initialize log from log superblock */\n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t} else {\n\t\t\tif (memcmp(logsuper->uuid, log->uuid, 16)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t/*\n\t\t * initialize for log append write mode\n\t\t */\n\t\t/* establish current/end-of-log page/buffer */\n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t/* if current page is full, move on to next page */\n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t/*\n\t\t * initialize log syncpoint\n\t\t */\n\t\t/*\n\t\t * write the first SYNCPT record with syncpoint = 0\n\t\t * (i.e., log redo up to HERE !);\n\t\t * remove current page from lbm write queue at end of pageout\n\t\t * (to write log superblock update), but do not release to\n\t\t * freelist;\n\t\t */\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t/*\n\t\t * update/write superblock\n\t\t */\n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t/* initialize logsync parameters */\n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t/*\n\t * initialize for lazy/group commit\n\t */\n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout30:\t\t/* release log page */\n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t/* release log superblock */\n\tlbmFree(bpsuper);\n\n      errout10:\t\t/* unwind lbmLogInit() */\n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t/* initialize the group commit serialization lock */\n\tLOGGC_LOCK_INIT(log);\n\n\t/* allocate/initialize the log write serialization lock */\n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t/*\n\t * initialize log i/o\n\t */\n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t/* check for disabled journaling to disk */\n\tif (log->no_integrity) {\n\t\t/*\n\t\t * Journal pages will still be filled.  When the time comes\n\t\t * to actually do the I/O, the write is not done, and the\n\t\t * endio routine is called directly.\n\t\t */\n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t/*\n\t\t * validate log superblock\n\t\t */\n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* logredo() should have been run successfully. */\n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* initialize log from log superblock */\n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t} else {\n\t\t\tif (memcmp(logsuper->uuid, log->uuid, 16)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t/*\n\t\t * initialize for log append write mode\n\t\t */\n\t\t/* establish current/end-of-log page/buffer */\n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t/* if current page is full, move on to next page */\n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t/*\n\t\t * initialize log syncpoint\n\t\t */\n\t\t/*\n\t\t * write the first SYNCPT record with syncpoint = 0\n\t\t * (i.e., log redo up to HERE !);\n\t\t * remove current page from lbm write queue at end of pageout\n\t\t * (to write log superblock update), but do not release to\n\t\t * freelist;\n\t\t */\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t/*\n\t\t * update/write superblock\n\t\t */\n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t/* initialize logsync parameters */\n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t/*\n\t * initialize for lazy/group commit\n\t */\n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout30:\t\t/* release log page */\n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t/* release log superblock */\n\tlbmFree(bpsuper);\n\n      errout10:\t\t/* unwind lbmLogInit() */\n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmLogFormat",
          "args": [
            "log",
            "newLogAddress",
            "newLogSize"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2384-2500",
          "snippet": "int lmLogFormat(struct jfs_log *log, s64 logAddress, int logSize)\n{\n\tint rc = -EIO;\n\tstruct jfs_sb_info *sbi;\n\tstruct logsuper *logsuper;\n\tstruct logpage *lp;\n\tint lspn;\t\t/* log sequence page number */\n\tstruct lrd *lrd_ptr;\n\tint npages = 0;\n\tstruct lbuf *bp;\n\n\tjfs_info(\"lmLogFormat: logAddress:%Ld logSize:%d\",\n\t\t (long long)logAddress, logSize);\n\n\tsbi = list_entry(log->sb_list.next, struct jfs_sb_info, log_list);\n\n\t/* allocate a log buffer */\n\tbp = lbmAllocate(log, 1);\n\n\tnpages = logSize >> sbi->l2nbperpage;\n\n\t/*\n\t *\tlog space:\n\t *\n\t * page 0 - reserved;\n\t * page 1 - log superblock;\n\t * page 2 - log data page: A SYNC log record is written\n\t *\t    into this page at logform time;\n\t * pages 3-N - log data page: set to empty log data pages;\n\t */\n\t/*\n\t *\tinit log superblock: log page 1\n\t */\n\tlogsuper = (struct logsuper *) bp->l_ldata;\n\n\tlogsuper->magic = cpu_to_le32(LOGMAGIC);\n\tlogsuper->version = cpu_to_le32(LOGVERSION);\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->flag = cpu_to_le32(sbi->mntflag);\t/* ? */\n\tlogsuper->size = cpu_to_le32(npages);\n\tlogsuper->bsize = cpu_to_le32(sbi->bsize);\n\tlogsuper->l2bsize = cpu_to_le32(sbi->l2bsize);\n\tlogsuper->end = cpu_to_le32(2 * LOGPSIZE + LOGPHDRSIZE + LOGRDSIZE);\n\n\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\tbp->l_blkno = logAddress + sbi->nbperpage;\n\tlbmStartIO(bp);\n\tif ((rc = lbmIOWait(bp, 0)))\n\t\tgoto exit;\n\n\t/*\n\t *\tinit pages 2 to npages-1 as log data pages:\n\t *\n\t * log page sequence number (lpsn) initialization:\n\t *\n\t * pn:   0     1     2     3                 n-1\n\t *       +-----+-----+=====+=====+===.....===+=====+\n\t * lspn:             N-1   0     1           N-2\n\t *                   <--- N page circular file ---->\n\t *\n\t * the N (= npages-2) data pages of the log is maintained as\n\t * a circular file for the log records;\n\t * lpsn grows by 1 monotonically as each log page is written\n\t * to the circular file of the log;\n\t * and setLogpage() will not reset the page number even if\n\t * the eor is equal to LOGPHDRSIZE. In order for binary search\n\t * still work in find log end process, we have to simulate the\n\t * log wrap situation at the log format time.\n\t * The 1st log page written will have the highest lpsn. Then\n\t * the succeeding log pages will have ascending order of\n\t * the lspn starting from 0, ... (N-2)\n\t */\n\tlp = (struct logpage *) bp->l_ldata;\n\t/*\n\t * initialize 1st log page to be written: lpsn = N - 1,\n\t * write a SYNCPT log record is written to this page\n\t */\n\tlp->h.page = lp->t.page = cpu_to_le32(npages - 3);\n\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE + LOGRDSIZE);\n\n\tlrd_ptr = (struct lrd *) &lp->data;\n\tlrd_ptr->logtid = 0;\n\tlrd_ptr->backchain = 0;\n\tlrd_ptr->type = cpu_to_le16(LOG_SYNCPT);\n\tlrd_ptr->length = 0;\n\tlrd_ptr->log.syncpt.sync = 0;\n\n\tbp->l_blkno += sbi->nbperpage;\n\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\tlbmStartIO(bp);\n\tif ((rc = lbmIOWait(bp, 0)))\n\t\tgoto exit;\n\n\t/*\n\t *\tinitialize succeeding log pages: lpsn = 0, 1, ..., (N-2)\n\t */\n\tfor (lspn = 0; lspn < npages - 3; lspn++) {\n\t\tlp->h.page = lp->t.page = cpu_to_le32(lspn);\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\n\n\t\tbp->l_blkno += sbi->nbperpage;\n\t\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\t\tlbmStartIO(bp);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto exit;\n\t}\n\n\trc = 0;\nexit:\n\t/*\n\t *\tfinalize log\n\t */\n\t/* release the buffer */\n\tlbmFree(bp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmDIRECT\t0x0100",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmDIRECT\t0x0100\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint lmLogFormat(struct jfs_log *log, s64 logAddress, int logSize)\n{\n\tint rc = -EIO;\n\tstruct jfs_sb_info *sbi;\n\tstruct logsuper *logsuper;\n\tstruct logpage *lp;\n\tint lspn;\t\t/* log sequence page number */\n\tstruct lrd *lrd_ptr;\n\tint npages = 0;\n\tstruct lbuf *bp;\n\n\tjfs_info(\"lmLogFormat: logAddress:%Ld logSize:%d\",\n\t\t (long long)logAddress, logSize);\n\n\tsbi = list_entry(log->sb_list.next, struct jfs_sb_info, log_list);\n\n\t/* allocate a log buffer */\n\tbp = lbmAllocate(log, 1);\n\n\tnpages = logSize >> sbi->l2nbperpage;\n\n\t/*\n\t *\tlog space:\n\t *\n\t * page 0 - reserved;\n\t * page 1 - log superblock;\n\t * page 2 - log data page: A SYNC log record is written\n\t *\t    into this page at logform time;\n\t * pages 3-N - log data page: set to empty log data pages;\n\t */\n\t/*\n\t *\tinit log superblock: log page 1\n\t */\n\tlogsuper = (struct logsuper *) bp->l_ldata;\n\n\tlogsuper->magic = cpu_to_le32(LOGMAGIC);\n\tlogsuper->version = cpu_to_le32(LOGVERSION);\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->flag = cpu_to_le32(sbi->mntflag);\t/* ? */\n\tlogsuper->size = cpu_to_le32(npages);\n\tlogsuper->bsize = cpu_to_le32(sbi->bsize);\n\tlogsuper->l2bsize = cpu_to_le32(sbi->l2bsize);\n\tlogsuper->end = cpu_to_le32(2 * LOGPSIZE + LOGPHDRSIZE + LOGRDSIZE);\n\n\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\tbp->l_blkno = logAddress + sbi->nbperpage;\n\tlbmStartIO(bp);\n\tif ((rc = lbmIOWait(bp, 0)))\n\t\tgoto exit;\n\n\t/*\n\t *\tinit pages 2 to npages-1 as log data pages:\n\t *\n\t * log page sequence number (lpsn) initialization:\n\t *\n\t * pn:   0     1     2     3                 n-1\n\t *       +-----+-----+=====+=====+===.....===+=====+\n\t * lspn:             N-1   0     1           N-2\n\t *                   <--- N page circular file ---->\n\t *\n\t * the N (= npages-2) data pages of the log is maintained as\n\t * a circular file for the log records;\n\t * lpsn grows by 1 monotonically as each log page is written\n\t * to the circular file of the log;\n\t * and setLogpage() will not reset the page number even if\n\t * the eor is equal to LOGPHDRSIZE. In order for binary search\n\t * still work in find log end process, we have to simulate the\n\t * log wrap situation at the log format time.\n\t * The 1st log page written will have the highest lpsn. Then\n\t * the succeeding log pages will have ascending order of\n\t * the lspn starting from 0, ... (N-2)\n\t */\n\tlp = (struct logpage *) bp->l_ldata;\n\t/*\n\t * initialize 1st log page to be written: lpsn = N - 1,\n\t * write a SYNCPT log record is written to this page\n\t */\n\tlp->h.page = lp->t.page = cpu_to_le32(npages - 3);\n\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE + LOGRDSIZE);\n\n\tlrd_ptr = (struct lrd *) &lp->data;\n\tlrd_ptr->logtid = 0;\n\tlrd_ptr->backchain = 0;\n\tlrd_ptr->type = cpu_to_le16(LOG_SYNCPT);\n\tlrd_ptr->length = 0;\n\tlrd_ptr->log.syncpt.sync = 0;\n\n\tbp->l_blkno += sbi->nbperpage;\n\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\tlbmStartIO(bp);\n\tif ((rc = lbmIOWait(bp, 0)))\n\t\tgoto exit;\n\n\t/*\n\t *\tinitialize succeeding log pages: lpsn = 0, 1, ..., (N-2)\n\t */\n\tfor (lspn = 0; lspn < npages - 3; lspn++) {\n\t\tlp->h.page = lp->t.page = cpu_to_le32(lspn);\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\n\n\t\tbp->l_blkno += sbi->nbperpage;\n\t\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\t\tlbmStartIO(bp);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto exit;\n\t}\n\n\trc = 0;\nexit:\n\t/*\n\t *\tfinalize log\n\t */\n\t/* release the buffer */\n\tlbmFree(bp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "newFSSize"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "FM_EXTENDFS"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLogShutdown",
          "args": [
            "log"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1654-1713",
          "snippet": "int lmLogShutdown(struct jfs_log * log)\n{\n\tint rc;\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\n\tjfs_info(\"lmLogShutdown: log:0x%p\", log);\n\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * write the last SYNCPT record with syncpoint = 0\n\t * (i.e., log redo up to HERE !)\n\t */\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\tlrd.length = 0;\n\tlrd.log.syncpt.sync = 0;\n\n\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\tlbmWrite(log, log->bp, lbmWRITE | lbmRELEASE | lbmSYNC, 0);\n\tlbmIOWait(log->bp, lbmFREE);\n\tlog->bp = NULL;\n\n\t/*\n\t * synchronous update log superblock\n\t * mark log state as shutdown cleanly\n\t * (i.e., Log does not need to be replayed).\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\tgoto out;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->end = cpu_to_le32(lsn);\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\tjfs_info(\"lmLogShutdown: lsn:0x%x page:%d eor:%d\",\n\t\t lsn, log->page, log->eor);\n\n      out:\n\t/*\n\t * shutdown per log i/o\n\t */\n\tlbmLogShutdown(log);\n\n\tif (rc) {\n\t\tjfs_warn(\"lmLogShutdown: exit(%d)\", rc);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint lmLogShutdown(struct jfs_log * log)\n{\n\tint rc;\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\n\tjfs_info(\"lmLogShutdown: log:0x%p\", log);\n\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * write the last SYNCPT record with syncpoint = 0\n\t * (i.e., log redo up to HERE !)\n\t */\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\tlrd.length = 0;\n\tlrd.log.syncpt.sync = 0;\n\n\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\tlbmWrite(log, log->bp, lbmWRITE | lbmRELEASE | lbmSYNC, 0);\n\tlbmIOWait(log->bp, lbmFREE);\n\tlog->bp = NULL;\n\n\t/*\n\t * synchronous update log superblock\n\t * mark log state as shutdown cleanly\n\t * (i.e., Log does not need to be replayed).\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\tgoto out;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->end = cpu_to_le32(lsn);\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\tjfs_info(\"lmLogShutdown: lsn:0x%x page:%d eor:%d\",\n\t\t lsn, log->page, log->eor);\n\n      out:\n\t/*\n\t * shutdown per log i/o\n\t */\n\tlbmLogShutdown(log);\n\n\tif (rc) {\n\t\tjfs_warn(\"lmLogShutdown: exit(%d)\", rc);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txQuiesce",
          "args": [
            "sb"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "txQuiesce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2859-2909",
          "snippet": "void txQuiesce(struct super_block *sb)\n{\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\ttid_t tid;\n\n\tset_bit(log_QUIESCE, &log->flag);\n\n\tTXN_LOCK();\nrestart:\n\twhile (!list_empty(&TxAnchor.anon_list)) {\n\t\tjfs_ip = list_entry(TxAnchor.anon_list.next,\n\t\t\t\t    struct jfs_inode_info,\n\t\t\t\t    anon_inode_list);\n\t\tip = &jfs_ip->vfs_inode;\n\n\t\t/*\n\t\t * inode will be removed from anonymous list\n\t\t * when it is committed\n\t\t */\n\t\tTXN_UNLOCK();\n\t\ttid = txBegin(ip->i_sb, COMMIT_INODE | COMMIT_FORCE);\n\t\tmutex_lock(&jfs_ip->commit_mutex);\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&jfs_ip->commit_mutex);\n\t\t/*\n\t\t * Just to be safe.  I don't know how\n\t\t * long we can run without blocking\n\t\t */\n\t\tcond_resched();\n\t\tTXN_LOCK();\n\t}\n\n\t/*\n\t * If jfs_sync is running in parallel, there could be some inodes\n\t * on anon_list2.  Let's check.\n\t */\n\tif (!list_empty(&TxAnchor.anon_list2)) {\n\t\tlist_splice(&TxAnchor.anon_list2, &TxAnchor.anon_list);\n\t\tINIT_LIST_HEAD(&TxAnchor.anon_list2);\n\t\tgoto restart;\n\t}\n\tTXN_UNLOCK();\n\n\t/*\n\t * We may need to kick off the group commit\n\t */\n\tjfs_flush_journal(log, 0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\n\nvoid txQuiesce(struct super_block *sb)\n{\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\ttid_t tid;\n\n\tset_bit(log_QUIESCE, &log->flag);\n\n\tTXN_LOCK();\nrestart:\n\twhile (!list_empty(&TxAnchor.anon_list)) {\n\t\tjfs_ip = list_entry(TxAnchor.anon_list.next,\n\t\t\t\t    struct jfs_inode_info,\n\t\t\t\t    anon_inode_list);\n\t\tip = &jfs_ip->vfs_inode;\n\n\t\t/*\n\t\t * inode will be removed from anonymous list\n\t\t * when it is committed\n\t\t */\n\t\tTXN_UNLOCK();\n\t\ttid = txBegin(ip->i_sb, COMMIT_INODE | COMMIT_FORCE);\n\t\tmutex_lock(&jfs_ip->commit_mutex);\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&jfs_ip->commit_mutex);\n\t\t/*\n\t\t * Just to be safe.  I don't know how\n\t\t * long we can run without blocking\n\t\t */\n\t\tcond_resched();\n\t\tTXN_LOCK();\n\t}\n\n\t/*\n\t * If jfs_sync is running in parallel, there could be some inodes\n\t * on anon_list2.  Let's check.\n\t */\n\tif (!list_empty(&TxAnchor.anon_list2)) {\n\t\tlist_splice(&TxAnchor.anon_list2, &TxAnchor.anon_list);\n\t\tINIT_LIST_HEAD(&TxAnchor.anon_list2);\n\t\tgoto restart;\n\t}\n\tTXN_UNLOCK();\n\n\t/*\n\t * We may need to kick off the group commit\n\t */\n\tjfs_flush_journal(log, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "t64",
            "BITSPERPAGE"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isReadOnly",
          "args": [
            "ipbmap"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "isReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "222-227",
          "snippet": "static inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "bh"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "newLVSize - 1"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "&sbi->fsckpxd"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&sbi->fsckpxd"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\n#define MEGABYTE32\t(MEGABYTE << 5)\n#define MEGABYTE\t(1 << L2MEGABYTE)\n#define BITSPERPAGE\t(PSIZE << 3)\n\nint jfs_extendfs(struct super_block *sb, s64 newLVSize, int newLogSize)\n{\n\tint rc = 0;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct inode *ipbmap2;\n\tstruct inode *ipimap = sbi->ipimap;\n\tstruct jfs_log *log = sbi->log;\n\tstruct bmap *bmp = sbi->bmap;\n\ts64 newLogAddress, newFSCKAddress;\n\tint newFSCKSize;\n\ts64 newMapSize = 0, mapSize;\n\ts64 XAddress, XSize, nblocks, xoff, xaddr, t64;\n\ts64 oldLVSize;\n\ts64 newFSSize;\n\ts64 VolumeSize;\n\tint newNpages = 0, nPages, newPage, xlen, t32;\n\tint tid;\n\tint log_formatted = 0;\n\tstruct inode *iplist[1];\n\tstruct jfs_superblock *j_sb, *j_sb2;\n\ts64 old_agsize;\n\tint agsizechanged = 0;\n\tstruct buffer_head *bh, *bh2;\n\n\t/* If the volume hasn't grown, get out now */\n\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\toldLVSize = addressPXD(&sbi->logpxd) + lengthPXD(&sbi->logpxd);\n\telse\n\t\toldLVSize = addressPXD(&sbi->fsckpxd) +\n\t\t    lengthPXD(&sbi->fsckpxd);\n\n\tif (oldLVSize >= newLVSize) {\n\t\tprintk(KERN_WARNING\n\t\t       \"jfs_extendfs: volume hasn't grown, returning\\n\");\n\t\tgoto out;\n\t}\n\n\tVolumeSize = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\n\tif (VolumeSize) {\n\t\tif (newLVSize > VolumeSize) {\n\t\t\tprintk(KERN_WARNING \"jfs_extendfs: invalid size\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* check the device */\n\t\tbh = sb_bread(sb, newLVSize - 1);\n\t\tif (!bh) {\n\t\t\tprintk(KERN_WARNING \"jfs_extendfs: invalid size\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbforget(bh);\n\t}\n\n\t/* Can't extend write-protected drive */\n\n\tif (isReadOnly(ipbmap)) {\n\t\tprintk(KERN_WARNING \"jfs_extendfs: read-only file system\\n\");\n\t\trc = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\treconfigure LV spaces\n\t *\t---------------------\n\t *\n\t * validate new size, or, if not specified, determine new size\n\t */\n\n\t/*\n\t * reconfigure inline log space:\n\t */\n\tif ((sbi->mntflag & JFS_INLINELOG)) {\n\t\tif (newLogSize == 0) {\n\t\t\t/*\n\t\t\t * no size specified: default to 1/256 of aggregate\n\t\t\t * size; rounded up to a megabyte boundary;\n\t\t\t */\n\t\t\tnewLogSize = newLVSize >> 8;\n\t\t\tt32 = (1 << (20 - sbi->l2bsize)) - 1;\n\t\t\tnewLogSize = (newLogSize + t32) & ~t32;\n\t\t\tnewLogSize =\n\t\t\t    min(newLogSize, MEGABYTE32 >> sbi->l2bsize);\n\t\t} else {\n\t\t\t/*\n\t\t\t * convert the newLogSize to fs blocks.\n\t\t\t *\n\t\t\t * Since this is given in megabytes, it will always be\n\t\t\t * an even number of pages.\n\t\t\t */\n\t\t\tnewLogSize = (newLogSize * MEGABYTE) >> sbi->l2bsize;\n\t\t}\n\n\t} else\n\t\tnewLogSize = 0;\n\n\tnewLogAddress = newLVSize - newLogSize;\n\n\t/*\n\t * reconfigure fsck work space:\n\t *\n\t * configure it to the end of the logical volume regardless of\n\t * whether file system extends to the end of the aggregate;\n\t * Need enough 4k pages to cover:\n\t *  - 1 bit per block in aggregate rounded up to BPERDMAP boundary\n\t *  - 1 extra page to handle control page and intermediate level pages\n\t *  - 50 extra pages for the chkdsk service log\n\t */\n\tt64 = ((newLVSize - newLogSize + BPERDMAP - 1) >> L2BPERDMAP)\n\t    << L2BPERDMAP;\n\tt32 = DIV_ROUND_UP(t64, BITSPERPAGE) + 1 + 50;\n\tnewFSCKSize = t32 << sbi->l2nbperpage;\n\tnewFSCKAddress = newLogAddress - newFSCKSize;\n\n\t/*\n\t * compute new file system space;\n\t */\n\tnewFSSize = newLVSize - newLogSize - newFSCKSize;\n\n\t/* file system cannot be shrunk */\n\tif (newFSSize < bmp->db_mapsize) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we're expanding enough that the inline log does not overlap\n\t * the old one, we can format the new log before we quiesce the\n\t * filesystem.\n\t */\n\tif ((sbi->mntflag & JFS_INLINELOG) && (newLogAddress > oldLVSize)) {\n\t\tif ((rc = lmLogFormat(log, newLogAddress, newLogSize)))\n\t\t\tgoto out;\n\t\tlog_formatted = 1;\n\t}\n\t/*\n\t *\tquiesce file system\n\t *\n\t * (prepare to move the inline log and to prevent map update)\n\t *\n\t * block any new transactions and wait for completion of\n\t * all wip transactions and flush modified pages s.t.\n\t * on-disk file system is in consistent state and\n\t * log is not required for recovery.\n\t */\n\ttxQuiesce(sb);\n\n\t/* Reset size of direct inode */\n\tsbi->direct_inode->i_size =  sb->s_bdev->bd_inode->i_size;\n\n\tif (sbi->mntflag & JFS_INLINELOG) {\n\t\t/*\n\t\t * deactivate old inline log\n\t\t */\n\t\tlmLogShutdown(log);\n\n\t\t/*\n\t\t * mark on-disk super block for fs in transition;\n\t\t *\n\t\t * update on-disk superblock for the new space configuration\n\t\t * of inline log space and fsck work space descriptors:\n\t\t * N.B. FS descriptor is NOT updated;\n\t\t *\n\t\t * crash recovery:\n\t\t * logredo(): if FM_EXTENDFS, return to fsck() for cleanup;\n\t\t * fsck(): if FM_EXTENDFS, reformat inline log and fsck\n\t\t * workspace from superblock inline log descriptor and fsck\n\t\t * workspace descriptor;\n\t\t */\n\n\t\t/* read in superblock */\n\t\tif ((rc = readSuper(sb, &bh)))\n\t\t\tgoto error_out;\n\t\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t\t/* mark extendfs() in progress */\n\t\tj_sb->s_state |= cpu_to_le32(FM_EXTENDFS);\n\t\tj_sb->s_xsize = cpu_to_le64(newFSSize);\n\t\tPXDaddress(&j_sb->s_xfsckpxd, newFSCKAddress);\n\t\tPXDlength(&j_sb->s_xfsckpxd, newFSCKSize);\n\t\tPXDaddress(&j_sb->s_xlogpxd, newLogAddress);\n\t\tPXDlength(&j_sb->s_xlogpxd, newLogSize);\n\n\t\t/* synchronously update superblock */\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\n\t\t/*\n\t\t * format new inline log synchronously;\n\t\t *\n\t\t * crash recovery: if log move in progress,\n\t\t * reformat log and exit success;\n\t\t */\n\t\tif (!log_formatted)\n\t\t\tif ((rc = lmLogFormat(log, newLogAddress, newLogSize)))\n\t\t\t\tgoto error_out;\n\n\t\t/*\n\t\t * activate new log\n\t\t */\n\t\tlog->base = newLogAddress;\n\t\tlog->size = newLogSize >> (L2LOGPSIZE - sb->s_blocksize_bits);\n\t\tif ((rc = lmLogInit(log)))\n\t\t\tgoto error_out;\n\t}\n\n\t/*\n\t *\textend block allocation map\n\t *\t---------------------------\n\t *\n\t * extendfs() for new extension, retry after crash recovery;\n\t *\n\t * note: both logredo() and fsck() rebuild map from\n\t * the bitmap and configuration parameter from superblock\n\t * (disregarding all other control information in the map);\n\t *\n\t * superblock:\n\t *  s_size: aggregate size in physical blocks;\n\t */\n\t/*\n\t *\tcompute the new block allocation map configuration\n\t *\n\t * map dinode:\n\t *  di_size: map file size in byte;\n\t *  di_nblocks: number of blocks allocated for map file;\n\t *  di_mapsize: number of blocks in aggregate (covered by map);\n\t * map control page:\n\t *  db_mapsize: number of blocks in aggregate (covered by map);\n\t */\n\tnewMapSize = newFSSize;\n\t/* number of data pages of new bmap file:\n\t * roundup new size to full dmap page boundary and\n\t * add 1 extra dmap page for next extendfs()\n\t */\n\tt64 = (newMapSize - 1) + BPERDMAP;\n\tnewNpages = BLKTODMAPN(t64) + 1;\n\n\t/*\n\t *\textend map from current map (WITHOUT growing mapfile)\n\t *\n\t * map new extension with unmapped part of the last partial\n\t * dmap page, if applicable, and extra page(s) allocated\n\t * at end of bmap by mkfs() or previous extendfs();\n\t */\n      extendBmap:\n\t/* compute number of blocks requested to extend */\n\tmapSize = bmp->db_mapsize;\n\tXAddress = mapSize;\t/* eXtension Address */\n\tXSize = newMapSize - mapSize;\t/* eXtension Size */\n\told_agsize = bmp->db_agsize;\t/* We need to know if this changes */\n\n\t/* compute number of blocks that can be extended by current mapfile */\n\tt64 = dbMapFileSizeToMapSize(ipbmap);\n\tif (mapSize > t64) {\n\t\tprintk(KERN_ERR \"jfs_extendfs: mapSize (0x%Lx) > t64 (0x%Lx)\\n\",\n\t\t       (long long) mapSize, (long long) t64);\n\t\trc = -EIO;\n\t\tgoto error_out;\n\t}\n\tnblocks = min(t64 - mapSize, XSize);\n\n\t/*\n\t * update map pages for new extension:\n\t *\n\t * update/init dmap and bubble up the control hierarchy\n\t * incrementally fold up dmaps into upper levels;\n\t * update bmap control page;\n\t */\n\tif ((rc = dbExtendFS(ipbmap, XAddress, nblocks)))\n\t\tgoto error_out;\n\n\tagsizechanged |= (bmp->db_agsize != old_agsize);\n\n\t/*\n\t * the map now has extended to cover additional nblocks:\n\t * dn_mapsize = oldMapsize + nblocks;\n\t */\n\t/* ipbmap->i_mapsize += nblocks; */\n\tXSize -= nblocks;\n\n\t/*\n\t *\tgrow map file to cover remaining extension\n\t *\tand/or one extra dmap page for next extendfs();\n\t *\n\t * allocate new map pages and its backing blocks, and\n\t * update map file xtree\n\t */\n\t/* compute number of data pages of current bmap file */\n\tnPages = ipbmap->i_size >> L2PSIZE;\n\n\t/* need to grow map file ? */\n\tif (nPages == newNpages)\n\t\tgoto finalizeBmap;\n\n\t/*\n\t * grow bmap file for the new map pages required:\n\t *\n\t * allocate growth at the start of newly extended region;\n\t * bmap file only grows sequentially, i.e., both data pages\n\t * and possibly xtree index pages may grow in append mode,\n\t * s.t. logredo() can reconstruct pre-extension state\n\t * by washing away bmap file of pages outside s_size boundary;\n\t */\n\t/*\n\t * journal map file growth as if a regular file growth:\n\t * (note: bmap is created with di_mode = IFJOURNAL|IFREG);\n\t *\n\t * journaling of bmap file growth is not required since\n\t * logredo() do/can not use log records of bmap file growth\n\t * but it provides careful write semantics, pmap update, etc.;\n\t */\n\t/* synchronous write of data pages: bmap data pages are\n\t * cached in meta-data cache, and not written out\n\t * by txCommit();\n\t */\n\tfilemap_fdatawait(ipbmap->i_mapping);\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\tdiWriteSpecial(ipbmap, 0);\n\n\tnewPage = nPages;\t/* first new page number */\n\txoff = newPage << sbi->l2nbperpage;\n\txlen = (newNpages - nPages) << sbi->l2nbperpage;\n\txlen = min(xlen, (int) nblocks) & ~(sbi->nbperpage - 1);\n\txaddr = XAddress;\n\n\ttid = txBegin(sb, COMMIT_FORCE);\n\n\tif ((rc = xtAppend(tid, ipbmap, 0, xoff, nblocks, &xlen, &xaddr, 0))) {\n\t\ttxEnd(tid);\n\t\tgoto error_out;\n\t}\n\t/* update bmap file size */\n\tipbmap->i_size += xlen << sbi->l2bsize;\n\tinode_add_bytes(ipbmap, xlen << sbi->l2bsize);\n\n\tiplist[0] = ipbmap;\n\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\ttxEnd(tid);\n\n\tif (rc)\n\t\tgoto error_out;\n\n\t/*\n\t * map file has been grown now to cover extension to further out;\n\t * di_size = new map file size;\n\t *\n\t * if huge extension, the previous extension based on previous\n\t * map file size may not have been sufficient to cover whole extension\n\t * (it could have been used up for new map pages),\n\t * but the newly grown map file now covers lot bigger new free space\n\t * available for further extension of map;\n\t */\n\t/* any more blocks to extend ? */\n\tif (XSize)\n\t\tgoto extendBmap;\n\n      finalizeBmap:\n\t/* finalize bmap */\n\tdbFinalizeBmap(ipbmap);\n\n\t/*\n\t *\tupdate inode allocation map\n\t *\t---------------------------\n\t *\n\t * move iag lists from old to new iag;\n\t * agstart field is not updated for logredo() to reconstruct\n\t * iag lists if system crash occurs.\n\t * (computation of ag number from agstart based on agsize\n\t * will correctly identify the new ag);\n\t */\n\t/* if new AG size the same as old AG size, done! */\n\tif (agsizechanged) {\n\t\tif ((rc = diExtendFS(ipimap, ipbmap)))\n\t\t\tgoto error_out;\n\n\t\t/* finalize imap */\n\t\tif ((rc = diSync(ipimap)))\n\t\t\tgoto error_out;\n\t}\n\n\t/*\n\t *\tfinalize\n\t *\t--------\n\t *\n\t * extension is committed when on-disk super block is\n\t * updated with new descriptors: logredo will recover\n\t * crash before it to pre-extension state;\n\t */\n\n\t/* sync log to skip log replay of bmap file growth transaction; */\n\t/* lmLogSync(log, 1); */\n\n\t/*\n\t * synchronous write bmap global control page;\n\t * for crash before completion of write\n\t * logredo() will recover to pre-extendfs state;\n\t * for crash after completion of write,\n\t * logredo() will recover post-extendfs state;\n\t */\n\tif ((rc = dbSync(ipbmap)))\n\t\tgoto error_out;\n\n\t/*\n\t * copy primary bmap inode to secondary bmap inode\n\t */\n\n\tipbmap2 = diReadSpecial(sb, BMAP_I, 1);\n\tif (ipbmap2 == NULL) {\n\t\tprintk(KERN_ERR \"jfs_extendfs: diReadSpecial(bmap) failed\\n\");\n\t\tgoto error_out;\n\t}\n\tmemcpy(&JFS_IP(ipbmap2)->i_xtroot, &JFS_IP(ipbmap)->i_xtroot, 288);\n\tipbmap2->i_size = ipbmap->i_size;\n\tipbmap2->i_blocks = ipbmap->i_blocks;\n\n\tdiWriteSpecial(ipbmap2, 1);\n\tdiFreeSpecial(ipbmap2);\n\n\t/*\n\t *\tupdate superblock\n\t */\n\tif ((rc = readSuper(sb, &bh)))\n\t\tgoto error_out;\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t/* mark extendfs() completion */\n\tj_sb->s_state &= cpu_to_le32(~FM_EXTENDFS);\n\tj_sb->s_size = cpu_to_le64(bmp->db_mapsize <<\n\t\t\t\t   le16_to_cpu(j_sb->s_l2bfactor));\n\tj_sb->s_agsize = cpu_to_le32(bmp->db_agsize);\n\n\t/* update inline log space descriptor */\n\tif (sbi->mntflag & JFS_INLINELOG) {\n\t\tPXDaddress(&(j_sb->s_logpxd), newLogAddress);\n\t\tPXDlength(&(j_sb->s_logpxd), newLogSize);\n\t}\n\n\t/* record log's mount serial number */\n\tj_sb->s_logserial = cpu_to_le32(log->serial);\n\n\t/* update fsck work space descriptor */\n\tPXDaddress(&(j_sb->s_fsckpxd), newFSCKAddress);\n\tPXDlength(&(j_sb->s_fsckpxd), newFSCKSize);\n\tj_sb->s_fscklog = 1;\n\t/* sb->s_fsckloglen remains the same */\n\n\t/* Update secondary superblock */\n\tbh2 = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (bh2) {\n\t\tj_sb2 = (struct jfs_superblock *)bh2->b_data;\n\t\tmemcpy(j_sb2, j_sb, sizeof (struct jfs_superblock));\n\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh2);\n\t\tbrelse(bh2);\n\t}\n\n\t/* write primary superblock */\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\tgoto resume;\n\n      error_out:\n\tjfs_error(sb, \"\\n\");\n\n      resume:\n\t/*\n\t *\tresume file system transactions\n\t */\n\ttxResume(sb);\n\n      out:\n\treturn rc;\n}"
  }
]