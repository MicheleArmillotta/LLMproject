[
  {
    "function_name": "exit_hostfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "1006-1009",
    "snippet": "static void __exit exit_hostfs(void)\n{\n\tunregister_filesystem(&hostfs_type);\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type hostfs_type = {\n\t.owner \t\t= THIS_MODULE,\n\t.name \t\t= \"hostfs\",\n\t.mount\t \t= hostfs_read_sb,\n\t.kill_sb\t= hostfs_kill_sb,\n\t.fs_flags \t= 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&hostfs_type"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic struct file_system_type hostfs_type = {\n\t.owner \t\t= THIS_MODULE,\n\t.name \t\t= \"hostfs\",\n\t.mount\t \t= hostfs_read_sb,\n\t.kill_sb\t= hostfs_kill_sb,\n\t.fs_flags \t= 0,\n};\n\nstatic void __exit exit_hostfs(void)\n{\n\tunregister_filesystem(&hostfs_type);\n}"
  },
  {
    "function_name": "init_hostfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "1001-1004",
    "snippet": "static int __init init_hostfs(void)\n{\n\treturn register_filesystem(&hostfs_type);\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type hostfs_type = {\n\t.owner \t\t= THIS_MODULE,\n\t.name \t\t= \"hostfs\",\n\t.mount\t \t= hostfs_read_sb,\n\t.kill_sb\t= hostfs_kill_sb,\n\t.fs_flags \t= 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&hostfs_type"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic struct file_system_type hostfs_type = {\n\t.owner \t\t= THIS_MODULE,\n\t.name \t\t= \"hostfs\",\n\t.mount\t \t= hostfs_read_sb,\n\t.kill_sb\t= hostfs_kill_sb,\n\t.fs_flags \t= 0,\n};\n\nstatic int __init init_hostfs(void)\n{\n\treturn register_filesystem(&hostfs_type);\n}"
  },
  {
    "function_name": "hostfs_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "986-990",
    "snippet": "static void hostfs_kill_sb(struct super_block *s)\n{\n\tkill_anon_super(s);\n\tkfree(s->s_fs_info);\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s->s_fs_info"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_anon_super",
          "args": [
            "s"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic void hostfs_kill_sb(struct super_block *s)\n{\n\tkill_anon_super(s);\n\tkfree(s->s_fs_info);\n}"
  },
  {
    "function_name": "hostfs_read_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "979-984",
    "snippet": "static struct dentry *hostfs_read_sb(struct file_system_type *type,\n\t\t\t  int flags, const char *dev_name,\n\t\t\t  void *data)\n{\n\treturn mount_nodev(type, flags, data, hostfs_fill_sb_common);\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_nodev",
          "args": [
            "type",
            "flags",
            "data",
            "hostfs_fill_sb_common"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic struct dentry *hostfs_read_sb(struct file_system_type *type,\n\t\t\t  int flags, const char *dev_name,\n\t\t\t  void *data)\n{\n\treturn mount_nodev(type, flags, data, hostfs_fill_sb_common);\n}"
  },
  {
    "function_name": "hostfs_fill_sb_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "922-977",
    "snippet": "static int hostfs_fill_sb_common(struct super_block *sb, void *d, int silent)\n{\n\tstruct inode *root_inode;\n\tchar *host_root_path, *req_root = d;\n\tint err;\n\n\tsb->s_blocksize = 1024;\n\tsb->s_blocksize_bits = 10;\n\tsb->s_magic = HOSTFS_SUPER_MAGIC;\n\tsb->s_op = &hostfs_sbops;\n\tsb->s_d_op = &simple_dentry_operations;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\n\t/* NULL is printed as <NULL> by sprintf: avoid that. */\n\tif (req_root == NULL)\n\t\treq_root = \"\";\n\n\terr = -ENOMEM;\n\tsb->s_fs_info = host_root_path =\n\t\tkmalloc(strlen(root_ino) + strlen(req_root) + 2, GFP_KERNEL);\n\tif (host_root_path == NULL)\n\t\tgoto out;\n\n\tsprintf(host_root_path, \"%s/%s\", root_ino, req_root);\n\n\troot_inode = new_inode(sb);\n\tif (!root_inode)\n\t\tgoto out;\n\n\terr = read_name(root_inode, host_root_path);\n\tif (err)\n\t\tgoto out_put;\n\n\tif (S_ISLNK(root_inode->i_mode)) {\n\t\tchar *name = follow_link(host_root_path);\n\t\tif (IS_ERR(name))\n\t\t\terr = PTR_ERR(name);\n\t\telse\n\t\t\terr = read_name(root_inode, name);\n\t\tkfree(name);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t}\n\n\terr = -ENOMEM;\n\tsb->s_root = d_make_root(root_inode);\n\tif (sb->s_root == NULL)\n\t\tgoto out;\n\n\treturn 0;\n\nout_put:\n\tiput(root_inode);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *root_ino = \"\";",
      "static const struct super_operations hostfs_sbops = {\n\t.alloc_inode\t= hostfs_alloc_inode,\n\t.destroy_inode\t= hostfs_destroy_inode,\n\t.evict_inode\t= hostfs_evict_inode,\n\t.statfs\t\t= hostfs_statfs,\n\t.show_options\t= hostfs_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "root_inode"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root_inode"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_name",
          "args": [
            "root_inode",
            "name"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "read_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "507-551",
          "snippet": "static int read_name(struct inode *ino, char *name)\n{\n\tdev_t rdev;\n\tstruct hostfs_stat st;\n\tint err = stat_file(name, &st, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* Reencode maj and min with the kernel encoding.*/\n\trdev = MKDEV(st.maj, st.min);\n\n\tswitch (st.mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tino->i_op = &hostfs_link_iops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tino->i_op = &hostfs_dir_iops;\n\t\tino->i_fop = &hostfs_dir_fops;\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(ino, st.mode & S_IFMT, rdev);\n\t\tino->i_op = &hostfs_iops;\n\t\tbreak;\n\n\tdefault:\n\t\tino->i_op = &hostfs_iops;\n\t\tino->i_fop = &hostfs_file_fops;\n\t\tino->i_mapping->a_ops = &hostfs_aops;\n\t}\n\n\tino->i_ino = st.ino;\n\tino->i_mode = st.mode;\n\tset_nlink(ino, st.nlink);\n\ti_uid_write(ino, st.uid);\n\ti_gid_write(ino, st.gid);\n\tino->i_atime = st.atime;\n\tino->i_mtime = st.mtime;\n\tino->i_ctime = st.ctime;\n\tino->i_size = st.size;\n\tino->i_blocks = st.blocks;\n\treturn 0;\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations hostfs_iops;",
            "static const struct inode_operations hostfs_dir_iops;",
            "static const struct inode_operations hostfs_link_iops;",
            "static const struct file_operations hostfs_file_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.splice_read\t= generic_file_splice_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.write\t\t= new_sync_write,\n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= hostfs_file_open,\n\t.release\t= hostfs_file_release,\n\t.fsync\t\t= hostfs_fsync,\n};",
            "static const struct file_operations hostfs_dir_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate\t= hostfs_readdir,\n\t.read\t\t= generic_read_dir,\n};",
            "static const struct address_space_operations hostfs_aops = {\n\t.writepage \t= hostfs_writepage,\n\t.readpage\t= hostfs_readpage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n\t.write_begin\t= hostfs_write_begin,\n\t.write_end\t= hostfs_write_end,\n};",
            "static const struct inode_operations hostfs_iops = {\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};",
            "static const struct inode_operations hostfs_dir_iops = {\n\t.create\t\t= hostfs_create,\n\t.lookup\t\t= hostfs_lookup,\n\t.link\t\t= hostfs_link,\n\t.unlink\t\t= hostfs_unlink,\n\t.symlink\t= hostfs_symlink,\n\t.mkdir\t\t= hostfs_mkdir,\n\t.rmdir\t\t= hostfs_rmdir,\n\t.mknod\t\t= hostfs_mknod,\n\t.rename2\t= hostfs_rename2,\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};",
            "static const struct inode_operations hostfs_link_iops = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= hostfs_follow_link,\n\t.put_link\t= hostfs_put_link,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations hostfs_iops;\nstatic const struct inode_operations hostfs_dir_iops;\nstatic const struct inode_operations hostfs_link_iops;\nstatic const struct file_operations hostfs_file_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.splice_read\t= generic_file_splice_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.write\t\t= new_sync_write,\n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= hostfs_file_open,\n\t.release\t= hostfs_file_release,\n\t.fsync\t\t= hostfs_fsync,\n};\nstatic const struct file_operations hostfs_dir_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate\t= hostfs_readdir,\n\t.read\t\t= generic_read_dir,\n};\nstatic const struct address_space_operations hostfs_aops = {\n\t.writepage \t= hostfs_writepage,\n\t.readpage\t= hostfs_readpage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n\t.write_begin\t= hostfs_write_begin,\n\t.write_end\t= hostfs_write_end,\n};\nstatic const struct inode_operations hostfs_iops = {\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};\nstatic const struct inode_operations hostfs_dir_iops = {\n\t.create\t\t= hostfs_create,\n\t.lookup\t\t= hostfs_lookup,\n\t.link\t\t= hostfs_link,\n\t.unlink\t\t= hostfs_unlink,\n\t.symlink\t= hostfs_symlink,\n\t.mkdir\t\t= hostfs_mkdir,\n\t.rmdir\t\t= hostfs_rmdir,\n\t.mknod\t\t= hostfs_mknod,\n\t.rename2\t= hostfs_rename2,\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};\nstatic const struct inode_operations hostfs_link_iops = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= hostfs_follow_link,\n\t.put_link\t= hostfs_put_link,\n};\n\nstatic int read_name(struct inode *ino, char *name)\n{\n\tdev_t rdev;\n\tstruct hostfs_stat st;\n\tint err = stat_file(name, &st, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* Reencode maj and min with the kernel encoding.*/\n\trdev = MKDEV(st.maj, st.min);\n\n\tswitch (st.mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tino->i_op = &hostfs_link_iops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tino->i_op = &hostfs_dir_iops;\n\t\tino->i_fop = &hostfs_dir_fops;\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(ino, st.mode & S_IFMT, rdev);\n\t\tino->i_op = &hostfs_iops;\n\t\tbreak;\n\n\tdefault:\n\t\tino->i_op = &hostfs_iops;\n\t\tino->i_fop = &hostfs_file_fops;\n\t\tino->i_mapping->a_ops = &hostfs_aops;\n\t}\n\n\tino->i_ino = st.ino;\n\tino->i_mode = st.mode;\n\tset_nlink(ino, st.nlink);\n\ti_uid_write(ino, st.uid);\n\ti_gid_write(ino, st.gid);\n\tino->i_atime = st.atime;\n\tino->i_mtime = st.mtime;\n\tino->i_ctime = st.ctime;\n\tino->i_size = st.size;\n\tino->i_blocks = st.blocks;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "name"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "name"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_link",
          "args": [
            "host_root_path"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "follow_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "133-179",
          "snippet": "static char *follow_link(char *link)\n{\n\tint len, n;\n\tchar *name, *resolved, *end;\n\n\tlen = 64;\n\twhile (1) {\n\t\tn = -ENOMEM;\n\t\tname = kmalloc(len, GFP_KERNEL);\n\t\tif (name == NULL)\n\t\t\tgoto out;\n\n\t\tn = hostfs_do_readlink(link, name, len);\n\t\tif (n < len)\n\t\t\tbreak;\n\t\tlen *= 2;\n\t\tkfree(name);\n\t}\n\tif (n < 0)\n\t\tgoto out_free;\n\n\tif (*name == '/')\n\t\treturn name;\n\n\tend = strrchr(link, '/');\n\tif (end == NULL)\n\t\treturn name;\n\n\t*(end + 1) = '\\0';\n\tlen = strlen(link) + strlen(name) + 1;\n\n\tresolved = kmalloc(len, GFP_KERNEL);\n\tif (resolved == NULL) {\n\t\tn = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tsprintf(resolved, \"%s%s\", link, name);\n\tkfree(name);\n\tkfree(link);\n\treturn resolved;\n\n out_free:\n\tkfree(name);\n out:\n\treturn ERR_PTR(n);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *follow_link(char *link)\n{\n\tint len, n;\n\tchar *name, *resolved, *end;\n\n\tlen = 64;\n\twhile (1) {\n\t\tn = -ENOMEM;\n\t\tname = kmalloc(len, GFP_KERNEL);\n\t\tif (name == NULL)\n\t\t\tgoto out;\n\n\t\tn = hostfs_do_readlink(link, name, len);\n\t\tif (n < len)\n\t\t\tbreak;\n\t\tlen *= 2;\n\t\tkfree(name);\n\t}\n\tif (n < 0)\n\t\tgoto out_free;\n\n\tif (*name == '/')\n\t\treturn name;\n\n\tend = strrchr(link, '/');\n\tif (end == NULL)\n\t\treturn name;\n\n\t*(end + 1) = '\\0';\n\tlen = strlen(link) + strlen(name) + 1;\n\n\tresolved = kmalloc(len, GFP_KERNEL);\n\tif (resolved == NULL) {\n\t\tn = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tsprintf(resolved, \"%s%s\", link, name);\n\tkfree(name);\n\tkfree(link);\n\treturn resolved;\n\n out_free:\n\tkfree(name);\n out:\n\treturn ERR_PTR(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "root_inode->i_mode"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "host_root_path",
            "\"%s/%s\"",
            "root_ino",
            "req_root"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1609-1628",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "strlen(root_ino) + strlen(req_root) + 2",
            "GFP_KERNEL"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "req_root"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *root_ino = \"\";\nstatic const struct super_operations hostfs_sbops = {\n\t.alloc_inode\t= hostfs_alloc_inode,\n\t.destroy_inode\t= hostfs_destroy_inode,\n\t.evict_inode\t= hostfs_evict_inode,\n\t.statfs\t\t= hostfs_statfs,\n\t.show_options\t= hostfs_show_options,\n};\n\nstatic int hostfs_fill_sb_common(struct super_block *sb, void *d, int silent)\n{\n\tstruct inode *root_inode;\n\tchar *host_root_path, *req_root = d;\n\tint err;\n\n\tsb->s_blocksize = 1024;\n\tsb->s_blocksize_bits = 10;\n\tsb->s_magic = HOSTFS_SUPER_MAGIC;\n\tsb->s_op = &hostfs_sbops;\n\tsb->s_d_op = &simple_dentry_operations;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\n\t/* NULL is printed as <NULL> by sprintf: avoid that. */\n\tif (req_root == NULL)\n\t\treq_root = \"\";\n\n\terr = -ENOMEM;\n\tsb->s_fs_info = host_root_path =\n\t\tkmalloc(strlen(root_ino) + strlen(req_root) + 2, GFP_KERNEL);\n\tif (host_root_path == NULL)\n\t\tgoto out;\n\n\tsprintf(host_root_path, \"%s/%s\", root_ino, req_root);\n\n\troot_inode = new_inode(sb);\n\tif (!root_inode)\n\t\tgoto out;\n\n\terr = read_name(root_inode, host_root_path);\n\tif (err)\n\t\tgoto out_put;\n\n\tif (S_ISLNK(root_inode->i_mode)) {\n\t\tchar *name = follow_link(host_root_path);\n\t\tif (IS_ERR(name))\n\t\t\terr = PTR_ERR(name);\n\t\telse\n\t\t\terr = read_name(root_inode, name);\n\t\tkfree(name);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t}\n\n\terr = -ENOMEM;\n\tsb->s_root = d_make_root(root_inode);\n\tif (sb->s_root == NULL)\n\t\tgoto out;\n\n\treturn 0;\n\nout_put:\n\tiput(root_inode);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "hostfs_put_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "909-914",
    "snippet": "static void hostfs_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)\n{\n\tchar *s = nd_get_link(nd);\n\tif (!IS_ERR(s))\n\t\t__putname(s);\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "s"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_get_link",
          "args": [
            "nd"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "nd_get_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "723-726",
          "snippet": "char *nd_get_link(struct nameidata *nd)\n{\n\treturn nd->saved_names[nd->depth];\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nchar *nd_get_link(struct nameidata *nd)\n{\n\treturn nd->saved_names[nd->depth];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic void hostfs_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)\n{\n\tchar *s = nd_get_link(nd);\n\tif (!IS_ERR(s))\n\t\t__putname(s);\n}"
  },
  {
    "function_name": "hostfs_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "885-907",
    "snippet": "static void *hostfs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tchar *link = __getname();\n\tif (link) {\n\t\tchar *path = dentry_name(dentry);\n\t\tint err = -ENOMEM;\n\t\tif (path) {\n\t\t\terr = hostfs_do_readlink(path, link, PATH_MAX);\n\t\t\tif (err == PATH_MAX)\n\t\t\t\terr = -E2BIG;\n\t\t\t__putname(path);\n\t\t}\n\t\tif (err < 0) {\n\t\t\t__putname(link);\n\t\t\tlink = ERR_PTR(err);\n\t\t}\n\t} else {\n\t\tlink = ERR_PTR(-ENOMEM);\n\t}\n\n\tnd_set_link(nd, link);\n\treturn NULL;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "link"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "link"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "path"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostfs_do_readlink",
          "args": [
            "path",
            "link",
            "PATH_MAX"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "hostfs_do_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "342-352",
          "snippet": "int hostfs_do_readlink(char *file, char *buf, int size)\n{\n\tint n;\n\n\tn = readlink(file, buf, size);\n\tif (n < 0)\n\t\treturn -errno;\n\tif (n < size)\n\t\tbuf[n] = '\\0';\n\treturn n;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint hostfs_do_readlink(char *file, char *buf, int size)\n{\n\tint n;\n\n\tn = readlink(file, buf, size);\n\tif (n < 0)\n\t\treturn -errno;\n\tif (n < size)\n\t\tbuf[n] = '\\0';\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "dentry"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__getname",
          "args": [],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic void *hostfs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tchar *link = __getname();\n\tif (link) {\n\t\tchar *path = dentry_name(dentry);\n\t\tint err = -ENOMEM;\n\t\tif (path) {\n\t\t\terr = hostfs_do_readlink(path, link, PATH_MAX);\n\t\t\tif (err == PATH_MAX)\n\t\t\t\terr = -E2BIG;\n\t\t\t__putname(path);\n\t\t}\n\t\tif (err < 0) {\n\t\t\t__putname(link);\n\t\t\tlink = ERR_PTR(err);\n\t\t}\n\t} else {\n\t\tlink = ERR_PTR(-ENOMEM);\n\t}\n\n\tnd_set_link(nd, link);\n\treturn NULL;\n}"
  },
  {
    "function_name": "hostfs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "798-864",
    "snippet": "static int hostfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hostfs_iattr attrs;\n\tchar *name;\n\tint err;\n\n\tint fd = HOSTFS_I(inode)->fd;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (append)\n\t\tattr->ia_valid &= ~ATTR_SIZE;\n\n\tattrs.ia_valid = 0;\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_MODE;\n\t\tattrs.ia_mode = attr->ia_mode;\n\t}\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_UID;\n\t\tattrs.ia_uid = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_GID;\n\t\tattrs.ia_gid = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_SIZE;\n\t\tattrs.ia_size = attr->ia_size;\n\t}\n\tif (attr->ia_valid & ATTR_ATIME) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_ATIME;\n\t\tattrs.ia_atime = attr->ia_atime;\n\t}\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_MTIME;\n\t\tattrs.ia_mtime = attr->ia_mtime;\n\t}\n\tif (attr->ia_valid & ATTR_CTIME) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_CTIME;\n\t\tattrs.ia_ctime = attr->ia_ctime;\n\t}\n\tif (attr->ia_valid & ATTR_ATIME_SET) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_ATIME_SET;\n\t}\n\tif (attr->ia_valid & ATTR_MTIME_SET) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_MTIME_SET;\n\t}\n\tname = dentry_name(dentry);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\terr = set_attr(name, &attrs, fd);\n\t__putname(name);\n\tif (err)\n\t\treturn err;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, attr->ia_size);\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int append = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_attr",
          "args": [
            "name",
            "&attrs",
            "fd"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "set_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "199-280",
          "snippet": "int set_attr(const char *file, struct hostfs_iattr *attrs, int fd)\n{\n\tstruct hostfs_stat st;\n\tstruct timeval times[2];\n\tint err, ma;\n\n\tif (attrs->ia_valid & HOSTFS_ATTR_MODE) {\n\t\tif (fd >= 0) {\n\t\t\tif (fchmod(fd, attrs->ia_mode) != 0)\n\t\t\t\treturn -errno;\n\t\t} else if (chmod(file, attrs->ia_mode) != 0) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\tif (attrs->ia_valid & HOSTFS_ATTR_UID) {\n\t\tif (fd >= 0) {\n\t\t\tif (fchown(fd, attrs->ia_uid, -1))\n\t\t\t\treturn -errno;\n\t\t} else if (chown(file, attrs->ia_uid, -1)) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\tif (attrs->ia_valid & HOSTFS_ATTR_GID) {\n\t\tif (fd >= 0) {\n\t\t\tif (fchown(fd, -1, attrs->ia_gid))\n\t\t\t\treturn -errno;\n\t\t} else if (chown(file, -1, attrs->ia_gid)) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\tif (attrs->ia_valid & HOSTFS_ATTR_SIZE) {\n\t\tif (fd >= 0) {\n\t\t\tif (ftruncate(fd, attrs->ia_size))\n\t\t\t\treturn -errno;\n\t\t} else if (truncate(file, attrs->ia_size)) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\n\t/*\n\t * Update accessed and/or modified time, in two parts: first set\n\t * times according to the changes to perform, and then call futimes()\n\t * or utimes() to apply them.\n\t */\n\tma = (HOSTFS_ATTR_ATIME_SET | HOSTFS_ATTR_MTIME_SET);\n\tif (attrs->ia_valid & ma) {\n\t\terr = stat_file(file, &st, fd);\n\t\tif (err != 0)\n\t\t\treturn err;\n\n\t\ttimes[0].tv_sec = st.atime.tv_sec;\n\t\ttimes[0].tv_usec = st.atime.tv_nsec / 1000;\n\t\ttimes[1].tv_sec = st.mtime.tv_sec;\n\t\ttimes[1].tv_usec = st.mtime.tv_nsec / 1000;\n\n\t\tif (attrs->ia_valid & HOSTFS_ATTR_ATIME_SET) {\n\t\t\ttimes[0].tv_sec = attrs->ia_atime.tv_sec;\n\t\t\ttimes[0].tv_usec = attrs->ia_atime.tv_nsec / 1000;\n\t\t}\n\t\tif (attrs->ia_valid & HOSTFS_ATTR_MTIME_SET) {\n\t\t\ttimes[1].tv_sec = attrs->ia_mtime.tv_sec;\n\t\t\ttimes[1].tv_usec = attrs->ia_mtime.tv_nsec / 1000;\n\t\t}\n\n\t\tif (fd >= 0) {\n\t\t\tif (futimes(fd, times) != 0)\n\t\t\t\treturn -errno;\n\t\t} else if (utimes(file, times) != 0) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\n\t/* Note: ctime is not handled */\n\tif (attrs->ia_valid & (HOSTFS_ATTR_ATIME | HOSTFS_ATTR_MTIME)) {\n\t\terr = stat_file(file, &st, fd);\n\t\tattrs->ia_atime = st.atime;\n\t\tattrs->ia_mtime = st.mtime;\n\t\tif (err != 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint set_attr(const char *file, struct hostfs_iattr *attrs, int fd)\n{\n\tstruct hostfs_stat st;\n\tstruct timeval times[2];\n\tint err, ma;\n\n\tif (attrs->ia_valid & HOSTFS_ATTR_MODE) {\n\t\tif (fd >= 0) {\n\t\t\tif (fchmod(fd, attrs->ia_mode) != 0)\n\t\t\t\treturn -errno;\n\t\t} else if (chmod(file, attrs->ia_mode) != 0) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\tif (attrs->ia_valid & HOSTFS_ATTR_UID) {\n\t\tif (fd >= 0) {\n\t\t\tif (fchown(fd, attrs->ia_uid, -1))\n\t\t\t\treturn -errno;\n\t\t} else if (chown(file, attrs->ia_uid, -1)) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\tif (attrs->ia_valid & HOSTFS_ATTR_GID) {\n\t\tif (fd >= 0) {\n\t\t\tif (fchown(fd, -1, attrs->ia_gid))\n\t\t\t\treturn -errno;\n\t\t} else if (chown(file, -1, attrs->ia_gid)) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\tif (attrs->ia_valid & HOSTFS_ATTR_SIZE) {\n\t\tif (fd >= 0) {\n\t\t\tif (ftruncate(fd, attrs->ia_size))\n\t\t\t\treturn -errno;\n\t\t} else if (truncate(file, attrs->ia_size)) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\n\t/*\n\t * Update accessed and/or modified time, in two parts: first set\n\t * times according to the changes to perform, and then call futimes()\n\t * or utimes() to apply them.\n\t */\n\tma = (HOSTFS_ATTR_ATIME_SET | HOSTFS_ATTR_MTIME_SET);\n\tif (attrs->ia_valid & ma) {\n\t\terr = stat_file(file, &st, fd);\n\t\tif (err != 0)\n\t\t\treturn err;\n\n\t\ttimes[0].tv_sec = st.atime.tv_sec;\n\t\ttimes[0].tv_usec = st.atime.tv_nsec / 1000;\n\t\ttimes[1].tv_sec = st.mtime.tv_sec;\n\t\ttimes[1].tv_usec = st.mtime.tv_nsec / 1000;\n\n\t\tif (attrs->ia_valid & HOSTFS_ATTR_ATIME_SET) {\n\t\t\ttimes[0].tv_sec = attrs->ia_atime.tv_sec;\n\t\t\ttimes[0].tv_usec = attrs->ia_atime.tv_nsec / 1000;\n\t\t}\n\t\tif (attrs->ia_valid & HOSTFS_ATTR_MTIME_SET) {\n\t\t\ttimes[1].tv_sec = attrs->ia_mtime.tv_sec;\n\t\t\ttimes[1].tv_usec = attrs->ia_mtime.tv_nsec / 1000;\n\t\t}\n\n\t\tif (fd >= 0) {\n\t\t\tif (futimes(fd, times) != 0)\n\t\t\t\treturn -errno;\n\t\t} else if (utimes(file, times) != 0) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\n\t/* Note: ctime is not handled */\n\tif (attrs->ia_valid & (HOSTFS_ATTR_ATIME | HOSTFS_ATTR_MTIME)) {\n\t\terr = stat_file(file, &st, fd);\n\t\tattrs->ia_atime = st.atime;\n\t\tattrs->ia_mtime = st.mtime;\n\t\tif (err != 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "dentry"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "attr->ia_gid"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "attr->ia_uid"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HOSTFS_I",
          "args": [
            "inode"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "HOSTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "29-32",
          "snippet": "static inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int append = 0;\n\nstatic int hostfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hostfs_iattr attrs;\n\tchar *name;\n\tint err;\n\n\tint fd = HOSTFS_I(inode)->fd;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (append)\n\t\tattr->ia_valid &= ~ATTR_SIZE;\n\n\tattrs.ia_valid = 0;\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_MODE;\n\t\tattrs.ia_mode = attr->ia_mode;\n\t}\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_UID;\n\t\tattrs.ia_uid = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_GID;\n\t\tattrs.ia_gid = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_SIZE;\n\t\tattrs.ia_size = attr->ia_size;\n\t}\n\tif (attr->ia_valid & ATTR_ATIME) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_ATIME;\n\t\tattrs.ia_atime = attr->ia_atime;\n\t}\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_MTIME;\n\t\tattrs.ia_mtime = attr->ia_mtime;\n\t}\n\tif (attr->ia_valid & ATTR_CTIME) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_CTIME;\n\t\tattrs.ia_ctime = attr->ia_ctime;\n\t}\n\tif (attr->ia_valid & ATTR_ATIME_SET) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_ATIME_SET;\n\t}\n\tif (attr->ia_valid & ATTR_MTIME_SET) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_MTIME_SET;\n\t}\n\tname = dentry_name(dentry);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\terr = set_attr(name, &attrs, fd);\n\t__putname(name);\n\tif (err)\n\t\treturn err;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, attr->ia_size);\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "hostfs_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "772-796",
    "snippet": "static int hostfs_permission(struct inode *ino, int desired)\n{\n\tchar *name;\n\tint r = 0, w = 0, x = 0, err;\n\n\tif (desired & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tif (desired & MAY_READ) r = 1;\n\tif (desired & MAY_WRITE) w = 1;\n\tif (desired & MAY_EXEC) x = 1;\n\tname = inode_name(ino);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\n\tif (S_ISCHR(ino->i_mode) || S_ISBLK(ino->i_mode) ||\n\t    S_ISFIFO(ino->i_mode) || S_ISSOCK(ino->i_mode))\n\t\terr = 0;\n\telse\n\t\terr = access_file(name, r, w, x);\n\t__putname(name);\n\tif (!err)\n\t\terr = generic_permission(ino, desired);\n\treturn err;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "ino",
            "desired"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_file",
          "args": [
            "name",
            "r",
            "w",
            "x"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "access_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "55-68",
          "snippet": "int access_file(char *path, int r, int w, int x)\n{\n\tint mode = 0;\n\n\tif (r)\n\t\tmode = R_OK;\n\tif (w)\n\t\tmode |= W_OK;\n\tif (x)\n\t\tmode |= X_OK;\n\tif (access(path, mode) != 0)\n\t\treturn -errno;\n\telse return 0;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint access_file(char *path, int r, int w, int x)\n{\n\tint mode = 0;\n\n\tif (r)\n\t\tmode = R_OK;\n\tif (w)\n\t\tmode |= W_OK;\n\tif (x)\n\t\tmode |= X_OK;\n\tif (access(path, mode) != 0)\n\t\treturn -errno;\n\telse return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "ino->i_mode"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "ino->i_mode"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "ino->i_mode"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "ino->i_mode"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_name",
          "args": [
            "ino"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "117-131",
          "snippet": "static char *inode_name(struct inode *ino)\n{\n\tstruct dentry *dentry;\n\tchar *name;\n\n\tdentry = d_find_alias(ino);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tname = dentry_name(dentry);\n\n\tdput(dentry);\n\n\treturn name;\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *inode_name(struct inode *ino)\n{\n\tstruct dentry *dentry;\n\tchar *name;\n\n\tdentry = d_find_alias(ino);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tname = dentry_name(dentry);\n\n\tdput(dentry);\n\n\treturn name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_permission(struct inode *ino, int desired)\n{\n\tchar *name;\n\tint r = 0, w = 0, x = 0, err;\n\n\tif (desired & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tif (desired & MAY_READ) r = 1;\n\tif (desired & MAY_WRITE) w = 1;\n\tif (desired & MAY_EXEC) x = 1;\n\tname = inode_name(ino);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\n\tif (S_ISCHR(ino->i_mode) || S_ISBLK(ino->i_mode) ||\n\t    S_ISFIFO(ino->i_mode) || S_ISSOCK(ino->i_mode))\n\t\terr = 0;\n\telse\n\t\terr = access_file(name, r, w, x);\n\t__putname(name);\n\tif (!err)\n\t\terr = generic_permission(ino, desired);\n\treturn err;\n}"
  },
  {
    "function_name": "hostfs_rename2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "744-770",
    "snippet": "static int hostfs_rename2(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t  struct inode *new_dir, struct dentry *new_dentry,\n\t\t\t  unsigned int flags)\n{\n\tchar *old_name, *new_name;\n\tint err;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\told_name = dentry_name(old_dentry);\n\tif (old_name == NULL)\n\t\treturn -ENOMEM;\n\tnew_name = dentry_name(new_dentry);\n\tif (new_name == NULL) {\n\t\t__putname(old_name);\n\t\treturn -ENOMEM;\n\t}\n\tif (!flags)\n\t\terr = rename_file(old_name, new_name);\n\telse\n\t\terr = rename2_file(old_name, new_name, flags);\n\n\t__putname(old_name);\n\t__putname(new_name);\n\treturn err;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "new_name"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "old_name"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename2_file",
          "args": [
            "old_name",
            "new_name",
            "flags"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "rename2_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "364-389",
          "snippet": "int rename2_file(char *from, char *to, unsigned int flags)\n{\n\tint err;\n\n#ifndef SYS_renameat2\n#  ifdef __x86_64__\n#    define SYS_renameat2 316\n#  endif\n#  ifdef __i386__\n#    define SYS_renameat2 353\n#  endif\n#endif\n\n#ifdef SYS_renameat2\n\terr = syscall(SYS_renameat2, AT_FDCWD, from, AT_FDCWD, to, flags);\n\tif (err < 0) {\n\t\tif (errno != ENOSYS)\n\t\t\treturn -errno;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n#else\n\treturn -EINVAL;\n#endif\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint rename2_file(char *from, char *to, unsigned int flags)\n{\n\tint err;\n\n#ifndef SYS_renameat2\n#  ifdef __x86_64__\n#    define SYS_renameat2 316\n#  endif\n#  ifdef __i386__\n#    define SYS_renameat2 353\n#  endif\n#endif\n\n#ifdef SYS_renameat2\n\terr = syscall(SYS_renameat2, AT_FDCWD, from, AT_FDCWD, to, flags);\n\tif (err < 0) {\n\t\tif (errno != ENOSYS)\n\t\t\treturn -errno;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n#else\n\treturn -EINVAL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rename_file",
          "args": [
            "old_name",
            "new_name"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "rename_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "354-362",
          "snippet": "int rename_file(char *from, char *to)\n{\n\tint err;\n\n\terr = rename(from, to);\n\tif (err < 0)\n\t\treturn -errno;\n\treturn 0;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint rename_file(char *from, char *to)\n{\n\tint err;\n\n\terr = rename(from, to);\n\tif (err < 0)\n\t\treturn -errno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "old_name"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "new_dentry"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_rename2(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t  struct inode *new_dir, struct dentry *new_dentry,\n\t\t\t  unsigned int flags)\n{\n\tchar *old_name, *new_name;\n\tint err;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\told_name = dentry_name(old_dentry);\n\tif (old_name == NULL)\n\t\treturn -ENOMEM;\n\tnew_name = dentry_name(new_dentry);\n\tif (new_name == NULL) {\n\t\t__putname(old_name);\n\t\treturn -ENOMEM;\n\t}\n\tif (!flags)\n\t\terr = rename_file(old_name, new_name);\n\telse\n\t\terr = rename2_file(old_name, new_name, flags);\n\n\t__putname(old_name);\n\t__putname(new_name);\n\treturn err;\n}"
  },
  {
    "function_name": "hostfs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "704-742",
    "snippet": "static int hostfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint err;\n\n\tinode = hostfs_iget(dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\terr = -ENOMEM;\n\tname = dentry_name(dentry);\n\tif (name == NULL)\n\t\tgoto out_put;\n\n\tinit_special_inode(inode, mode, dev);\n\terr = do_mknod(name, mode, MAJOR(dev), MINOR(dev));\n\tif (!err)\n\t\tgoto out_free;\n\n\terr = read_name(inode, name);\n\t__putname(name);\n\tif (err)\n\t\tgoto out_put;\n\tif (err)\n\t\tgoto out_put;\n\n\td_instantiate(dentry, inode);\n\treturn 0;\n\n out_free:\n\t__putname(name);\n out_put:\n\tiput(inode);\n out:\n\treturn err;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_name",
          "args": [
            "inode",
            "name"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "read_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "507-551",
          "snippet": "static int read_name(struct inode *ino, char *name)\n{\n\tdev_t rdev;\n\tstruct hostfs_stat st;\n\tint err = stat_file(name, &st, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* Reencode maj and min with the kernel encoding.*/\n\trdev = MKDEV(st.maj, st.min);\n\n\tswitch (st.mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tino->i_op = &hostfs_link_iops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tino->i_op = &hostfs_dir_iops;\n\t\tino->i_fop = &hostfs_dir_fops;\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(ino, st.mode & S_IFMT, rdev);\n\t\tino->i_op = &hostfs_iops;\n\t\tbreak;\n\n\tdefault:\n\t\tino->i_op = &hostfs_iops;\n\t\tino->i_fop = &hostfs_file_fops;\n\t\tino->i_mapping->a_ops = &hostfs_aops;\n\t}\n\n\tino->i_ino = st.ino;\n\tino->i_mode = st.mode;\n\tset_nlink(ino, st.nlink);\n\ti_uid_write(ino, st.uid);\n\ti_gid_write(ino, st.gid);\n\tino->i_atime = st.atime;\n\tino->i_mtime = st.mtime;\n\tino->i_ctime = st.ctime;\n\tino->i_size = st.size;\n\tino->i_blocks = st.blocks;\n\treturn 0;\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations hostfs_iops;",
            "static const struct inode_operations hostfs_dir_iops;",
            "static const struct inode_operations hostfs_link_iops;",
            "static const struct file_operations hostfs_file_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.splice_read\t= generic_file_splice_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.write\t\t= new_sync_write,\n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= hostfs_file_open,\n\t.release\t= hostfs_file_release,\n\t.fsync\t\t= hostfs_fsync,\n};",
            "static const struct file_operations hostfs_dir_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate\t= hostfs_readdir,\n\t.read\t\t= generic_read_dir,\n};",
            "static const struct address_space_operations hostfs_aops = {\n\t.writepage \t= hostfs_writepage,\n\t.readpage\t= hostfs_readpage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n\t.write_begin\t= hostfs_write_begin,\n\t.write_end\t= hostfs_write_end,\n};",
            "static const struct inode_operations hostfs_iops = {\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};",
            "static const struct inode_operations hostfs_dir_iops = {\n\t.create\t\t= hostfs_create,\n\t.lookup\t\t= hostfs_lookup,\n\t.link\t\t= hostfs_link,\n\t.unlink\t\t= hostfs_unlink,\n\t.symlink\t= hostfs_symlink,\n\t.mkdir\t\t= hostfs_mkdir,\n\t.rmdir\t\t= hostfs_rmdir,\n\t.mknod\t\t= hostfs_mknod,\n\t.rename2\t= hostfs_rename2,\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};",
            "static const struct inode_operations hostfs_link_iops = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= hostfs_follow_link,\n\t.put_link\t= hostfs_put_link,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations hostfs_iops;\nstatic const struct inode_operations hostfs_dir_iops;\nstatic const struct inode_operations hostfs_link_iops;\nstatic const struct file_operations hostfs_file_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.splice_read\t= generic_file_splice_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.write\t\t= new_sync_write,\n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= hostfs_file_open,\n\t.release\t= hostfs_file_release,\n\t.fsync\t\t= hostfs_fsync,\n};\nstatic const struct file_operations hostfs_dir_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate\t= hostfs_readdir,\n\t.read\t\t= generic_read_dir,\n};\nstatic const struct address_space_operations hostfs_aops = {\n\t.writepage \t= hostfs_writepage,\n\t.readpage\t= hostfs_readpage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n\t.write_begin\t= hostfs_write_begin,\n\t.write_end\t= hostfs_write_end,\n};\nstatic const struct inode_operations hostfs_iops = {\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};\nstatic const struct inode_operations hostfs_dir_iops = {\n\t.create\t\t= hostfs_create,\n\t.lookup\t\t= hostfs_lookup,\n\t.link\t\t= hostfs_link,\n\t.unlink\t\t= hostfs_unlink,\n\t.symlink\t= hostfs_symlink,\n\t.mkdir\t\t= hostfs_mkdir,\n\t.rmdir\t\t= hostfs_rmdir,\n\t.mknod\t\t= hostfs_mknod,\n\t.rename2\t= hostfs_rename2,\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};\nstatic const struct inode_operations hostfs_link_iops = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= hostfs_follow_link,\n\t.put_link\t= hostfs_put_link,\n};\n\nstatic int read_name(struct inode *ino, char *name)\n{\n\tdev_t rdev;\n\tstruct hostfs_stat st;\n\tint err = stat_file(name, &st, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* Reencode maj and min with the kernel encoding.*/\n\trdev = MKDEV(st.maj, st.min);\n\n\tswitch (st.mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tino->i_op = &hostfs_link_iops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tino->i_op = &hostfs_dir_iops;\n\t\tino->i_fop = &hostfs_dir_fops;\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(ino, st.mode & S_IFMT, rdev);\n\t\tino->i_op = &hostfs_iops;\n\t\tbreak;\n\n\tdefault:\n\t\tino->i_op = &hostfs_iops;\n\t\tino->i_fop = &hostfs_file_fops;\n\t\tino->i_mapping->a_ops = &hostfs_aops;\n\t}\n\n\tino->i_ino = st.ino;\n\tino->i_mode = st.mode;\n\tset_nlink(ino, st.nlink);\n\ti_uid_write(ino, st.uid);\n\ti_gid_write(ino, st.gid);\n\tino->i_atime = st.atime;\n\tino->i_mtime = st.mtime;\n\tino->i_ctime = st.ctime;\n\tino->i_size = st.size;\n\tino->i_blocks = st.blocks;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_mknod",
          "args": [
            "name",
            "mode",
            "MAJOR(dev)",
            "MINOR(dev)"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "do_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "322-330",
          "snippet": "int do_mknod(const char *file, int mode, unsigned int major, unsigned int minor)\n{\n\tint err;\n\n\terr = mknod(file, mode, os_makedev(major, minor));\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint do_mknod(const char *file, int mode, unsigned int major, unsigned int minor)\n{\n\tint err;\n\n\terr = mknod(file, mode, os_makedev(major, minor));\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "mode",
            "dev"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "dentry"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostfs_iget",
          "args": [
            "dir->i_sb"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "hostfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "181-187",
          "snippet": "static struct inode *hostfs_iget(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn inode;\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic struct inode *hostfs_iget(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint err;\n\n\tinode = hostfs_iget(dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\terr = -ENOMEM;\n\tname = dentry_name(dentry);\n\tif (name == NULL)\n\t\tgoto out_put;\n\n\tinit_special_inode(inode, mode, dev);\n\terr = do_mknod(name, mode, MAJOR(dev), MINOR(dev));\n\tif (!err)\n\t\tgoto out_free;\n\n\terr = read_name(inode, name);\n\t__putname(name);\n\tif (err)\n\t\tgoto out_put;\n\tif (err)\n\t\tgoto out_put;\n\n\td_instantiate(dentry, inode);\n\treturn 0;\n\n out_free:\n\t__putname(name);\n out_put:\n\tiput(inode);\n out:\n\treturn err;\n}"
  },
  {
    "function_name": "hostfs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "692-702",
    "snippet": "static int hostfs_rmdir(struct inode *ino, struct dentry *dentry)\n{\n\tchar *file;\n\tint err;\n\n\tif ((file = dentry_name(dentry)) == NULL)\n\t\treturn -ENOMEM;\n\terr = do_rmdir(file);\n\t__putname(file);\n\treturn err;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "file"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_rmdir",
          "args": [
            "file"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "do_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "312-320",
          "snippet": "int do_rmdir(const char *file)\n{\n\tint err;\n\n\terr = rmdir(file);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint do_rmdir(const char *file)\n{\n\tint err;\n\n\terr = rmdir(file);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "dentry"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_rmdir(struct inode *ino, struct dentry *dentry)\n{\n\tchar *file;\n\tint err;\n\n\tif ((file = dentry_name(dentry)) == NULL)\n\t\treturn -ENOMEM;\n\terr = do_rmdir(file);\n\t__putname(file);\n\treturn err;\n}"
  },
  {
    "function_name": "hostfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "680-690",
    "snippet": "static int hostfs_mkdir(struct inode *ino, struct dentry *dentry, umode_t mode)\n{\n\tchar *file;\n\tint err;\n\n\tif ((file = dentry_name(dentry)) == NULL)\n\t\treturn -ENOMEM;\n\terr = do_mkdir(file, mode);\n\t__putname(file);\n\treturn err;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "file"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mkdir",
          "args": [
            "file",
            "mode"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "do_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "302-310",
          "snippet": "int do_mkdir(const char *file, int mode)\n{\n\tint err;\n\n\terr = mkdir(file, mode);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint do_mkdir(const char *file, int mode)\n{\n\tint err;\n\n\terr = mkdir(file, mode);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "dentry"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_mkdir(struct inode *ino, struct dentry *dentry, umode_t mode)\n{\n\tchar *file;\n\tint err;\n\n\tif ((file = dentry_name(dentry)) == NULL)\n\t\treturn -ENOMEM;\n\terr = do_mkdir(file, mode);\n\t__putname(file);\n\treturn err;\n}"
  },
  {
    "function_name": "hostfs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "667-678",
    "snippet": "static int hostfs_symlink(struct inode *ino, struct dentry *dentry,\n\t\t\t  const char *to)\n{\n\tchar *file;\n\tint err;\n\n\tif ((file = dentry_name(dentry)) == NULL)\n\t\treturn -ENOMEM;\n\terr = make_symlink(file, to);\n\t__putname(file);\n\treturn err;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "file"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_symlink",
          "args": [
            "file",
            "to"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "make_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "282-290",
          "snippet": "int make_symlink(const char *from, const char *to)\n{\n\tint err;\n\n\terr = symlink(to, from);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint make_symlink(const char *from, const char *to)\n{\n\tint err;\n\n\terr = symlink(to, from);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "dentry"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_symlink(struct inode *ino, struct dentry *dentry,\n\t\t\t  const char *to)\n{\n\tchar *file;\n\tint err;\n\n\tif ((file = dentry_name(dentry)) == NULL)\n\t\treturn -ENOMEM;\n\terr = make_symlink(file, to);\n\t__putname(file);\n\treturn err;\n}"
  },
  {
    "function_name": "hostfs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "651-665",
    "snippet": "static int hostfs_unlink(struct inode *ino, struct dentry *dentry)\n{\n\tchar *file;\n\tint err;\n\n\tif (append)\n\t\treturn -EPERM;\n\n\tif ((file = dentry_name(dentry)) == NULL)\n\t\treturn -ENOMEM;\n\n\terr = unlink_file(file);\n\t__putname(file);\n\treturn err;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int append = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "file"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink_file",
          "args": [
            "file"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "292-300",
          "snippet": "int unlink_file(const char *file)\n{\n\tint err;\n\n\terr = unlink(file);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint unlink_file(const char *file)\n{\n\tint err;\n\n\terr = unlink(file);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "dentry"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int append = 0;\n\nstatic int hostfs_unlink(struct inode *ino, struct dentry *dentry)\n{\n\tchar *file;\n\tint err;\n\n\tif (append)\n\t\treturn -EPERM;\n\n\tif ((file = dentry_name(dentry)) == NULL)\n\t\treturn -ENOMEM;\n\n\terr = unlink_file(file);\n\t__putname(file);\n\treturn err;\n}"
  },
  {
    "function_name": "hostfs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "632-649",
    "snippet": "static int hostfs_link(struct dentry *to, struct inode *ino,\n\t\t       struct dentry *from)\n{\n\tchar *from_name, *to_name;\n\tint err;\n\n\tif ((from_name = dentry_name(from)) == NULL)\n\t\treturn -ENOMEM;\n\tto_name = dentry_name(to);\n\tif (to_name == NULL) {\n\t\t__putname(from_name);\n\t\treturn -ENOMEM;\n\t}\n\terr = link_file(to_name, from_name);\n\t__putname(from_name);\n\t__putname(to_name);\n\treturn err;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "to_name"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "from_name"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_file",
          "args": [
            "to_name",
            "from_name"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "link_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "332-340",
          "snippet": "int link_file(const char *to, const char *from)\n{\n\tint err;\n\n\terr = link(to, from);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint link_file(const char *to, const char *from)\n{\n\tint err;\n\n\terr = link(to, from);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "from_name"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "to"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_link(struct dentry *to, struct inode *ino,\n\t\t       struct dentry *from)\n{\n\tchar *from_name, *to_name;\n\tint err;\n\n\tif ((from_name = dentry_name(from)) == NULL)\n\t\treturn -ENOMEM;\n\tto_name = dentry_name(to);\n\tif (to_name == NULL) {\n\t\t__putname(from_name);\n\t\treturn -ENOMEM;\n\t}\n\terr = link_file(to_name, from_name);\n\t__putname(from_name);\n\t__putname(to_name);\n\treturn err;\n}"
  },
  {
    "function_name": "hostfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "595-630",
    "snippet": "static struct dentry *hostfs_lookup(struct inode *ino, struct dentry *dentry,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint err;\n\n\tinode = hostfs_iget(ino->i_sb);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\terr = -ENOMEM;\n\tname = dentry_name(dentry);\n\tif (name == NULL)\n\t\tgoto out_put;\n\n\terr = read_name(inode, name);\n\n\t__putname(name);\n\tif (err == -ENOENT) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\telse if (err)\n\t\tgoto out_put;\n\n\td_add(dentry, inode);\n\treturn NULL;\n\n out_put:\n\tiput(inode);\n out:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_name",
          "args": [
            "inode",
            "name"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "read_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "507-551",
          "snippet": "static int read_name(struct inode *ino, char *name)\n{\n\tdev_t rdev;\n\tstruct hostfs_stat st;\n\tint err = stat_file(name, &st, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* Reencode maj and min with the kernel encoding.*/\n\trdev = MKDEV(st.maj, st.min);\n\n\tswitch (st.mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tino->i_op = &hostfs_link_iops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tino->i_op = &hostfs_dir_iops;\n\t\tino->i_fop = &hostfs_dir_fops;\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(ino, st.mode & S_IFMT, rdev);\n\t\tino->i_op = &hostfs_iops;\n\t\tbreak;\n\n\tdefault:\n\t\tino->i_op = &hostfs_iops;\n\t\tino->i_fop = &hostfs_file_fops;\n\t\tino->i_mapping->a_ops = &hostfs_aops;\n\t}\n\n\tino->i_ino = st.ino;\n\tino->i_mode = st.mode;\n\tset_nlink(ino, st.nlink);\n\ti_uid_write(ino, st.uid);\n\ti_gid_write(ino, st.gid);\n\tino->i_atime = st.atime;\n\tino->i_mtime = st.mtime;\n\tino->i_ctime = st.ctime;\n\tino->i_size = st.size;\n\tino->i_blocks = st.blocks;\n\treturn 0;\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations hostfs_iops;",
            "static const struct inode_operations hostfs_dir_iops;",
            "static const struct inode_operations hostfs_link_iops;",
            "static const struct file_operations hostfs_file_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.splice_read\t= generic_file_splice_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.write\t\t= new_sync_write,\n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= hostfs_file_open,\n\t.release\t= hostfs_file_release,\n\t.fsync\t\t= hostfs_fsync,\n};",
            "static const struct file_operations hostfs_dir_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate\t= hostfs_readdir,\n\t.read\t\t= generic_read_dir,\n};",
            "static const struct address_space_operations hostfs_aops = {\n\t.writepage \t= hostfs_writepage,\n\t.readpage\t= hostfs_readpage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n\t.write_begin\t= hostfs_write_begin,\n\t.write_end\t= hostfs_write_end,\n};",
            "static const struct inode_operations hostfs_iops = {\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};",
            "static const struct inode_operations hostfs_dir_iops = {\n\t.create\t\t= hostfs_create,\n\t.lookup\t\t= hostfs_lookup,\n\t.link\t\t= hostfs_link,\n\t.unlink\t\t= hostfs_unlink,\n\t.symlink\t= hostfs_symlink,\n\t.mkdir\t\t= hostfs_mkdir,\n\t.rmdir\t\t= hostfs_rmdir,\n\t.mknod\t\t= hostfs_mknod,\n\t.rename2\t= hostfs_rename2,\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};",
            "static const struct inode_operations hostfs_link_iops = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= hostfs_follow_link,\n\t.put_link\t= hostfs_put_link,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations hostfs_iops;\nstatic const struct inode_operations hostfs_dir_iops;\nstatic const struct inode_operations hostfs_link_iops;\nstatic const struct file_operations hostfs_file_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.splice_read\t= generic_file_splice_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.write\t\t= new_sync_write,\n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= hostfs_file_open,\n\t.release\t= hostfs_file_release,\n\t.fsync\t\t= hostfs_fsync,\n};\nstatic const struct file_operations hostfs_dir_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate\t= hostfs_readdir,\n\t.read\t\t= generic_read_dir,\n};\nstatic const struct address_space_operations hostfs_aops = {\n\t.writepage \t= hostfs_writepage,\n\t.readpage\t= hostfs_readpage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n\t.write_begin\t= hostfs_write_begin,\n\t.write_end\t= hostfs_write_end,\n};\nstatic const struct inode_operations hostfs_iops = {\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};\nstatic const struct inode_operations hostfs_dir_iops = {\n\t.create\t\t= hostfs_create,\n\t.lookup\t\t= hostfs_lookup,\n\t.link\t\t= hostfs_link,\n\t.unlink\t\t= hostfs_unlink,\n\t.symlink\t= hostfs_symlink,\n\t.mkdir\t\t= hostfs_mkdir,\n\t.rmdir\t\t= hostfs_rmdir,\n\t.mknod\t\t= hostfs_mknod,\n\t.rename2\t= hostfs_rename2,\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};\nstatic const struct inode_operations hostfs_link_iops = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= hostfs_follow_link,\n\t.put_link\t= hostfs_put_link,\n};\n\nstatic int read_name(struct inode *ino, char *name)\n{\n\tdev_t rdev;\n\tstruct hostfs_stat st;\n\tint err = stat_file(name, &st, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* Reencode maj and min with the kernel encoding.*/\n\trdev = MKDEV(st.maj, st.min);\n\n\tswitch (st.mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tino->i_op = &hostfs_link_iops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tino->i_op = &hostfs_dir_iops;\n\t\tino->i_fop = &hostfs_dir_fops;\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(ino, st.mode & S_IFMT, rdev);\n\t\tino->i_op = &hostfs_iops;\n\t\tbreak;\n\n\tdefault:\n\t\tino->i_op = &hostfs_iops;\n\t\tino->i_fop = &hostfs_file_fops;\n\t\tino->i_mapping->a_ops = &hostfs_aops;\n\t}\n\n\tino->i_ino = st.ino;\n\tino->i_mode = st.mode;\n\tset_nlink(ino, st.nlink);\n\ti_uid_write(ino, st.uid);\n\ti_gid_write(ino, st.gid);\n\tino->i_atime = st.atime;\n\tino->i_mtime = st.mtime;\n\tino->i_ctime = st.ctime;\n\tino->i_size = st.size;\n\tino->i_blocks = st.blocks;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "dentry"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostfs_iget",
          "args": [
            "ino->i_sb"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "hostfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "181-187",
          "snippet": "static struct inode *hostfs_iget(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn inode;\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic struct inode *hostfs_iget(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic struct dentry *hostfs_lookup(struct inode *ino, struct dentry *dentry,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint err;\n\n\tinode = hostfs_iget(ino->i_sb);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\terr = -ENOMEM;\n\tname = dentry_name(dentry);\n\tif (name == NULL)\n\t\tgoto out_put;\n\n\terr = read_name(inode, name);\n\n\t__putname(name);\n\tif (err == -ENOENT) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\telse if (err)\n\t\tgoto out_put;\n\n\td_add(dentry, inode);\n\treturn NULL;\n\n out_put:\n\tiput(inode);\n out:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "hostfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "553-593",
    "snippet": "static int hostfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t bool excl)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint error, fd;\n\n\tinode = hostfs_iget(dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\terror = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\terror = -ENOMEM;\n\tname = dentry_name(dentry);\n\tif (name == NULL)\n\t\tgoto out_put;\n\n\tfd = file_create(name,\n\t\t\t mode & S_IRUSR, mode & S_IWUSR, mode & S_IXUSR,\n\t\t\t mode & S_IRGRP, mode & S_IWGRP, mode & S_IXGRP,\n\t\t\t mode & S_IROTH, mode & S_IWOTH, mode & S_IXOTH);\n\tif (fd < 0)\n\t\terror = fd;\n\telse\n\t\terror = read_name(inode, name);\n\n\t__putname(name);\n\tif (error)\n\t\tgoto out_put;\n\n\tHOSTFS_I(inode)->fd = fd;\n\tHOSTFS_I(inode)->mode = FMODE_READ | FMODE_WRITE;\n\td_instantiate(dentry, inode);\n\treturn 0;\n\n out_put:\n\tiput(inode);\n out:\n\treturn error;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HOSTFS_I",
          "args": [
            "inode"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "HOSTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "29-32",
          "snippet": "static inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_name",
          "args": [
            "inode",
            "name"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "read_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "507-551",
          "snippet": "static int read_name(struct inode *ino, char *name)\n{\n\tdev_t rdev;\n\tstruct hostfs_stat st;\n\tint err = stat_file(name, &st, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* Reencode maj and min with the kernel encoding.*/\n\trdev = MKDEV(st.maj, st.min);\n\n\tswitch (st.mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tino->i_op = &hostfs_link_iops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tino->i_op = &hostfs_dir_iops;\n\t\tino->i_fop = &hostfs_dir_fops;\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(ino, st.mode & S_IFMT, rdev);\n\t\tino->i_op = &hostfs_iops;\n\t\tbreak;\n\n\tdefault:\n\t\tino->i_op = &hostfs_iops;\n\t\tino->i_fop = &hostfs_file_fops;\n\t\tino->i_mapping->a_ops = &hostfs_aops;\n\t}\n\n\tino->i_ino = st.ino;\n\tino->i_mode = st.mode;\n\tset_nlink(ino, st.nlink);\n\ti_uid_write(ino, st.uid);\n\ti_gid_write(ino, st.gid);\n\tino->i_atime = st.atime;\n\tino->i_mtime = st.mtime;\n\tino->i_ctime = st.ctime;\n\tino->i_size = st.size;\n\tino->i_blocks = st.blocks;\n\treturn 0;\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations hostfs_iops;",
            "static const struct inode_operations hostfs_dir_iops;",
            "static const struct inode_operations hostfs_link_iops;",
            "static const struct file_operations hostfs_file_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.splice_read\t= generic_file_splice_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.write\t\t= new_sync_write,\n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= hostfs_file_open,\n\t.release\t= hostfs_file_release,\n\t.fsync\t\t= hostfs_fsync,\n};",
            "static const struct file_operations hostfs_dir_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate\t= hostfs_readdir,\n\t.read\t\t= generic_read_dir,\n};",
            "static const struct address_space_operations hostfs_aops = {\n\t.writepage \t= hostfs_writepage,\n\t.readpage\t= hostfs_readpage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n\t.write_begin\t= hostfs_write_begin,\n\t.write_end\t= hostfs_write_end,\n};",
            "static const struct inode_operations hostfs_iops = {\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};",
            "static const struct inode_operations hostfs_dir_iops = {\n\t.create\t\t= hostfs_create,\n\t.lookup\t\t= hostfs_lookup,\n\t.link\t\t= hostfs_link,\n\t.unlink\t\t= hostfs_unlink,\n\t.symlink\t= hostfs_symlink,\n\t.mkdir\t\t= hostfs_mkdir,\n\t.rmdir\t\t= hostfs_rmdir,\n\t.mknod\t\t= hostfs_mknod,\n\t.rename2\t= hostfs_rename2,\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};",
            "static const struct inode_operations hostfs_link_iops = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= hostfs_follow_link,\n\t.put_link\t= hostfs_put_link,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations hostfs_iops;\nstatic const struct inode_operations hostfs_dir_iops;\nstatic const struct inode_operations hostfs_link_iops;\nstatic const struct file_operations hostfs_file_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.splice_read\t= generic_file_splice_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.write\t\t= new_sync_write,\n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= hostfs_file_open,\n\t.release\t= hostfs_file_release,\n\t.fsync\t\t= hostfs_fsync,\n};\nstatic const struct file_operations hostfs_dir_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate\t= hostfs_readdir,\n\t.read\t\t= generic_read_dir,\n};\nstatic const struct address_space_operations hostfs_aops = {\n\t.writepage \t= hostfs_writepage,\n\t.readpage\t= hostfs_readpage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n\t.write_begin\t= hostfs_write_begin,\n\t.write_end\t= hostfs_write_end,\n};\nstatic const struct inode_operations hostfs_iops = {\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};\nstatic const struct inode_operations hostfs_dir_iops = {\n\t.create\t\t= hostfs_create,\n\t.lookup\t\t= hostfs_lookup,\n\t.link\t\t= hostfs_link,\n\t.unlink\t\t= hostfs_unlink,\n\t.symlink\t= hostfs_symlink,\n\t.mkdir\t\t= hostfs_mkdir,\n\t.rmdir\t\t= hostfs_rmdir,\n\t.mknod\t\t= hostfs_mknod,\n\t.rename2\t= hostfs_rename2,\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};\nstatic const struct inode_operations hostfs_link_iops = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= hostfs_follow_link,\n\t.put_link\t= hostfs_put_link,\n};\n\nstatic int read_name(struct inode *ino, char *name)\n{\n\tdev_t rdev;\n\tstruct hostfs_stat st;\n\tint err = stat_file(name, &st, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* Reencode maj and min with the kernel encoding.*/\n\trdev = MKDEV(st.maj, st.min);\n\n\tswitch (st.mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tino->i_op = &hostfs_link_iops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tino->i_op = &hostfs_dir_iops;\n\t\tino->i_fop = &hostfs_dir_fops;\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(ino, st.mode & S_IFMT, rdev);\n\t\tino->i_op = &hostfs_iops;\n\t\tbreak;\n\n\tdefault:\n\t\tino->i_op = &hostfs_iops;\n\t\tino->i_fop = &hostfs_file_fops;\n\t\tino->i_mapping->a_ops = &hostfs_aops;\n\t}\n\n\tino->i_ino = st.ino;\n\tino->i_mode = st.mode;\n\tset_nlink(ino, st.nlink);\n\ti_uid_write(ino, st.uid);\n\ti_gid_write(ino, st.gid);\n\tino->i_atime = st.atime;\n\tino->i_mtime = st.mtime;\n\tino->i_ctime = st.ctime;\n\tino->i_size = st.size;\n\tino->i_blocks = st.blocks;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_create",
          "args": [
            "name",
            "mode & S_IRUSR",
            "mode & S_IWUSR",
            "mode & S_IXUSR",
            "mode & S_IRGRP",
            "mode & S_IWGRP",
            "mode & S_IXGRP",
            "mode & S_IROTH",
            "mode & S_IWOTH",
            "mode & S_IXOTH"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "file_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "178-197",
          "snippet": "int file_create(char *name, int ur, int uw, int ux, int gr,\n\t\tint gw, int gx, int or, int ow, int ox)\n{\n\tint mode, fd;\n\n\tmode = 0;\n\tmode |= ur ? S_IRUSR : 0;\n\tmode |= uw ? S_IWUSR : 0;\n\tmode |= ux ? S_IXUSR : 0;\n\tmode |= gr ? S_IRGRP : 0;\n\tmode |= gw ? S_IWGRP : 0;\n\tmode |= gx ? S_IXGRP : 0;\n\tmode |= or ? S_IROTH : 0;\n\tmode |= ow ? S_IWOTH : 0;\n\tmode |= ox ? S_IXOTH : 0;\n\tfd = open64(name, O_CREAT | O_RDWR, mode);\n\tif (fd < 0)\n\t\treturn -errno;\n\treturn fd;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint file_create(char *name, int ur, int uw, int ux, int gr,\n\t\tint gw, int gx, int or, int ow, int ox)\n{\n\tint mode, fd;\n\n\tmode = 0;\n\tmode |= ur ? S_IRUSR : 0;\n\tmode |= uw ? S_IWUSR : 0;\n\tmode |= ux ? S_IXUSR : 0;\n\tmode |= gr ? S_IRGRP : 0;\n\tmode |= gw ? S_IWGRP : 0;\n\tmode |= gx ? S_IXGRP : 0;\n\tmode |= or ? S_IROTH : 0;\n\tmode |= ow ? S_IWOTH : 0;\n\tmode |= ox ? S_IXOTH : 0;\n\tfd = open64(name, O_CREAT | O_RDWR, mode);\n\tif (fd < 0)\n\t\treturn -errno;\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "dentry"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostfs_iget",
          "args": [
            "dir->i_sb"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "hostfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "181-187",
          "snippet": "static struct inode *hostfs_iget(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn inode;\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic struct inode *hostfs_iget(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t bool excl)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint error, fd;\n\n\tinode = hostfs_iget(dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\terror = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\terror = -ENOMEM;\n\tname = dentry_name(dentry);\n\tif (name == NULL)\n\t\tgoto out_put;\n\n\tfd = file_create(name,\n\t\t\t mode & S_IRUSR, mode & S_IWUSR, mode & S_IXUSR,\n\t\t\t mode & S_IRGRP, mode & S_IWGRP, mode & S_IXGRP,\n\t\t\t mode & S_IROTH, mode & S_IWOTH, mode & S_IXOTH);\n\tif (fd < 0)\n\t\terror = fd;\n\telse\n\t\terror = read_name(inode, name);\n\n\t__putname(name);\n\tif (error)\n\t\tgoto out_put;\n\n\tHOSTFS_I(inode)->fd = fd;\n\tHOSTFS_I(inode)->mode = FMODE_READ | FMODE_WRITE;\n\td_instantiate(dentry, inode);\n\treturn 0;\n\n out_put:\n\tiput(inode);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "read_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "507-551",
    "snippet": "static int read_name(struct inode *ino, char *name)\n{\n\tdev_t rdev;\n\tstruct hostfs_stat st;\n\tint err = stat_file(name, &st, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* Reencode maj and min with the kernel encoding.*/\n\trdev = MKDEV(st.maj, st.min);\n\n\tswitch (st.mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tino->i_op = &hostfs_link_iops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tino->i_op = &hostfs_dir_iops;\n\t\tino->i_fop = &hostfs_dir_fops;\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(ino, st.mode & S_IFMT, rdev);\n\t\tino->i_op = &hostfs_iops;\n\t\tbreak;\n\n\tdefault:\n\t\tino->i_op = &hostfs_iops;\n\t\tino->i_fop = &hostfs_file_fops;\n\t\tino->i_mapping->a_ops = &hostfs_aops;\n\t}\n\n\tino->i_ino = st.ino;\n\tino->i_mode = st.mode;\n\tset_nlink(ino, st.nlink);\n\ti_uid_write(ino, st.uid);\n\ti_gid_write(ino, st.gid);\n\tino->i_atime = st.atime;\n\tino->i_mtime = st.mtime;\n\tino->i_ctime = st.ctime;\n\tino->i_size = st.size;\n\tino->i_blocks = st.blocks;\n\treturn 0;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations hostfs_iops;",
      "static const struct inode_operations hostfs_dir_iops;",
      "static const struct inode_operations hostfs_link_iops;",
      "static const struct file_operations hostfs_file_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.splice_read\t= generic_file_splice_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.write\t\t= new_sync_write,\n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= hostfs_file_open,\n\t.release\t= hostfs_file_release,\n\t.fsync\t\t= hostfs_fsync,\n};",
      "static const struct file_operations hostfs_dir_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate\t= hostfs_readdir,\n\t.read\t\t= generic_read_dir,\n};",
      "static const struct address_space_operations hostfs_aops = {\n\t.writepage \t= hostfs_writepage,\n\t.readpage\t= hostfs_readpage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n\t.write_begin\t= hostfs_write_begin,\n\t.write_end\t= hostfs_write_end,\n};",
      "static const struct inode_operations hostfs_iops = {\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};",
      "static const struct inode_operations hostfs_dir_iops = {\n\t.create\t\t= hostfs_create,\n\t.lookup\t\t= hostfs_lookup,\n\t.link\t\t= hostfs_link,\n\t.unlink\t\t= hostfs_unlink,\n\t.symlink\t= hostfs_symlink,\n\t.mkdir\t\t= hostfs_mkdir,\n\t.rmdir\t\t= hostfs_rmdir,\n\t.mknod\t\t= hostfs_mknod,\n\t.rename2\t= hostfs_rename2,\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};",
      "static const struct inode_operations hostfs_link_iops = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= hostfs_follow_link,\n\t.put_link\t= hostfs_put_link,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "ino",
            "st.gid"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "ino",
            "st.uid"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "ino",
            "st.nlink"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "ino",
            "st.mode & S_IFMT",
            "rdev"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "st.maj",
            "st.min"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat_file",
          "args": [
            "name",
            "&st",
            "-1"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "stat_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "41-53",
          "snippet": "int stat_file(const char *path, struct hostfs_stat *p, int fd)\n{\n\tstruct stat64 buf;\n\n\tif (fd >= 0) {\n\t\tif (fstat64(fd, &buf) < 0)\n\t\t\treturn -errno;\n\t} else if (lstat64(path, &buf) < 0) {\n\t\treturn -errno;\n\t}\n\tstat64_to_hostfs(&buf, p);\n\treturn 0;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint stat_file(const char *path, struct hostfs_stat *p, int fd)\n{\n\tstruct stat64 buf;\n\n\tif (fd >= 0) {\n\t\tif (fstat64(fd, &buf) < 0)\n\t\t\treturn -errno;\n\t} else if (lstat64(path, &buf) < 0) {\n\t\treturn -errno;\n\t}\n\tstat64_to_hostfs(&buf, p);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations hostfs_iops;\nstatic const struct inode_operations hostfs_dir_iops;\nstatic const struct inode_operations hostfs_link_iops;\nstatic const struct file_operations hostfs_file_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.splice_read\t= generic_file_splice_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.write\t\t= new_sync_write,\n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= hostfs_file_open,\n\t.release\t= hostfs_file_release,\n\t.fsync\t\t= hostfs_fsync,\n};\nstatic const struct file_operations hostfs_dir_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate\t= hostfs_readdir,\n\t.read\t\t= generic_read_dir,\n};\nstatic const struct address_space_operations hostfs_aops = {\n\t.writepage \t= hostfs_writepage,\n\t.readpage\t= hostfs_readpage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n\t.write_begin\t= hostfs_write_begin,\n\t.write_end\t= hostfs_write_end,\n};\nstatic const struct inode_operations hostfs_iops = {\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};\nstatic const struct inode_operations hostfs_dir_iops = {\n\t.create\t\t= hostfs_create,\n\t.lookup\t\t= hostfs_lookup,\n\t.link\t\t= hostfs_link,\n\t.unlink\t\t= hostfs_unlink,\n\t.symlink\t= hostfs_symlink,\n\t.mkdir\t\t= hostfs_mkdir,\n\t.rmdir\t\t= hostfs_rmdir,\n\t.mknod\t\t= hostfs_mknod,\n\t.rename2\t= hostfs_rename2,\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};\nstatic const struct inode_operations hostfs_link_iops = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= hostfs_follow_link,\n\t.put_link\t= hostfs_put_link,\n};\n\nstatic int read_name(struct inode *ino, char *name)\n{\n\tdev_t rdev;\n\tstruct hostfs_stat st;\n\tint err = stat_file(name, &st, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* Reencode maj and min with the kernel encoding.*/\n\trdev = MKDEV(st.maj, st.min);\n\n\tswitch (st.mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tino->i_op = &hostfs_link_iops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tino->i_op = &hostfs_dir_iops;\n\t\tino->i_fop = &hostfs_dir_fops;\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(ino, st.mode & S_IFMT, rdev);\n\t\tino->i_op = &hostfs_iops;\n\t\tbreak;\n\n\tdefault:\n\t\tino->i_op = &hostfs_iops;\n\t\tino->i_fop = &hostfs_file_fops;\n\t\tino->i_mapping->a_ops = &hostfs_aops;\n\t}\n\n\tino->i_ino = st.ino;\n\tino->i_mode = st.mode;\n\tset_nlink(ino, st.nlink);\n\ti_uid_write(ino, st.uid);\n\ti_gid_write(ino, st.gid);\n\tino->i_atime = st.atime;\n\tino->i_mtime = st.mtime;\n\tino->i_ctime = st.ctime;\n\tino->i_size = st.size;\n\tino->i_blocks = st.blocks;\n\treturn 0;\n}"
  },
  {
    "function_name": "hostfs_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "471-497",
    "snippet": "static int hostfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned copied,\n\t\t\t    struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tvoid *buffer;\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tint err;\n\n\tbuffer = kmap(page);\n\terr = write_file(FILE_HOSTFS_I(file)->fd, &pos, buffer + from, copied);\n\tkunmap(page);\n\n\tif (!PageUptodate(page) && err == PAGE_CACHE_SIZE)\n\t\tSetPageUptodate(page);\n\n\t/*\n\t * If err > 0, write_file has added err to pos, so we are comparing\n\t * i_size against the last byte written.\n\t */\n\tif (err > 0 && (pos > inode->i_size))\n\t\tinode->i_size = pos;\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn err;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_file",
          "args": [
            "FILE_HOSTFS_I(file)->fd",
            "&pos",
            "buffer + from",
            "copied"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "129-138",
          "snippet": "int write_file(int fd, unsigned long long *offset, const char *buf, int len)\n{\n\tint n;\n\n\tn = pwrite64(fd, buf, len, *offset);\n\tif (n < 0)\n\t\treturn -errno;\n\t*offset += n;\n\treturn n;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint write_file(int fd, unsigned long long *offset, const char *buf, int len)\n{\n\tint n;\n\n\tn = pwrite64(fd, buf, len, *offset);\n\tif (n < 0)\n\t\treturn -errno;\n\t*offset += n;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILE_HOSTFS_I",
          "args": [
            "file"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned copied,\n\t\t\t    struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tvoid *buffer;\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tint err;\n\n\tbuffer = kmap(page);\n\terr = write_file(FILE_HOSTFS_I(file)->fd, &pos, buffer + from, copied);\n\tkunmap(page);\n\n\tif (!PageUptodate(page) && err == PAGE_CACHE_SIZE)\n\t\tSetPageUptodate(page);\n\n\t/*\n\t * If err > 0, write_file has added err to pos, so we are comparing\n\t * i_size against the last byte written.\n\t */\n\tif (err > 0 && (pos > inode->i_size))\n\t\tinode->i_size = pos;\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn err;\n}"
  },
  {
    "function_name": "hostfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "459-469",
    "snippet": "static int hostfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t      loff_t pos, unsigned len, unsigned flags,\n\t\t\t      struct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\n\t*pagep = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!*pagep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t      loff_t pos, unsigned len, unsigned flags,\n\t\t\t      struct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\n\t*pagep = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!*pagep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "hostfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "434-457",
    "snippet": "static int hostfs_readpage(struct file *file, struct page *page)\n{\n\tchar *buffer;\n\tlong long start;\n\tint err = 0;\n\n\tstart = (long long) page->index << PAGE_CACHE_SHIFT;\n\tbuffer = kmap(page);\n\terr = read_file(FILE_HOSTFS_I(file)->fd, &start, buffer,\n\t\t\tPAGE_CACHE_SIZE);\n\tif (err < 0)\n\t\tgoto out;\n\n\tmemset(&buffer[err], 0, PAGE_CACHE_SIZE - err);\n\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tif (PageError(page)) ClearPageError(page);\n\terr = 0;\n out:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&buffer[err]",
            "0",
            "PAGE_CACHE_SIZE - err"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_file",
          "args": [
            "FILE_HOSTFS_I(file)->fd",
            "&start",
            "buffer",
            "PAGE_CACHE_SIZE"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "read_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "118-127",
          "snippet": "int read_file(int fd, unsigned long long *offset, char *buf, int len)\n{\n\tint n;\n\n\tn = pread64(fd, buf, len, *offset);\n\tif (n < 0)\n\t\treturn -errno;\n\t*offset += n;\n\treturn n;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint read_file(int fd, unsigned long long *offset, char *buf, int len)\n{\n\tint n;\n\n\tn = pread64(fd, buf, len, *offset);\n\tif (n < 0)\n\t\treturn -errno;\n\t*offset += n;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILE_HOSTFS_I",
          "args": [
            "file"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_readpage(struct file *file, struct page *page)\n{\n\tchar *buffer;\n\tlong long start;\n\tint err = 0;\n\n\tstart = (long long) page->index << PAGE_CACHE_SHIFT;\n\tbuffer = kmap(page);\n\terr = read_file(FILE_HOSTFS_I(file)->fd, &start, buffer,\n\t\t\tPAGE_CACHE_SIZE);\n\tif (err < 0)\n\t\tgoto out;\n\n\tmemset(&buffer[err], 0, PAGE_CACHE_SIZE - err);\n\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tif (PageError(page)) ClearPageError(page);\n\terr = 0;\n out:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "hostfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "398-432",
    "snippet": "static int hostfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tchar *buffer;\n\tunsigned long long base;\n\tint count = PAGE_CACHE_SIZE;\n\tint end_index = inode->i_size >> PAGE_CACHE_SHIFT;\n\tint err;\n\n\tif (page->index >= end_index)\n\t\tcount = inode->i_size & (PAGE_CACHE_SIZE-1);\n\n\tbuffer = kmap(page);\n\tbase = ((unsigned long long) page->index) << PAGE_CACHE_SHIFT;\n\n\terr = write_file(HOSTFS_I(inode)->fd, &base, buffer, count);\n\tif (err != count) {\n\t\tClearPageUptodate(page);\n\t\tgoto out;\n\t}\n\n\tif (base > inode->i_size)\n\t\tinode->i_size = base;\n\n\tif (PageError(page))\n\t\tClearPageError(page);\n\terr = 0;\n\n out:\n\tkunmap(page);\n\n\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_file",
          "args": [
            "HOSTFS_I(inode)->fd",
            "&base",
            "buffer",
            "count"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "129-138",
          "snippet": "int write_file(int fd, unsigned long long *offset, const char *buf, int len)\n{\n\tint n;\n\n\tn = pwrite64(fd, buf, len, *offset);\n\tif (n < 0)\n\t\treturn -errno;\n\t*offset += n;\n\treturn n;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint write_file(int fd, unsigned long long *offset, const char *buf, int len)\n{\n\tint n;\n\n\tn = pwrite64(fd, buf, len, *offset);\n\tif (n < 0)\n\t\treturn -errno;\n\t*offset += n;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HOSTFS_I",
          "args": [
            "inode"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "HOSTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "29-32",
          "snippet": "static inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tchar *buffer;\n\tunsigned long long base;\n\tint count = PAGE_CACHE_SIZE;\n\tint end_index = inode->i_size >> PAGE_CACHE_SHIFT;\n\tint err;\n\n\tif (page->index >= end_index)\n\t\tcount = inode->i_size & (PAGE_CACHE_SIZE-1);\n\n\tbuffer = kmap(page);\n\tbase = ((unsigned long long) page->index) << PAGE_CACHE_SHIFT;\n\n\terr = write_file(HOSTFS_I(inode)->fd, &base, buffer, count);\n\tif (err != count) {\n\t\tClearPageUptodate(page);\n\t\tgoto out;\n\t}\n\n\tif (base > inode->i_size)\n\t\tinode->i_size = base;\n\n\tif (PageError(page))\n\t\tClearPageError(page);\n\terr = 0;\n\n out:\n\tkunmap(page);\n\n\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "hostfs_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "362-377",
    "snippet": "static int hostfs_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\tint datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tret = fsync_file(HOSTFS_I(inode)->fd, datasync);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsync_file",
          "args": [
            "HOSTFS_I(inode)->fd",
            "datasync"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "fsync_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "150-161",
          "snippet": "int fsync_file(int fd, int datasync)\n{\n\tint ret;\n\tif (datasync)\n\t\tret = fdatasync(fd);\n\telse\n\t\tret = fsync(fd);\n\n\tif (ret < 0)\n\t\treturn -errno;\n\treturn 0;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint fsync_file(int fd, int datasync)\n{\n\tint ret;\n\tif (datasync)\n\t\tret = fdatasync(fd);\n\telse\n\t\tret = fsync(fd);\n\n\tif (ret < 0)\n\t\treturn -errno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HOSTFS_I",
          "args": [
            "inode"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "HOSTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "29-32",
          "snippet": "static inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\tint datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tret = fsync_file(HOSTFS_I(inode)->fd, datasync);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hostfs_file_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "355-360",
    "snippet": "static int hostfs_file_release(struct inode *inode, struct file *file)\n{\n\tfilemap_write_and_wait(inode->i_mapping);\n\n\treturn 0;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_file_release(struct inode *inode, struct file *file)\n{\n\tfilemap_write_and_wait(inode->i_mapping);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hostfs_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "296-353",
    "snippet": "static int hostfs_file_open(struct inode *ino, struct file *file)\n{\n\tstatic DEFINE_MUTEX(open_mutex);\n\tchar *name;\n\tfmode_t mode = 0;\n\tint err;\n\tint r = 0, w = 0, fd;\n\n\tmode = file->f_mode & (FMODE_READ | FMODE_WRITE);\n\tif ((mode & HOSTFS_I(ino)->mode) == mode)\n\t\treturn 0;\n\n\tmode |= HOSTFS_I(ino)->mode;\n\nretry:\n\tif (mode & FMODE_READ)\n\t\tr = 1;\n\tif (mode & FMODE_WRITE)\n\t\tw = 1;\n\tif (w)\n\t\tr = 1;\n\n\tname = dentry_name(file->f_path.dentry);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\n\tfd = open_file(name, r, w, append);\n\t__putname(name);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tmutex_lock(&open_mutex);\n\t/* somebody else had handled it first? */\n\tif ((mode & HOSTFS_I(ino)->mode) == mode) {\n\t\tmutex_unlock(&open_mutex);\n\t\treturn 0;\n\t}\n\tif ((mode | HOSTFS_I(ino)->mode) != mode) {\n\t\tmode |= HOSTFS_I(ino)->mode;\n\t\tmutex_unlock(&open_mutex);\n\t\tclose_file(&fd);\n\t\tgoto retry;\n\t}\n\tif (HOSTFS_I(ino)->fd == -1) {\n\t\tHOSTFS_I(ino)->fd = fd;\n\t} else {\n\t\terr = replace_file(fd, HOSTFS_I(ino)->fd);\n\t\tclose_file(&fd);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&open_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\tHOSTFS_I(ino)->mode = mode;\n\tmutex_unlock(&open_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int append = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&open_mutex"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HOSTFS_I",
          "args": [
            "ino"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "HOSTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "29-32",
          "snippet": "static inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&open_mutex"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_file",
          "args": [
            "&fd"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "close_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "168-171",
          "snippet": "void close_file(void *stream)\n{\n\tclose(*((int *) stream));\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nvoid close_file(void *stream)\n{\n\tclose(*((int *) stream));\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_file",
          "args": [
            "fd",
            "HOSTFS_I(ino)->fd"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "replace_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "163-166",
          "snippet": "int replace_file(int oldfd, int fd)\n{\n\treturn dup2(oldfd, fd);\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint replace_file(int oldfd, int fd)\n{\n\treturn dup2(oldfd, fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&open_mutex"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&open_mutex"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&open_mutex"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_file",
          "args": [
            "name",
            "r",
            "w",
            "append"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "70-88",
          "snippet": "int open_file(char *path, int r, int w, int append)\n{\n\tint mode = 0, fd;\n\n\tif (r && !w)\n\t\tmode = O_RDONLY;\n\telse if (!r && w)\n\t\tmode = O_WRONLY;\n\telse if (r && w)\n\t\tmode = O_RDWR;\n\telse panic(\"Impossible mode in open_file\");\n\n\tif (append)\n\t\tmode |= O_APPEND;\n\tfd = open64(path, mode);\n\tif (fd < 0)\n\t\treturn -errno;\n\telse return fd;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint open_file(char *path, int r, int w, int append)\n{\n\tint mode = 0, fd;\n\n\tif (r && !w)\n\t\tmode = O_RDONLY;\n\telse if (!r && w)\n\t\tmode = O_WRONLY;\n\telse if (r && w)\n\t\tmode = O_RDWR;\n\telse panic(\"Impossible mode in open_file\");\n\n\tif (append)\n\t\tmode |= O_APPEND;\n\tfd = open64(path, mode);\n\tif (fd < 0)\n\t\treturn -errno;\n\telse return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int append = 0;\n\nstatic int hostfs_file_open(struct inode *ino, struct file *file)\n{\n\tstatic DEFINE_MUTEX(open_mutex);\n\tchar *name;\n\tfmode_t mode = 0;\n\tint err;\n\tint r = 0, w = 0, fd;\n\n\tmode = file->f_mode & (FMODE_READ | FMODE_WRITE);\n\tif ((mode & HOSTFS_I(ino)->mode) == mode)\n\t\treturn 0;\n\n\tmode |= HOSTFS_I(ino)->mode;\n\nretry:\n\tif (mode & FMODE_READ)\n\t\tr = 1;\n\tif (mode & FMODE_WRITE)\n\t\tw = 1;\n\tif (w)\n\t\tr = 1;\n\n\tname = dentry_name(file->f_path.dentry);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\n\tfd = open_file(name, r, w, append);\n\t__putname(name);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tmutex_lock(&open_mutex);\n\t/* somebody else had handled it first? */\n\tif ((mode & HOSTFS_I(ino)->mode) == mode) {\n\t\tmutex_unlock(&open_mutex);\n\t\treturn 0;\n\t}\n\tif ((mode | HOSTFS_I(ino)->mode) != mode) {\n\t\tmode |= HOSTFS_I(ino)->mode;\n\t\tmutex_unlock(&open_mutex);\n\t\tclose_file(&fd);\n\t\tgoto retry;\n\t}\n\tif (HOSTFS_I(ino)->fd == -1) {\n\t\tHOSTFS_I(ino)->fd = fd;\n\t} else {\n\t\terr = replace_file(fd, HOSTFS_I(ino)->fd);\n\t\tclose_file(&fd);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&open_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\tHOSTFS_I(ino)->mode = mode;\n\tmutex_unlock(&open_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hostfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "271-294",
    "snippet": "static int hostfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tvoid *dir;\n\tchar *name;\n\tunsigned long long next, ino;\n\tint error, len;\n\tunsigned int type;\n\n\tname = dentry_name(file->f_path.dentry);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\tdir = open_dir(name, &error);\n\t__putname(name);\n\tif (dir == NULL)\n\t\treturn -error;\n\tnext = ctx->pos;\n\twhile ((name = read_dir(dir, &next, &ino, &len, &type)) != NULL) {\n\t\tif (!dir_emit(ctx, name, len, ino, type))\n\t\t\tbreak;\n\t\tctx->pos = next;\n\t}\n\tclose_dir(dir);\n\treturn 0;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close_dir",
          "args": [
            "dir"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "close_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "173-176",
          "snippet": "void close_dir(void *stream)\n{\n\tclosedir(stream);\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nvoid close_dir(void *stream)\n{\n\tclosedir(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "name",
            "len",
            "ino",
            "type"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_dir",
          "args": [
            "dir",
            "&next",
            "&ino",
            "&len",
            "&type"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "read_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "100-116",
          "snippet": "char *read_dir(void *stream, unsigned long long *pos,\n\t       unsigned long long *ino_out, int *len_out,\n\t       unsigned int *type_out)\n{\n\tDIR *dir = stream;\n\tstruct dirent *ent;\n\n\tseekdir(dir, *pos);\n\tent = readdir(dir);\n\tif (ent == NULL)\n\t\treturn NULL;\n\t*len_out = strlen(ent->d_name);\n\t*ino_out = ent->d_ino;\n\t*type_out = ent->d_type;\n\t*pos = telldir(dir);\n\treturn ent->d_name;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nchar *read_dir(void *stream, unsigned long long *pos,\n\t       unsigned long long *ino_out, int *len_out,\n\t       unsigned int *type_out)\n{\n\tDIR *dir = stream;\n\tstruct dirent *ent;\n\n\tseekdir(dir, *pos);\n\tent = readdir(dir);\n\tif (ent == NULL)\n\t\treturn NULL;\n\t*len_out = strlen(ent->d_name);\n\t*ino_out = ent->d_ino;\n\t*type_out = ent->d_type;\n\t*pos = telldir(dir);\n\treturn ent->d_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_dir",
          "args": [
            "name",
            "&error"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "open_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "90-98",
          "snippet": "void *open_dir(char *path, int *err_out)\n{\n\tDIR *dir;\n\n\tdir = opendir(path);\n\t*err_out = errno;\n\n\treturn dir;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nvoid *open_dir(char *path, int *err_out)\n{\n\tDIR *dir;\n\n\tdir = opendir(path);\n\t*err_out = errno;\n\n\treturn dir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tvoid *dir;\n\tchar *name;\n\tunsigned long long next, ino;\n\tint error, len;\n\tunsigned int type;\n\n\tname = dentry_name(file->f_path.dentry);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\tdir = open_dir(name, &error);\n\t__putname(name);\n\tif (dir == NULL)\n\t\treturn -error;\n\tnext = ctx->pos;\n\twhile ((name = read_dir(dir, &next, &ino, &len, &type)) != NULL) {\n\t\tif (!dir_emit(ctx, name, len, ino, type))\n\t\t\tbreak;\n\t\tctx->pos = next;\n\t}\n\tclose_dir(dir);\n\treturn 0;\n}"
  },
  {
    "function_name": "hostfs_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "252-261",
    "snippet": "static int hostfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tconst char *root_path = root->d_sb->s_fs_info;\n\tsize_t offset = strlen(root_ino) + 1;\n\n\tif (strlen(root_path) > offset)\n\t\tseq_printf(seq, \",%s\", root_path + offset);\n\n\treturn 0;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *root_ino = \"\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",%s\"",
            "root_path + offset"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "root_path"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *root_ino = \"\";\n\nstatic int hostfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tconst char *root_path = root->d_sb->s_fs_info;\n\tsize_t offset = strlen(root_ino) + 1;\n\n\tif (strlen(root_path) > offset)\n\t\tseq_printf(seq, \",%s\", root_path + offset);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hostfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "247-250",
    "snippet": "static void hostfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, hostfs_i_callback);\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "hostfs_i_callback"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic void hostfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, hostfs_i_callback);\n}"
  },
  {
    "function_name": "hostfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "241-245",
    "snippet": "static void hostfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkfree(HOSTFS_I(inode));\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "HOSTFS_I(inode)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HOSTFS_I",
          "args": [
            "inode"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "HOSTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "29-32",
          "snippet": "static inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic void hostfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkfree(HOSTFS_I(inode));\n}"
  },
  {
    "function_name": "hostfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "231-239",
    "snippet": "static void hostfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (HOSTFS_I(inode)->fd != -1) {\n\t\tclose_file(&HOSTFS_I(inode)->fd);\n\t\tHOSTFS_I(inode)->fd = -1;\n\t}\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HOSTFS_I",
          "args": [
            "inode"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "HOSTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "29-32",
          "snippet": "static inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_file",
          "args": [
            "&HOSTFS_I(inode)->fd"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "close_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "168-171",
          "snippet": "void close_file(void *stream)\n{\n\tclose(*((int *) stream));\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nvoid close_file(void *stream)\n{\n\tclose(*((int *) stream));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic void hostfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (HOSTFS_I(inode)->fd != -1) {\n\t\tclose_file(&HOSTFS_I(inode)->fd);\n\t\tHOSTFS_I(inode)->fd = -1;\n\t}\n}"
  },
  {
    "function_name": "hostfs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "218-229",
    "snippet": "static struct inode *hostfs_alloc_inode(struct super_block *sb)\n{\n\tstruct hostfs_inode_info *hi;\n\n\thi = kmalloc(sizeof(*hi), GFP_KERNEL);\n\tif (hi == NULL)\n\t\treturn NULL;\n\thi->fd = -1;\n\thi->mode = 0;\n\tinode_init_once(&hi->vfs_inode);\n\treturn &hi->vfs_inode;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&hi->vfs_inode"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*hi)",
            "GFP_KERNEL"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic struct inode *hostfs_alloc_inode(struct super_block *sb)\n{\n\tstruct hostfs_inode_info *hi;\n\n\thi = kmalloc(sizeof(*hi), GFP_KERNEL);\n\tif (hi == NULL)\n\t\treturn NULL;\n\thi->fd = -1;\n\thi->mode = 0;\n\tinode_init_once(&hi->vfs_inode);\n\treturn &hi->vfs_inode;\n}"
  },
  {
    "function_name": "hostfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "189-216",
    "snippet": "static int hostfs_statfs(struct dentry *dentry, struct kstatfs *sf)\n{\n\t/*\n\t * do_statfs uses struct statfs64 internally, but the linux kernel\n\t * struct statfs still has 32-bit versions for most of these fields,\n\t * so we convert them here\n\t */\n\tint err;\n\tlong long f_blocks;\n\tlong long f_bfree;\n\tlong long f_bavail;\n\tlong long f_files;\n\tlong long f_ffree;\n\n\terr = do_statfs(dentry->d_sb->s_fs_info,\n\t\t\t&sf->f_bsize, &f_blocks, &f_bfree, &f_bavail, &f_files,\n\t\t\t&f_ffree, &sf->f_fsid, sizeof(sf->f_fsid),\n\t\t\t&sf->f_namelen);\n\tif (err)\n\t\treturn err;\n\tsf->f_blocks = f_blocks;\n\tsf->f_bfree = f_bfree;\n\tsf->f_bavail = f_bavail;\n\tsf->f_files = f_files;\n\tsf->f_ffree = f_ffree;\n\tsf->f_type = HOSTFS_SUPER_MAGIC;\n\treturn 0;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_statfs",
          "args": [
            "dentry->d_sb->s_fs_info",
            "&sf->f_bsize",
            "&f_blocks",
            "&f_bfree",
            "&f_bavail",
            "&f_files",
            "&f_ffree",
            "&sf->f_fsid",
            "sizeof(sf->f_fsid)",
            "&sf->f_namelen"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "do_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "391-415",
          "snippet": "int do_statfs(char *root, long *bsize_out, long long *blocks_out,\n\t      long long *bfree_out, long long *bavail_out,\n\t      long long *files_out, long long *ffree_out,\n\t      void *fsid_out, int fsid_size, long *namelen_out)\n{\n\tstruct statfs64 buf;\n\tint err;\n\n\terr = statfs64(root, &buf);\n\tif (err < 0)\n\t\treturn -errno;\n\n\t*bsize_out = buf.f_bsize;\n\t*blocks_out = buf.f_blocks;\n\t*bfree_out = buf.f_bfree;\n\t*bavail_out = buf.f_bavail;\n\t*files_out = buf.f_files;\n\t*ffree_out = buf.f_ffree;\n\tmemcpy(fsid_out, &buf.f_fsid,\n\t       sizeof(buf.f_fsid) > fsid_size ? fsid_size :\n\t       sizeof(buf.f_fsid));\n\t*namelen_out = buf.f_namelen;\n\n\treturn 0;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint do_statfs(char *root, long *bsize_out, long long *blocks_out,\n\t      long long *bfree_out, long long *bavail_out,\n\t      long long *files_out, long long *ffree_out,\n\t      void *fsid_out, int fsid_size, long *namelen_out)\n{\n\tstruct statfs64 buf;\n\tint err;\n\n\terr = statfs64(root, &buf);\n\tif (err < 0)\n\t\treturn -errno;\n\n\t*bsize_out = buf.f_bsize;\n\t*blocks_out = buf.f_blocks;\n\t*bfree_out = buf.f_bfree;\n\t*bavail_out = buf.f_bavail;\n\t*files_out = buf.f_files;\n\t*ffree_out = buf.f_ffree;\n\tmemcpy(fsid_out, &buf.f_fsid,\n\t       sizeof(buf.f_fsid) > fsid_size ? fsid_size :\n\t       sizeof(buf.f_fsid));\n\t*namelen_out = buf.f_namelen;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic int hostfs_statfs(struct dentry *dentry, struct kstatfs *sf)\n{\n\t/*\n\t * do_statfs uses struct statfs64 internally, but the linux kernel\n\t * struct statfs still has 32-bit versions for most of these fields,\n\t * so we convert them here\n\t */\n\tint err;\n\tlong long f_blocks;\n\tlong long f_bfree;\n\tlong long f_bavail;\n\tlong long f_files;\n\tlong long f_ffree;\n\n\terr = do_statfs(dentry->d_sb->s_fs_info,\n\t\t\t&sf->f_bsize, &f_blocks, &f_bfree, &f_bavail, &f_files,\n\t\t\t&f_ffree, &sf->f_fsid, sizeof(sf->f_fsid),\n\t\t\t&sf->f_namelen);\n\tif (err)\n\t\treturn err;\n\tsf->f_blocks = f_blocks;\n\tsf->f_bfree = f_bfree;\n\tsf->f_bavail = f_bavail;\n\tsf->f_files = f_files;\n\tsf->f_ffree = f_ffree;\n\tsf->f_type = HOSTFS_SUPER_MAGIC;\n\treturn 0;\n}"
  },
  {
    "function_name": "hostfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "181-187",
    "snippet": "static struct inode *hostfs_iget(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn inode;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic struct inode *hostfs_iget(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn inode;\n}"
  },
  {
    "function_name": "follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "133-179",
    "snippet": "static char *follow_link(char *link)\n{\n\tint len, n;\n\tchar *name, *resolved, *end;\n\n\tlen = 64;\n\twhile (1) {\n\t\tn = -ENOMEM;\n\t\tname = kmalloc(len, GFP_KERNEL);\n\t\tif (name == NULL)\n\t\t\tgoto out;\n\n\t\tn = hostfs_do_readlink(link, name, len);\n\t\tif (n < len)\n\t\t\tbreak;\n\t\tlen *= 2;\n\t\tkfree(name);\n\t}\n\tif (n < 0)\n\t\tgoto out_free;\n\n\tif (*name == '/')\n\t\treturn name;\n\n\tend = strrchr(link, '/');\n\tif (end == NULL)\n\t\treturn name;\n\n\t*(end + 1) = '\\0';\n\tlen = strlen(link) + strlen(name) + 1;\n\n\tresolved = kmalloc(len, GFP_KERNEL);\n\tif (resolved == NULL) {\n\t\tn = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tsprintf(resolved, \"%s%s\", link, name);\n\tkfree(name);\n\tkfree(link);\n\treturn resolved;\n\n out_free:\n\tkfree(name);\n out:\n\treturn ERR_PTR(n);\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "n"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "resolved",
            "\"%s%s\"",
            "link",
            "name"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1609-1628",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "link",
            "'/'"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostfs_do_readlink",
          "args": [
            "link",
            "name",
            "len"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "hostfs_do_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_user.c",
          "lines": "342-352",
          "snippet": "int hostfs_do_readlink(char *file, char *buf, int size)\n{\n\tint n;\n\n\tn = readlink(file, buf, size);\n\tif (n < 0)\n\t\treturn -errno;\n\tif (n < size)\n\t\tbuf[n] = '\\0';\n\treturn n;\n}",
          "includes": [
            "#include <utime.h>",
            "#include \"hostfs.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <utime.h>\n#include \"hostfs.h\"\n#include <sys/syscall.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint hostfs_do_readlink(char *file, char *buf, int size)\n{\n\tint n;\n\n\tn = readlink(file, buf, size);\n\tif (n < 0)\n\t\treturn -errno;\n\tif (n < size)\n\t\tbuf[n] = '\\0';\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *follow_link(char *link)\n{\n\tint len, n;\n\tchar *name, *resolved, *end;\n\n\tlen = 64;\n\twhile (1) {\n\t\tn = -ENOMEM;\n\t\tname = kmalloc(len, GFP_KERNEL);\n\t\tif (name == NULL)\n\t\t\tgoto out;\n\n\t\tn = hostfs_do_readlink(link, name, len);\n\t\tif (n < len)\n\t\t\tbreak;\n\t\tlen *= 2;\n\t\tkfree(name);\n\t}\n\tif (n < 0)\n\t\tgoto out_free;\n\n\tif (*name == '/')\n\t\treturn name;\n\n\tend = strrchr(link, '/');\n\tif (end == NULL)\n\t\treturn name;\n\n\t*(end + 1) = '\\0';\n\tlen = strlen(link) + strlen(name) + 1;\n\n\tresolved = kmalloc(len, GFP_KERNEL);\n\tif (resolved == NULL) {\n\t\tn = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tsprintf(resolved, \"%s%s\", link, name);\n\tkfree(name);\n\tkfree(link);\n\treturn resolved;\n\n out_free:\n\tkfree(name);\n out:\n\treturn ERR_PTR(n);\n}"
  },
  {
    "function_name": "inode_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "117-131",
    "snippet": "static char *inode_name(struct inode *ino)\n{\n\tstruct dentry *dentry;\n\tchar *name;\n\n\tdentry = d_find_alias(ino);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tname = dentry_name(dentry);\n\n\tdput(dentry);\n\n\treturn name;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "dentry"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "108-115",
          "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "ino"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *inode_name(struct inode *ino)\n{\n\tstruct dentry *dentry;\n\tchar *name;\n\n\tdentry = d_find_alias(ino);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tname = dentry_name(dentry);\n\n\tdput(dentry);\n\n\treturn name;\n}"
  },
  {
    "function_name": "dentry_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "108-115",
    "snippet": "static char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dentry_name",
          "args": [
            "dentry",
            "name"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "__dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
          "lines": "83-106",
          "snippet": "static char *__dentry_name(struct dentry *dentry, char *name)\n{\n\tchar *p = dentry_path_raw(dentry, name, PATH_MAX);\n\tchar *root;\n\tsize_t len;\n\n\troot = dentry->d_sb->s_fs_info;\n\tlen = strlen(root);\n\tif (IS_ERR(p)) {\n\t\t__putname(name);\n\t\treturn NULL;\n\t}\n\tstrlcpy(name, root, PATH_MAX);\n\tif (len > p - name) {\n\t\t__putname(name);\n\t\treturn NULL;\n\t}\n\tif (p > name + len) {\n\t\tchar *s = name + len;\n\t\twhile ((*s++ = *p++) != '\\0')\n\t\t\t;\n\t}\n\treturn name;\n}",
          "includes": [
            "#include <kern.h>",
            "#include <init.h>",
            "#include \"hostfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/statfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *__dentry_name(struct dentry *dentry, char *name)\n{\n\tchar *p = dentry_path_raw(dentry, name, PATH_MAX);\n\tchar *root;\n\tsize_t len;\n\n\troot = dentry->d_sb->s_fs_info;\n\tlen = strlen(root);\n\tif (IS_ERR(p)) {\n\t\t__putname(name);\n\t\treturn NULL;\n\t}\n\tstrlcpy(name, root, PATH_MAX);\n\tif (len > p - name) {\n\t\t__putname(name);\n\t\treturn NULL;\n\t}\n\tif (p > name + len) {\n\t\tchar *s = name + len;\n\t\twhile ((*s++ = *p++) != '\\0')\n\t\t\t;\n\t}\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__getname",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}"
  },
  {
    "function_name": "__dentry_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "83-106",
    "snippet": "static char *__dentry_name(struct dentry *dentry, char *name)\n{\n\tchar *p = dentry_path_raw(dentry, name, PATH_MAX);\n\tchar *root;\n\tsize_t len;\n\n\troot = dentry->d_sb->s_fs_info;\n\tlen = strlen(root);\n\tif (IS_ERR(p)) {\n\t\t__putname(name);\n\t\treturn NULL;\n\t}\n\tstrlcpy(name, root, PATH_MAX);\n\tif (len > p - name) {\n\t\t__putname(name);\n\t\treturn NULL;\n\t}\n\tif (p > name + len) {\n\t\tchar *s = name + len;\n\t\twhile ((*s++ = *p++) != '\\0')\n\t\t\t;\n\t}\n\treturn name;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "name",
            "root",
            "PATH_MAX"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "root"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_path_raw",
          "args": [
            "dentry",
            "name",
            "PATH_MAX"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_path_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3160-3163",
          "snippet": "char *dentry_path_raw(struct dentry *dentry, char *buf, int buflen)\n{\n\treturn __dentry_path(dentry, buf, buflen);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nchar *dentry_path_raw(struct dentry *dentry, char *buf, int buflen)\n{\n\treturn __dentry_path(dentry, buf, buflen);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *__dentry_name(struct dentry *dentry, char *name)\n{\n\tchar *p = dentry_path_raw(dentry, name, PATH_MAX);\n\tchar *root;\n\tsize_t len;\n\n\troot = dentry->d_sb->s_fs_info;\n\tlen = strlen(root);\n\tif (IS_ERR(p)) {\n\t\t__putname(name);\n\t\treturn NULL;\n\t}\n\tstrlcpy(name, root, PATH_MAX);\n\tif (len > p - name) {\n\t\t__putname(name);\n\t\treturn NULL;\n\t}\n\tif (p > name + len) {\n\t\tchar *s = name + len;\n\t\twhile ((*s++ = *p++) != '\\0')\n\t\t\t;\n\t}\n\treturn name;\n}"
  },
  {
    "function_name": "hostfs_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "45-69",
    "snippet": "static int __init hostfs_args(char *options, int *add)\n{\n\tchar *ptr;\n\n\tptr = strchr(options, ',');\n\tif (ptr != NULL)\n\t\t*ptr++ = '\\0';\n\tif (*options != '\\0')\n\t\troot_ino = options;\n\n\toptions = ptr;\n\twhile (options) {\n\t\tptr = strchr(options, ',');\n\t\tif (ptr != NULL)\n\t\t\t*ptr++ = '\\0';\n\t\tif (*options != '\\0') {\n\t\t\tif (!strcmp(options, \"append\"))\n\t\t\t\tappend = 1;\n\t\t\telse printf(\"hostfs_args - unsupported option - %s\\n\",\n\t\t\t\t    options);\n\t\t}\n\t\toptions = ptr;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *root_ino = \"\";",
      "static int append = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"hostfs_args - unsupported option - %s\\n\"",
            "options"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "options",
            "\"append\""
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "options",
            "','"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "options",
            "','"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic char *root_ino = \"\";\nstatic int append = 0;\n\nstatic int __init hostfs_args(char *options, int *add)\n{\n\tchar *ptr;\n\n\tptr = strchr(options, ',');\n\tif (ptr != NULL)\n\t\t*ptr++ = '\\0';\n\tif (*options != '\\0')\n\t\troot_ino = options;\n\n\toptions = ptr;\n\twhile (options) {\n\t\tptr = strchr(options, ',');\n\t\tif (ptr != NULL)\n\t\t\t*ptr++ = '\\0';\n\t\tif (*options != '\\0') {\n\t\t\tif (!strcmp(options, \"append\"))\n\t\t\t\tappend = 1;\n\t\t\telse printf(\"hostfs_args - unsupported option - %s\\n\",\n\t\t\t\t    options);\n\t\t}\n\t\toptions = ptr;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "HOSTFS_I",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hostfs/hostfs_kern.c",
    "lines": "29-32",
    "snippet": "static inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}",
    "includes": [
      "#include <kern.h>",
      "#include <init.h>",
      "#include \"hostfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/statfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "inode",
            "structhostfs_inode_info",
            "vfs_inode"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kern.h>\n#include <init.h>\n#include \"hostfs.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}"
  }
]