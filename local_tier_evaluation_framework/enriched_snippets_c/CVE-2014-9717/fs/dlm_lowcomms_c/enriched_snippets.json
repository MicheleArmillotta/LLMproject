[
  {
    "function_name": "dlm_lowcomms_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1818-1830",
    "snippet": "void dlm_lowcomms_exit(void)\n{\n\tstruct dlm_node_addr *na, *safe;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tlist_for_each_entry_safe(na, safe, &dlm_node_addrs, list) {\n\t\tlist_del(&na->list);\n\t\twhile (na->addr_count--)\n\t\t\tkfree(na->addr[na->addr_count]);\n\t\tkfree(na);\n\t}\n\tspin_unlock(&dlm_node_addrs_spin);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(dlm_node_addrs);",
      "static DEFINE_SPINLOCK(dlm_node_addrs_spin);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_node_addrs_spin"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "na"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "na->addr[na->addr_count]"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&na->list"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "na",
            "safe",
            "&dlm_node_addrs",
            "list"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_node_addrs_spin"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic LIST_HEAD(dlm_node_addrs);\nstatic DEFINE_SPINLOCK(dlm_node_addrs_spin);\n\nvoid dlm_lowcomms_exit(void)\n{\n\tstruct dlm_node_addr *na, *safe;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tlist_for_each_entry_safe(na, safe, &dlm_node_addrs, list) {\n\t\tlist_del(&na->list);\n\t\twhile (na->addr_count--)\n\t\t\tkfree(na->addr[na->addr_count]);\n\t\tkfree(na);\n\t}\n\tspin_unlock(&dlm_node_addrs_spin);\n}"
  },
  {
    "function_name": "dlm_lowcomms_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1766-1816",
    "snippet": "int dlm_lowcomms_start(void)\n{\n\tint error = -EINVAL;\n\tstruct connection *con;\n\tint i;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&connection_hash[i]);\n\n\tinit_local();\n\tif (!dlm_local_count) {\n\t\terror = -ENOTCONN;\n\t\tlog_print(\"no local IP address has been set\");\n\t\tgoto fail;\n\t}\n\n\terror = -ENOMEM;\n\tcon_cache = kmem_cache_create(\"dlm_conn\", sizeof(struct connection),\n\t\t\t\t      __alignof__(struct connection), 0,\n\t\t\t\t      NULL);\n\tif (!con_cache)\n\t\tgoto fail;\n\n\terror = work_start();\n\tif (error)\n\t\tgoto fail_destroy;\n\n\tdlm_allow_conn = 1;\n\n\t/* Start listening */\n\tif (dlm_config.ci_protocol == 0)\n\t\terror = tcp_listen_for_all();\n\telse\n\t\terror = sctp_listen_for_all();\n\tif (error)\n\t\tgoto fail_unlisten;\n\n\treturn 0;\n\nfail_unlisten:\n\tdlm_allow_conn = 0;\n\tcon = nodeid2con(0,0);\n\tif (con) {\n\t\tclose_connection(con, false);\n\t\tkmem_cache_free(con_cache, con);\n\t}\nfail_destroy:\n\tkmem_cache_destroy(con_cache);\nfail:\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CONN_HASH_SIZE 32"
    ],
    "globals_used": [
      "static int dlm_local_count;",
      "static int dlm_allow_conn;",
      "static struct hlist_head connection_hash[CONN_HASH_SIZE];",
      "static struct kmem_cache *con_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "con_cache"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "con_cache",
            "con"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_connection",
          "args": [
            "con",
            "false"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "close_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "517-536",
          "snippet": "static void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeid2con",
          "args": [
            "0",
            "0"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "244-253",
          "snippet": "static struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sctp_listen_for_all",
          "args": [],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "sctp_listen_for_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1353-1432",
          "snippet": "static int sctp_listen_for_all(void)\n{\n\tstruct socket *sock = NULL;\n\tstruct sockaddr_storage localaddr;\n\tstruct sctp_event_subscribe subscribe;\n\tint result = -EINVAL, num = 1, i, addr_len;\n\tstruct connection *con = nodeid2con(0, GFP_NOFS);\n\tint bufsize = NEEDED_RMEM;\n\tint one = 1;\n\n\tif (!con)\n\t\treturn -ENOMEM;\n\n\tlog_print(\"Using SCTP for communications\");\n\n\tresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_SEQPACKET,\n\t\t\t\t  IPPROTO_SCTP, &sock);\n\tif (result < 0) {\n\t\tlog_print(\"Can't create comms socket, check SCTP is loaded\");\n\t\tgoto out;\n\t}\n\n\t/* Listen for events */\n\tmemset(&subscribe, 0, sizeof(subscribe));\n\tsubscribe.sctp_data_io_event = 1;\n\tsubscribe.sctp_association_event = 1;\n\tsubscribe.sctp_send_failure_event = 1;\n\tsubscribe.sctp_shutdown_event = 1;\n\tsubscribe.sctp_partial_delivery_event = 1;\n\n\tresult = kernel_setsockopt(sock, SOL_SOCKET, SO_RCVBUFFORCE,\n\t\t\t\t (char *)&bufsize, sizeof(bufsize));\n\tif (result)\n\t\tlog_print(\"Error increasing buffer space on socket %d\", result);\n\n\tresult = kernel_setsockopt(sock, SOL_SCTP, SCTP_EVENTS,\n\t\t\t\t   (char *)&subscribe, sizeof(subscribe));\n\tif (result < 0) {\n\t\tlog_print(\"Failed to set SCTP_EVENTS on socket: result=%d\",\n\t\t\t  result);\n\t\tgoto create_delsock;\n\t}\n\n\tresult = kernel_setsockopt(sock, SOL_SCTP, SCTP_NODELAY, (char *)&one,\n\t\t\t\t   sizeof(one));\n\tif (result < 0)\n\t\tlog_print(\"Could not set SCTP NODELAY error %d\\n\", result);\n\n\t/* Init con struct */\n\tsock->sk->sk_user_data = con;\n\tcon->sock = sock;\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->rx_action = receive_from_sock;\n\tcon->connect_action = sctp_init_assoc;\n\n\t/* Bind to all interfaces. */\n\tfor (i = 0; i < dlm_local_count; i++) {\n\t\tmemcpy(&localaddr, dlm_local_addr[i], sizeof(localaddr));\n\t\tmake_sockaddr(&localaddr, dlm_config.ci_tcp_port, &addr_len);\n\n\t\tresult = add_sctp_bind_addr(con, &localaddr, addr_len, num);\n\t\tif (result)\n\t\t\tgoto create_delsock;\n\t\t++num;\n\t}\n\n\tresult = sock->ops->listen(sock, 5);\n\tif (result < 0) {\n\t\tlog_print(\"Can't set socket listening\");\n\t\tgoto create_delsock;\n\t}\n\n\treturn 0;\n\ncreate_delsock:\n\tsock_release(sock);\n\tcon->sock = NULL;\nout:\n\treturn result;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define NEEDED_RMEM (4*1024*1024)"
          ],
          "globals_used": [
            "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];",
            "static int dlm_local_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define NEEDED_RMEM (4*1024*1024)\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\nstatic int dlm_local_count;\n\nstatic int sctp_listen_for_all(void)\n{\n\tstruct socket *sock = NULL;\n\tstruct sockaddr_storage localaddr;\n\tstruct sctp_event_subscribe subscribe;\n\tint result = -EINVAL, num = 1, i, addr_len;\n\tstruct connection *con = nodeid2con(0, GFP_NOFS);\n\tint bufsize = NEEDED_RMEM;\n\tint one = 1;\n\n\tif (!con)\n\t\treturn -ENOMEM;\n\n\tlog_print(\"Using SCTP for communications\");\n\n\tresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_SEQPACKET,\n\t\t\t\t  IPPROTO_SCTP, &sock);\n\tif (result < 0) {\n\t\tlog_print(\"Can't create comms socket, check SCTP is loaded\");\n\t\tgoto out;\n\t}\n\n\t/* Listen for events */\n\tmemset(&subscribe, 0, sizeof(subscribe));\n\tsubscribe.sctp_data_io_event = 1;\n\tsubscribe.sctp_association_event = 1;\n\tsubscribe.sctp_send_failure_event = 1;\n\tsubscribe.sctp_shutdown_event = 1;\n\tsubscribe.sctp_partial_delivery_event = 1;\n\n\tresult = kernel_setsockopt(sock, SOL_SOCKET, SO_RCVBUFFORCE,\n\t\t\t\t (char *)&bufsize, sizeof(bufsize));\n\tif (result)\n\t\tlog_print(\"Error increasing buffer space on socket %d\", result);\n\n\tresult = kernel_setsockopt(sock, SOL_SCTP, SCTP_EVENTS,\n\t\t\t\t   (char *)&subscribe, sizeof(subscribe));\n\tif (result < 0) {\n\t\tlog_print(\"Failed to set SCTP_EVENTS on socket: result=%d\",\n\t\t\t  result);\n\t\tgoto create_delsock;\n\t}\n\n\tresult = kernel_setsockopt(sock, SOL_SCTP, SCTP_NODELAY, (char *)&one,\n\t\t\t\t   sizeof(one));\n\tif (result < 0)\n\t\tlog_print(\"Could not set SCTP NODELAY error %d\\n\", result);\n\n\t/* Init con struct */\n\tsock->sk->sk_user_data = con;\n\tcon->sock = sock;\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->rx_action = receive_from_sock;\n\tcon->connect_action = sctp_init_assoc;\n\n\t/* Bind to all interfaces. */\n\tfor (i = 0; i < dlm_local_count; i++) {\n\t\tmemcpy(&localaddr, dlm_local_addr[i], sizeof(localaddr));\n\t\tmake_sockaddr(&localaddr, dlm_config.ci_tcp_port, &addr_len);\n\n\t\tresult = add_sctp_bind_addr(con, &localaddr, addr_len, num);\n\t\tif (result)\n\t\t\tgoto create_delsock;\n\t\t++num;\n\t}\n\n\tresult = sock->ops->listen(sock, 5);\n\tif (result < 0) {\n\t\tlog_print(\"Can't set socket listening\");\n\t\tgoto create_delsock;\n\t}\n\n\treturn 0;\n\ncreate_delsock:\n\tsock_release(sock);\n\tcon->sock = NULL;\nout:\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcp_listen_for_all",
          "args": [],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "tcp_listen_for_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1434-1462",
          "snippet": "static int tcp_listen_for_all(void)\n{\n\tstruct socket *sock = NULL;\n\tstruct connection *con = nodeid2con(0, GFP_NOFS);\n\tint result = -EINVAL;\n\n\tif (!con)\n\t\treturn -ENOMEM;\n\n\t/* We don't support multi-homed hosts */\n\tif (dlm_local_addr[1] != NULL) {\n\t\tlog_print(\"TCP protocol can't handle multi-homed hosts, \"\n\t\t\t  \"try SCTP\");\n\t\treturn -EINVAL;\n\t}\n\n\tlog_print(\"Using TCP for communications\");\n\n\tsock = tcp_create_listen_sock(con, dlm_local_addr[0]);\n\tif (sock) {\n\t\tadd_sock(sock, con);\n\t\tresult = 0;\n\t}\n\telse {\n\t\tresult = -EADDRINUSE;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\n\nstatic int tcp_listen_for_all(void)\n{\n\tstruct socket *sock = NULL;\n\tstruct connection *con = nodeid2con(0, GFP_NOFS);\n\tint result = -EINVAL;\n\n\tif (!con)\n\t\treturn -ENOMEM;\n\n\t/* We don't support multi-homed hosts */\n\tif (dlm_local_addr[1] != NULL) {\n\t\tlog_print(\"TCP protocol can't handle multi-homed hosts, \"\n\t\t\t  \"try SCTP\");\n\t\treturn -EINVAL;\n\t}\n\n\tlog_print(\"Using TCP for communications\");\n\n\tsock = tcp_create_listen_sock(con, dlm_local_addr[0]);\n\tif (sock) {\n\t\tadd_sock(sock, con);\n\t\tresult = 0;\n\t}\n\telse {\n\t\tresult = -EADDRINUSE;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_start",
          "args": [],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "work_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1709-1727",
          "snippet": "static int work_start(void)\n{\n\trecv_workqueue = alloc_workqueue(\"dlm_recv\",\n\t\t\t\t\t WQ_UNBOUND | WQ_MEM_RECLAIM, 1);\n\tif (!recv_workqueue) {\n\t\tlog_print(\"can't start dlm_recv\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsend_workqueue = alloc_workqueue(\"dlm_send\",\n\t\t\t\t\t WQ_UNBOUND | WQ_MEM_RECLAIM, 1);\n\tif (!send_workqueue) {\n\t\tlog_print(\"can't start dlm_send\");\n\t\tdestroy_workqueue(recv_workqueue);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *recv_workqueue;",
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct workqueue_struct *recv_workqueue;\nstatic struct workqueue_struct *send_workqueue;\n\nstatic int work_start(void)\n{\n\trecv_workqueue = alloc_workqueue(\"dlm_recv\",\n\t\t\t\t\t WQ_UNBOUND | WQ_MEM_RECLAIM, 1);\n\tif (!recv_workqueue) {\n\t\tlog_print(\"can't start dlm_recv\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsend_workqueue = alloc_workqueue(\"dlm_send\",\n\t\t\t\t\t WQ_UNBOUND | WQ_MEM_RECLAIM, 1);\n\tif (!send_workqueue) {\n\t\tlog_print(\"can't start dlm_send\");\n\t\tdestroy_workqueue(recv_workqueue);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"dlm_conn\"",
            "sizeof(struct connection)",
            "__alignof__(struct connection)",
            "0",
            "NULL"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"no local IP address has been set\""
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_local",
          "args": [],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "init_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1310-1326",
          "snippet": "static void init_local(void)\n{\n\tstruct sockaddr_storage sas, *addr;\n\tint i;\n\n\tdlm_local_count = 0;\n\tfor (i = 0; i < DLM_MAX_ADDR_COUNT; i++) {\n\t\tif (dlm_our_addr(&sas, i))\n\t\t\tbreak;\n\n\t\taddr = kmalloc(sizeof(*addr), GFP_NOFS);\n\t\tif (!addr)\n\t\t\tbreak;\n\t\tmemcpy(addr, &sas, sizeof(*addr));\n\t\tdlm_local_addr[dlm_local_count++] = addr;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];",
            "static int dlm_local_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\nstatic int dlm_local_count;\n\nstatic void init_local(void)\n{\n\tstruct sockaddr_storage sas, *addr;\n\tint i;\n\n\tdlm_local_count = 0;\n\tfor (i = 0; i < DLM_MAX_ADDR_COUNT; i++) {\n\t\tif (dlm_our_addr(&sas, i))\n\t\t\tbreak;\n\n\t\taddr = kmalloc(sizeof(*addr), GFP_NOFS);\n\t\tif (!addr)\n\t\t\tbreak;\n\t\tmemcpy(addr, &sas, sizeof(*addr));\n\t\tdlm_local_addr[dlm_local_count++] = addr;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&connection_hash[i]"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CONN_HASH_SIZE 32\n\nstatic int dlm_local_count;\nstatic int dlm_allow_conn;\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\nstatic struct kmem_cache *con_cache;\n\nint dlm_lowcomms_start(void)\n{\n\tint error = -EINVAL;\n\tstruct connection *con;\n\tint i;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&connection_hash[i]);\n\n\tinit_local();\n\tif (!dlm_local_count) {\n\t\terror = -ENOTCONN;\n\t\tlog_print(\"no local IP address has been set\");\n\t\tgoto fail;\n\t}\n\n\terror = -ENOMEM;\n\tcon_cache = kmem_cache_create(\"dlm_conn\", sizeof(struct connection),\n\t\t\t\t      __alignof__(struct connection), 0,\n\t\t\t\t      NULL);\n\tif (!con_cache)\n\t\tgoto fail;\n\n\terror = work_start();\n\tif (error)\n\t\tgoto fail_destroy;\n\n\tdlm_allow_conn = 1;\n\n\t/* Start listening */\n\tif (dlm_config.ci_protocol == 0)\n\t\terror = tcp_listen_for_all();\n\telse\n\t\terror = sctp_listen_for_all();\n\tif (error)\n\t\tgoto fail_unlisten;\n\n\treturn 0;\n\nfail_unlisten:\n\tdlm_allow_conn = 0;\n\tcon = nodeid2con(0,0);\n\tif (con) {\n\t\tclose_connection(con, false);\n\t\tkmem_cache_free(con_cache, con);\n\t}\nfail_destroy:\n\tkmem_cache_destroy(con_cache);\nfail:\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_lowcomms_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1745-1764",
    "snippet": "void dlm_lowcomms_stop(void)\n{\n\t/* Set all the flags to prevent any\n\t   socket activity.\n\t*/\n\tmutex_lock(&connections_lock);\n\tdlm_allow_conn = 0;\n\tforeach_conn(stop_conn);\n\tmutex_unlock(&connections_lock);\n\n\twork_stop();\n\n\tmutex_lock(&connections_lock);\n\tclean_writequeues();\n\n\tforeach_conn(free_conn);\n\n\tmutex_unlock(&connections_lock);\n\tkmem_cache_destroy(con_cache);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_allow_conn;",
      "static DEFINE_MUTEX(connections_lock);",
      "static struct kmem_cache *con_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "con_cache"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&connections_lock"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach_conn",
          "args": [
            "free_conn"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "foreach_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "232-242",
          "snippet": "static void foreach_conn(void (*conn_func)(struct connection *c))\n{\n\tint i;\n\tstruct hlist_node *n;\n\tstruct connection *con;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_safe(con, n, &connection_hash[i], list)\n\t\t\tconn_func(con);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CONN_HASH_SIZE 32"
          ],
          "globals_used": [
            "static struct hlist_head connection_hash[CONN_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CONN_HASH_SIZE 32\n\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\n\nstatic void foreach_conn(void (*conn_func)(struct connection *c))\n{\n\tint i;\n\tstruct hlist_node *n;\n\tstruct connection *con;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_safe(con, n, &connection_hash[i], list)\n\t\t\tconn_func(con);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_writequeues",
          "args": [],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "clean_writequeues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1698-1701",
          "snippet": "static void clean_writequeues(void)\n{\n\tforeach_conn(clean_one_writequeue);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void clean_writequeues(void)\n{\n\tforeach_conn(clean_one_writequeue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&connections_lock"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_stop",
          "args": [],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "work_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1703-1707",
          "snippet": "static void work_stop(void)\n{\n\tdestroy_workqueue(recv_workqueue);\n\tdestroy_workqueue(send_workqueue);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *recv_workqueue;",
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct workqueue_struct *recv_workqueue;\nstatic struct workqueue_struct *send_workqueue;\n\nstatic void work_stop(void)\n{\n\tdestroy_workqueue(recv_workqueue);\n\tdestroy_workqueue(send_workqueue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&connections_lock"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&connections_lock"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic int dlm_allow_conn;\nstatic DEFINE_MUTEX(connections_lock);\nstatic struct kmem_cache *con_cache;\n\nvoid dlm_lowcomms_stop(void)\n{\n\t/* Set all the flags to prevent any\n\t   socket activity.\n\t*/\n\tmutex_lock(&connections_lock);\n\tdlm_allow_conn = 0;\n\tforeach_conn(stop_conn);\n\tmutex_unlock(&connections_lock);\n\n\twork_stop();\n\n\tmutex_lock(&connections_lock);\n\tclean_writequeues();\n\n\tforeach_conn(free_conn);\n\n\tmutex_unlock(&connections_lock);\n\tkmem_cache_destroy(con_cache);\n}"
  },
  {
    "function_name": "free_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1736-1743",
    "snippet": "static void free_conn(struct connection *con)\n{\n\tclose_connection(con, true);\n\tif (con->othercon)\n\t\tkmem_cache_free(con_cache, con->othercon);\n\thlist_del(&con->list);\n\tkmem_cache_free(con_cache, con);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *con_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "con_cache",
            "con"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&con->list"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "con_cache",
            "con->othercon"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_connection",
          "args": [
            "con",
            "true"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "close_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "517-536",
          "snippet": "static void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct kmem_cache *con_cache;\n\nstatic void free_conn(struct connection *con)\n{\n\tclose_connection(con, true);\n\tif (con->othercon)\n\t\tkmem_cache_free(con_cache, con->othercon);\n\thlist_del(&con->list);\n\tkmem_cache_free(con_cache, con);\n}"
  },
  {
    "function_name": "stop_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1729-1734",
    "snippet": "static void stop_conn(struct connection *con)\n{\n\tcon->flags |= 0x0F;\n\tif (con->sock && con->sock->sk)\n\t\tcon->sock->sk->sk_user_data = NULL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void stop_conn(struct connection *con)\n{\n\tcon->flags |= 0x0F;\n\tif (con->sock && con->sock->sk)\n\t\tcon->sock->sk->sk_user_data = NULL;\n}"
  },
  {
    "function_name": "work_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1709-1727",
    "snippet": "static int work_start(void)\n{\n\trecv_workqueue = alloc_workqueue(\"dlm_recv\",\n\t\t\t\t\t WQ_UNBOUND | WQ_MEM_RECLAIM, 1);\n\tif (!recv_workqueue) {\n\t\tlog_print(\"can't start dlm_recv\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsend_workqueue = alloc_workqueue(\"dlm_send\",\n\t\t\t\t\t WQ_UNBOUND | WQ_MEM_RECLAIM, 1);\n\tif (!send_workqueue) {\n\t\tlog_print(\"can't start dlm_send\");\n\t\tdestroy_workqueue(recv_workqueue);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *recv_workqueue;",
      "static struct workqueue_struct *send_workqueue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "recv_workqueue"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"can't start dlm_send\""
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"dlm_send\"",
            "WQ_UNBOUND | WQ_MEM_RECLAIM",
            "1"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"can't start dlm_recv\""
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"dlm_recv\"",
            "WQ_UNBOUND | WQ_MEM_RECLAIM",
            "1"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct workqueue_struct *recv_workqueue;\nstatic struct workqueue_struct *send_workqueue;\n\nstatic int work_start(void)\n{\n\trecv_workqueue = alloc_workqueue(\"dlm_recv\",\n\t\t\t\t\t WQ_UNBOUND | WQ_MEM_RECLAIM, 1);\n\tif (!recv_workqueue) {\n\t\tlog_print(\"can't start dlm_recv\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsend_workqueue = alloc_workqueue(\"dlm_send\",\n\t\t\t\t\t WQ_UNBOUND | WQ_MEM_RECLAIM, 1);\n\tif (!send_workqueue) {\n\t\tlog_print(\"can't start dlm_send\");\n\t\tdestroy_workqueue(recv_workqueue);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "work_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1703-1707",
    "snippet": "static void work_stop(void)\n{\n\tdestroy_workqueue(recv_workqueue);\n\tdestroy_workqueue(send_workqueue);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *recv_workqueue;",
      "static struct workqueue_struct *send_workqueue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "send_workqueue"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct workqueue_struct *recv_workqueue;\nstatic struct workqueue_struct *send_workqueue;\n\nstatic void work_stop(void)\n{\n\tdestroy_workqueue(recv_workqueue);\n\tdestroy_workqueue(send_workqueue);\n}"
  },
  {
    "function_name": "clean_writequeues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1698-1701",
    "snippet": "static void clean_writequeues(void)\n{\n\tforeach_conn(clean_one_writequeue);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "foreach_conn",
          "args": [
            "clean_one_writequeue"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "foreach_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "232-242",
          "snippet": "static void foreach_conn(void (*conn_func)(struct connection *c))\n{\n\tint i;\n\tstruct hlist_node *n;\n\tstruct connection *con;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_safe(con, n, &connection_hash[i], list)\n\t\t\tconn_func(con);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CONN_HASH_SIZE 32"
          ],
          "globals_used": [
            "static struct hlist_head connection_hash[CONN_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CONN_HASH_SIZE 32\n\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\n\nstatic void foreach_conn(void (*conn_func)(struct connection *c))\n{\n\tint i;\n\tstruct hlist_node *n;\n\tstruct connection *con;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_safe(con, n, &connection_hash[i], list)\n\t\t\tconn_func(con);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void clean_writequeues(void)\n{\n\tforeach_conn(clean_one_writequeue);\n}"
  },
  {
    "function_name": "process_send_sockets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1684-1694",
    "snippet": "static void process_send_sockets(struct work_struct *work)\n{\n\tstruct connection *con = container_of(work, struct connection, swork);\n\n\tif (test_and_clear_bit(CF_CONNECT_PENDING, &con->flags)) {\n\t\tcon->connect_action(con);\n\t\tset_bit(CF_WRITE_PENDING, &con->flags);\n\t}\n\tif (test_and_clear_bit(CF_WRITE_PENDING, &con->flags))\n\t\tsend_to_sock(con);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_CONNECT_PENDING 3",
      "#define CF_WRITE_PENDING 2"
    ],
    "globals_used": [
      "static void process_recv_sockets(struct work_struct *work);",
      "static void process_send_sockets(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_to_sock",
          "args": [
            "con"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "send_to_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1555-1623",
          "snippet": "static void send_to_sock(struct connection *con)\n{\n\tint ret = 0;\n\tconst int msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL;\n\tstruct writequeue_entry *e;\n\tint len, offset;\n\tint count = 0;\n\n\tmutex_lock(&con->sock_mutex);\n\tif (con->sock == NULL)\n\t\tgoto out_connect;\n\n\tspin_lock(&con->writequeue_lock);\n\tfor (;;) {\n\t\te = list_entry(con->writequeue.next, struct writequeue_entry,\n\t\t\t       list);\n\t\tif ((struct list_head *) e == &con->writequeue)\n\t\t\tbreak;\n\n\t\tlen = e->len;\n\t\toffset = e->offset;\n\t\tBUG_ON(len == 0 && e->users == 0);\n\t\tspin_unlock(&con->writequeue_lock);\n\n\t\tret = 0;\n\t\tif (len) {\n\t\t\tret = kernel_sendpage(con->sock, e->page, offset, len,\n\t\t\t\t\t      msg_flags);\n\t\t\tif (ret == -EAGAIN || ret == 0) {\n\t\t\t\tif (ret == -EAGAIN &&\n\t\t\t\t    test_bit(SOCK_ASYNC_NOSPACE, &con->sock->flags) &&\n\t\t\t\t    !test_and_set_bit(CF_APP_LIMITED, &con->flags)) {\n\t\t\t\t\t/* Notify TCP that we're limited by the\n\t\t\t\t\t * application window size.\n\t\t\t\t\t */\n\t\t\t\t\tset_bit(SOCK_NOSPACE, &con->sock->flags);\n\t\t\t\t\tcon->sock->sk->sk_write_pending++;\n\t\t\t\t}\n\t\t\t\tcond_resched();\n\t\t\t\tgoto out;\n\t\t\t} else if (ret < 0)\n\t\t\t\tgoto send_error;\n\t\t}\n\n\t\t/* Don't starve people filling buffers */\n\t\tif (++count >= MAX_SEND_MSG_COUNT) {\n\t\t\tcond_resched();\n\t\t\tcount = 0;\n\t\t}\n\n\t\tspin_lock(&con->writequeue_lock);\n\t\twritequeue_entry_complete(e, ret);\n\t}\n\tspin_unlock(&con->writequeue_lock);\nout:\n\tmutex_unlock(&con->sock_mutex);\n\treturn;\n\nsend_error:\n\tmutex_unlock(&con->sock_mutex);\n\tclose_connection(con, false);\n\tlowcomms_connect_sock(con);\n\treturn;\n\nout_connect:\n\tmutex_unlock(&con->sock_mutex);\n\tif (!test_bit(CF_INIT_PENDING, &con->flags))\n\t\tlowcomms_connect_sock(con);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CF_APP_LIMITED 7",
            "#define CF_INIT_PENDING 4",
            "#define MAX_SEND_MSG_COUNT 25"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_APP_LIMITED 7\n#define CF_INIT_PENDING 4\n#define MAX_SEND_MSG_COUNT 25\n\nstatic void send_to_sock(struct connection *con)\n{\n\tint ret = 0;\n\tconst int msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL;\n\tstruct writequeue_entry *e;\n\tint len, offset;\n\tint count = 0;\n\n\tmutex_lock(&con->sock_mutex);\n\tif (con->sock == NULL)\n\t\tgoto out_connect;\n\n\tspin_lock(&con->writequeue_lock);\n\tfor (;;) {\n\t\te = list_entry(con->writequeue.next, struct writequeue_entry,\n\t\t\t       list);\n\t\tif ((struct list_head *) e == &con->writequeue)\n\t\t\tbreak;\n\n\t\tlen = e->len;\n\t\toffset = e->offset;\n\t\tBUG_ON(len == 0 && e->users == 0);\n\t\tspin_unlock(&con->writequeue_lock);\n\n\t\tret = 0;\n\t\tif (len) {\n\t\t\tret = kernel_sendpage(con->sock, e->page, offset, len,\n\t\t\t\t\t      msg_flags);\n\t\t\tif (ret == -EAGAIN || ret == 0) {\n\t\t\t\tif (ret == -EAGAIN &&\n\t\t\t\t    test_bit(SOCK_ASYNC_NOSPACE, &con->sock->flags) &&\n\t\t\t\t    !test_and_set_bit(CF_APP_LIMITED, &con->flags)) {\n\t\t\t\t\t/* Notify TCP that we're limited by the\n\t\t\t\t\t * application window size.\n\t\t\t\t\t */\n\t\t\t\t\tset_bit(SOCK_NOSPACE, &con->sock->flags);\n\t\t\t\t\tcon->sock->sk->sk_write_pending++;\n\t\t\t\t}\n\t\t\t\tcond_resched();\n\t\t\t\tgoto out;\n\t\t\t} else if (ret < 0)\n\t\t\t\tgoto send_error;\n\t\t}\n\n\t\t/* Don't starve people filling buffers */\n\t\tif (++count >= MAX_SEND_MSG_COUNT) {\n\t\t\tcond_resched();\n\t\t\tcount = 0;\n\t\t}\n\n\t\tspin_lock(&con->writequeue_lock);\n\t\twritequeue_entry_complete(e, ret);\n\t}\n\tspin_unlock(&con->writequeue_lock);\nout:\n\tmutex_unlock(&con->sock_mutex);\n\treturn;\n\nsend_error:\n\tmutex_unlock(&con->sock_mutex);\n\tclose_connection(con, false);\n\tlowcomms_connect_sock(con);\n\treturn;\n\nout_connect:\n\tmutex_unlock(&con->sock_mutex);\n\tif (!test_bit(CF_INIT_PENDING, &con->flags))\n\t\tlowcomms_connect_sock(con);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "CF_WRITE_PENDING",
            "&con->flags"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CF_WRITE_PENDING",
            "&con->flags"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "con->connect_action",
          "args": [
            "con"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structconnection",
            "swork"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_CONNECT_PENDING 3\n#define CF_WRITE_PENDING 2\n\nstatic void process_recv_sockets(struct work_struct *work);\nstatic void process_send_sockets(struct work_struct *work);\n\nstatic void process_send_sockets(struct work_struct *work)\n{\n\tstruct connection *con = container_of(work, struct connection, swork);\n\n\tif (test_and_clear_bit(CF_CONNECT_PENDING, &con->flags)) {\n\t\tcon->connect_action(con);\n\t\tset_bit(CF_WRITE_PENDING, &con->flags);\n\t}\n\tif (test_and_clear_bit(CF_WRITE_PENDING, &con->flags))\n\t\tsend_to_sock(con);\n}"
  },
  {
    "function_name": "process_recv_sockets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1672-1681",
    "snippet": "static void process_recv_sockets(struct work_struct *work)\n{\n\tstruct connection *con = container_of(work, struct connection, rwork);\n\tint err;\n\n\tclear_bit(CF_READ_PENDING, &con->flags);\n\tdo {\n\t\terr = con->rx_action(con);\n\t} while (!err);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_READ_PENDING 1"
    ],
    "globals_used": [
      "static void process_recv_sockets(struct work_struct *work);",
      "static void process_send_sockets(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "con->rx_action",
          "args": [
            "con"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CF_READ_PENDING",
            "&con->flags"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structconnection",
            "rwork"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_READ_PENDING 1\n\nstatic void process_recv_sockets(struct work_struct *work);\nstatic void process_send_sockets(struct work_struct *work);\n\nstatic void process_recv_sockets(struct work_struct *work)\n{\n\tstruct connection *con = container_of(work, struct connection, rwork);\n\tint err;\n\n\tclear_bit(CF_READ_PENDING, &con->flags);\n\tdo {\n\t\terr = con->rx_action(con);\n\t} while (!err);\n}"
  },
  {
    "function_name": "dlm_lowcomms_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1639-1669",
    "snippet": "int dlm_lowcomms_close(int nodeid)\n{\n\tstruct connection *con;\n\tstruct dlm_node_addr *na;\n\n\tlog_print(\"closing connection to node %d\", nodeid);\n\tcon = nodeid2con(nodeid, 0);\n\tif (con) {\n\t\tclear_bit(CF_CONNECT_PENDING, &con->flags);\n\t\tclear_bit(CF_WRITE_PENDING, &con->flags);\n\t\tset_bit(CF_CLOSE, &con->flags);\n\t\tif (cancel_work_sync(&con->swork))\n\t\t\tlog_print(\"canceled swork for node %d\", nodeid);\n\t\tif (cancel_work_sync(&con->rwork))\n\t\t\tlog_print(\"canceled rwork for node %d\", nodeid);\n\t\tclean_one_writequeue(con);\n\t\tclose_connection(con, true);\n\t}\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tna = find_node_addr(nodeid);\n\tif (na) {\n\t\tlist_del(&na->list);\n\t\twhile (na->addr_count--)\n\t\t\tkfree(na->addr[na->addr_count]);\n\t\tkfree(na);\n\t}\n\tspin_unlock(&dlm_node_addrs_spin);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_CLOSE 6",
      "#define CF_CONNECT_PENDING 3",
      "#define CF_WRITE_PENDING 2"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(dlm_node_addrs_spin);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_node_addrs_spin"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "na"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "na->addr[na->addr_count]"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&na->list"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_node_addr",
          "args": [
            "nodeid"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "find_node_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "275-284",
          "snippet": "static struct dlm_node_addr *find_node_addr(int nodeid)\n{\n\tstruct dlm_node_addr *na;\n\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (na->nodeid == nodeid)\n\t\t\treturn na;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dlm_node_addrs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic LIST_HEAD(dlm_node_addrs);\n\nstatic struct dlm_node_addr *find_node_addr(int nodeid)\n{\n\tstruct dlm_node_addr *na;\n\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (na->nodeid == nodeid)\n\t\t\treturn na;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_node_addrs_spin"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_connection",
          "args": [
            "con",
            "true"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "close_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "517-536",
          "snippet": "static void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_one_writequeue",
          "args": [
            "con"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "clean_one_writequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1625-1635",
          "snippet": "static void clean_one_writequeue(struct connection *con)\n{\n\tstruct writequeue_entry *e, *safe;\n\n\tspin_lock(&con->writequeue_lock);\n\tlist_for_each_entry_safe(e, safe, &con->writequeue, list) {\n\t\tlist_del(&e->list);\n\t\tfree_entry(e);\n\t}\n\tspin_unlock(&con->writequeue_lock);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void clean_one_writequeue(struct connection *con)\n{\n\tstruct writequeue_entry *e, *safe;\n\n\tspin_lock(&con->writequeue_lock);\n\tlist_for_each_entry_safe(e, safe, &con->writequeue, list) {\n\t\tlist_del(&e->list);\n\t\tfree_entry(e);\n\t}\n\tspin_unlock(&con->writequeue_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"canceled rwork for node %d\"",
            "nodeid"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "&con->rwork"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "&con->swork"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CF_CLOSE",
            "&con->flags"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CF_WRITE_PENDING",
            "&con->flags"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeid2con",
          "args": [
            "nodeid",
            "0"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "244-253",
          "snippet": "static struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_CLOSE 6\n#define CF_CONNECT_PENDING 3\n#define CF_WRITE_PENDING 2\n\nstatic DEFINE_SPINLOCK(dlm_node_addrs_spin);\n\nint dlm_lowcomms_close(int nodeid)\n{\n\tstruct connection *con;\n\tstruct dlm_node_addr *na;\n\n\tlog_print(\"closing connection to node %d\", nodeid);\n\tcon = nodeid2con(nodeid, 0);\n\tif (con) {\n\t\tclear_bit(CF_CONNECT_PENDING, &con->flags);\n\t\tclear_bit(CF_WRITE_PENDING, &con->flags);\n\t\tset_bit(CF_CLOSE, &con->flags);\n\t\tif (cancel_work_sync(&con->swork))\n\t\t\tlog_print(\"canceled swork for node %d\", nodeid);\n\t\tif (cancel_work_sync(&con->rwork))\n\t\t\tlog_print(\"canceled rwork for node %d\", nodeid);\n\t\tclean_one_writequeue(con);\n\t\tclose_connection(con, true);\n\t}\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tna = find_node_addr(nodeid);\n\tif (na) {\n\t\tlist_del(&na->list);\n\t\twhile (na->addr_count--)\n\t\t\tkfree(na->addr[na->addr_count]);\n\t\tkfree(na);\n\t}\n\tspin_unlock(&dlm_node_addrs_spin);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "clean_one_writequeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1625-1635",
    "snippet": "static void clean_one_writequeue(struct connection *con)\n{\n\tstruct writequeue_entry *e, *safe;\n\n\tspin_lock(&con->writequeue_lock);\n\tlist_for_each_entry_safe(e, safe, &con->writequeue, list) {\n\t\tlist_del(&e->list);\n\t\tfree_entry(e);\n\t}\n\tspin_unlock(&con->writequeue_lock);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&con->writequeue_lock"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_entry",
          "args": [
            "e"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "free_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1036-1040",
          "snippet": "static void free_entry(struct writequeue_entry *e)\n{\n\t__free_page(e->page);\n\tkfree(e);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void free_entry(struct writequeue_entry *e)\n{\n\t__free_page(e->page);\n\tkfree(e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&e->list"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "e",
            "safe",
            "&con->writequeue",
            "list"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&con->writequeue_lock"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void clean_one_writequeue(struct connection *con)\n{\n\tstruct writequeue_entry *e, *safe;\n\n\tspin_lock(&con->writequeue_lock);\n\tlist_for_each_entry_safe(e, safe, &con->writequeue, list) {\n\t\tlist_del(&e->list);\n\t\tfree_entry(e);\n\t}\n\tspin_unlock(&con->writequeue_lock);\n}"
  },
  {
    "function_name": "send_to_sock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1555-1623",
    "snippet": "static void send_to_sock(struct connection *con)\n{\n\tint ret = 0;\n\tconst int msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL;\n\tstruct writequeue_entry *e;\n\tint len, offset;\n\tint count = 0;\n\n\tmutex_lock(&con->sock_mutex);\n\tif (con->sock == NULL)\n\t\tgoto out_connect;\n\n\tspin_lock(&con->writequeue_lock);\n\tfor (;;) {\n\t\te = list_entry(con->writequeue.next, struct writequeue_entry,\n\t\t\t       list);\n\t\tif ((struct list_head *) e == &con->writequeue)\n\t\t\tbreak;\n\n\t\tlen = e->len;\n\t\toffset = e->offset;\n\t\tBUG_ON(len == 0 && e->users == 0);\n\t\tspin_unlock(&con->writequeue_lock);\n\n\t\tret = 0;\n\t\tif (len) {\n\t\t\tret = kernel_sendpage(con->sock, e->page, offset, len,\n\t\t\t\t\t      msg_flags);\n\t\t\tif (ret == -EAGAIN || ret == 0) {\n\t\t\t\tif (ret == -EAGAIN &&\n\t\t\t\t    test_bit(SOCK_ASYNC_NOSPACE, &con->sock->flags) &&\n\t\t\t\t    !test_and_set_bit(CF_APP_LIMITED, &con->flags)) {\n\t\t\t\t\t/* Notify TCP that we're limited by the\n\t\t\t\t\t * application window size.\n\t\t\t\t\t */\n\t\t\t\t\tset_bit(SOCK_NOSPACE, &con->sock->flags);\n\t\t\t\t\tcon->sock->sk->sk_write_pending++;\n\t\t\t\t}\n\t\t\t\tcond_resched();\n\t\t\t\tgoto out;\n\t\t\t} else if (ret < 0)\n\t\t\t\tgoto send_error;\n\t\t}\n\n\t\t/* Don't starve people filling buffers */\n\t\tif (++count >= MAX_SEND_MSG_COUNT) {\n\t\t\tcond_resched();\n\t\t\tcount = 0;\n\t\t}\n\n\t\tspin_lock(&con->writequeue_lock);\n\t\twritequeue_entry_complete(e, ret);\n\t}\n\tspin_unlock(&con->writequeue_lock);\nout:\n\tmutex_unlock(&con->sock_mutex);\n\treturn;\n\nsend_error:\n\tmutex_unlock(&con->sock_mutex);\n\tclose_connection(con, false);\n\tlowcomms_connect_sock(con);\n\treturn;\n\nout_connect:\n\tmutex_unlock(&con->sock_mutex);\n\tif (!test_bit(CF_INIT_PENDING, &con->flags))\n\t\tlowcomms_connect_sock(con);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_APP_LIMITED 7",
      "#define CF_INIT_PENDING 4",
      "#define MAX_SEND_MSG_COUNT 25"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lowcomms_connect_sock",
          "args": [
            "con"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "lowcomms_connect_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "452-458",
          "snippet": "static inline void lowcomms_connect_sock(struct connection *con)\n{\n\tif (test_bit(CF_CLOSE, &con->flags))\n\t\treturn;\n\tif (!test_and_set_bit(CF_CONNECT_PENDING, &con->flags))\n\t\tqueue_work(send_workqueue, &con->swork);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CF_CLOSE 6",
            "#define CF_CONNECT_PENDING 3"
          ],
          "globals_used": [
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_CLOSE 6\n#define CF_CONNECT_PENDING 3\n\nstatic struct workqueue_struct *send_workqueue;\n\nstatic inline void lowcomms_connect_sock(struct connection *con)\n{\n\tif (test_bit(CF_CLOSE, &con->flags))\n\t\treturn;\n\tif (!test_and_set_bit(CF_CONNECT_PENDING, &con->flags))\n\t\tqueue_work(send_workqueue, &con->swork);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CF_INIT_PENDING",
            "&con->flags"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_connection",
          "args": [
            "con",
            "false"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "close_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "517-536",
          "snippet": "static void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&con->writequeue_lock"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "writequeue_entry_complete",
          "args": [
            "e",
            "ret"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "writequeue_entry_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1049-1058",
          "snippet": "static void writequeue_entry_complete(struct writequeue_entry *e, int completed)\n{\n\te->offset += completed;\n\te->len -= completed;\n\n\tif (e->len == 0 && e->users == 0) {\n\t\tlist_del(&e->list);\n\t\tfree_entry(e);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void writequeue_entry_complete(struct writequeue_entry *e, int completed)\n{\n\te->offset += completed;\n\te->len -= completed;\n\n\tif (e->len == 0 && e->users == 0) {\n\t\tlist_del(&e->list);\n\t\tfree_entry(e);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&con->writequeue_lock"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "SOCK_NOSPACE",
            "&con->sock->flags"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CF_APP_LIMITED",
            "&con->flags"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_sendpage",
          "args": [
            "con->sock",
            "e->page",
            "offset",
            "len",
            "msg_flags"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len == 0 && e->users == 0"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "con->writequeue.next",
            "structwritequeue_entry",
            "list"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_APP_LIMITED 7\n#define CF_INIT_PENDING 4\n#define MAX_SEND_MSG_COUNT 25\n\nstatic void send_to_sock(struct connection *con)\n{\n\tint ret = 0;\n\tconst int msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL;\n\tstruct writequeue_entry *e;\n\tint len, offset;\n\tint count = 0;\n\n\tmutex_lock(&con->sock_mutex);\n\tif (con->sock == NULL)\n\t\tgoto out_connect;\n\n\tspin_lock(&con->writequeue_lock);\n\tfor (;;) {\n\t\te = list_entry(con->writequeue.next, struct writequeue_entry,\n\t\t\t       list);\n\t\tif ((struct list_head *) e == &con->writequeue)\n\t\t\tbreak;\n\n\t\tlen = e->len;\n\t\toffset = e->offset;\n\t\tBUG_ON(len == 0 && e->users == 0);\n\t\tspin_unlock(&con->writequeue_lock);\n\n\t\tret = 0;\n\t\tif (len) {\n\t\t\tret = kernel_sendpage(con->sock, e->page, offset, len,\n\t\t\t\t\t      msg_flags);\n\t\t\tif (ret == -EAGAIN || ret == 0) {\n\t\t\t\tif (ret == -EAGAIN &&\n\t\t\t\t    test_bit(SOCK_ASYNC_NOSPACE, &con->sock->flags) &&\n\t\t\t\t    !test_and_set_bit(CF_APP_LIMITED, &con->flags)) {\n\t\t\t\t\t/* Notify TCP that we're limited by the\n\t\t\t\t\t * application window size.\n\t\t\t\t\t */\n\t\t\t\t\tset_bit(SOCK_NOSPACE, &con->sock->flags);\n\t\t\t\t\tcon->sock->sk->sk_write_pending++;\n\t\t\t\t}\n\t\t\t\tcond_resched();\n\t\t\t\tgoto out;\n\t\t\t} else if (ret < 0)\n\t\t\t\tgoto send_error;\n\t\t}\n\n\t\t/* Don't starve people filling buffers */\n\t\tif (++count >= MAX_SEND_MSG_COUNT) {\n\t\t\tcond_resched();\n\t\t\tcount = 0;\n\t\t}\n\n\t\tspin_lock(&con->writequeue_lock);\n\t\twritequeue_entry_complete(e, ret);\n\t}\n\tspin_unlock(&con->writequeue_lock);\nout:\n\tmutex_unlock(&con->sock_mutex);\n\treturn;\n\nsend_error:\n\tmutex_unlock(&con->sock_mutex);\n\tclose_connection(con, false);\n\tlowcomms_connect_sock(con);\n\treturn;\n\nout_connect:\n\tmutex_unlock(&con->sock_mutex);\n\tif (!test_bit(CF_INIT_PENDING, &con->flags))\n\t\tlowcomms_connect_sock(con);\n}"
  },
  {
    "function_name": "dlm_lowcomms_commit_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1531-1552",
    "snippet": "void dlm_lowcomms_commit_buffer(void *mh)\n{\n\tstruct writequeue_entry *e = (struct writequeue_entry *)mh;\n\tstruct connection *con = e->con;\n\tint users;\n\n\tspin_lock(&con->writequeue_lock);\n\tusers = --e->users;\n\tif (users)\n\t\tgoto out;\n\te->len = e->end - e->offset;\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags)) {\n\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n\treturn;\n\nout:\n\tspin_unlock(&con->writequeue_lock);\n\treturn;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_WRITE_PENDING 2"
    ],
    "globals_used": [
      "static struct workqueue_struct *send_workqueue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&con->writequeue_lock"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "send_workqueue",
            "&con->swork"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CF_WRITE_PENDING",
            "&con->flags"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&con->writequeue_lock"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_WRITE_PENDING 2\n\nstatic struct workqueue_struct *send_workqueue;\n\nvoid dlm_lowcomms_commit_buffer(void *mh)\n{\n\tstruct writequeue_entry *e = (struct writequeue_entry *)mh;\n\tstruct connection *con = e->con;\n\tint users;\n\n\tspin_lock(&con->writequeue_lock);\n\tusers = --e->users;\n\tif (users)\n\t\tgoto out;\n\te->len = e->end - e->offset;\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags)) {\n\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n\treturn;\n\nout:\n\tspin_unlock(&con->writequeue_lock);\n\treturn;\n}"
  },
  {
    "function_name": "dlm_lowcomms_get_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1490-1529",
    "snippet": "void *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc)\n{\n\tstruct connection *con;\n\tstruct writequeue_entry *e;\n\tint offset = 0;\n\n\tcon = nodeid2con(nodeid, allocation);\n\tif (!con)\n\t\treturn NULL;\n\n\tspin_lock(&con->writequeue_lock);\n\te = list_entry(con->writequeue.prev, struct writequeue_entry, list);\n\tif ((&e->list == &con->writequeue) ||\n\t    (PAGE_CACHE_SIZE - e->end < len)) {\n\t\te = NULL;\n\t} else {\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t}\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (e) {\n\tgot_one:\n\t\t*ppc = page_address(e->page) + offset;\n\t\treturn e;\n\t}\n\n\te = new_writequeue_entry(con, allocation);\n\tif (e) {\n\t\tspin_lock(&con->writequeue_lock);\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t\tlist_add_tail(&e->list, &con->writequeue);\n\t\tspin_unlock(&con->writequeue_lock);\n\t\tgoto got_one;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&con->writequeue_lock"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&e->list",
            "&con->writequeue"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&con->writequeue_lock"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_writequeue_entry",
          "args": [
            "con",
            "allocation"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "new_writequeue_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1466-1488",
          "snippet": "static struct writequeue_entry *new_writequeue_entry(struct connection *con,\n\t\t\t\t\t\t     gfp_t allocation)\n{\n\tstruct writequeue_entry *entry;\n\n\tentry = kmalloc(sizeof(struct writequeue_entry), allocation);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->page = alloc_page(allocation);\n\tif (!entry->page) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\n\tentry->offset = 0;\n\tentry->len = 0;\n\tentry->end = 0;\n\tentry->users = 0;\n\tentry->con = con;\n\n\treturn entry;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct writequeue_entry *new_writequeue_entry(struct connection *con,\n\t\t\t\t\t\t     gfp_t allocation)\n{\n\tstruct writequeue_entry *entry;\n\n\tentry = kmalloc(sizeof(struct writequeue_entry), allocation);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->page = alloc_page(allocation);\n\tif (!entry->page) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\n\tentry->offset = 0;\n\tentry->len = 0;\n\tentry->end = 0;\n\tentry->users = 0;\n\tentry->con = con;\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "e->page"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "con->writequeue.prev",
            "structwritequeue_entry",
            "list"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeid2con",
          "args": [
            "nodeid",
            "allocation"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "244-253",
          "snippet": "static struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nvoid *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc)\n{\n\tstruct connection *con;\n\tstruct writequeue_entry *e;\n\tint offset = 0;\n\n\tcon = nodeid2con(nodeid, allocation);\n\tif (!con)\n\t\treturn NULL;\n\n\tspin_lock(&con->writequeue_lock);\n\te = list_entry(con->writequeue.prev, struct writequeue_entry, list);\n\tif ((&e->list == &con->writequeue) ||\n\t    (PAGE_CACHE_SIZE - e->end < len)) {\n\t\te = NULL;\n\t} else {\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t}\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (e) {\n\tgot_one:\n\t\t*ppc = page_address(e->page) + offset;\n\t\treturn e;\n\t}\n\n\te = new_writequeue_entry(con, allocation);\n\tif (e) {\n\t\tspin_lock(&con->writequeue_lock);\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t\tlist_add_tail(&e->list, &con->writequeue);\n\t\tspin_unlock(&con->writequeue_lock);\n\t\tgoto got_one;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "new_writequeue_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1466-1488",
    "snippet": "static struct writequeue_entry *new_writequeue_entry(struct connection *con,\n\t\t\t\t\t\t     gfp_t allocation)\n{\n\tstruct writequeue_entry *entry;\n\n\tentry = kmalloc(sizeof(struct writequeue_entry), allocation);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->page = alloc_page(allocation);\n\tif (!entry->page) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\n\tentry->offset = 0;\n\tentry->len = 0;\n\tentry->end = 0;\n\tentry->users = 0;\n\tentry->con = con;\n\n\treturn entry;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "allocation"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct writequeue_entry)",
            "allocation"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct writequeue_entry *new_writequeue_entry(struct connection *con,\n\t\t\t\t\t\t     gfp_t allocation)\n{\n\tstruct writequeue_entry *entry;\n\n\tentry = kmalloc(sizeof(struct writequeue_entry), allocation);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->page = alloc_page(allocation);\n\tif (!entry->page) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\n\tentry->offset = 0;\n\tentry->len = 0;\n\tentry->end = 0;\n\tentry->users = 0;\n\tentry->con = con;\n\n\treturn entry;\n}"
  },
  {
    "function_name": "tcp_listen_for_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1434-1462",
    "snippet": "static int tcp_listen_for_all(void)\n{\n\tstruct socket *sock = NULL;\n\tstruct connection *con = nodeid2con(0, GFP_NOFS);\n\tint result = -EINVAL;\n\n\tif (!con)\n\t\treturn -ENOMEM;\n\n\t/* We don't support multi-homed hosts */\n\tif (dlm_local_addr[1] != NULL) {\n\t\tlog_print(\"TCP protocol can't handle multi-homed hosts, \"\n\t\t\t  \"try SCTP\");\n\t\treturn -EINVAL;\n\t}\n\n\tlog_print(\"Using TCP for communications\");\n\n\tsock = tcp_create_listen_sock(con, dlm_local_addr[0]);\n\tif (sock) {\n\t\tadd_sock(sock, con);\n\t\tresult = 0;\n\t}\n\telse {\n\t\tresult = -EADDRINUSE;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_sock",
          "args": [
            "sock",
            "con"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "add_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "485-495",
          "snippet": "static void add_sock(struct socket *sock, struct connection *con)\n{\n\tcon->sock = sock;\n\n\t/* Install a data_ready callback */\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->sock->sk->sk_write_space = lowcomms_write_space;\n\tcon->sock->sk->sk_state_change = lowcomms_state_change;\n\tcon->sock->sk->sk_user_data = con;\n\tcon->sock->sk->sk_allocation = GFP_NOFS;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void add_sock(struct socket *sock, struct connection *con)\n{\n\tcon->sock = sock;\n\n\t/* Install a data_ready callback */\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->sock->sk->sk_write_space = lowcomms_write_space;\n\tcon->sock->sk->sk_state_change = lowcomms_state_change;\n\tcon->sock->sk->sk_user_data = con;\n\tcon->sock->sk->sk_allocation = GFP_NOFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcp_create_listen_sock",
          "args": [
            "con",
            "dlm_local_addr[0]"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "tcp_create_listen_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1247-1307",
          "snippet": "static struct socket *tcp_create_listen_sock(struct connection *con,\n\t\t\t\t\t     struct sockaddr_storage *saddr)\n{\n\tstruct socket *sock = NULL;\n\tint result = 0;\n\tint one = 1;\n\tint addr_len;\n\n\tif (dlm_local_addr[0]->ss_family == AF_INET)\n\t\taddr_len = sizeof(struct sockaddr_in);\n\telse\n\t\taddr_len = sizeof(struct sockaddr_in6);\n\n\t/* Create a socket to communicate with */\n\tresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_STREAM,\n\t\t\t\t  IPPROTO_TCP, &sock);\n\tif (result < 0) {\n\t\tlog_print(\"Can't create listening comms socket\");\n\t\tgoto create_out;\n\t}\n\n\t/* Turn off Nagle's algorithm */\n\tkernel_setsockopt(sock, SOL_TCP, TCP_NODELAY, (char *)&one,\n\t\t\t  sizeof(one));\n\n\tresult = kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t\t   (char *)&one, sizeof(one));\n\n\tif (result < 0) {\n\t\tlog_print(\"Failed to set SO_REUSEADDR on socket: %d\", result);\n\t}\n\tcon->rx_action = tcp_accept_from_sock;\n\tcon->connect_action = tcp_connect_to_sock;\n\n\t/* Bind to our port */\n\tmake_sockaddr(saddr, dlm_config.ci_tcp_port, &addr_len);\n\tresult = sock->ops->bind(sock, (struct sockaddr *) saddr, addr_len);\n\tif (result < 0) {\n\t\tlog_print(\"Can't bind to port %d\", dlm_config.ci_tcp_port);\n\t\tsock_release(sock);\n\t\tsock = NULL;\n\t\tcon->sock = NULL;\n\t\tgoto create_out;\n\t}\n\tresult = kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,\n\t\t\t\t (char *)&one, sizeof(one));\n\tif (result < 0) {\n\t\tlog_print(\"Set keepalive failed: %d\", result);\n\t}\n\n\tresult = sock->ops->listen(sock, 5);\n\tif (result < 0) {\n\t\tlog_print(\"Can't listen on port %d\", dlm_config.ci_tcp_port);\n\t\tsock_release(sock);\n\t\tsock = NULL;\n\t\tgoto create_out;\n\t}\n\ncreate_out:\n\treturn sock;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\n\nstatic struct socket *tcp_create_listen_sock(struct connection *con,\n\t\t\t\t\t     struct sockaddr_storage *saddr)\n{\n\tstruct socket *sock = NULL;\n\tint result = 0;\n\tint one = 1;\n\tint addr_len;\n\n\tif (dlm_local_addr[0]->ss_family == AF_INET)\n\t\taddr_len = sizeof(struct sockaddr_in);\n\telse\n\t\taddr_len = sizeof(struct sockaddr_in6);\n\n\t/* Create a socket to communicate with */\n\tresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_STREAM,\n\t\t\t\t  IPPROTO_TCP, &sock);\n\tif (result < 0) {\n\t\tlog_print(\"Can't create listening comms socket\");\n\t\tgoto create_out;\n\t}\n\n\t/* Turn off Nagle's algorithm */\n\tkernel_setsockopt(sock, SOL_TCP, TCP_NODELAY, (char *)&one,\n\t\t\t  sizeof(one));\n\n\tresult = kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t\t   (char *)&one, sizeof(one));\n\n\tif (result < 0) {\n\t\tlog_print(\"Failed to set SO_REUSEADDR on socket: %d\", result);\n\t}\n\tcon->rx_action = tcp_accept_from_sock;\n\tcon->connect_action = tcp_connect_to_sock;\n\n\t/* Bind to our port */\n\tmake_sockaddr(saddr, dlm_config.ci_tcp_port, &addr_len);\n\tresult = sock->ops->bind(sock, (struct sockaddr *) saddr, addr_len);\n\tif (result < 0) {\n\t\tlog_print(\"Can't bind to port %d\", dlm_config.ci_tcp_port);\n\t\tsock_release(sock);\n\t\tsock = NULL;\n\t\tcon->sock = NULL;\n\t\tgoto create_out;\n\t}\n\tresult = kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,\n\t\t\t\t (char *)&one, sizeof(one));\n\tif (result < 0) {\n\t\tlog_print(\"Set keepalive failed: %d\", result);\n\t}\n\n\tresult = sock->ops->listen(sock, 5);\n\tif (result < 0) {\n\t\tlog_print(\"Can't listen on port %d\", dlm_config.ci_tcp_port);\n\t\tsock_release(sock);\n\t\tsock = NULL;\n\t\tgoto create_out;\n\t}\n\ncreate_out:\n\treturn sock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Using TCP for communications\""
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"TCP protocol can't handle multi-homed hosts, \"\n\t\t\t  \"try SCTP\""
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeid2con",
          "args": [
            "0",
            "GFP_NOFS"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "244-253",
          "snippet": "static struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\n\nstatic int tcp_listen_for_all(void)\n{\n\tstruct socket *sock = NULL;\n\tstruct connection *con = nodeid2con(0, GFP_NOFS);\n\tint result = -EINVAL;\n\n\tif (!con)\n\t\treturn -ENOMEM;\n\n\t/* We don't support multi-homed hosts */\n\tif (dlm_local_addr[1] != NULL) {\n\t\tlog_print(\"TCP protocol can't handle multi-homed hosts, \"\n\t\t\t  \"try SCTP\");\n\t\treturn -EINVAL;\n\t}\n\n\tlog_print(\"Using TCP for communications\");\n\n\tsock = tcp_create_listen_sock(con, dlm_local_addr[0]);\n\tif (sock) {\n\t\tadd_sock(sock, con);\n\t\tresult = 0;\n\t}\n\telse {\n\t\tresult = -EADDRINUSE;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "sctp_listen_for_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1353-1432",
    "snippet": "static int sctp_listen_for_all(void)\n{\n\tstruct socket *sock = NULL;\n\tstruct sockaddr_storage localaddr;\n\tstruct sctp_event_subscribe subscribe;\n\tint result = -EINVAL, num = 1, i, addr_len;\n\tstruct connection *con = nodeid2con(0, GFP_NOFS);\n\tint bufsize = NEEDED_RMEM;\n\tint one = 1;\n\n\tif (!con)\n\t\treturn -ENOMEM;\n\n\tlog_print(\"Using SCTP for communications\");\n\n\tresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_SEQPACKET,\n\t\t\t\t  IPPROTO_SCTP, &sock);\n\tif (result < 0) {\n\t\tlog_print(\"Can't create comms socket, check SCTP is loaded\");\n\t\tgoto out;\n\t}\n\n\t/* Listen for events */\n\tmemset(&subscribe, 0, sizeof(subscribe));\n\tsubscribe.sctp_data_io_event = 1;\n\tsubscribe.sctp_association_event = 1;\n\tsubscribe.sctp_send_failure_event = 1;\n\tsubscribe.sctp_shutdown_event = 1;\n\tsubscribe.sctp_partial_delivery_event = 1;\n\n\tresult = kernel_setsockopt(sock, SOL_SOCKET, SO_RCVBUFFORCE,\n\t\t\t\t (char *)&bufsize, sizeof(bufsize));\n\tif (result)\n\t\tlog_print(\"Error increasing buffer space on socket %d\", result);\n\n\tresult = kernel_setsockopt(sock, SOL_SCTP, SCTP_EVENTS,\n\t\t\t\t   (char *)&subscribe, sizeof(subscribe));\n\tif (result < 0) {\n\t\tlog_print(\"Failed to set SCTP_EVENTS on socket: result=%d\",\n\t\t\t  result);\n\t\tgoto create_delsock;\n\t}\n\n\tresult = kernel_setsockopt(sock, SOL_SCTP, SCTP_NODELAY, (char *)&one,\n\t\t\t\t   sizeof(one));\n\tif (result < 0)\n\t\tlog_print(\"Could not set SCTP NODELAY error %d\\n\", result);\n\n\t/* Init con struct */\n\tsock->sk->sk_user_data = con;\n\tcon->sock = sock;\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->rx_action = receive_from_sock;\n\tcon->connect_action = sctp_init_assoc;\n\n\t/* Bind to all interfaces. */\n\tfor (i = 0; i < dlm_local_count; i++) {\n\t\tmemcpy(&localaddr, dlm_local_addr[i], sizeof(localaddr));\n\t\tmake_sockaddr(&localaddr, dlm_config.ci_tcp_port, &addr_len);\n\n\t\tresult = add_sctp_bind_addr(con, &localaddr, addr_len, num);\n\t\tif (result)\n\t\t\tgoto create_delsock;\n\t\t++num;\n\t}\n\n\tresult = sock->ops->listen(sock, 5);\n\tif (result < 0) {\n\t\tlog_print(\"Can't set socket listening\");\n\t\tgoto create_delsock;\n\t}\n\n\treturn 0;\n\ncreate_delsock:\n\tsock_release(sock);\n\tcon->sock = NULL;\nout:\n\treturn result;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define NEEDED_RMEM (4*1024*1024)"
    ],
    "globals_used": [
      "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];",
      "static int dlm_local_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "sock"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Can't set socket listening\""
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock->ops->listen",
          "args": [
            "sock",
            "5"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_sctp_bind_addr",
          "args": [
            "con",
            "&localaddr",
            "addr_len",
            "num"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "add_sctp_bind_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1330-1350",
          "snippet": "static int add_sctp_bind_addr(struct connection *sctp_con,\n\t\t\t      struct sockaddr_storage *addr,\n\t\t\t      int addr_len, int num)\n{\n\tint result = 0;\n\n\tif (num == 1)\n\t\tresult = kernel_bind(sctp_con->sock,\n\t\t\t\t     (struct sockaddr *) addr,\n\t\t\t\t     addr_len);\n\telse\n\t\tresult = kernel_setsockopt(sctp_con->sock, SOL_SCTP,\n\t\t\t\t\t   SCTP_SOCKOPT_BINDX_ADD,\n\t\t\t\t\t   (char *)addr, addr_len);\n\n\tif (result < 0)\n\t\tlog_print(\"Can't bind to port %d addr number %d\",\n\t\t\t  dlm_config.ci_tcp_port, num);\n\n\treturn result;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic int add_sctp_bind_addr(struct connection *sctp_con,\n\t\t\t      struct sockaddr_storage *addr,\n\t\t\t      int addr_len, int num)\n{\n\tint result = 0;\n\n\tif (num == 1)\n\t\tresult = kernel_bind(sctp_con->sock,\n\t\t\t\t     (struct sockaddr *) addr,\n\t\t\t\t     addr_len);\n\telse\n\t\tresult = kernel_setsockopt(sctp_con->sock, SOL_SCTP,\n\t\t\t\t\t   SCTP_SOCKOPT_BINDX_ADD,\n\t\t\t\t\t   (char *)addr, addr_len);\n\n\tif (result < 0)\n\t\tlog_print(\"Can't bind to port %d addr number %d\",\n\t\t\t  dlm_config.ci_tcp_port, num);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_sockaddr",
          "args": [
            "&localaddr",
            "dlm_config.ci_tcp_port",
            "&addr_len"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "make_sockaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "499-514",
          "snippet": "static void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\n\nstatic void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&localaddr",
            "dlm_local_addr[i]",
            "sizeof(localaddr)"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Could not set SCTP NODELAY error %d\\n\"",
            "result"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "sock",
            "SOL_SCTP",
            "SCTP_NODELAY",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "sock",
            "SOL_SCTP",
            "SCTP_EVENTS",
            "(char *)&subscribe",
            "sizeof(subscribe)"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "sock",
            "SOL_SOCKET",
            "SO_RCVBUFFORCE",
            "(char *)&bufsize",
            "sizeof(bufsize)"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&subscribe",
            "0",
            "sizeof(subscribe)"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Can't create comms socket, check SCTP is loaded\""
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_create_kern",
          "args": [
            "dlm_local_addr[0]->ss_family",
            "SOCK_SEQPACKET",
            "IPPROTO_SCTP",
            "&sock"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Using SCTP for communications\""
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeid2con",
          "args": [
            "0",
            "GFP_NOFS"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "244-253",
          "snippet": "static struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define NEEDED_RMEM (4*1024*1024)\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\nstatic int dlm_local_count;\n\nstatic int sctp_listen_for_all(void)\n{\n\tstruct socket *sock = NULL;\n\tstruct sockaddr_storage localaddr;\n\tstruct sctp_event_subscribe subscribe;\n\tint result = -EINVAL, num = 1, i, addr_len;\n\tstruct connection *con = nodeid2con(0, GFP_NOFS);\n\tint bufsize = NEEDED_RMEM;\n\tint one = 1;\n\n\tif (!con)\n\t\treturn -ENOMEM;\n\n\tlog_print(\"Using SCTP for communications\");\n\n\tresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_SEQPACKET,\n\t\t\t\t  IPPROTO_SCTP, &sock);\n\tif (result < 0) {\n\t\tlog_print(\"Can't create comms socket, check SCTP is loaded\");\n\t\tgoto out;\n\t}\n\n\t/* Listen for events */\n\tmemset(&subscribe, 0, sizeof(subscribe));\n\tsubscribe.sctp_data_io_event = 1;\n\tsubscribe.sctp_association_event = 1;\n\tsubscribe.sctp_send_failure_event = 1;\n\tsubscribe.sctp_shutdown_event = 1;\n\tsubscribe.sctp_partial_delivery_event = 1;\n\n\tresult = kernel_setsockopt(sock, SOL_SOCKET, SO_RCVBUFFORCE,\n\t\t\t\t (char *)&bufsize, sizeof(bufsize));\n\tif (result)\n\t\tlog_print(\"Error increasing buffer space on socket %d\", result);\n\n\tresult = kernel_setsockopt(sock, SOL_SCTP, SCTP_EVENTS,\n\t\t\t\t   (char *)&subscribe, sizeof(subscribe));\n\tif (result < 0) {\n\t\tlog_print(\"Failed to set SCTP_EVENTS on socket: result=%d\",\n\t\t\t  result);\n\t\tgoto create_delsock;\n\t}\n\n\tresult = kernel_setsockopt(sock, SOL_SCTP, SCTP_NODELAY, (char *)&one,\n\t\t\t\t   sizeof(one));\n\tif (result < 0)\n\t\tlog_print(\"Could not set SCTP NODELAY error %d\\n\", result);\n\n\t/* Init con struct */\n\tsock->sk->sk_user_data = con;\n\tcon->sock = sock;\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->rx_action = receive_from_sock;\n\tcon->connect_action = sctp_init_assoc;\n\n\t/* Bind to all interfaces. */\n\tfor (i = 0; i < dlm_local_count; i++) {\n\t\tmemcpy(&localaddr, dlm_local_addr[i], sizeof(localaddr));\n\t\tmake_sockaddr(&localaddr, dlm_config.ci_tcp_port, &addr_len);\n\n\t\tresult = add_sctp_bind_addr(con, &localaddr, addr_len, num);\n\t\tif (result)\n\t\t\tgoto create_delsock;\n\t\t++num;\n\t}\n\n\tresult = sock->ops->listen(sock, 5);\n\tif (result < 0) {\n\t\tlog_print(\"Can't set socket listening\");\n\t\tgoto create_delsock;\n\t}\n\n\treturn 0;\n\ncreate_delsock:\n\tsock_release(sock);\n\tcon->sock = NULL;\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "add_sctp_bind_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1330-1350",
    "snippet": "static int add_sctp_bind_addr(struct connection *sctp_con,\n\t\t\t      struct sockaddr_storage *addr,\n\t\t\t      int addr_len, int num)\n{\n\tint result = 0;\n\n\tif (num == 1)\n\t\tresult = kernel_bind(sctp_con->sock,\n\t\t\t\t     (struct sockaddr *) addr,\n\t\t\t\t     addr_len);\n\telse\n\t\tresult = kernel_setsockopt(sctp_con->sock, SOL_SCTP,\n\t\t\t\t\t   SCTP_SOCKOPT_BINDX_ADD,\n\t\t\t\t\t   (char *)addr, addr_len);\n\n\tif (result < 0)\n\t\tlog_print(\"Can't bind to port %d addr number %d\",\n\t\t\t  dlm_config.ci_tcp_port, num);\n\n\treturn result;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Can't bind to port %d addr number %d\"",
            "dlm_config.ci_tcp_port",
            "num"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "sctp_con->sock",
            "SOL_SCTP",
            "SCTP_SOCKOPT_BINDX_ADD",
            "(char *)addr",
            "addr_len"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_bind",
          "args": [
            "sctp_con->sock",
            "(struct sockaddr *) addr",
            "addr_len"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic int add_sctp_bind_addr(struct connection *sctp_con,\n\t\t\t      struct sockaddr_storage *addr,\n\t\t\t      int addr_len, int num)\n{\n\tint result = 0;\n\n\tif (num == 1)\n\t\tresult = kernel_bind(sctp_con->sock,\n\t\t\t\t     (struct sockaddr *) addr,\n\t\t\t\t     addr_len);\n\telse\n\t\tresult = kernel_setsockopt(sctp_con->sock, SOL_SCTP,\n\t\t\t\t\t   SCTP_SOCKOPT_BINDX_ADD,\n\t\t\t\t\t   (char *)addr, addr_len);\n\n\tif (result < 0)\n\t\tlog_print(\"Can't bind to port %d addr number %d\",\n\t\t\t  dlm_config.ci_tcp_port, num);\n\n\treturn result;\n}"
  },
  {
    "function_name": "init_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1310-1326",
    "snippet": "static void init_local(void)\n{\n\tstruct sockaddr_storage sas, *addr;\n\tint i;\n\n\tdlm_local_count = 0;\n\tfor (i = 0; i < DLM_MAX_ADDR_COUNT; i++) {\n\t\tif (dlm_our_addr(&sas, i))\n\t\t\tbreak;\n\n\t\taddr = kmalloc(sizeof(*addr), GFP_NOFS);\n\t\tif (!addr)\n\t\t\tbreak;\n\t\tmemcpy(addr, &sas, sizeof(*addr));\n\t\tdlm_local_addr[dlm_local_count++] = addr;\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];",
      "static int dlm_local_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "addr",
            "&sas",
            "sizeof(*addr)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*addr)",
            "GFP_NOFS"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_addr",
          "args": [
            "&sas",
            "i"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "1000-1008",
          "snippet": "int dlm_our_addr(struct sockaddr_storage *addr, int num)\n{\n\tif (!local_comm)\n\t\treturn -1;\n\tif (num + 1 > local_comm->addr_count)\n\t\treturn -1;\n\tmemcpy(addr, local_comm->addr[num], sizeof(*addr));\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_addr(struct sockaddr_storage *addr, int num)\n{\n\tif (!local_comm)\n\t\treturn -1;\n\tif (num + 1 > local_comm->addr_count)\n\t\treturn -1;\n\tmemcpy(addr, local_comm->addr[num], sizeof(*addr));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\nstatic int dlm_local_count;\n\nstatic void init_local(void)\n{\n\tstruct sockaddr_storage sas, *addr;\n\tint i;\n\n\tdlm_local_count = 0;\n\tfor (i = 0; i < DLM_MAX_ADDR_COUNT; i++) {\n\t\tif (dlm_our_addr(&sas, i))\n\t\t\tbreak;\n\n\t\taddr = kmalloc(sizeof(*addr), GFP_NOFS);\n\t\tif (!addr)\n\t\t\tbreak;\n\t\tmemcpy(addr, &sas, sizeof(*addr));\n\t\tdlm_local_addr[dlm_local_count++] = addr;\n\t}\n}"
  },
  {
    "function_name": "tcp_create_listen_sock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1247-1307",
    "snippet": "static struct socket *tcp_create_listen_sock(struct connection *con,\n\t\t\t\t\t     struct sockaddr_storage *saddr)\n{\n\tstruct socket *sock = NULL;\n\tint result = 0;\n\tint one = 1;\n\tint addr_len;\n\n\tif (dlm_local_addr[0]->ss_family == AF_INET)\n\t\taddr_len = sizeof(struct sockaddr_in);\n\telse\n\t\taddr_len = sizeof(struct sockaddr_in6);\n\n\t/* Create a socket to communicate with */\n\tresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_STREAM,\n\t\t\t\t  IPPROTO_TCP, &sock);\n\tif (result < 0) {\n\t\tlog_print(\"Can't create listening comms socket\");\n\t\tgoto create_out;\n\t}\n\n\t/* Turn off Nagle's algorithm */\n\tkernel_setsockopt(sock, SOL_TCP, TCP_NODELAY, (char *)&one,\n\t\t\t  sizeof(one));\n\n\tresult = kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t\t   (char *)&one, sizeof(one));\n\n\tif (result < 0) {\n\t\tlog_print(\"Failed to set SO_REUSEADDR on socket: %d\", result);\n\t}\n\tcon->rx_action = tcp_accept_from_sock;\n\tcon->connect_action = tcp_connect_to_sock;\n\n\t/* Bind to our port */\n\tmake_sockaddr(saddr, dlm_config.ci_tcp_port, &addr_len);\n\tresult = sock->ops->bind(sock, (struct sockaddr *) saddr, addr_len);\n\tif (result < 0) {\n\t\tlog_print(\"Can't bind to port %d\", dlm_config.ci_tcp_port);\n\t\tsock_release(sock);\n\t\tsock = NULL;\n\t\tcon->sock = NULL;\n\t\tgoto create_out;\n\t}\n\tresult = kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,\n\t\t\t\t (char *)&one, sizeof(one));\n\tif (result < 0) {\n\t\tlog_print(\"Set keepalive failed: %d\", result);\n\t}\n\n\tresult = sock->ops->listen(sock, 5);\n\tif (result < 0) {\n\t\tlog_print(\"Can't listen on port %d\", dlm_config.ci_tcp_port);\n\t\tsock_release(sock);\n\t\tsock = NULL;\n\t\tgoto create_out;\n\t}\n\ncreate_out:\n\treturn sock;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "sock"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Can't listen on port %d\"",
            "dlm_config.ci_tcp_port"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock->ops->listen",
          "args": [
            "sock",
            "5"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "sock",
            "SOL_SOCKET",
            "SO_KEEPALIVE",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "sock"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock->ops->bind",
          "args": [
            "sock",
            "(struct sockaddr *) saddr",
            "addr_len"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_sockaddr",
          "args": [
            "saddr",
            "dlm_config.ci_tcp_port",
            "&addr_len"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "make_sockaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "499-514",
          "snippet": "static void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\n\nstatic void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "sock",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "sock",
            "SOL_TCP",
            "TCP_NODELAY",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Can't create listening comms socket\""
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_create_kern",
          "args": [
            "dlm_local_addr[0]->ss_family",
            "SOCK_STREAM",
            "IPPROTO_TCP",
            "&sock"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\n\nstatic struct socket *tcp_create_listen_sock(struct connection *con,\n\t\t\t\t\t     struct sockaddr_storage *saddr)\n{\n\tstruct socket *sock = NULL;\n\tint result = 0;\n\tint one = 1;\n\tint addr_len;\n\n\tif (dlm_local_addr[0]->ss_family == AF_INET)\n\t\taddr_len = sizeof(struct sockaddr_in);\n\telse\n\t\taddr_len = sizeof(struct sockaddr_in6);\n\n\t/* Create a socket to communicate with */\n\tresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_STREAM,\n\t\t\t\t  IPPROTO_TCP, &sock);\n\tif (result < 0) {\n\t\tlog_print(\"Can't create listening comms socket\");\n\t\tgoto create_out;\n\t}\n\n\t/* Turn off Nagle's algorithm */\n\tkernel_setsockopt(sock, SOL_TCP, TCP_NODELAY, (char *)&one,\n\t\t\t  sizeof(one));\n\n\tresult = kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t\t   (char *)&one, sizeof(one));\n\n\tif (result < 0) {\n\t\tlog_print(\"Failed to set SO_REUSEADDR on socket: %d\", result);\n\t}\n\tcon->rx_action = tcp_accept_from_sock;\n\tcon->connect_action = tcp_connect_to_sock;\n\n\t/* Bind to our port */\n\tmake_sockaddr(saddr, dlm_config.ci_tcp_port, &addr_len);\n\tresult = sock->ops->bind(sock, (struct sockaddr *) saddr, addr_len);\n\tif (result < 0) {\n\t\tlog_print(\"Can't bind to port %d\", dlm_config.ci_tcp_port);\n\t\tsock_release(sock);\n\t\tsock = NULL;\n\t\tcon->sock = NULL;\n\t\tgoto create_out;\n\t}\n\tresult = kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,\n\t\t\t\t (char *)&one, sizeof(one));\n\tif (result < 0) {\n\t\tlog_print(\"Set keepalive failed: %d\", result);\n\t}\n\n\tresult = sock->ops->listen(sock, 5);\n\tif (result < 0) {\n\t\tlog_print(\"Can't listen on port %d\", dlm_config.ci_tcp_port);\n\t\tsock_release(sock);\n\t\tsock = NULL;\n\t\tgoto create_out;\n\t}\n\ncreate_out:\n\treturn sock;\n}"
  },
  {
    "function_name": "tcp_connect_to_sock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1154-1245",
    "snippet": "static void tcp_connect_to_sock(struct connection *con)\n{\n\tstruct sockaddr_storage saddr, src_addr;\n\tint addr_len;\n\tstruct socket *sock = NULL;\n\tint one = 1;\n\tint result;\n\n\tif (con->nodeid == 0) {\n\t\tlog_print(\"attempt to connect sock 0 foiled\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&con->sock_mutex);\n\tif (con->retries++ > MAX_CONNECT_RETRIES)\n\t\tgoto out;\n\n\t/* Some odd races can cause double-connects, ignore them */\n\tif (con->sock)\n\t\tgoto out;\n\n\t/* Create a socket to communicate with */\n\tresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_STREAM,\n\t\t\t\t  IPPROTO_TCP, &sock);\n\tif (result < 0)\n\t\tgoto out_err;\n\n\tmemset(&saddr, 0, sizeof(saddr));\n\tresult = nodeid_to_addr(con->nodeid, &saddr, NULL, false);\n\tif (result < 0) {\n\t\tlog_print(\"no address for nodeid %d\", con->nodeid);\n\t\tgoto out_err;\n\t}\n\n\tsock->sk->sk_user_data = con;\n\tcon->rx_action = receive_from_sock;\n\tcon->connect_action = tcp_connect_to_sock;\n\tadd_sock(sock, con);\n\n\t/* Bind to our cluster-known address connecting to avoid\n\t   routing problems */\n\tmemcpy(&src_addr, dlm_local_addr[0], sizeof(src_addr));\n\tmake_sockaddr(&src_addr, 0, &addr_len);\n\tresult = sock->ops->bind(sock, (struct sockaddr *) &src_addr,\n\t\t\t\t addr_len);\n\tif (result < 0) {\n\t\tlog_print(\"could not bind for connect: %d\", result);\n\t\t/* This *may* not indicate a critical error */\n\t}\n\n\tmake_sockaddr(&saddr, dlm_config.ci_tcp_port, &addr_len);\n\n\tlog_print(\"connecting to %d\", con->nodeid);\n\n\t/* Turn off Nagle's algorithm */\n\tkernel_setsockopt(sock, SOL_TCP, TCP_NODELAY, (char *)&one,\n\t\t\t  sizeof(one));\n\n\tresult = sock->ops->connect(sock, (struct sockaddr *)&saddr, addr_len,\n\t\t\t\t   O_NONBLOCK);\n\tif (result == -EINPROGRESS)\n\t\tresult = 0;\n\tif (result == 0)\n\t\tgoto out;\n\nout_err:\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t} else if (sock) {\n\t\tsock_release(sock);\n\t}\n\t/*\n\t * Some errors are fatal and this list might need adjusting. For other\n\t * errors we try again until the max number of retries is reached.\n\t */\n\tif (result != -EHOSTUNREACH &&\n\t    result != -ENETUNREACH &&\n\t    result != -ENETDOWN && \n\t    result != -EINVAL &&\n\t    result != -EPROTONOSUPPORT) {\n\t\tlog_print(\"connect %d try %d error %d\", con->nodeid,\n\t\t\t  con->retries, result);\n\t\tmutex_unlock(&con->sock_mutex);\n\t\tmsleep(1000);\n\t\tlowcomms_connect_sock(con);\n\t\treturn;\n\t}\nout:\n\tmutex_unlock(&con->sock_mutex);\n\treturn;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define MAX_CONNECT_RETRIES 3"
    ],
    "globals_used": [
      "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowcomms_connect_sock",
          "args": [
            "con"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "lowcomms_connect_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "452-458",
          "snippet": "static inline void lowcomms_connect_sock(struct connection *con)\n{\n\tif (test_bit(CF_CLOSE, &con->flags))\n\t\treturn;\n\tif (!test_and_set_bit(CF_CONNECT_PENDING, &con->flags))\n\t\tqueue_work(send_workqueue, &con->swork);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CF_CLOSE 6",
            "#define CF_CONNECT_PENDING 3"
          ],
          "globals_used": [
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_CLOSE 6\n#define CF_CONNECT_PENDING 3\n\nstatic struct workqueue_struct *send_workqueue;\n\nstatic inline void lowcomms_connect_sock(struct connection *con)\n{\n\tif (test_bit(CF_CLOSE, &con->flags))\n\t\treturn;\n\tif (!test_and_set_bit(CF_CONNECT_PENDING, &con->flags))\n\t\tqueue_work(send_workqueue, &con->swork);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1000"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"connect %d try %d error %d\"",
            "con->nodeid",
            "con->retries",
            "result"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "sock"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "con->sock"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock->ops->connect",
          "args": [
            "sock",
            "(struct sockaddr *)&saddr",
            "addr_len",
            "O_NONBLOCK"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "sock",
            "SOL_TCP",
            "TCP_NODELAY",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"connecting to %d\"",
            "con->nodeid"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_sockaddr",
          "args": [
            "&saddr",
            "dlm_config.ci_tcp_port",
            "&addr_len"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "make_sockaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "499-514",
          "snippet": "static void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\n\nstatic void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock->ops->bind",
          "args": [
            "sock",
            "(struct sockaddr *) &src_addr",
            "addr_len"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&src_addr",
            "dlm_local_addr[0]",
            "sizeof(src_addr)"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_sock",
          "args": [
            "sock",
            "con"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "add_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "485-495",
          "snippet": "static void add_sock(struct socket *sock, struct connection *con)\n{\n\tcon->sock = sock;\n\n\t/* Install a data_ready callback */\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->sock->sk->sk_write_space = lowcomms_write_space;\n\tcon->sock->sk->sk_state_change = lowcomms_state_change;\n\tcon->sock->sk->sk_user_data = con;\n\tcon->sock->sk->sk_allocation = GFP_NOFS;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void add_sock(struct socket *sock, struct connection *con)\n{\n\tcon->sock = sock;\n\n\t/* Install a data_ready callback */\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->sock->sk->sk_write_space = lowcomms_write_space;\n\tcon->sock->sk->sk_state_change = lowcomms_state_change;\n\tcon->sock->sk->sk_user_data = con;\n\tcon->sock->sk->sk_allocation = GFP_NOFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeid_to_addr",
          "args": [
            "con->nodeid",
            "&saddr",
            "NULL",
            "false"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid_to_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "313-359",
          "snippet": "static int nodeid_to_addr(int nodeid, struct sockaddr_storage *sas_out,\n\t\t\t  struct sockaddr *sa_out, bool try_new_addr)\n{\n\tstruct sockaddr_storage sas;\n\tstruct dlm_node_addr *na;\n\n\tif (!dlm_local_count)\n\t\treturn -1;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tna = find_node_addr(nodeid);\n\tif (na && na->addr_count) {\n\t\tif (try_new_addr) {\n\t\t\tna->curr_addr_index++;\n\t\t\tif (na->curr_addr_index == na->addr_count)\n\t\t\t\tna->curr_addr_index = 0;\n\t\t}\n\n\t\tmemcpy(&sas, na->addr[na->curr_addr_index ],\n\t\t\tsizeof(struct sockaddr_storage));\n\t}\n\tspin_unlock(&dlm_node_addrs_spin);\n\n\tif (!na)\n\t\treturn -EEXIST;\n\n\tif (!na->addr_count)\n\t\treturn -ENOENT;\n\n\tif (sas_out)\n\t\tmemcpy(sas_out, &sas, sizeof(struct sockaddr_storage));\n\n\tif (!sa_out)\n\t\treturn 0;\n\n\tif (dlm_local_addr[0]->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4  = (struct sockaddr_in *) &sas;\n\t\tstruct sockaddr_in *ret4 = (struct sockaddr_in *) sa_out;\n\t\tret4->sin_addr.s_addr = in4->sin_addr.s_addr;\n\t} else {\n\t\tstruct sockaddr_in6 *in6  = (struct sockaddr_in6 *) &sas;\n\t\tstruct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) sa_out;\n\t\tret6->sin6_addr = in6->sin6_addr;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(dlm_node_addrs_spin);",
            "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];",
            "static int dlm_local_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_SPINLOCK(dlm_node_addrs_spin);\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\nstatic int dlm_local_count;\n\nstatic int nodeid_to_addr(int nodeid, struct sockaddr_storage *sas_out,\n\t\t\t  struct sockaddr *sa_out, bool try_new_addr)\n{\n\tstruct sockaddr_storage sas;\n\tstruct dlm_node_addr *na;\n\n\tif (!dlm_local_count)\n\t\treturn -1;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tna = find_node_addr(nodeid);\n\tif (na && na->addr_count) {\n\t\tif (try_new_addr) {\n\t\t\tna->curr_addr_index++;\n\t\t\tif (na->curr_addr_index == na->addr_count)\n\t\t\t\tna->curr_addr_index = 0;\n\t\t}\n\n\t\tmemcpy(&sas, na->addr[na->curr_addr_index ],\n\t\t\tsizeof(struct sockaddr_storage));\n\t}\n\tspin_unlock(&dlm_node_addrs_spin);\n\n\tif (!na)\n\t\treturn -EEXIST;\n\n\tif (!na->addr_count)\n\t\treturn -ENOENT;\n\n\tif (sas_out)\n\t\tmemcpy(sas_out, &sas, sizeof(struct sockaddr_storage));\n\n\tif (!sa_out)\n\t\treturn 0;\n\n\tif (dlm_local_addr[0]->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4  = (struct sockaddr_in *) &sas;\n\t\tstruct sockaddr_in *ret4 = (struct sockaddr_in *) sa_out;\n\t\tret4->sin_addr.s_addr = in4->sin_addr.s_addr;\n\t} else {\n\t\tstruct sockaddr_in6 *in6  = (struct sockaddr_in6 *) &sas;\n\t\tstruct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) sa_out;\n\t\tret6->sin6_addr = in6->sin6_addr;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&saddr",
            "0",
            "sizeof(saddr)"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_create_kern",
          "args": [
            "dlm_local_addr[0]->ss_family",
            "SOCK_STREAM",
            "IPPROTO_TCP",
            "&sock"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"attempt to connect sock 0 foiled\""
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define MAX_CONNECT_RETRIES 3\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\n\nstatic void tcp_connect_to_sock(struct connection *con)\n{\n\tstruct sockaddr_storage saddr, src_addr;\n\tint addr_len;\n\tstruct socket *sock = NULL;\n\tint one = 1;\n\tint result;\n\n\tif (con->nodeid == 0) {\n\t\tlog_print(\"attempt to connect sock 0 foiled\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&con->sock_mutex);\n\tif (con->retries++ > MAX_CONNECT_RETRIES)\n\t\tgoto out;\n\n\t/* Some odd races can cause double-connects, ignore them */\n\tif (con->sock)\n\t\tgoto out;\n\n\t/* Create a socket to communicate with */\n\tresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_STREAM,\n\t\t\t\t  IPPROTO_TCP, &sock);\n\tif (result < 0)\n\t\tgoto out_err;\n\n\tmemset(&saddr, 0, sizeof(saddr));\n\tresult = nodeid_to_addr(con->nodeid, &saddr, NULL, false);\n\tif (result < 0) {\n\t\tlog_print(\"no address for nodeid %d\", con->nodeid);\n\t\tgoto out_err;\n\t}\n\n\tsock->sk->sk_user_data = con;\n\tcon->rx_action = receive_from_sock;\n\tcon->connect_action = tcp_connect_to_sock;\n\tadd_sock(sock, con);\n\n\t/* Bind to our cluster-known address connecting to avoid\n\t   routing problems */\n\tmemcpy(&src_addr, dlm_local_addr[0], sizeof(src_addr));\n\tmake_sockaddr(&src_addr, 0, &addr_len);\n\tresult = sock->ops->bind(sock, (struct sockaddr *) &src_addr,\n\t\t\t\t addr_len);\n\tif (result < 0) {\n\t\tlog_print(\"could not bind for connect: %d\", result);\n\t\t/* This *may* not indicate a critical error */\n\t}\n\n\tmake_sockaddr(&saddr, dlm_config.ci_tcp_port, &addr_len);\n\n\tlog_print(\"connecting to %d\", con->nodeid);\n\n\t/* Turn off Nagle's algorithm */\n\tkernel_setsockopt(sock, SOL_TCP, TCP_NODELAY, (char *)&one,\n\t\t\t  sizeof(one));\n\n\tresult = sock->ops->connect(sock, (struct sockaddr *)&saddr, addr_len,\n\t\t\t\t   O_NONBLOCK);\n\tif (result == -EINPROGRESS)\n\t\tresult = 0;\n\tif (result == 0)\n\t\tgoto out;\n\nout_err:\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t} else if (sock) {\n\t\tsock_release(sock);\n\t}\n\t/*\n\t * Some errors are fatal and this list might need adjusting. For other\n\t * errors we try again until the max number of retries is reached.\n\t */\n\tif (result != -EHOSTUNREACH &&\n\t    result != -ENETUNREACH &&\n\t    result != -ENETDOWN && \n\t    result != -EINVAL &&\n\t    result != -EPROTONOSUPPORT) {\n\t\tlog_print(\"connect %d try %d error %d\", con->nodeid,\n\t\t\t  con->retries, result);\n\t\tmutex_unlock(&con->sock_mutex);\n\t\tmsleep(1000);\n\t\tlowcomms_connect_sock(con);\n\t\treturn;\n\t}\nout:\n\tmutex_unlock(&con->sock_mutex);\n\treturn;\n}"
  },
  {
    "function_name": "sctp_init_assoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1065-1151",
    "snippet": "static void sctp_init_assoc(struct connection *con)\n{\n\tstruct sockaddr_storage rem_addr;\n\tchar outcmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\n\tstruct msghdr outmessage;\n\tstruct cmsghdr *cmsg;\n\tstruct sctp_sndrcvinfo *sinfo;\n\tstruct connection *base_con;\n\tstruct writequeue_entry *e;\n\tint len, offset;\n\tint ret;\n\tint addrlen;\n\tstruct kvec iov[1];\n\n\tmutex_lock(&con->sock_mutex);\n\tif (test_and_set_bit(CF_INIT_PENDING, &con->flags))\n\t\tgoto unlock;\n\n\tif (nodeid_to_addr(con->nodeid, NULL, (struct sockaddr *)&rem_addr,\n\t\t\t   con->try_new_addr)) {\n\t\tlog_print(\"no address for nodeid %d\", con->nodeid);\n\t\tgoto unlock;\n\t}\n\tbase_con = nodeid2con(0, 0);\n\tBUG_ON(base_con == NULL);\n\n\tmake_sockaddr(&rem_addr, dlm_config.ci_tcp_port, &addrlen);\n\n\toutmessage.msg_name = &rem_addr;\n\toutmessage.msg_namelen = addrlen;\n\toutmessage.msg_control = outcmsg;\n\toutmessage.msg_controllen = sizeof(outcmsg);\n\toutmessage.msg_flags = MSG_EOR;\n\n\tspin_lock(&con->writequeue_lock);\n\n\tif (list_empty(&con->writequeue)) {\n\t\tspin_unlock(&con->writequeue_lock);\n\t\tlog_print(\"writequeue empty for nodeid %d\", con->nodeid);\n\t\tgoto unlock;\n\t}\n\n\te = list_first_entry(&con->writequeue, struct writequeue_entry, list);\n\tlen = e->len;\n\toffset = e->offset;\n\n\t/* Send the first block off the write queue */\n\tiov[0].iov_base = page_address(e->page)+offset;\n\tiov[0].iov_len = len;\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (rem_addr.ss_family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&rem_addr;\n\t\tlog_print(\"Trying to connect to %pI4\", &sin->sin_addr.s_addr);\n\t} else {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&rem_addr;\n\t\tlog_print(\"Trying to connect to %pI6\", &sin6->sin6_addr);\n\t}\n\n\tcmsg = CMSG_FIRSTHDR(&outmessage);\n\tcmsg->cmsg_level = IPPROTO_SCTP;\n\tcmsg->cmsg_type = SCTP_SNDRCV;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));\n\tsinfo = CMSG_DATA(cmsg);\n\tmemset(sinfo, 0x00, sizeof(struct sctp_sndrcvinfo));\n\tsinfo->sinfo_ppid = cpu_to_le32(con->nodeid);\n\toutmessage.msg_controllen = cmsg->cmsg_len;\n\tsinfo->sinfo_flags |= SCTP_ADDR_OVER;\n\n\tret = kernel_sendmsg(base_con->sock, &outmessage, iov, 1, len);\n\tif (ret < 0) {\n\t\tlog_print(\"Send first packet to node %d failed: %d\",\n\t\t\t  con->nodeid, ret);\n\n\t\t/* Try again later */\n\t\tclear_bit(CF_CONNECT_PENDING, &con->flags);\n\t\tclear_bit(CF_INIT_PENDING, &con->flags);\n\t}\n\telse {\n\t\tspin_lock(&con->writequeue_lock);\n\t\twritequeue_entry_complete(e, ret);\n\t\tspin_unlock(&con->writequeue_lock);\n\t}\n\nunlock:\n\tmutex_unlock(&con->sock_mutex);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_INIT_PENDING 4",
      "#define CF_CONNECT_PENDING 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&con->writequeue_lock"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "writequeue_entry_complete",
          "args": [
            "e",
            "ret"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "writequeue_entry_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1049-1058",
          "snippet": "static void writequeue_entry_complete(struct writequeue_entry *e, int completed)\n{\n\te->offset += completed;\n\te->len -= completed;\n\n\tif (e->len == 0 && e->users == 0) {\n\t\tlist_del(&e->list);\n\t\tfree_entry(e);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void writequeue_entry_complete(struct writequeue_entry *e, int completed)\n{\n\te->offset += completed;\n\te->len -= completed;\n\n\tif (e->len == 0 && e->users == 0) {\n\t\tlist_del(&e->list);\n\t\tfree_entry(e);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&con->writequeue_lock"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CF_INIT_PENDING",
            "&con->flags"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Send first packet to node %d failed: %d\"",
            "con->nodeid",
            "ret"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_sendmsg",
          "args": [
            "base_con->sock",
            "&outmessage",
            "iov",
            "1",
            "len"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "con->nodeid"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sinfo",
            "0x00",
            "sizeof(struct sctp_sndrcvinfo)"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_DATA",
          "args": [
            "cmsg"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_LEN",
          "args": [
            "sizeof(struct sctp_sndrcvinfo)"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_FIRSTHDR",
          "args": [
            "&outmessage"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Trying to connect to %pI6\"",
            "&sin6->sin6_addr"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "e->page"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&con->writequeue",
            "structwritequeue_entry",
            "list"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&con->writequeue"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_sockaddr",
          "args": [
            "&rem_addr",
            "dlm_config.ci_tcp_port",
            "&addrlen"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "make_sockaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "499-514",
          "snippet": "static void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\n\nstatic void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "base_con == NULL"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeid2con",
          "args": [
            "0",
            "0"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "244-253",
          "snippet": "static struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeid_to_addr",
          "args": [
            "con->nodeid",
            "NULL",
            "(struct sockaddr *)&rem_addr",
            "con->try_new_addr"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid_to_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "313-359",
          "snippet": "static int nodeid_to_addr(int nodeid, struct sockaddr_storage *sas_out,\n\t\t\t  struct sockaddr *sa_out, bool try_new_addr)\n{\n\tstruct sockaddr_storage sas;\n\tstruct dlm_node_addr *na;\n\n\tif (!dlm_local_count)\n\t\treturn -1;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tna = find_node_addr(nodeid);\n\tif (na && na->addr_count) {\n\t\tif (try_new_addr) {\n\t\t\tna->curr_addr_index++;\n\t\t\tif (na->curr_addr_index == na->addr_count)\n\t\t\t\tna->curr_addr_index = 0;\n\t\t}\n\n\t\tmemcpy(&sas, na->addr[na->curr_addr_index ],\n\t\t\tsizeof(struct sockaddr_storage));\n\t}\n\tspin_unlock(&dlm_node_addrs_spin);\n\n\tif (!na)\n\t\treturn -EEXIST;\n\n\tif (!na->addr_count)\n\t\treturn -ENOENT;\n\n\tif (sas_out)\n\t\tmemcpy(sas_out, &sas, sizeof(struct sockaddr_storage));\n\n\tif (!sa_out)\n\t\treturn 0;\n\n\tif (dlm_local_addr[0]->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4  = (struct sockaddr_in *) &sas;\n\t\tstruct sockaddr_in *ret4 = (struct sockaddr_in *) sa_out;\n\t\tret4->sin_addr.s_addr = in4->sin_addr.s_addr;\n\t} else {\n\t\tstruct sockaddr_in6 *in6  = (struct sockaddr_in6 *) &sas;\n\t\tstruct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) sa_out;\n\t\tret6->sin6_addr = in6->sin6_addr;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(dlm_node_addrs_spin);",
            "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];",
            "static int dlm_local_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_SPINLOCK(dlm_node_addrs_spin);\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\nstatic int dlm_local_count;\n\nstatic int nodeid_to_addr(int nodeid, struct sockaddr_storage *sas_out,\n\t\t\t  struct sockaddr *sa_out, bool try_new_addr)\n{\n\tstruct sockaddr_storage sas;\n\tstruct dlm_node_addr *na;\n\n\tif (!dlm_local_count)\n\t\treturn -1;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tna = find_node_addr(nodeid);\n\tif (na && na->addr_count) {\n\t\tif (try_new_addr) {\n\t\t\tna->curr_addr_index++;\n\t\t\tif (na->curr_addr_index == na->addr_count)\n\t\t\t\tna->curr_addr_index = 0;\n\t\t}\n\n\t\tmemcpy(&sas, na->addr[na->curr_addr_index ],\n\t\t\tsizeof(struct sockaddr_storage));\n\t}\n\tspin_unlock(&dlm_node_addrs_spin);\n\n\tif (!na)\n\t\treturn -EEXIST;\n\n\tif (!na->addr_count)\n\t\treturn -ENOENT;\n\n\tif (sas_out)\n\t\tmemcpy(sas_out, &sas, sizeof(struct sockaddr_storage));\n\n\tif (!sa_out)\n\t\treturn 0;\n\n\tif (dlm_local_addr[0]->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4  = (struct sockaddr_in *) &sas;\n\t\tstruct sockaddr_in *ret4 = (struct sockaddr_in *) sa_out;\n\t\tret4->sin_addr.s_addr = in4->sin_addr.s_addr;\n\t} else {\n\t\tstruct sockaddr_in6 *in6  = (struct sockaddr_in6 *) &sas;\n\t\tstruct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) sa_out;\n\t\tret6->sin6_addr = in6->sin6_addr;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CF_INIT_PENDING",
            "&con->flags"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "sizeof(struct sctp_sndrcvinfo)"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_INIT_PENDING 4\n#define CF_CONNECT_PENDING 3\n\nstatic void sctp_init_assoc(struct connection *con)\n{\n\tstruct sockaddr_storage rem_addr;\n\tchar outcmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\n\tstruct msghdr outmessage;\n\tstruct cmsghdr *cmsg;\n\tstruct sctp_sndrcvinfo *sinfo;\n\tstruct connection *base_con;\n\tstruct writequeue_entry *e;\n\tint len, offset;\n\tint ret;\n\tint addrlen;\n\tstruct kvec iov[1];\n\n\tmutex_lock(&con->sock_mutex);\n\tif (test_and_set_bit(CF_INIT_PENDING, &con->flags))\n\t\tgoto unlock;\n\n\tif (nodeid_to_addr(con->nodeid, NULL, (struct sockaddr *)&rem_addr,\n\t\t\t   con->try_new_addr)) {\n\t\tlog_print(\"no address for nodeid %d\", con->nodeid);\n\t\tgoto unlock;\n\t}\n\tbase_con = nodeid2con(0, 0);\n\tBUG_ON(base_con == NULL);\n\n\tmake_sockaddr(&rem_addr, dlm_config.ci_tcp_port, &addrlen);\n\n\toutmessage.msg_name = &rem_addr;\n\toutmessage.msg_namelen = addrlen;\n\toutmessage.msg_control = outcmsg;\n\toutmessage.msg_controllen = sizeof(outcmsg);\n\toutmessage.msg_flags = MSG_EOR;\n\n\tspin_lock(&con->writequeue_lock);\n\n\tif (list_empty(&con->writequeue)) {\n\t\tspin_unlock(&con->writequeue_lock);\n\t\tlog_print(\"writequeue empty for nodeid %d\", con->nodeid);\n\t\tgoto unlock;\n\t}\n\n\te = list_first_entry(&con->writequeue, struct writequeue_entry, list);\n\tlen = e->len;\n\toffset = e->offset;\n\n\t/* Send the first block off the write queue */\n\tiov[0].iov_base = page_address(e->page)+offset;\n\tiov[0].iov_len = len;\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (rem_addr.ss_family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&rem_addr;\n\t\tlog_print(\"Trying to connect to %pI4\", &sin->sin_addr.s_addr);\n\t} else {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&rem_addr;\n\t\tlog_print(\"Trying to connect to %pI6\", &sin6->sin6_addr);\n\t}\n\n\tcmsg = CMSG_FIRSTHDR(&outmessage);\n\tcmsg->cmsg_level = IPPROTO_SCTP;\n\tcmsg->cmsg_type = SCTP_SNDRCV;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));\n\tsinfo = CMSG_DATA(cmsg);\n\tmemset(sinfo, 0x00, sizeof(struct sctp_sndrcvinfo));\n\tsinfo->sinfo_ppid = cpu_to_le32(con->nodeid);\n\toutmessage.msg_controllen = cmsg->cmsg_len;\n\tsinfo->sinfo_flags |= SCTP_ADDR_OVER;\n\n\tret = kernel_sendmsg(base_con->sock, &outmessage, iov, 1, len);\n\tif (ret < 0) {\n\t\tlog_print(\"Send first packet to node %d failed: %d\",\n\t\t\t  con->nodeid, ret);\n\n\t\t/* Try again later */\n\t\tclear_bit(CF_CONNECT_PENDING, &con->flags);\n\t\tclear_bit(CF_INIT_PENDING, &con->flags);\n\t}\n\telse {\n\t\tspin_lock(&con->writequeue_lock);\n\t\twritequeue_entry_complete(e, ret);\n\t\tspin_unlock(&con->writequeue_lock);\n\t}\n\nunlock:\n\tmutex_unlock(&con->sock_mutex);\n}"
  },
  {
    "function_name": "writequeue_entry_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1049-1058",
    "snippet": "static void writequeue_entry_complete(struct writequeue_entry *e, int completed)\n{\n\te->offset += completed;\n\te->len -= completed;\n\n\tif (e->len == 0 && e->users == 0) {\n\t\tlist_del(&e->list);\n\t\tfree_entry(e);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_entry",
          "args": [
            "e"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "free_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1036-1040",
          "snippet": "static void free_entry(struct writequeue_entry *e)\n{\n\t__free_page(e->page);\n\tkfree(e);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void free_entry(struct writequeue_entry *e)\n{\n\t__free_page(e->page);\n\tkfree(e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&e->list"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void writequeue_entry_complete(struct writequeue_entry *e, int completed)\n{\n\te->offset += completed;\n\te->len -= completed;\n\n\tif (e->len == 0 && e->users == 0) {\n\t\tlist_del(&e->list);\n\t\tfree_entry(e);\n\t}\n}"
  },
  {
    "function_name": "free_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "1036-1040",
    "snippet": "static void free_entry(struct writequeue_entry *e)\n{\n\t__free_page(e->page);\n\tkfree(e);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "e"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "e->page"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void free_entry(struct writequeue_entry *e)\n{\n\t__free_page(e->page);\n\tkfree(e);\n}"
  },
  {
    "function_name": "tcp_accept_from_sock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "906-1034",
    "snippet": "static int tcp_accept_from_sock(struct connection *con)\n{\n\tint result;\n\tstruct sockaddr_storage peeraddr;\n\tstruct socket *newsock;\n\tint len;\n\tint nodeid;\n\tstruct connection *newcon;\n\tstruct connection *addcon;\n\n\tmutex_lock(&connections_lock);\n\tif (!dlm_allow_conn) {\n\t\tmutex_unlock(&connections_lock);\n\t\treturn -1;\n\t}\n\tmutex_unlock(&connections_lock);\n\n\tmemset(&peeraddr, 0, sizeof(peeraddr));\n\tresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_STREAM,\n\t\t\t\t  IPPROTO_TCP, &newsock);\n\tif (result < 0)\n\t\treturn -ENOMEM;\n\n\tmutex_lock_nested(&con->sock_mutex, 0);\n\n\tresult = -ENOTCONN;\n\tif (con->sock == NULL)\n\t\tgoto accept_err;\n\n\tnewsock->type = con->sock->type;\n\tnewsock->ops = con->sock->ops;\n\n\tresult = con->sock->ops->accept(con->sock, newsock, O_NONBLOCK);\n\tif (result < 0)\n\t\tgoto accept_err;\n\n\t/* Get the connected socket's peer */\n\tmemset(&peeraddr, 0, sizeof(peeraddr));\n\tif (newsock->ops->getname(newsock, (struct sockaddr *)&peeraddr,\n\t\t\t\t  &len, 2)) {\n\t\tresult = -ECONNABORTED;\n\t\tgoto accept_err;\n\t}\n\n\t/* Get the new node's NODEID */\n\tmake_sockaddr(&peeraddr, 0, &len);\n\tif (addr_to_nodeid(&peeraddr, &nodeid)) {\n\t\tunsigned char *b=(unsigned char *)&peeraddr;\n\t\tlog_print(\"connect from non cluster node\");\n\t\tprint_hex_dump_bytes(\"ss: \", DUMP_PREFIX_NONE, \n\t\t\t\t     b, sizeof(struct sockaddr_storage));\n\t\tsock_release(newsock);\n\t\tmutex_unlock(&con->sock_mutex);\n\t\treturn -1;\n\t}\n\n\tlog_print(\"got connection from %d\", nodeid);\n\n\t/*  Check to see if we already have a connection to this node. This\n\t *  could happen if the two nodes initiate a connection at roughly\n\t *  the same time and the connections cross on the wire.\n\t *  In this case we store the incoming one in \"othercon\"\n\t */\n\tnewcon = nodeid2con(nodeid, GFP_NOFS);\n\tif (!newcon) {\n\t\tresult = -ENOMEM;\n\t\tgoto accept_err;\n\t}\n\tmutex_lock_nested(&newcon->sock_mutex, 1);\n\tif (newcon->sock) {\n\t\tstruct connection *othercon = newcon->othercon;\n\n\t\tif (!othercon) {\n\t\t\tothercon = kmem_cache_zalloc(con_cache, GFP_NOFS);\n\t\t\tif (!othercon) {\n\t\t\t\tlog_print(\"failed to allocate incoming socket\");\n\t\t\t\tmutex_unlock(&newcon->sock_mutex);\n\t\t\t\tresult = -ENOMEM;\n\t\t\t\tgoto accept_err;\n\t\t\t}\n\t\t\tothercon->nodeid = nodeid;\n\t\t\tothercon->rx_action = receive_from_sock;\n\t\t\tmutex_init(&othercon->sock_mutex);\n\t\t\tINIT_WORK(&othercon->swork, process_send_sockets);\n\t\t\tINIT_WORK(&othercon->rwork, process_recv_sockets);\n\t\t\tset_bit(CF_IS_OTHERCON, &othercon->flags);\n\t\t}\n\t\tif (!othercon->sock) {\n\t\t\tnewcon->othercon = othercon;\n\t\t\tothercon->sock = newsock;\n\t\t\tnewsock->sk->sk_user_data = othercon;\n\t\t\tadd_sock(newsock, othercon);\n\t\t\taddcon = othercon;\n\t\t}\n\t\telse {\n\t\t\tprintk(\"Extra connection from node %d attempted\\n\", nodeid);\n\t\t\tresult = -EAGAIN;\n\t\t\tmutex_unlock(&newcon->sock_mutex);\n\t\t\tgoto accept_err;\n\t\t}\n\t}\n\telse {\n\t\tnewsock->sk->sk_user_data = newcon;\n\t\tnewcon->rx_action = receive_from_sock;\n\t\tadd_sock(newsock, newcon);\n\t\taddcon = newcon;\n\t}\n\n\tmutex_unlock(&newcon->sock_mutex);\n\n\t/*\n\t * Add it to the active queue in case we got data\n\t * between processing the accept adding the socket\n\t * to the read_sockets list\n\t */\n\tif (!test_and_set_bit(CF_READ_PENDING, &addcon->flags))\n\t\tqueue_work(recv_workqueue, &addcon->rwork);\n\tmutex_unlock(&con->sock_mutex);\n\n\treturn 0;\n\naccept_err:\n\tmutex_unlock(&con->sock_mutex);\n\tsock_release(newsock);\n\n\tif (result != -EAGAIN)\n\t\tlog_print(\"error accepting connection from node: %d\", result);\n\treturn result;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_IS_OTHERCON 5",
      "#define CF_READ_PENDING 1"
    ],
    "globals_used": [
      "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];",
      "static int dlm_allow_conn;",
      "static struct workqueue_struct *recv_workqueue;",
      "static DEFINE_MUTEX(connections_lock);",
      "static struct kmem_cache *con_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"error accepting connection from node: %d\"",
            "result"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "newsock"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "recv_workqueue",
            "&addcon->rwork"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CF_READ_PENDING",
            "&addcon->flags"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&newcon->sock_mutex"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_sock",
          "args": [
            "newsock",
            "newcon"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "add_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "485-495",
          "snippet": "static void add_sock(struct socket *sock, struct connection *con)\n{\n\tcon->sock = sock;\n\n\t/* Install a data_ready callback */\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->sock->sk->sk_write_space = lowcomms_write_space;\n\tcon->sock->sk->sk_state_change = lowcomms_state_change;\n\tcon->sock->sk->sk_user_data = con;\n\tcon->sock->sk->sk_allocation = GFP_NOFS;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void add_sock(struct socket *sock, struct connection *con)\n{\n\tcon->sock = sock;\n\n\t/* Install a data_ready callback */\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->sock->sk->sk_write_space = lowcomms_write_space;\n\tcon->sock->sk->sk_state_change = lowcomms_state_change;\n\tcon->sock->sk->sk_user_data = con;\n\tcon->sock->sk->sk_allocation = GFP_NOFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&newcon->sock_mutex"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Extra connection from node %d attempted\\n\"",
            "nodeid"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CF_IS_OTHERCON",
            "&othercon->flags"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&othercon->rwork",
            "process_recv_sockets"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&othercon->swork",
            "process_send_sockets"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&othercon->sock_mutex"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&newcon->sock_mutex"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"failed to allocate incoming socket\""
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "con_cache",
            "GFP_NOFS"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&newcon->sock_mutex",
            "1"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeid2con",
          "args": [
            "nodeid",
            "GFP_NOFS"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "244-253",
          "snippet": "static struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "newsock"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump_bytes",
          "args": [
            "\"ss: \"",
            "DUMP_PREFIX_NONE",
            "b",
            "sizeof(struct sockaddr_storage)"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"connect from non cluster node\""
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr_to_nodeid",
          "args": [
            "&peeraddr",
            "&nodeid"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "361-383",
          "snippet": "static int addr_to_nodeid(struct sockaddr_storage *addr, int *nodeid)\n{\n\tstruct dlm_node_addr *na;\n\tint rv = -EEXIST;\n\tint addr_i;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (!na->addr_count)\n\t\t\tcontinue;\n\n\t\tfor (addr_i = 0; addr_i < na->addr_count; addr_i++) {\n\t\t\tif (addr_compare(na->addr[addr_i], addr)) {\n\t\t\t\t*nodeid = na->nodeid;\n\t\t\t\trv = 0;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\nunlock:\n\tspin_unlock(&dlm_node_addrs_spin);\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dlm_node_addrs);",
            "static DEFINE_SPINLOCK(dlm_node_addrs_spin);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic LIST_HEAD(dlm_node_addrs);\nstatic DEFINE_SPINLOCK(dlm_node_addrs_spin);\n\nstatic int addr_to_nodeid(struct sockaddr_storage *addr, int *nodeid)\n{\n\tstruct dlm_node_addr *na;\n\tint rv = -EEXIST;\n\tint addr_i;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (!na->addr_count)\n\t\t\tcontinue;\n\n\t\tfor (addr_i = 0; addr_i < na->addr_count; addr_i++) {\n\t\t\tif (addr_compare(na->addr[addr_i], addr)) {\n\t\t\t\t*nodeid = na->nodeid;\n\t\t\t\trv = 0;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\nunlock:\n\tspin_unlock(&dlm_node_addrs_spin);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_sockaddr",
          "args": [
            "&peeraddr",
            "0",
            "&len"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "make_sockaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "499-514",
          "snippet": "static void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\n\nstatic void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "newsock->ops->getname",
          "args": [
            "newsock",
            "(struct sockaddr *)&peeraddr",
            "&len",
            "2"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&peeraddr",
            "0",
            "sizeof(peeraddr)"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "con->sock->ops->accept",
          "args": [
            "con->sock",
            "newsock",
            "O_NONBLOCK"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&con->sock_mutex",
            "0"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_create_kern",
          "args": [
            "dlm_local_addr[0]->ss_family",
            "SOCK_STREAM",
            "IPPROTO_TCP",
            "&newsock"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&peeraddr",
            "0",
            "sizeof(peeraddr)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&connections_lock"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&connections_lock"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&connections_lock"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_IS_OTHERCON 5\n#define CF_READ_PENDING 1\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\nstatic int dlm_allow_conn;\nstatic struct workqueue_struct *recv_workqueue;\nstatic DEFINE_MUTEX(connections_lock);\nstatic struct kmem_cache *con_cache;\n\nstatic int tcp_accept_from_sock(struct connection *con)\n{\n\tint result;\n\tstruct sockaddr_storage peeraddr;\n\tstruct socket *newsock;\n\tint len;\n\tint nodeid;\n\tstruct connection *newcon;\n\tstruct connection *addcon;\n\n\tmutex_lock(&connections_lock);\n\tif (!dlm_allow_conn) {\n\t\tmutex_unlock(&connections_lock);\n\t\treturn -1;\n\t}\n\tmutex_unlock(&connections_lock);\n\n\tmemset(&peeraddr, 0, sizeof(peeraddr));\n\tresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_STREAM,\n\t\t\t\t  IPPROTO_TCP, &newsock);\n\tif (result < 0)\n\t\treturn -ENOMEM;\n\n\tmutex_lock_nested(&con->sock_mutex, 0);\n\n\tresult = -ENOTCONN;\n\tif (con->sock == NULL)\n\t\tgoto accept_err;\n\n\tnewsock->type = con->sock->type;\n\tnewsock->ops = con->sock->ops;\n\n\tresult = con->sock->ops->accept(con->sock, newsock, O_NONBLOCK);\n\tif (result < 0)\n\t\tgoto accept_err;\n\n\t/* Get the connected socket's peer */\n\tmemset(&peeraddr, 0, sizeof(peeraddr));\n\tif (newsock->ops->getname(newsock, (struct sockaddr *)&peeraddr,\n\t\t\t\t  &len, 2)) {\n\t\tresult = -ECONNABORTED;\n\t\tgoto accept_err;\n\t}\n\n\t/* Get the new node's NODEID */\n\tmake_sockaddr(&peeraddr, 0, &len);\n\tif (addr_to_nodeid(&peeraddr, &nodeid)) {\n\t\tunsigned char *b=(unsigned char *)&peeraddr;\n\t\tlog_print(\"connect from non cluster node\");\n\t\tprint_hex_dump_bytes(\"ss: \", DUMP_PREFIX_NONE, \n\t\t\t\t     b, sizeof(struct sockaddr_storage));\n\t\tsock_release(newsock);\n\t\tmutex_unlock(&con->sock_mutex);\n\t\treturn -1;\n\t}\n\n\tlog_print(\"got connection from %d\", nodeid);\n\n\t/*  Check to see if we already have a connection to this node. This\n\t *  could happen if the two nodes initiate a connection at roughly\n\t *  the same time and the connections cross on the wire.\n\t *  In this case we store the incoming one in \"othercon\"\n\t */\n\tnewcon = nodeid2con(nodeid, GFP_NOFS);\n\tif (!newcon) {\n\t\tresult = -ENOMEM;\n\t\tgoto accept_err;\n\t}\n\tmutex_lock_nested(&newcon->sock_mutex, 1);\n\tif (newcon->sock) {\n\t\tstruct connection *othercon = newcon->othercon;\n\n\t\tif (!othercon) {\n\t\t\tothercon = kmem_cache_zalloc(con_cache, GFP_NOFS);\n\t\t\tif (!othercon) {\n\t\t\t\tlog_print(\"failed to allocate incoming socket\");\n\t\t\t\tmutex_unlock(&newcon->sock_mutex);\n\t\t\t\tresult = -ENOMEM;\n\t\t\t\tgoto accept_err;\n\t\t\t}\n\t\t\tothercon->nodeid = nodeid;\n\t\t\tothercon->rx_action = receive_from_sock;\n\t\t\tmutex_init(&othercon->sock_mutex);\n\t\t\tINIT_WORK(&othercon->swork, process_send_sockets);\n\t\t\tINIT_WORK(&othercon->rwork, process_recv_sockets);\n\t\t\tset_bit(CF_IS_OTHERCON, &othercon->flags);\n\t\t}\n\t\tif (!othercon->sock) {\n\t\t\tnewcon->othercon = othercon;\n\t\t\tothercon->sock = newsock;\n\t\t\tnewsock->sk->sk_user_data = othercon;\n\t\t\tadd_sock(newsock, othercon);\n\t\t\taddcon = othercon;\n\t\t}\n\t\telse {\n\t\t\tprintk(\"Extra connection from node %d attempted\\n\", nodeid);\n\t\t\tresult = -EAGAIN;\n\t\t\tmutex_unlock(&newcon->sock_mutex);\n\t\t\tgoto accept_err;\n\t\t}\n\t}\n\telse {\n\t\tnewsock->sk->sk_user_data = newcon;\n\t\tnewcon->rx_action = receive_from_sock;\n\t\tadd_sock(newsock, newcon);\n\t\taddcon = newcon;\n\t}\n\n\tmutex_unlock(&newcon->sock_mutex);\n\n\t/*\n\t * Add it to the active queue in case we got data\n\t * between processing the accept adding the socket\n\t * to the read_sockets list\n\t */\n\tif (!test_and_set_bit(CF_READ_PENDING, &addcon->flags))\n\t\tqueue_work(recv_workqueue, &addcon->rwork);\n\tmutex_unlock(&con->sock_mutex);\n\n\treturn 0;\n\naccept_err:\n\tmutex_unlock(&con->sock_mutex);\n\tsock_release(newsock);\n\n\tif (result != -EAGAIN)\n\t\tlog_print(\"error accepting connection from node: %d\", result);\n\treturn result;\n}"
  },
  {
    "function_name": "receive_from_sock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "787-903",
    "snippet": "static int receive_from_sock(struct connection *con)\n{\n\tint ret = 0;\n\tstruct msghdr msg = {};\n\tstruct kvec iov[2];\n\tunsigned len;\n\tint r;\n\tint call_again_soon = 0;\n\tint nvec;\n\tchar incmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\n\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock == NULL) {\n\t\tret = -EAGAIN;\n\t\tgoto out_close;\n\t}\n\n\tif (con->rx_page == NULL) {\n\t\t/*\n\t\t * This doesn't need to be atomic, but I think it should\n\t\t * improve performance if it is.\n\t\t */\n\t\tcon->rx_page = alloc_page(GFP_ATOMIC);\n\t\tif (con->rx_page == NULL)\n\t\t\tgoto out_resched;\n\t\tcbuf_init(&con->cb, PAGE_CACHE_SIZE);\n\t}\n\n\t/* Only SCTP needs these really */\n\tmemset(&incmsg, 0, sizeof(incmsg));\n\tmsg.msg_control = incmsg;\n\tmsg.msg_controllen = sizeof(incmsg);\n\n\t/*\n\t * iov[0] is the bit of the circular buffer between the current end\n\t * point (cb.base + cb.len) and the end of the buffer.\n\t */\n\tiov[0].iov_len = con->cb.base - cbuf_data(&con->cb);\n\tiov[0].iov_base = page_address(con->rx_page) + cbuf_data(&con->cb);\n\tiov[1].iov_len = 0;\n\tnvec = 1;\n\n\t/*\n\t * iov[1] is the bit of the circular buffer between the start of the\n\t * buffer and the start of the currently used section (cb.base)\n\t */\n\tif (cbuf_data(&con->cb) >= con->cb.base) {\n\t\tiov[0].iov_len = PAGE_CACHE_SIZE - cbuf_data(&con->cb);\n\t\tiov[1].iov_len = con->cb.base;\n\t\tiov[1].iov_base = page_address(con->rx_page);\n\t\tnvec = 2;\n\t}\n\tlen = iov[0].iov_len + iov[1].iov_len;\n\n\tr = ret = kernel_recvmsg(con->sock, &msg, iov, nvec, len,\n\t\t\t       MSG_DONTWAIT | MSG_NOSIGNAL);\n\tif (ret <= 0)\n\t\tgoto out_close;\n\n\t/* Process SCTP notifications */\n\tif (msg.msg_flags & MSG_NOTIFICATION) {\n\t\tmsg.msg_control = incmsg;\n\t\tmsg.msg_controllen = sizeof(incmsg);\n\n\t\tprocess_sctp_notification(con, &msg,\n\t\t\t\tpage_address(con->rx_page) + con->cb.base);\n\t\tmutex_unlock(&con->sock_mutex);\n\t\treturn 0;\n\t}\n\tBUG_ON(con->nodeid == 0);\n\n\tif (ret == len)\n\t\tcall_again_soon = 1;\n\tcbuf_add(&con->cb, ret);\n\tret = dlm_process_incoming_buffer(con->nodeid,\n\t\t\t\t\t  page_address(con->rx_page),\n\t\t\t\t\t  con->cb.base, con->cb.len,\n\t\t\t\t\t  PAGE_CACHE_SIZE);\n\tif (ret == -EBADMSG) {\n\t\tlog_print(\"lowcomms: addr=%p, base=%u, len=%u, \"\n\t\t\t  \"iov_len=%u, iov_base[0]=%p, read=%d\",\n\t\t\t  page_address(con->rx_page), con->cb.base, con->cb.len,\n\t\t\t  len, iov[0].iov_base, r);\n\t}\n\tif (ret < 0)\n\t\tgoto out_close;\n\tcbuf_eat(&con->cb, ret);\n\n\tif (cbuf_empty(&con->cb) && !call_again_soon) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tif (call_again_soon)\n\t\tgoto out_resched;\n\tmutex_unlock(&con->sock_mutex);\n\treturn 0;\n\nout_resched:\n\tif (!test_and_set_bit(CF_READ_PENDING, &con->flags))\n\t\tqueue_work(recv_workqueue, &con->rwork);\n\tmutex_unlock(&con->sock_mutex);\n\treturn -EAGAIN;\n\nout_close:\n\tmutex_unlock(&con->sock_mutex);\n\tif (ret != -EAGAIN) {\n\t\tclose_connection(con, false);\n\t\t/* Reconnect when there is something to send */\n\t}\n\t/* Don't return success if we really got EOF */\n\tif (ret == 0)\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_READ_PENDING 1"
    ],
    "globals_used": [
      "static struct workqueue_struct *recv_workqueue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close_connection",
          "args": [
            "con",
            "false"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "close_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "517-536",
          "snippet": "static void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "recv_workqueue",
            "&con->rwork"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CF_READ_PENDING",
            "&con->flags"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "con->rx_page"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbuf_empty",
          "args": [
            "&con->cb"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "cbuf_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "98-101",
          "snippet": "static bool cbuf_empty(struct cbuf *cb)\n{\n\treturn cb->len == 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic bool cbuf_empty(struct cbuf *cb)\n{\n\treturn cb->len == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cbuf_eat",
          "args": [
            "&con->cb",
            "ret"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "cbuf_eat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "91-96",
          "snippet": "static void cbuf_eat(struct cbuf *cb, int n)\n{\n\tcb->len  -= n;\n\tcb->base += n;\n\tcb->base &= cb->mask;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void cbuf_eat(struct cbuf *cb, int n)\n{\n\tcb->len  -= n;\n\tcb->base += n;\n\tcb->base &= cb->mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"lowcomms: addr=%p, base=%u, len=%u, \"\n\t\t\t  \"iov_len=%u, iov_base[0]=%p, read=%d\"",
            "page_address(con->rx_page)",
            "con->cb.base",
            "con->cb.len",
            "len",
            "iov[0].iov_base",
            "r"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "con->rx_page"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_process_incoming_buffer",
          "args": [
            "con->nodeid",
            "page_address(con->rx_page)",
            "con->cb.base",
            "con->cb.len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_process_incoming_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/midcomms.c",
          "lines": "58-136",
          "snippet": "int dlm_process_incoming_buffer(int nodeid, const void *base,\n\t\t\t\tunsigned offset, unsigned len, unsigned limit)\n{\n\tunion {\n\t\tunsigned char __buf[DLM_INBUF_LEN];\n\t\t/* this is to force proper alignment on some arches */\n\t\tunion dlm_packet p;\n\t} __tmp;\n\tunion dlm_packet *p = &__tmp.p;\n\tint ret = 0;\n\tint err = 0;\n\tuint16_t msglen;\n\tuint32_t lockspace;\n\n\twhile (len > sizeof(struct dlm_header)) {\n\n\t\t/* Copy just the header to check the total length.  The\n\t\t   message may wrap around the end of the buffer back to the\n\t\t   start, so we need to use a temp buffer and copy_from_cb. */\n\n\t\tcopy_from_cb(p, base, offset, sizeof(struct dlm_header),\n\t\t\t     limit);\n\n\t\tmsglen = le16_to_cpu(p->header.h_length);\n\t\tlockspace = p->header.h_lockspace;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < sizeof(struct dlm_header))\n\t\t\tbreak;\n\t\tif (p->header.h_cmd == DLM_MSG) {\n\t\t\tif (msglen < sizeof(struct dlm_message))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (msglen < sizeof(struct dlm_rcom))\n\t\t\t\tbreak;\n\t\t}\n\t\terr = -E2BIG;\n\t\tif (msglen > dlm_config.ci_buffer_size) {\n\t\t\tlog_print(\"message size %d from %d too big, buf len %d\",\n\t\t\t\t  msglen, nodeid, len);\n\t\t\tbreak;\n\t\t}\n\t\terr = 0;\n\n\t\t/* If only part of the full message is contained in this\n\t\t   buffer, then do nothing and wait for lowcomms to call\n\t\t   us again later with more data.  We return 0 meaning\n\t\t   we've consumed none of the input buffer. */\n\n\t\tif (msglen > len)\n\t\t\tbreak;\n\n\t\t/* Allocate a larger temp buffer if the full message won't fit\n\t\t   in the buffer on the stack (which should work for most\n\t\t   ordinary messages). */\n\n\t\tif (msglen > sizeof(__tmp) && p == &__tmp.p) {\n\t\t\tp = kmalloc(dlm_config.ci_buffer_size, GFP_NOFS);\n\t\t\tif (p == NULL)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tcopy_from_cb(p, base, offset, msglen, limit);\n\n\t\tBUG_ON(lockspace != p->header.h_lockspace);\n\n\t\tret += msglen;\n\t\toffset += msglen;\n\t\toffset &= (limit - 1);\n\t\tlen -= msglen;\n\n\t\tdlm_receive_buffer(p, nodeid);\n\t}\n\n\tif (p != &__tmp.p)\n\t\tkfree(p);\n\n\treturn err ? err : ret;\n}",
          "includes": [
            "#include \"midcomms.h\"",
            "#include \"lock.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midcomms.h\"\n#include \"lock.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n\nint dlm_process_incoming_buffer(int nodeid, const void *base,\n\t\t\t\tunsigned offset, unsigned len, unsigned limit)\n{\n\tunion {\n\t\tunsigned char __buf[DLM_INBUF_LEN];\n\t\t/* this is to force proper alignment on some arches */\n\t\tunion dlm_packet p;\n\t} __tmp;\n\tunion dlm_packet *p = &__tmp.p;\n\tint ret = 0;\n\tint err = 0;\n\tuint16_t msglen;\n\tuint32_t lockspace;\n\n\twhile (len > sizeof(struct dlm_header)) {\n\n\t\t/* Copy just the header to check the total length.  The\n\t\t   message may wrap around the end of the buffer back to the\n\t\t   start, so we need to use a temp buffer and copy_from_cb. */\n\n\t\tcopy_from_cb(p, base, offset, sizeof(struct dlm_header),\n\t\t\t     limit);\n\n\t\tmsglen = le16_to_cpu(p->header.h_length);\n\t\tlockspace = p->header.h_lockspace;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < sizeof(struct dlm_header))\n\t\t\tbreak;\n\t\tif (p->header.h_cmd == DLM_MSG) {\n\t\t\tif (msglen < sizeof(struct dlm_message))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (msglen < sizeof(struct dlm_rcom))\n\t\t\t\tbreak;\n\t\t}\n\t\terr = -E2BIG;\n\t\tif (msglen > dlm_config.ci_buffer_size) {\n\t\t\tlog_print(\"message size %d from %d too big, buf len %d\",\n\t\t\t\t  msglen, nodeid, len);\n\t\t\tbreak;\n\t\t}\n\t\terr = 0;\n\n\t\t/* If only part of the full message is contained in this\n\t\t   buffer, then do nothing and wait for lowcomms to call\n\t\t   us again later with more data.  We return 0 meaning\n\t\t   we've consumed none of the input buffer. */\n\n\t\tif (msglen > len)\n\t\t\tbreak;\n\n\t\t/* Allocate a larger temp buffer if the full message won't fit\n\t\t   in the buffer on the stack (which should work for most\n\t\t   ordinary messages). */\n\n\t\tif (msglen > sizeof(__tmp) && p == &__tmp.p) {\n\t\t\tp = kmalloc(dlm_config.ci_buffer_size, GFP_NOFS);\n\t\t\tif (p == NULL)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tcopy_from_cb(p, base, offset, msglen, limit);\n\n\t\tBUG_ON(lockspace != p->header.h_lockspace);\n\n\t\tret += msglen;\n\t\toffset += msglen;\n\t\toffset &= (limit - 1);\n\t\tlen -= msglen;\n\n\t\tdlm_receive_buffer(p, nodeid);\n\t}\n\n\tif (p != &__tmp.p)\n\t\tkfree(p);\n\n\treturn err ? err : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "con->rx_page"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbuf_add",
          "args": [
            "&con->cb",
            "ret"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "cbuf_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "75-78",
          "snippet": "static void cbuf_add(struct cbuf *cb, int n)\n{\n\tcb->len += n;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void cbuf_add(struct cbuf *cb, int n)\n{\n\tcb->len += n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "con->nodeid == 0"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_sctp_notification",
          "args": [
            "con",
            "&msg",
            "page_address(con->rx_page) + con->cb.base"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "process_sctp_notification",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "653-784",
          "snippet": "static void process_sctp_notification(struct connection *con,\n\t\t\t\t      struct msghdr *msg, char *buf)\n{\n\tunion sctp_notification *sn = (union sctp_notification *)buf;\n\tstruct linger linger;\n\n\tswitch (sn->sn_header.sn_type) {\n\tcase SCTP_SEND_FAILED:\n\t\tretry_failed_sctp_send(con, &sn->sn_send_failed, buf);\n\t\tbreak;\n\tcase SCTP_ASSOC_CHANGE:\n\t\tswitch (sn->sn_assoc_change.sac_state) {\n\t\tcase SCTP_COMM_UP:\n\t\tcase SCTP_RESTART:\n\t\t{\n\t\t\t/* Check that the new node is in the lockspace */\n\t\t\tstruct sctp_prim prim;\n\t\t\tint nodeid;\n\t\t\tint prim_len, ret;\n\t\t\tint addr_len;\n\t\t\tstruct connection *new_con;\n\n\t\t\t/*\n\t\t\t * We get this before any data for an association.\n\t\t\t * We verify that the node is in the cluster and\n\t\t\t * then peel off a socket for it.\n\t\t\t */\n\t\t\tif ((int)sn->sn_assoc_change.sac_assoc_id <= 0) {\n\t\t\t\tlog_print(\"COMM_UP for invalid assoc ID %d\",\n\t\t\t\t\t (int)sn->sn_assoc_change.sac_assoc_id);\n\t\t\t\tsctp_init_failed();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmemset(&prim, 0, sizeof(struct sctp_prim));\n\t\t\tprim_len = sizeof(struct sctp_prim);\n\t\t\tprim.ssp_assoc_id = sn->sn_assoc_change.sac_assoc_id;\n\n\t\t\tret = kernel_getsockopt(con->sock,\n\t\t\t\t\t\tIPPROTO_SCTP,\n\t\t\t\t\t\tSCTP_PRIMARY_ADDR,\n\t\t\t\t\t\t(char*)&prim,\n\t\t\t\t\t\t&prim_len);\n\t\t\tif (ret < 0) {\n\t\t\t\tlog_print(\"getsockopt/sctp_primary_addr on \"\n\t\t\t\t\t  \"new assoc %d failed : %d\",\n\t\t\t\t\t  (int)sn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t\t  ret);\n\n\t\t\t\t/* Retry INIT later */\n\t\t\t\tnew_con = assoc2con(sn->sn_assoc_change.sac_assoc_id);\n\t\t\t\tif (new_con)\n\t\t\t\t\tclear_bit(CF_CONNECT_PENDING, &con->flags);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmake_sockaddr(&prim.ssp_addr, 0, &addr_len);\n\t\t\tif (addr_to_nodeid(&prim.ssp_addr, &nodeid)) {\n\t\t\t\tunsigned char *b=(unsigned char *)&prim.ssp_addr;\n\t\t\t\tlog_print(\"reject connect from unknown addr\");\n\t\t\t\tprint_hex_dump_bytes(\"ss: \", DUMP_PREFIX_NONE, \n\t\t\t\t\t\t     b, sizeof(struct sockaddr_storage));\n\t\t\t\tsctp_send_shutdown(prim.ssp_assoc_id);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnew_con = nodeid2con(nodeid, GFP_NOFS);\n\t\t\tif (!new_con)\n\t\t\t\treturn;\n\n\t\t\t/* Peel off a new sock */\n\t\t\tlock_sock(con->sock->sk);\n\t\t\tret = sctp_do_peeloff(con->sock->sk,\n\t\t\t\tsn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t&new_con->sock);\n\t\t\trelease_sock(con->sock->sk);\n\t\t\tif (ret < 0) {\n\t\t\t\tlog_print(\"Can't peel off a socket for \"\n\t\t\t\t\t  \"connection %d to node %d: err=%d\",\n\t\t\t\t\t  (int)sn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t\t  nodeid, ret);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tadd_sock(new_con->sock, new_con);\n\n\t\t\tlinger.l_onoff = 1;\n\t\t\tlinger.l_linger = 0;\n\t\t\tret = kernel_setsockopt(new_con->sock, SOL_SOCKET, SO_LINGER,\n\t\t\t\t\t\t(char *)&linger, sizeof(linger));\n\t\t\tif (ret < 0)\n\t\t\t\tlog_print(\"set socket option SO_LINGER failed\");\n\n\t\t\tlog_print(\"connecting to %d sctp association %d\",\n\t\t\t\t nodeid, (int)sn->sn_assoc_change.sac_assoc_id);\n\n\t\t\tnew_con->sctp_assoc = sn->sn_assoc_change.sac_assoc_id;\n\t\t\tnew_con->try_new_addr = false;\n\t\t\t/* Send any pending writes */\n\t\t\tclear_bit(CF_CONNECT_PENDING, &new_con->flags);\n\t\t\tclear_bit(CF_INIT_PENDING, &new_con->flags);\n\t\t\tif (!test_and_set_bit(CF_WRITE_PENDING, &new_con->flags)) {\n\t\t\t\tqueue_work(send_workqueue, &new_con->swork);\n\t\t\t}\n\t\t\tif (!test_and_set_bit(CF_READ_PENDING, &new_con->flags))\n\t\t\t\tqueue_work(recv_workqueue, &new_con->rwork);\n\t\t}\n\t\tbreak;\n\n\t\tcase SCTP_COMM_LOST:\n\t\tcase SCTP_SHUTDOWN_COMP:\n\t\t{\n\t\t\tcon = assoc2con(sn->sn_assoc_change.sac_assoc_id);\n\t\t\tif (con) {\n\t\t\t\tcon->sctp_assoc = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase SCTP_CANT_STR_ASSOC:\n\t\t{\n\t\t\t/* Will retry init when we get the send failed notification */\n\t\t\tlog_print(\"Can't start SCTP association - retrying\");\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tlog_print(\"unexpected SCTP assoc change id=%d state=%d\",\n\t\t\t\t  (int)sn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t  sn->sn_assoc_change.sac_state);\n\t\t}\n\tdefault:\n\t\t; /* fall through */\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CF_INIT_PENDING 4",
            "#define CF_CONNECT_PENDING 3",
            "#define CF_WRITE_PENDING 2",
            "#define CF_READ_PENDING 1"
          ],
          "globals_used": [
            "static struct workqueue_struct *recv_workqueue;",
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_INIT_PENDING 4\n#define CF_CONNECT_PENDING 3\n#define CF_WRITE_PENDING 2\n#define CF_READ_PENDING 1\n\nstatic struct workqueue_struct *recv_workqueue;\nstatic struct workqueue_struct *send_workqueue;\n\nstatic void process_sctp_notification(struct connection *con,\n\t\t\t\t      struct msghdr *msg, char *buf)\n{\n\tunion sctp_notification *sn = (union sctp_notification *)buf;\n\tstruct linger linger;\n\n\tswitch (sn->sn_header.sn_type) {\n\tcase SCTP_SEND_FAILED:\n\t\tretry_failed_sctp_send(con, &sn->sn_send_failed, buf);\n\t\tbreak;\n\tcase SCTP_ASSOC_CHANGE:\n\t\tswitch (sn->sn_assoc_change.sac_state) {\n\t\tcase SCTP_COMM_UP:\n\t\tcase SCTP_RESTART:\n\t\t{\n\t\t\t/* Check that the new node is in the lockspace */\n\t\t\tstruct sctp_prim prim;\n\t\t\tint nodeid;\n\t\t\tint prim_len, ret;\n\t\t\tint addr_len;\n\t\t\tstruct connection *new_con;\n\n\t\t\t/*\n\t\t\t * We get this before any data for an association.\n\t\t\t * We verify that the node is in the cluster and\n\t\t\t * then peel off a socket for it.\n\t\t\t */\n\t\t\tif ((int)sn->sn_assoc_change.sac_assoc_id <= 0) {\n\t\t\t\tlog_print(\"COMM_UP for invalid assoc ID %d\",\n\t\t\t\t\t (int)sn->sn_assoc_change.sac_assoc_id);\n\t\t\t\tsctp_init_failed();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmemset(&prim, 0, sizeof(struct sctp_prim));\n\t\t\tprim_len = sizeof(struct sctp_prim);\n\t\t\tprim.ssp_assoc_id = sn->sn_assoc_change.sac_assoc_id;\n\n\t\t\tret = kernel_getsockopt(con->sock,\n\t\t\t\t\t\tIPPROTO_SCTP,\n\t\t\t\t\t\tSCTP_PRIMARY_ADDR,\n\t\t\t\t\t\t(char*)&prim,\n\t\t\t\t\t\t&prim_len);\n\t\t\tif (ret < 0) {\n\t\t\t\tlog_print(\"getsockopt/sctp_primary_addr on \"\n\t\t\t\t\t  \"new assoc %d failed : %d\",\n\t\t\t\t\t  (int)sn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t\t  ret);\n\n\t\t\t\t/* Retry INIT later */\n\t\t\t\tnew_con = assoc2con(sn->sn_assoc_change.sac_assoc_id);\n\t\t\t\tif (new_con)\n\t\t\t\t\tclear_bit(CF_CONNECT_PENDING, &con->flags);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmake_sockaddr(&prim.ssp_addr, 0, &addr_len);\n\t\t\tif (addr_to_nodeid(&prim.ssp_addr, &nodeid)) {\n\t\t\t\tunsigned char *b=(unsigned char *)&prim.ssp_addr;\n\t\t\t\tlog_print(\"reject connect from unknown addr\");\n\t\t\t\tprint_hex_dump_bytes(\"ss: \", DUMP_PREFIX_NONE, \n\t\t\t\t\t\t     b, sizeof(struct sockaddr_storage));\n\t\t\t\tsctp_send_shutdown(prim.ssp_assoc_id);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnew_con = nodeid2con(nodeid, GFP_NOFS);\n\t\t\tif (!new_con)\n\t\t\t\treturn;\n\n\t\t\t/* Peel off a new sock */\n\t\t\tlock_sock(con->sock->sk);\n\t\t\tret = sctp_do_peeloff(con->sock->sk,\n\t\t\t\tsn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t&new_con->sock);\n\t\t\trelease_sock(con->sock->sk);\n\t\t\tif (ret < 0) {\n\t\t\t\tlog_print(\"Can't peel off a socket for \"\n\t\t\t\t\t  \"connection %d to node %d: err=%d\",\n\t\t\t\t\t  (int)sn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t\t  nodeid, ret);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tadd_sock(new_con->sock, new_con);\n\n\t\t\tlinger.l_onoff = 1;\n\t\t\tlinger.l_linger = 0;\n\t\t\tret = kernel_setsockopt(new_con->sock, SOL_SOCKET, SO_LINGER,\n\t\t\t\t\t\t(char *)&linger, sizeof(linger));\n\t\t\tif (ret < 0)\n\t\t\t\tlog_print(\"set socket option SO_LINGER failed\");\n\n\t\t\tlog_print(\"connecting to %d sctp association %d\",\n\t\t\t\t nodeid, (int)sn->sn_assoc_change.sac_assoc_id);\n\n\t\t\tnew_con->sctp_assoc = sn->sn_assoc_change.sac_assoc_id;\n\t\t\tnew_con->try_new_addr = false;\n\t\t\t/* Send any pending writes */\n\t\t\tclear_bit(CF_CONNECT_PENDING, &new_con->flags);\n\t\t\tclear_bit(CF_INIT_PENDING, &new_con->flags);\n\t\t\tif (!test_and_set_bit(CF_WRITE_PENDING, &new_con->flags)) {\n\t\t\t\tqueue_work(send_workqueue, &new_con->swork);\n\t\t\t}\n\t\t\tif (!test_and_set_bit(CF_READ_PENDING, &new_con->flags))\n\t\t\t\tqueue_work(recv_workqueue, &new_con->rwork);\n\t\t}\n\t\tbreak;\n\n\t\tcase SCTP_COMM_LOST:\n\t\tcase SCTP_SHUTDOWN_COMP:\n\t\t{\n\t\t\tcon = assoc2con(sn->sn_assoc_change.sac_assoc_id);\n\t\t\tif (con) {\n\t\t\t\tcon->sctp_assoc = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase SCTP_CANT_STR_ASSOC:\n\t\t{\n\t\t\t/* Will retry init when we get the send failed notification */\n\t\t\tlog_print(\"Can't start SCTP association - retrying\");\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tlog_print(\"unexpected SCTP assoc change id=%d state=%d\",\n\t\t\t\t  (int)sn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t  sn->sn_assoc_change.sac_state);\n\t\t}\n\tdefault:\n\t\t; /* fall through */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "con->rx_page"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_recvmsg",
          "args": [
            "con->sock",
            "&msg",
            "iov",
            "nvec",
            "len",
            "MSG_DONTWAIT | MSG_NOSIGNAL"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "con->rx_page"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbuf_data",
          "args": [
            "&con->cb"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "cbuf_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "80-83",
          "snippet": "static int cbuf_data(struct cbuf *cb)\n{\n\treturn ((cb->base + cb->len) & cb->mask);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic int cbuf_data(struct cbuf *cb)\n{\n\treturn ((cb->base + cb->len) & cb->mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "con->rx_page"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&incmsg",
            "0",
            "sizeof(incmsg)"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbuf_init",
          "args": [
            "&con->cb",
            "PAGE_CACHE_SIZE"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "cbuf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "85-89",
          "snippet": "static void cbuf_init(struct cbuf *cb, int size)\n{\n\tcb->base = cb->len = 0;\n\tcb->mask = size-1;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void cbuf_init(struct cbuf *cb, int size)\n{\n\tcb->base = cb->len = 0;\n\tcb->mask = size-1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_ATOMIC"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "sizeof(struct sctp_sndrcvinfo)"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_READ_PENDING 1\n\nstatic struct workqueue_struct *recv_workqueue;\n\nstatic int receive_from_sock(struct connection *con)\n{\n\tint ret = 0;\n\tstruct msghdr msg = {};\n\tstruct kvec iov[2];\n\tunsigned len;\n\tint r;\n\tint call_again_soon = 0;\n\tint nvec;\n\tchar incmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\n\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock == NULL) {\n\t\tret = -EAGAIN;\n\t\tgoto out_close;\n\t}\n\n\tif (con->rx_page == NULL) {\n\t\t/*\n\t\t * This doesn't need to be atomic, but I think it should\n\t\t * improve performance if it is.\n\t\t */\n\t\tcon->rx_page = alloc_page(GFP_ATOMIC);\n\t\tif (con->rx_page == NULL)\n\t\t\tgoto out_resched;\n\t\tcbuf_init(&con->cb, PAGE_CACHE_SIZE);\n\t}\n\n\t/* Only SCTP needs these really */\n\tmemset(&incmsg, 0, sizeof(incmsg));\n\tmsg.msg_control = incmsg;\n\tmsg.msg_controllen = sizeof(incmsg);\n\n\t/*\n\t * iov[0] is the bit of the circular buffer between the current end\n\t * point (cb.base + cb.len) and the end of the buffer.\n\t */\n\tiov[0].iov_len = con->cb.base - cbuf_data(&con->cb);\n\tiov[0].iov_base = page_address(con->rx_page) + cbuf_data(&con->cb);\n\tiov[1].iov_len = 0;\n\tnvec = 1;\n\n\t/*\n\t * iov[1] is the bit of the circular buffer between the start of the\n\t * buffer and the start of the currently used section (cb.base)\n\t */\n\tif (cbuf_data(&con->cb) >= con->cb.base) {\n\t\tiov[0].iov_len = PAGE_CACHE_SIZE - cbuf_data(&con->cb);\n\t\tiov[1].iov_len = con->cb.base;\n\t\tiov[1].iov_base = page_address(con->rx_page);\n\t\tnvec = 2;\n\t}\n\tlen = iov[0].iov_len + iov[1].iov_len;\n\n\tr = ret = kernel_recvmsg(con->sock, &msg, iov, nvec, len,\n\t\t\t       MSG_DONTWAIT | MSG_NOSIGNAL);\n\tif (ret <= 0)\n\t\tgoto out_close;\n\n\t/* Process SCTP notifications */\n\tif (msg.msg_flags & MSG_NOTIFICATION) {\n\t\tmsg.msg_control = incmsg;\n\t\tmsg.msg_controllen = sizeof(incmsg);\n\n\t\tprocess_sctp_notification(con, &msg,\n\t\t\t\tpage_address(con->rx_page) + con->cb.base);\n\t\tmutex_unlock(&con->sock_mutex);\n\t\treturn 0;\n\t}\n\tBUG_ON(con->nodeid == 0);\n\n\tif (ret == len)\n\t\tcall_again_soon = 1;\n\tcbuf_add(&con->cb, ret);\n\tret = dlm_process_incoming_buffer(con->nodeid,\n\t\t\t\t\t  page_address(con->rx_page),\n\t\t\t\t\t  con->cb.base, con->cb.len,\n\t\t\t\t\t  PAGE_CACHE_SIZE);\n\tif (ret == -EBADMSG) {\n\t\tlog_print(\"lowcomms: addr=%p, base=%u, len=%u, \"\n\t\t\t  \"iov_len=%u, iov_base[0]=%p, read=%d\",\n\t\t\t  page_address(con->rx_page), con->cb.base, con->cb.len,\n\t\t\t  len, iov[0].iov_base, r);\n\t}\n\tif (ret < 0)\n\t\tgoto out_close;\n\tcbuf_eat(&con->cb, ret);\n\n\tif (cbuf_empty(&con->cb) && !call_again_soon) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tif (call_again_soon)\n\t\tgoto out_resched;\n\tmutex_unlock(&con->sock_mutex);\n\treturn 0;\n\nout_resched:\n\tif (!test_and_set_bit(CF_READ_PENDING, &con->flags))\n\t\tqueue_work(recv_workqueue, &con->rwork);\n\tmutex_unlock(&con->sock_mutex);\n\treturn -EAGAIN;\n\nout_close:\n\tmutex_unlock(&con->sock_mutex);\n\tif (ret != -EAGAIN) {\n\t\tclose_connection(con, false);\n\t\t/* Reconnect when there is something to send */\n\t}\n\t/* Don't return success if we really got EOF */\n\tif (ret == 0)\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "process_sctp_notification",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "653-784",
    "snippet": "static void process_sctp_notification(struct connection *con,\n\t\t\t\t      struct msghdr *msg, char *buf)\n{\n\tunion sctp_notification *sn = (union sctp_notification *)buf;\n\tstruct linger linger;\n\n\tswitch (sn->sn_header.sn_type) {\n\tcase SCTP_SEND_FAILED:\n\t\tretry_failed_sctp_send(con, &sn->sn_send_failed, buf);\n\t\tbreak;\n\tcase SCTP_ASSOC_CHANGE:\n\t\tswitch (sn->sn_assoc_change.sac_state) {\n\t\tcase SCTP_COMM_UP:\n\t\tcase SCTP_RESTART:\n\t\t{\n\t\t\t/* Check that the new node is in the lockspace */\n\t\t\tstruct sctp_prim prim;\n\t\t\tint nodeid;\n\t\t\tint prim_len, ret;\n\t\t\tint addr_len;\n\t\t\tstruct connection *new_con;\n\n\t\t\t/*\n\t\t\t * We get this before any data for an association.\n\t\t\t * We verify that the node is in the cluster and\n\t\t\t * then peel off a socket for it.\n\t\t\t */\n\t\t\tif ((int)sn->sn_assoc_change.sac_assoc_id <= 0) {\n\t\t\t\tlog_print(\"COMM_UP for invalid assoc ID %d\",\n\t\t\t\t\t (int)sn->sn_assoc_change.sac_assoc_id);\n\t\t\t\tsctp_init_failed();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmemset(&prim, 0, sizeof(struct sctp_prim));\n\t\t\tprim_len = sizeof(struct sctp_prim);\n\t\t\tprim.ssp_assoc_id = sn->sn_assoc_change.sac_assoc_id;\n\n\t\t\tret = kernel_getsockopt(con->sock,\n\t\t\t\t\t\tIPPROTO_SCTP,\n\t\t\t\t\t\tSCTP_PRIMARY_ADDR,\n\t\t\t\t\t\t(char*)&prim,\n\t\t\t\t\t\t&prim_len);\n\t\t\tif (ret < 0) {\n\t\t\t\tlog_print(\"getsockopt/sctp_primary_addr on \"\n\t\t\t\t\t  \"new assoc %d failed : %d\",\n\t\t\t\t\t  (int)sn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t\t  ret);\n\n\t\t\t\t/* Retry INIT later */\n\t\t\t\tnew_con = assoc2con(sn->sn_assoc_change.sac_assoc_id);\n\t\t\t\tif (new_con)\n\t\t\t\t\tclear_bit(CF_CONNECT_PENDING, &con->flags);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmake_sockaddr(&prim.ssp_addr, 0, &addr_len);\n\t\t\tif (addr_to_nodeid(&prim.ssp_addr, &nodeid)) {\n\t\t\t\tunsigned char *b=(unsigned char *)&prim.ssp_addr;\n\t\t\t\tlog_print(\"reject connect from unknown addr\");\n\t\t\t\tprint_hex_dump_bytes(\"ss: \", DUMP_PREFIX_NONE, \n\t\t\t\t\t\t     b, sizeof(struct sockaddr_storage));\n\t\t\t\tsctp_send_shutdown(prim.ssp_assoc_id);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnew_con = nodeid2con(nodeid, GFP_NOFS);\n\t\t\tif (!new_con)\n\t\t\t\treturn;\n\n\t\t\t/* Peel off a new sock */\n\t\t\tlock_sock(con->sock->sk);\n\t\t\tret = sctp_do_peeloff(con->sock->sk,\n\t\t\t\tsn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t&new_con->sock);\n\t\t\trelease_sock(con->sock->sk);\n\t\t\tif (ret < 0) {\n\t\t\t\tlog_print(\"Can't peel off a socket for \"\n\t\t\t\t\t  \"connection %d to node %d: err=%d\",\n\t\t\t\t\t  (int)sn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t\t  nodeid, ret);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tadd_sock(new_con->sock, new_con);\n\n\t\t\tlinger.l_onoff = 1;\n\t\t\tlinger.l_linger = 0;\n\t\t\tret = kernel_setsockopt(new_con->sock, SOL_SOCKET, SO_LINGER,\n\t\t\t\t\t\t(char *)&linger, sizeof(linger));\n\t\t\tif (ret < 0)\n\t\t\t\tlog_print(\"set socket option SO_LINGER failed\");\n\n\t\t\tlog_print(\"connecting to %d sctp association %d\",\n\t\t\t\t nodeid, (int)sn->sn_assoc_change.sac_assoc_id);\n\n\t\t\tnew_con->sctp_assoc = sn->sn_assoc_change.sac_assoc_id;\n\t\t\tnew_con->try_new_addr = false;\n\t\t\t/* Send any pending writes */\n\t\t\tclear_bit(CF_CONNECT_PENDING, &new_con->flags);\n\t\t\tclear_bit(CF_INIT_PENDING, &new_con->flags);\n\t\t\tif (!test_and_set_bit(CF_WRITE_PENDING, &new_con->flags)) {\n\t\t\t\tqueue_work(send_workqueue, &new_con->swork);\n\t\t\t}\n\t\t\tif (!test_and_set_bit(CF_READ_PENDING, &new_con->flags))\n\t\t\t\tqueue_work(recv_workqueue, &new_con->rwork);\n\t\t}\n\t\tbreak;\n\n\t\tcase SCTP_COMM_LOST:\n\t\tcase SCTP_SHUTDOWN_COMP:\n\t\t{\n\t\t\tcon = assoc2con(sn->sn_assoc_change.sac_assoc_id);\n\t\t\tif (con) {\n\t\t\t\tcon->sctp_assoc = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase SCTP_CANT_STR_ASSOC:\n\t\t{\n\t\t\t/* Will retry init when we get the send failed notification */\n\t\t\tlog_print(\"Can't start SCTP association - retrying\");\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tlog_print(\"unexpected SCTP assoc change id=%d state=%d\",\n\t\t\t\t  (int)sn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t  sn->sn_assoc_change.sac_state);\n\t\t}\n\tdefault:\n\t\t; /* fall through */\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_INIT_PENDING 4",
      "#define CF_CONNECT_PENDING 3",
      "#define CF_WRITE_PENDING 2",
      "#define CF_READ_PENDING 1"
    ],
    "globals_used": [
      "static struct workqueue_struct *recv_workqueue;",
      "static struct workqueue_struct *send_workqueue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"unexpected SCTP assoc change id=%d state=%d\"",
            "(int)sn->sn_assoc_change.sac_assoc_id",
            "sn->sn_assoc_change.sac_state"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Can't start SCTP association - retrying\""
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc2con",
          "args": [
            "sn->sn_assoc_change.sac_assoc_id"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "assoc2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "256-273",
          "snippet": "static struct connection *assoc2con(int assoc_id)\n{\n\tint i;\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\n\tfor (i = 0 ; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry(con, &connection_hash[i], list) {\n\t\t\tif (con->sctp_assoc == assoc_id) {\n\t\t\t\tmutex_unlock(&connections_lock);\n\t\t\t\treturn con;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&connections_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CONN_HASH_SIZE 32"
          ],
          "globals_used": [
            "static struct hlist_head connection_hash[CONN_HASH_SIZE];",
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CONN_HASH_SIZE 32\n\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *assoc2con(int assoc_id)\n{\n\tint i;\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\n\tfor (i = 0 ; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry(con, &connection_hash[i], list) {\n\t\t\tif (con->sctp_assoc == assoc_id) {\n\t\t\t\tmutex_unlock(&connections_lock);\n\t\t\t\treturn con;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&connections_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "recv_workqueue",
            "&new_con->rwork"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CF_READ_PENDING",
            "&new_con->flags"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CF_INIT_PENDING",
            "&new_con->flags"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"connecting to %d sctp association %d\"",
            "nodeid",
            "(int)sn->sn_assoc_change.sac_assoc_id"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"set socket option SO_LINGER failed\""
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "new_con->sock",
            "SOL_SOCKET",
            "SO_LINGER",
            "(char *)&linger",
            "sizeof(linger)"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_sock",
          "args": [
            "new_con->sock",
            "new_con"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "add_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "485-495",
          "snippet": "static void add_sock(struct socket *sock, struct connection *con)\n{\n\tcon->sock = sock;\n\n\t/* Install a data_ready callback */\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->sock->sk->sk_write_space = lowcomms_write_space;\n\tcon->sock->sk->sk_state_change = lowcomms_state_change;\n\tcon->sock->sk->sk_user_data = con;\n\tcon->sock->sk->sk_allocation = GFP_NOFS;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void add_sock(struct socket *sock, struct connection *con)\n{\n\tcon->sock = sock;\n\n\t/* Install a data_ready callback */\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->sock->sk->sk_write_space = lowcomms_write_space;\n\tcon->sock->sk->sk_state_change = lowcomms_state_change;\n\tcon->sock->sk->sk_user_data = con;\n\tcon->sock->sk->sk_allocation = GFP_NOFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Can't peel off a socket for \"\n\t\t\t\t\t  \"connection %d to node %d: err=%d\"",
            "(int)sn->sn_assoc_change.sac_assoc_id",
            "nodeid",
            "ret"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_sock",
          "args": [
            "con->sock->sk"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sctp_do_peeloff",
          "args": [
            "con->sock->sk",
            "sn->sn_assoc_change.sac_assoc_id",
            "&new_con->sock"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_sock",
          "args": [
            "con->sock->sk"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeid2con",
          "args": [
            "nodeid",
            "GFP_NOFS"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "244-253",
          "snippet": "static struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sctp_send_shutdown",
          "args": [
            "prim.ssp_assoc_id"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "sctp_send_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "539-572",
          "snippet": "static void sctp_send_shutdown(sctp_assoc_t associd)\n{\n\tstatic char outcmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\n\tstruct msghdr outmessage;\n\tstruct cmsghdr *cmsg;\n\tstruct sctp_sndrcvinfo *sinfo;\n\tint ret;\n\tstruct connection *con;\n\n\tcon = nodeid2con(0,0);\n\tBUG_ON(con == NULL);\n\n\toutmessage.msg_name = NULL;\n\toutmessage.msg_namelen = 0;\n\toutmessage.msg_control = outcmsg;\n\toutmessage.msg_controllen = sizeof(outcmsg);\n\toutmessage.msg_flags = MSG_EOR;\n\n\tcmsg = CMSG_FIRSTHDR(&outmessage);\n\tcmsg->cmsg_level = IPPROTO_SCTP;\n\tcmsg->cmsg_type = SCTP_SNDRCV;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));\n\toutmessage.msg_controllen = cmsg->cmsg_len;\n\tsinfo = CMSG_DATA(cmsg);\n\tmemset(sinfo, 0x00, sizeof(struct sctp_sndrcvinfo));\n\n\tsinfo->sinfo_flags |= MSG_EOF;\n\tsinfo->sinfo_assoc_id = associd;\n\n\tret = kernel_sendmsg(con->sock, &outmessage, NULL, 0, 0);\n\n\tif (ret != 0)\n\t\tlog_print(\"send EOF to node failed: %d\", ret);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void sctp_send_shutdown(sctp_assoc_t associd)\n{\n\tstatic char outcmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\n\tstruct msghdr outmessage;\n\tstruct cmsghdr *cmsg;\n\tstruct sctp_sndrcvinfo *sinfo;\n\tint ret;\n\tstruct connection *con;\n\n\tcon = nodeid2con(0,0);\n\tBUG_ON(con == NULL);\n\n\toutmessage.msg_name = NULL;\n\toutmessage.msg_namelen = 0;\n\toutmessage.msg_control = outcmsg;\n\toutmessage.msg_controllen = sizeof(outcmsg);\n\toutmessage.msg_flags = MSG_EOR;\n\n\tcmsg = CMSG_FIRSTHDR(&outmessage);\n\tcmsg->cmsg_level = IPPROTO_SCTP;\n\tcmsg->cmsg_type = SCTP_SNDRCV;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));\n\toutmessage.msg_controllen = cmsg->cmsg_len;\n\tsinfo = CMSG_DATA(cmsg);\n\tmemset(sinfo, 0x00, sizeof(struct sctp_sndrcvinfo));\n\n\tsinfo->sinfo_flags |= MSG_EOF;\n\tsinfo->sinfo_assoc_id = associd;\n\n\tret = kernel_sendmsg(con->sock, &outmessage, NULL, 0, 0);\n\n\tif (ret != 0)\n\t\tlog_print(\"send EOF to node failed: %d\", ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_hex_dump_bytes",
          "args": [
            "\"ss: \"",
            "DUMP_PREFIX_NONE",
            "b",
            "sizeof(struct sockaddr_storage)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"reject connect from unknown addr\""
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr_to_nodeid",
          "args": [
            "&prim.ssp_addr",
            "&nodeid"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "361-383",
          "snippet": "static int addr_to_nodeid(struct sockaddr_storage *addr, int *nodeid)\n{\n\tstruct dlm_node_addr *na;\n\tint rv = -EEXIST;\n\tint addr_i;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (!na->addr_count)\n\t\t\tcontinue;\n\n\t\tfor (addr_i = 0; addr_i < na->addr_count; addr_i++) {\n\t\t\tif (addr_compare(na->addr[addr_i], addr)) {\n\t\t\t\t*nodeid = na->nodeid;\n\t\t\t\trv = 0;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\nunlock:\n\tspin_unlock(&dlm_node_addrs_spin);\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dlm_node_addrs);",
            "static DEFINE_SPINLOCK(dlm_node_addrs_spin);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic LIST_HEAD(dlm_node_addrs);\nstatic DEFINE_SPINLOCK(dlm_node_addrs_spin);\n\nstatic int addr_to_nodeid(struct sockaddr_storage *addr, int *nodeid)\n{\n\tstruct dlm_node_addr *na;\n\tint rv = -EEXIST;\n\tint addr_i;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (!na->addr_count)\n\t\t\tcontinue;\n\n\t\tfor (addr_i = 0; addr_i < na->addr_count; addr_i++) {\n\t\t\tif (addr_compare(na->addr[addr_i], addr)) {\n\t\t\t\t*nodeid = na->nodeid;\n\t\t\t\trv = 0;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\nunlock:\n\tspin_unlock(&dlm_node_addrs_spin);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_sockaddr",
          "args": [
            "&prim.ssp_addr",
            "0",
            "&addr_len"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "make_sockaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "499-514",
          "snippet": "static void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\n\nstatic void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"getsockopt/sctp_primary_addr on \"\n\t\t\t\t\t  \"new assoc %d failed : %d\"",
            "(int)sn->sn_assoc_change.sac_assoc_id",
            "ret"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_getsockopt",
          "args": [
            "con->sock",
            "IPPROTO_SCTP",
            "SCTP_PRIMARY_ADDR",
            "(char*)&prim",
            "&prim_len"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&prim",
            "0",
            "sizeof(struct sctp_prim)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sctp_init_failed",
          "args": [],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "sctp_init_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "600-607",
          "snippet": "static void sctp_init_failed(void)\n{\n\tmutex_lock(&connections_lock);\n\n\tforeach_conn(sctp_init_failed_foreach);\n\n\tmutex_unlock(&connections_lock);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic void sctp_init_failed(void)\n{\n\tmutex_lock(&connections_lock);\n\n\tforeach_conn(sctp_init_failed_foreach);\n\n\tmutex_unlock(&connections_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"COMM_UP for invalid assoc ID %d\"",
            "(int)sn->sn_assoc_change.sac_assoc_id"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retry_failed_sctp_send",
          "args": [
            "con",
            "&sn->sn_send_failed",
            "buf"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "retry_failed_sctp_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "609-650",
          "snippet": "static void retry_failed_sctp_send(struct connection *recv_con,\n\t\t\t\t   struct sctp_send_failed *sn_send_failed,\n\t\t\t\t   char *buf)\n{\n\tint len = sn_send_failed->ssf_length - sizeof(struct sctp_send_failed);\n\tstruct dlm_mhandle *mh;\n\tstruct connection *con;\n\tchar *retry_buf;\n\tint nodeid = sn_send_failed->ssf_info.sinfo_ppid;\n\n\tlog_print(\"Retry sending %d bytes to node id %d\", len, nodeid);\n\t\n\tif (!nodeid) {\n\t\tlog_print(\"Shouldn't resend data via listening connection.\");\n\t\treturn;\n\t}\n\n\tcon = nodeid2con(nodeid, 0);\n\tif (!con) {\n\t\tlog_print(\"Could not look up con for nodeid %d\\n\",\n\t\t\t  nodeid);\n\t\treturn;\n\t}\n\n\tmh = dlm_lowcomms_get_buffer(nodeid, len, GFP_NOFS, &retry_buf);\n\tif (!mh) {\n\t\tlog_print(\"Could not allocate buf for retry.\");\n\t\treturn;\n\t}\n\tmemcpy(retry_buf, buf + sizeof(struct sctp_send_failed), len);\n\tdlm_lowcomms_commit_buffer(mh);\n\n\t/*\n\t * If we got a assoc changed event before the send failed event then\n\t * we only need to retry the send.\n\t */\n\tif (con->sctp_assoc) {\n\t\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\n\t\t\tqueue_work(send_workqueue, &con->swork);\n\t} else\n\t\tsctp_init_failed_foreach(con);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CF_WRITE_PENDING 2"
          ],
          "globals_used": [
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_WRITE_PENDING 2\n\nstatic struct workqueue_struct *send_workqueue;\n\nstatic void retry_failed_sctp_send(struct connection *recv_con,\n\t\t\t\t   struct sctp_send_failed *sn_send_failed,\n\t\t\t\t   char *buf)\n{\n\tint len = sn_send_failed->ssf_length - sizeof(struct sctp_send_failed);\n\tstruct dlm_mhandle *mh;\n\tstruct connection *con;\n\tchar *retry_buf;\n\tint nodeid = sn_send_failed->ssf_info.sinfo_ppid;\n\n\tlog_print(\"Retry sending %d bytes to node id %d\", len, nodeid);\n\t\n\tif (!nodeid) {\n\t\tlog_print(\"Shouldn't resend data via listening connection.\");\n\t\treturn;\n\t}\n\n\tcon = nodeid2con(nodeid, 0);\n\tif (!con) {\n\t\tlog_print(\"Could not look up con for nodeid %d\\n\",\n\t\t\t  nodeid);\n\t\treturn;\n\t}\n\n\tmh = dlm_lowcomms_get_buffer(nodeid, len, GFP_NOFS, &retry_buf);\n\tif (!mh) {\n\t\tlog_print(\"Could not allocate buf for retry.\");\n\t\treturn;\n\t}\n\tmemcpy(retry_buf, buf + sizeof(struct sctp_send_failed), len);\n\tdlm_lowcomms_commit_buffer(mh);\n\n\t/*\n\t * If we got a assoc changed event before the send failed event then\n\t * we only need to retry the send.\n\t */\n\tif (con->sctp_assoc) {\n\t\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\n\t\t\tqueue_work(send_workqueue, &con->swork);\n\t} else\n\t\tsctp_init_failed_foreach(con);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_INIT_PENDING 4\n#define CF_CONNECT_PENDING 3\n#define CF_WRITE_PENDING 2\n#define CF_READ_PENDING 1\n\nstatic struct workqueue_struct *recv_workqueue;\nstatic struct workqueue_struct *send_workqueue;\n\nstatic void process_sctp_notification(struct connection *con,\n\t\t\t\t      struct msghdr *msg, char *buf)\n{\n\tunion sctp_notification *sn = (union sctp_notification *)buf;\n\tstruct linger linger;\n\n\tswitch (sn->sn_header.sn_type) {\n\tcase SCTP_SEND_FAILED:\n\t\tretry_failed_sctp_send(con, &sn->sn_send_failed, buf);\n\t\tbreak;\n\tcase SCTP_ASSOC_CHANGE:\n\t\tswitch (sn->sn_assoc_change.sac_state) {\n\t\tcase SCTP_COMM_UP:\n\t\tcase SCTP_RESTART:\n\t\t{\n\t\t\t/* Check that the new node is in the lockspace */\n\t\t\tstruct sctp_prim prim;\n\t\t\tint nodeid;\n\t\t\tint prim_len, ret;\n\t\t\tint addr_len;\n\t\t\tstruct connection *new_con;\n\n\t\t\t/*\n\t\t\t * We get this before any data for an association.\n\t\t\t * We verify that the node is in the cluster and\n\t\t\t * then peel off a socket for it.\n\t\t\t */\n\t\t\tif ((int)sn->sn_assoc_change.sac_assoc_id <= 0) {\n\t\t\t\tlog_print(\"COMM_UP for invalid assoc ID %d\",\n\t\t\t\t\t (int)sn->sn_assoc_change.sac_assoc_id);\n\t\t\t\tsctp_init_failed();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmemset(&prim, 0, sizeof(struct sctp_prim));\n\t\t\tprim_len = sizeof(struct sctp_prim);\n\t\t\tprim.ssp_assoc_id = sn->sn_assoc_change.sac_assoc_id;\n\n\t\t\tret = kernel_getsockopt(con->sock,\n\t\t\t\t\t\tIPPROTO_SCTP,\n\t\t\t\t\t\tSCTP_PRIMARY_ADDR,\n\t\t\t\t\t\t(char*)&prim,\n\t\t\t\t\t\t&prim_len);\n\t\t\tif (ret < 0) {\n\t\t\t\tlog_print(\"getsockopt/sctp_primary_addr on \"\n\t\t\t\t\t  \"new assoc %d failed : %d\",\n\t\t\t\t\t  (int)sn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t\t  ret);\n\n\t\t\t\t/* Retry INIT later */\n\t\t\t\tnew_con = assoc2con(sn->sn_assoc_change.sac_assoc_id);\n\t\t\t\tif (new_con)\n\t\t\t\t\tclear_bit(CF_CONNECT_PENDING, &con->flags);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmake_sockaddr(&prim.ssp_addr, 0, &addr_len);\n\t\t\tif (addr_to_nodeid(&prim.ssp_addr, &nodeid)) {\n\t\t\t\tunsigned char *b=(unsigned char *)&prim.ssp_addr;\n\t\t\t\tlog_print(\"reject connect from unknown addr\");\n\t\t\t\tprint_hex_dump_bytes(\"ss: \", DUMP_PREFIX_NONE, \n\t\t\t\t\t\t     b, sizeof(struct sockaddr_storage));\n\t\t\t\tsctp_send_shutdown(prim.ssp_assoc_id);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnew_con = nodeid2con(nodeid, GFP_NOFS);\n\t\t\tif (!new_con)\n\t\t\t\treturn;\n\n\t\t\t/* Peel off a new sock */\n\t\t\tlock_sock(con->sock->sk);\n\t\t\tret = sctp_do_peeloff(con->sock->sk,\n\t\t\t\tsn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t&new_con->sock);\n\t\t\trelease_sock(con->sock->sk);\n\t\t\tif (ret < 0) {\n\t\t\t\tlog_print(\"Can't peel off a socket for \"\n\t\t\t\t\t  \"connection %d to node %d: err=%d\",\n\t\t\t\t\t  (int)sn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t\t  nodeid, ret);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tadd_sock(new_con->sock, new_con);\n\n\t\t\tlinger.l_onoff = 1;\n\t\t\tlinger.l_linger = 0;\n\t\t\tret = kernel_setsockopt(new_con->sock, SOL_SOCKET, SO_LINGER,\n\t\t\t\t\t\t(char *)&linger, sizeof(linger));\n\t\t\tif (ret < 0)\n\t\t\t\tlog_print(\"set socket option SO_LINGER failed\");\n\n\t\t\tlog_print(\"connecting to %d sctp association %d\",\n\t\t\t\t nodeid, (int)sn->sn_assoc_change.sac_assoc_id);\n\n\t\t\tnew_con->sctp_assoc = sn->sn_assoc_change.sac_assoc_id;\n\t\t\tnew_con->try_new_addr = false;\n\t\t\t/* Send any pending writes */\n\t\t\tclear_bit(CF_CONNECT_PENDING, &new_con->flags);\n\t\t\tclear_bit(CF_INIT_PENDING, &new_con->flags);\n\t\t\tif (!test_and_set_bit(CF_WRITE_PENDING, &new_con->flags)) {\n\t\t\t\tqueue_work(send_workqueue, &new_con->swork);\n\t\t\t}\n\t\t\tif (!test_and_set_bit(CF_READ_PENDING, &new_con->flags))\n\t\t\t\tqueue_work(recv_workqueue, &new_con->rwork);\n\t\t}\n\t\tbreak;\n\n\t\tcase SCTP_COMM_LOST:\n\t\tcase SCTP_SHUTDOWN_COMP:\n\t\t{\n\t\t\tcon = assoc2con(sn->sn_assoc_change.sac_assoc_id);\n\t\t\tif (con) {\n\t\t\t\tcon->sctp_assoc = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase SCTP_CANT_STR_ASSOC:\n\t\t{\n\t\t\t/* Will retry init when we get the send failed notification */\n\t\t\tlog_print(\"Can't start SCTP association - retrying\");\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tlog_print(\"unexpected SCTP assoc change id=%d state=%d\",\n\t\t\t\t  (int)sn->sn_assoc_change.sac_assoc_id,\n\t\t\t\t  sn->sn_assoc_change.sac_state);\n\t\t}\n\tdefault:\n\t\t; /* fall through */\n\t}\n}"
  },
  {
    "function_name": "retry_failed_sctp_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "609-650",
    "snippet": "static void retry_failed_sctp_send(struct connection *recv_con,\n\t\t\t\t   struct sctp_send_failed *sn_send_failed,\n\t\t\t\t   char *buf)\n{\n\tint len = sn_send_failed->ssf_length - sizeof(struct sctp_send_failed);\n\tstruct dlm_mhandle *mh;\n\tstruct connection *con;\n\tchar *retry_buf;\n\tint nodeid = sn_send_failed->ssf_info.sinfo_ppid;\n\n\tlog_print(\"Retry sending %d bytes to node id %d\", len, nodeid);\n\t\n\tif (!nodeid) {\n\t\tlog_print(\"Shouldn't resend data via listening connection.\");\n\t\treturn;\n\t}\n\n\tcon = nodeid2con(nodeid, 0);\n\tif (!con) {\n\t\tlog_print(\"Could not look up con for nodeid %d\\n\",\n\t\t\t  nodeid);\n\t\treturn;\n\t}\n\n\tmh = dlm_lowcomms_get_buffer(nodeid, len, GFP_NOFS, &retry_buf);\n\tif (!mh) {\n\t\tlog_print(\"Could not allocate buf for retry.\");\n\t\treturn;\n\t}\n\tmemcpy(retry_buf, buf + sizeof(struct sctp_send_failed), len);\n\tdlm_lowcomms_commit_buffer(mh);\n\n\t/*\n\t * If we got a assoc changed event before the send failed event then\n\t * we only need to retry the send.\n\t */\n\tif (con->sctp_assoc) {\n\t\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\n\t\t\tqueue_work(send_workqueue, &con->swork);\n\t} else\n\t\tsctp_init_failed_foreach(con);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_WRITE_PENDING 2"
    ],
    "globals_used": [
      "static struct workqueue_struct *send_workqueue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sctp_init_failed_foreach",
          "args": [
            "con"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "sctp_init_failed_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "574-596",
          "snippet": "static void sctp_init_failed_foreach(struct connection *con)\n{\n\n\t/*\n\t * Don't try to recover base con and handle race where the\n\t * other node's assoc init creates a assoc and we get that\n\t * notification, then we get a notification that our attempt\n\t * failed due. This happens when we are still trying the primary\n\t * address, but the other node has already tried secondary addrs\n\t * and found one that worked.\n\t */\n\tif (!con->nodeid || con->sctp_assoc)\n\t\treturn;\n\n\tlog_print(\"Retrying SCTP association init for node %d\\n\", con->nodeid);\n\n\tcon->try_new_addr = true;\n\tcon->sctp_assoc = 0;\n\tif (test_and_clear_bit(CF_INIT_PENDING, &con->flags)) {\n\t\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\n\t\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CF_INIT_PENDING 4",
            "#define CF_WRITE_PENDING 2"
          ],
          "globals_used": [
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_INIT_PENDING 4\n#define CF_WRITE_PENDING 2\n\nstatic struct workqueue_struct *send_workqueue;\n\nstatic void sctp_init_failed_foreach(struct connection *con)\n{\n\n\t/*\n\t * Don't try to recover base con and handle race where the\n\t * other node's assoc init creates a assoc and we get that\n\t * notification, then we get a notification that our attempt\n\t * failed due. This happens when we are still trying the primary\n\t * address, but the other node has already tried secondary addrs\n\t * and found one that worked.\n\t */\n\tif (!con->nodeid || con->sctp_assoc)\n\t\treturn;\n\n\tlog_print(\"Retrying SCTP association init for node %d\\n\", con->nodeid);\n\n\tcon->try_new_addr = true;\n\tcon->sctp_assoc = 0;\n\tif (test_and_clear_bit(CF_INIT_PENDING, &con->flags)) {\n\t\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\n\t\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "send_workqueue",
            "&con->swork"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CF_WRITE_PENDING",
            "&con->flags"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lowcomms_commit_buffer",
          "args": [
            "mh"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lowcomms_commit_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1531-1552",
          "snippet": "void dlm_lowcomms_commit_buffer(void *mh)\n{\n\tstruct writequeue_entry *e = (struct writequeue_entry *)mh;\n\tstruct connection *con = e->con;\n\tint users;\n\n\tspin_lock(&con->writequeue_lock);\n\tusers = --e->users;\n\tif (users)\n\t\tgoto out;\n\te->len = e->end - e->offset;\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags)) {\n\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n\treturn;\n\nout:\n\tspin_unlock(&con->writequeue_lock);\n\treturn;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CF_WRITE_PENDING 2"
          ],
          "globals_used": [
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_WRITE_PENDING 2\n\nstatic struct workqueue_struct *send_workqueue;\n\nvoid dlm_lowcomms_commit_buffer(void *mh)\n{\n\tstruct writequeue_entry *e = (struct writequeue_entry *)mh;\n\tstruct connection *con = e->con;\n\tint users;\n\n\tspin_lock(&con->writequeue_lock);\n\tusers = --e->users;\n\tif (users)\n\t\tgoto out;\n\te->len = e->end - e->offset;\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags)) {\n\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n\treturn;\n\nout:\n\tspin_unlock(&con->writequeue_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "retry_buf",
            "buf + sizeof(struct sctp_send_failed)",
            "len"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Could not allocate buf for retry.\""
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lowcomms_get_buffer",
          "args": [
            "nodeid",
            "len",
            "GFP_NOFS",
            "&retry_buf"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lowcomms_get_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1490-1529",
          "snippet": "void *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc)\n{\n\tstruct connection *con;\n\tstruct writequeue_entry *e;\n\tint offset = 0;\n\n\tcon = nodeid2con(nodeid, allocation);\n\tif (!con)\n\t\treturn NULL;\n\n\tspin_lock(&con->writequeue_lock);\n\te = list_entry(con->writequeue.prev, struct writequeue_entry, list);\n\tif ((&e->list == &con->writequeue) ||\n\t    (PAGE_CACHE_SIZE - e->end < len)) {\n\t\te = NULL;\n\t} else {\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t}\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (e) {\n\tgot_one:\n\t\t*ppc = page_address(e->page) + offset;\n\t\treturn e;\n\t}\n\n\te = new_writequeue_entry(con, allocation);\n\tif (e) {\n\t\tspin_lock(&con->writequeue_lock);\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t\tlist_add_tail(&e->list, &con->writequeue);\n\t\tspin_unlock(&con->writequeue_lock);\n\t\tgoto got_one;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nvoid *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc)\n{\n\tstruct connection *con;\n\tstruct writequeue_entry *e;\n\tint offset = 0;\n\n\tcon = nodeid2con(nodeid, allocation);\n\tif (!con)\n\t\treturn NULL;\n\n\tspin_lock(&con->writequeue_lock);\n\te = list_entry(con->writequeue.prev, struct writequeue_entry, list);\n\tif ((&e->list == &con->writequeue) ||\n\t    (PAGE_CACHE_SIZE - e->end < len)) {\n\t\te = NULL;\n\t} else {\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t}\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (e) {\n\tgot_one:\n\t\t*ppc = page_address(e->page) + offset;\n\t\treturn e;\n\t}\n\n\te = new_writequeue_entry(con, allocation);\n\tif (e) {\n\t\tspin_lock(&con->writequeue_lock);\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t\tlist_add_tail(&e->list, &con->writequeue);\n\t\tspin_unlock(&con->writequeue_lock);\n\t\tgoto got_one;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Could not look up con for nodeid %d\\n\"",
            "nodeid"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeid2con",
          "args": [
            "nodeid",
            "0"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "244-253",
          "snippet": "static struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Shouldn't resend data via listening connection.\""
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Retry sending %d bytes to node id %d\"",
            "len",
            "nodeid"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_WRITE_PENDING 2\n\nstatic struct workqueue_struct *send_workqueue;\n\nstatic void retry_failed_sctp_send(struct connection *recv_con,\n\t\t\t\t   struct sctp_send_failed *sn_send_failed,\n\t\t\t\t   char *buf)\n{\n\tint len = sn_send_failed->ssf_length - sizeof(struct sctp_send_failed);\n\tstruct dlm_mhandle *mh;\n\tstruct connection *con;\n\tchar *retry_buf;\n\tint nodeid = sn_send_failed->ssf_info.sinfo_ppid;\n\n\tlog_print(\"Retry sending %d bytes to node id %d\", len, nodeid);\n\t\n\tif (!nodeid) {\n\t\tlog_print(\"Shouldn't resend data via listening connection.\");\n\t\treturn;\n\t}\n\n\tcon = nodeid2con(nodeid, 0);\n\tif (!con) {\n\t\tlog_print(\"Could not look up con for nodeid %d\\n\",\n\t\t\t  nodeid);\n\t\treturn;\n\t}\n\n\tmh = dlm_lowcomms_get_buffer(nodeid, len, GFP_NOFS, &retry_buf);\n\tif (!mh) {\n\t\tlog_print(\"Could not allocate buf for retry.\");\n\t\treturn;\n\t}\n\tmemcpy(retry_buf, buf + sizeof(struct sctp_send_failed), len);\n\tdlm_lowcomms_commit_buffer(mh);\n\n\t/*\n\t * If we got a assoc changed event before the send failed event then\n\t * we only need to retry the send.\n\t */\n\tif (con->sctp_assoc) {\n\t\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\n\t\t\tqueue_work(send_workqueue, &con->swork);\n\t} else\n\t\tsctp_init_failed_foreach(con);\n}"
  },
  {
    "function_name": "sctp_init_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "600-607",
    "snippet": "static void sctp_init_failed(void)\n{\n\tmutex_lock(&connections_lock);\n\n\tforeach_conn(sctp_init_failed_foreach);\n\n\tmutex_unlock(&connections_lock);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(connections_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&connections_lock"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach_conn",
          "args": [
            "sctp_init_failed_foreach"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "foreach_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "232-242",
          "snippet": "static void foreach_conn(void (*conn_func)(struct connection *c))\n{\n\tint i;\n\tstruct hlist_node *n;\n\tstruct connection *con;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_safe(con, n, &connection_hash[i], list)\n\t\t\tconn_func(con);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CONN_HASH_SIZE 32"
          ],
          "globals_used": [
            "static struct hlist_head connection_hash[CONN_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CONN_HASH_SIZE 32\n\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\n\nstatic void foreach_conn(void (*conn_func)(struct connection *c))\n{\n\tint i;\n\tstruct hlist_node *n;\n\tstruct connection *con;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_safe(con, n, &connection_hash[i], list)\n\t\t\tconn_func(con);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&connections_lock"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic void sctp_init_failed(void)\n{\n\tmutex_lock(&connections_lock);\n\n\tforeach_conn(sctp_init_failed_foreach);\n\n\tmutex_unlock(&connections_lock);\n}"
  },
  {
    "function_name": "sctp_init_failed_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "574-596",
    "snippet": "static void sctp_init_failed_foreach(struct connection *con)\n{\n\n\t/*\n\t * Don't try to recover base con and handle race where the\n\t * other node's assoc init creates a assoc and we get that\n\t * notification, then we get a notification that our attempt\n\t * failed due. This happens when we are still trying the primary\n\t * address, but the other node has already tried secondary addrs\n\t * and found one that worked.\n\t */\n\tif (!con->nodeid || con->sctp_assoc)\n\t\treturn;\n\n\tlog_print(\"Retrying SCTP association init for node %d\\n\", con->nodeid);\n\n\tcon->try_new_addr = true;\n\tcon->sctp_assoc = 0;\n\tif (test_and_clear_bit(CF_INIT_PENDING, &con->flags)) {\n\t\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\n\t\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_INIT_PENDING 4",
      "#define CF_WRITE_PENDING 2"
    ],
    "globals_used": [
      "static struct workqueue_struct *send_workqueue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "send_workqueue",
            "&con->swork"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CF_WRITE_PENDING",
            "&con->flags"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "CF_INIT_PENDING",
            "&con->flags"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Retrying SCTP association init for node %d\\n\"",
            "con->nodeid"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_INIT_PENDING 4\n#define CF_WRITE_PENDING 2\n\nstatic struct workqueue_struct *send_workqueue;\n\nstatic void sctp_init_failed_foreach(struct connection *con)\n{\n\n\t/*\n\t * Don't try to recover base con and handle race where the\n\t * other node's assoc init creates a assoc and we get that\n\t * notification, then we get a notification that our attempt\n\t * failed due. This happens when we are still trying the primary\n\t * address, but the other node has already tried secondary addrs\n\t * and found one that worked.\n\t */\n\tif (!con->nodeid || con->sctp_assoc)\n\t\treturn;\n\n\tlog_print(\"Retrying SCTP association init for node %d\\n\", con->nodeid);\n\n\tcon->try_new_addr = true;\n\tcon->sctp_assoc = 0;\n\tif (test_and_clear_bit(CF_INIT_PENDING, &con->flags)) {\n\t\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\n\t\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n}"
  },
  {
    "function_name": "sctp_send_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "539-572",
    "snippet": "static void sctp_send_shutdown(sctp_assoc_t associd)\n{\n\tstatic char outcmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\n\tstruct msghdr outmessage;\n\tstruct cmsghdr *cmsg;\n\tstruct sctp_sndrcvinfo *sinfo;\n\tint ret;\n\tstruct connection *con;\n\n\tcon = nodeid2con(0,0);\n\tBUG_ON(con == NULL);\n\n\toutmessage.msg_name = NULL;\n\toutmessage.msg_namelen = 0;\n\toutmessage.msg_control = outcmsg;\n\toutmessage.msg_controllen = sizeof(outcmsg);\n\toutmessage.msg_flags = MSG_EOR;\n\n\tcmsg = CMSG_FIRSTHDR(&outmessage);\n\tcmsg->cmsg_level = IPPROTO_SCTP;\n\tcmsg->cmsg_type = SCTP_SNDRCV;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));\n\toutmessage.msg_controllen = cmsg->cmsg_len;\n\tsinfo = CMSG_DATA(cmsg);\n\tmemset(sinfo, 0x00, sizeof(struct sctp_sndrcvinfo));\n\n\tsinfo->sinfo_flags |= MSG_EOF;\n\tsinfo->sinfo_assoc_id = associd;\n\n\tret = kernel_sendmsg(con->sock, &outmessage, NULL, 0, 0);\n\n\tif (ret != 0)\n\t\tlog_print(\"send EOF to node failed: %d\", ret);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"send EOF to node failed: %d\"",
            "ret"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_sendmsg",
          "args": [
            "con->sock",
            "&outmessage",
            "NULL",
            "0",
            "0"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sinfo",
            "0x00",
            "sizeof(struct sctp_sndrcvinfo)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_DATA",
          "args": [
            "cmsg"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_LEN",
          "args": [
            "sizeof(struct sctp_sndrcvinfo)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_FIRSTHDR",
          "args": [
            "&outmessage"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "con == NULL"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeid2con",
          "args": [
            "0",
            "0"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "244-253",
          "snippet": "static struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "sizeof(struct sctp_sndrcvinfo)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void sctp_send_shutdown(sctp_assoc_t associd)\n{\n\tstatic char outcmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\n\tstruct msghdr outmessage;\n\tstruct cmsghdr *cmsg;\n\tstruct sctp_sndrcvinfo *sinfo;\n\tint ret;\n\tstruct connection *con;\n\n\tcon = nodeid2con(0,0);\n\tBUG_ON(con == NULL);\n\n\toutmessage.msg_name = NULL;\n\toutmessage.msg_namelen = 0;\n\toutmessage.msg_control = outcmsg;\n\toutmessage.msg_controllen = sizeof(outcmsg);\n\toutmessage.msg_flags = MSG_EOR;\n\n\tcmsg = CMSG_FIRSTHDR(&outmessage);\n\tcmsg->cmsg_level = IPPROTO_SCTP;\n\tcmsg->cmsg_type = SCTP_SNDRCV;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));\n\toutmessage.msg_controllen = cmsg->cmsg_len;\n\tsinfo = CMSG_DATA(cmsg);\n\tmemset(sinfo, 0x00, sizeof(struct sctp_sndrcvinfo));\n\n\tsinfo->sinfo_flags |= MSG_EOF;\n\tsinfo->sinfo_assoc_id = associd;\n\n\tret = kernel_sendmsg(con->sock, &outmessage, NULL, 0, 0);\n\n\tif (ret != 0)\n\t\tlog_print(\"send EOF to node failed: %d\", ret);\n}"
  },
  {
    "function_name": "close_connection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "517-536",
    "snippet": "static void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "con->rx_page"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_connection",
          "args": [
            "con->othercon",
            "false"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "close_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "517-536",
          "snippet": "static void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "con->sock"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void close_connection(struct connection *con, bool and_other)\n{\n\tmutex_lock(&con->sock_mutex);\n\n\tif (con->sock) {\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\tif (con->othercon && and_other) {\n\t\t/* Will only re-enter once. */\n\t\tclose_connection(con->othercon, false);\n\t}\n\tif (con->rx_page) {\n\t\t__free_page(con->rx_page);\n\t\tcon->rx_page = NULL;\n\t}\n\n\tcon->retries = 0;\n\tmutex_unlock(&con->sock_mutex);\n}"
  },
  {
    "function_name": "make_sockaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "499-514",
    "snippet": "static void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)saddr + *addr_len",
            "0",
            "sizeof(struct sockaddr_storage) - *addr_len"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "port"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&in4_addr->sin_zero",
            "0",
            "sizeof(in4_addr->sin_zero)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "port"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\n\nstatic void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0]->ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}"
  },
  {
    "function_name": "add_sock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "485-495",
    "snippet": "static void add_sock(struct socket *sock, struct connection *con)\n{\n\tcon->sock = sock;\n\n\t/* Install a data_ready callback */\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->sock->sk->sk_write_space = lowcomms_write_space;\n\tcon->sock->sk->sk_state_change = lowcomms_state_change;\n\tcon->sock->sk->sk_user_data = con;\n\tcon->sock->sk->sk_allocation = GFP_NOFS;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void add_sock(struct socket *sock, struct connection *con)\n{\n\tcon->sock = sock;\n\n\t/* Install a data_ready callback */\n\tcon->sock->sk->sk_data_ready = lowcomms_data_ready;\n\tcon->sock->sk->sk_write_space = lowcomms_write_space;\n\tcon->sock->sk->sk_state_change = lowcomms_state_change;\n\tcon->sock->sk->sk_user_data = con;\n\tcon->sock->sk->sk_allocation = GFP_NOFS;\n}"
  },
  {
    "function_name": "dlm_lowcomms_connect_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "466-482",
    "snippet": "int dlm_lowcomms_connect_node(int nodeid)\n{\n\tstruct connection *con;\n\n\t/* with sctp there's no connecting without sending */\n\tif (dlm_config.ci_protocol != 0)\n\t\treturn 0;\n\n\tif (nodeid == dlm_our_nodeid())\n\t\treturn 0;\n\n\tcon = nodeid2con(nodeid, GFP_NOFS);\n\tif (!con)\n\t\treturn -ENOMEM;\n\tlowcomms_connect_sock(con);\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lowcomms_connect_sock",
          "args": [
            "con"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "lowcomms_connect_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "452-458",
          "snippet": "static inline void lowcomms_connect_sock(struct connection *con)\n{\n\tif (test_bit(CF_CLOSE, &con->flags))\n\t\treturn;\n\tif (!test_and_set_bit(CF_CONNECT_PENDING, &con->flags))\n\t\tqueue_work(send_workqueue, &con->swork);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CF_CLOSE 6",
            "#define CF_CONNECT_PENDING 3"
          ],
          "globals_used": [
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_CLOSE 6\n#define CF_CONNECT_PENDING 3\n\nstatic struct workqueue_struct *send_workqueue;\n\nstatic inline void lowcomms_connect_sock(struct connection *con)\n{\n\tif (test_bit(CF_CLOSE, &con->flags))\n\t\treturn;\n\tif (!test_and_set_bit(CF_CONNECT_PENDING, &con->flags))\n\t\tqueue_work(send_workqueue, &con->swork);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeid2con",
          "args": [
            "nodeid",
            "GFP_NOFS"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "244-253",
          "snippet": "static struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(connections_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nint dlm_lowcomms_connect_node(int nodeid)\n{\n\tstruct connection *con;\n\n\t/* with sctp there's no connecting without sending */\n\tif (dlm_config.ci_protocol != 0)\n\t\treturn 0;\n\n\tif (nodeid == dlm_our_nodeid())\n\t\treturn 0;\n\n\tcon = nodeid2con(nodeid, GFP_NOFS);\n\tif (!con)\n\t\treturn -ENOMEM;\n\tlowcomms_connect_sock(con);\n\treturn 0;\n}"
  },
  {
    "function_name": "lowcomms_state_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "460-464",
    "snippet": "static void lowcomms_state_change(struct sock *sk)\n{\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tlowcomms_write_space(sk);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lowcomms_write_space",
          "args": [
            "sk"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "lowcomms_write_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "434-450",
          "snippet": "static void lowcomms_write_space(struct sock *sk)\n{\n\tstruct connection *con = sock2con(sk);\n\n\tif (!con)\n\t\treturn;\n\n\tclear_bit(SOCK_NOSPACE, &con->sock->flags);\n\n\tif (test_and_clear_bit(CF_APP_LIMITED, &con->flags)) {\n\t\tcon->sock->sk->sk_write_pending--;\n\t\tclear_bit(SOCK_ASYNC_NOSPACE, &con->sock->flags);\n\t}\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\n\t\tqueue_work(send_workqueue, &con->swork);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CF_APP_LIMITED 7",
            "#define CF_WRITE_PENDING 2"
          ],
          "globals_used": [
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_APP_LIMITED 7\n#define CF_WRITE_PENDING 2\n\nstatic struct workqueue_struct *send_workqueue;\n\nstatic void lowcomms_write_space(struct sock *sk)\n{\n\tstruct connection *con = sock2con(sk);\n\n\tif (!con)\n\t\treturn;\n\n\tclear_bit(SOCK_NOSPACE, &con->sock->flags);\n\n\tif (test_and_clear_bit(CF_APP_LIMITED, &con->flags)) {\n\t\tcon->sock->sk->sk_write_pending--;\n\t\tclear_bit(SOCK_ASYNC_NOSPACE, &con->sock->flags);\n\t}\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\n\t\tqueue_work(send_workqueue, &con->swork);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void lowcomms_state_change(struct sock *sk)\n{\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tlowcomms_write_space(sk);\n}"
  },
  {
    "function_name": "lowcomms_connect_sock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "452-458",
    "snippet": "static inline void lowcomms_connect_sock(struct connection *con)\n{\n\tif (test_bit(CF_CLOSE, &con->flags))\n\t\treturn;\n\tif (!test_and_set_bit(CF_CONNECT_PENDING, &con->flags))\n\t\tqueue_work(send_workqueue, &con->swork);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_CLOSE 6",
      "#define CF_CONNECT_PENDING 3"
    ],
    "globals_used": [
      "static struct workqueue_struct *send_workqueue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "send_workqueue",
            "&con->swork"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CF_CONNECT_PENDING",
            "&con->flags"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CF_CLOSE",
            "&con->flags"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_CLOSE 6\n#define CF_CONNECT_PENDING 3\n\nstatic struct workqueue_struct *send_workqueue;\n\nstatic inline void lowcomms_connect_sock(struct connection *con)\n{\n\tif (test_bit(CF_CLOSE, &con->flags))\n\t\treturn;\n\tif (!test_and_set_bit(CF_CONNECT_PENDING, &con->flags))\n\t\tqueue_work(send_workqueue, &con->swork);\n}"
  },
  {
    "function_name": "lowcomms_write_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "434-450",
    "snippet": "static void lowcomms_write_space(struct sock *sk)\n{\n\tstruct connection *con = sock2con(sk);\n\n\tif (!con)\n\t\treturn;\n\n\tclear_bit(SOCK_NOSPACE, &con->sock->flags);\n\n\tif (test_and_clear_bit(CF_APP_LIMITED, &con->flags)) {\n\t\tcon->sock->sk->sk_write_pending--;\n\t\tclear_bit(SOCK_ASYNC_NOSPACE, &con->sock->flags);\n\t}\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\n\t\tqueue_work(send_workqueue, &con->swork);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_APP_LIMITED 7",
      "#define CF_WRITE_PENDING 2"
    ],
    "globals_used": [
      "static struct workqueue_struct *send_workqueue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "send_workqueue",
            "&con->swork"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CF_WRITE_PENDING",
            "&con->flags"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "SOCK_ASYNC_NOSPACE",
            "&con->sock->flags"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "CF_APP_LIMITED",
            "&con->flags"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock2con",
          "args": [
            "sk"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_APP_LIMITED 7\n#define CF_WRITE_PENDING 2\n\nstatic struct workqueue_struct *send_workqueue;\n\nstatic void lowcomms_write_space(struct sock *sk)\n{\n\tstruct connection *con = sock2con(sk);\n\n\tif (!con)\n\t\treturn;\n\n\tclear_bit(SOCK_NOSPACE, &con->sock->flags);\n\n\tif (test_and_clear_bit(CF_APP_LIMITED, &con->flags)) {\n\t\tcon->sock->sk->sk_write_pending--;\n\t\tclear_bit(SOCK_ASYNC_NOSPACE, &con->sock->flags);\n\t}\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\n\t\tqueue_work(send_workqueue, &con->swork);\n}"
  },
  {
    "function_name": "lowcomms_data_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "427-432",
    "snippet": "static void lowcomms_data_ready(struct sock *sk)\n{\n\tstruct connection *con = sock2con(sk);\n\tif (con && !test_and_set_bit(CF_READ_PENDING, &con->flags))\n\t\tqueue_work(recv_workqueue, &con->rwork);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CF_READ_PENDING 1"
    ],
    "globals_used": [
      "static struct workqueue_struct *recv_workqueue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "recv_workqueue",
            "&con->rwork"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CF_READ_PENDING",
            "&con->flags"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock2con",
          "args": [
            "sk"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_READ_PENDING 1\n\nstatic struct workqueue_struct *recv_workqueue;\n\nstatic void lowcomms_data_ready(struct sock *sk)\n{\n\tstruct connection *con = sock2con(sk);\n\tif (con && !test_and_set_bit(CF_READ_PENDING, &con->flags))\n\t\tqueue_work(recv_workqueue, &con->rwork);\n}"
  },
  {
    "function_name": "dlm_lowcomms_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "385-424",
    "snippet": "int dlm_lowcomms_addr(int nodeid, struct sockaddr_storage *addr, int len)\n{\n\tstruct sockaddr_storage *new_addr;\n\tstruct dlm_node_addr *new_node, *na;\n\n\tnew_node = kzalloc(sizeof(struct dlm_node_addr), GFP_NOFS);\n\tif (!new_node)\n\t\treturn -ENOMEM;\n\n\tnew_addr = kzalloc(sizeof(struct sockaddr_storage), GFP_NOFS);\n\tif (!new_addr) {\n\t\tkfree(new_node);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(new_addr, addr, len);\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tna = find_node_addr(nodeid);\n\tif (!na) {\n\t\tnew_node->nodeid = nodeid;\n\t\tnew_node->addr[0] = new_addr;\n\t\tnew_node->addr_count = 1;\n\t\tlist_add(&new_node->list, &dlm_node_addrs);\n\t\tspin_unlock(&dlm_node_addrs_spin);\n\t\treturn 0;\n\t}\n\n\tif (na->addr_count >= DLM_MAX_ADDR_COUNT) {\n\t\tspin_unlock(&dlm_node_addrs_spin);\n\t\tkfree(new_addr);\n\t\tkfree(new_node);\n\t\treturn -ENOSPC;\n\t}\n\n\tna->addr[na->addr_count++] = new_addr;\n\tspin_unlock(&dlm_node_addrs_spin);\n\tkfree(new_node);\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(dlm_node_addrs);",
      "static DEFINE_SPINLOCK(dlm_node_addrs_spin);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_node"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_node_addrs_spin"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_node"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_addr"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_node->list",
            "&dlm_node_addrs"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_node_addr",
          "args": [
            "nodeid"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "find_node_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "275-284",
          "snippet": "static struct dlm_node_addr *find_node_addr(int nodeid)\n{\n\tstruct dlm_node_addr *na;\n\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (na->nodeid == nodeid)\n\t\t\treturn na;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dlm_node_addrs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic LIST_HEAD(dlm_node_addrs);\n\nstatic struct dlm_node_addr *find_node_addr(int nodeid)\n{\n\tstruct dlm_node_addr *na;\n\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (na->nodeid == nodeid)\n\t\t\treturn na;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_node_addrs_spin"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_addr",
            "addr",
            "len"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_node"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct sockaddr_storage)",
            "GFP_NOFS"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dlm_node_addr)",
            "GFP_NOFS"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic LIST_HEAD(dlm_node_addrs);\nstatic DEFINE_SPINLOCK(dlm_node_addrs_spin);\n\nint dlm_lowcomms_addr(int nodeid, struct sockaddr_storage *addr, int len)\n{\n\tstruct sockaddr_storage *new_addr;\n\tstruct dlm_node_addr *new_node, *na;\n\n\tnew_node = kzalloc(sizeof(struct dlm_node_addr), GFP_NOFS);\n\tif (!new_node)\n\t\treturn -ENOMEM;\n\n\tnew_addr = kzalloc(sizeof(struct sockaddr_storage), GFP_NOFS);\n\tif (!new_addr) {\n\t\tkfree(new_node);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(new_addr, addr, len);\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tna = find_node_addr(nodeid);\n\tif (!na) {\n\t\tnew_node->nodeid = nodeid;\n\t\tnew_node->addr[0] = new_addr;\n\t\tnew_node->addr_count = 1;\n\t\tlist_add(&new_node->list, &dlm_node_addrs);\n\t\tspin_unlock(&dlm_node_addrs_spin);\n\t\treturn 0;\n\t}\n\n\tif (na->addr_count >= DLM_MAX_ADDR_COUNT) {\n\t\tspin_unlock(&dlm_node_addrs_spin);\n\t\tkfree(new_addr);\n\t\tkfree(new_node);\n\t\treturn -ENOSPC;\n\t}\n\n\tna->addr[na->addr_count++] = new_addr;\n\tspin_unlock(&dlm_node_addrs_spin);\n\tkfree(new_node);\n\treturn 0;\n}"
  },
  {
    "function_name": "addr_to_nodeid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "361-383",
    "snippet": "static int addr_to_nodeid(struct sockaddr_storage *addr, int *nodeid)\n{\n\tstruct dlm_node_addr *na;\n\tint rv = -EEXIST;\n\tint addr_i;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (!na->addr_count)\n\t\t\tcontinue;\n\n\t\tfor (addr_i = 0; addr_i < na->addr_count; addr_i++) {\n\t\t\tif (addr_compare(na->addr[addr_i], addr)) {\n\t\t\t\t*nodeid = na->nodeid;\n\t\t\t\trv = 0;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\nunlock:\n\tspin_unlock(&dlm_node_addrs_spin);\n\treturn rv;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(dlm_node_addrs);",
      "static DEFINE_SPINLOCK(dlm_node_addrs_spin);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_node_addrs_spin"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_compare",
          "args": [
            "na->addr[addr_i]",
            "addr"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "addr_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "286-311",
          "snippet": "static int addr_compare(struct sockaddr_storage *x, struct sockaddr_storage *y)\n{\n\tswitch (x->ss_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *sinx = (struct sockaddr_in *)x;\n\t\tstruct sockaddr_in *siny = (struct sockaddr_in *)y;\n\t\tif (sinx->sin_addr.s_addr != siny->sin_addr.s_addr)\n\t\t\treturn 0;\n\t\tif (sinx->sin_port != siny->sin_port)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *sinx = (struct sockaddr_in6 *)x;\n\t\tstruct sockaddr_in6 *siny = (struct sockaddr_in6 *)y;\n\t\tif (!ipv6_addr_equal(&sinx->sin6_addr, &siny->sin6_addr))\n\t\t\treturn 0;\n\t\tif (sinx->sin6_port != siny->sin6_port)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic int addr_compare(struct sockaddr_storage *x, struct sockaddr_storage *y)\n{\n\tswitch (x->ss_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *sinx = (struct sockaddr_in *)x;\n\t\tstruct sockaddr_in *siny = (struct sockaddr_in *)y;\n\t\tif (sinx->sin_addr.s_addr != siny->sin_addr.s_addr)\n\t\t\treturn 0;\n\t\tif (sinx->sin_port != siny->sin_port)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *sinx = (struct sockaddr_in6 *)x;\n\t\tstruct sockaddr_in6 *siny = (struct sockaddr_in6 *)y;\n\t\tif (!ipv6_addr_equal(&sinx->sin6_addr, &siny->sin6_addr))\n\t\t\treturn 0;\n\t\tif (sinx->sin6_port != siny->sin6_port)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "na",
            "&dlm_node_addrs",
            "list"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_node_addrs_spin"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic LIST_HEAD(dlm_node_addrs);\nstatic DEFINE_SPINLOCK(dlm_node_addrs_spin);\n\nstatic int addr_to_nodeid(struct sockaddr_storage *addr, int *nodeid)\n{\n\tstruct dlm_node_addr *na;\n\tint rv = -EEXIST;\n\tint addr_i;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (!na->addr_count)\n\t\t\tcontinue;\n\n\t\tfor (addr_i = 0; addr_i < na->addr_count; addr_i++) {\n\t\t\tif (addr_compare(na->addr[addr_i], addr)) {\n\t\t\t\t*nodeid = na->nodeid;\n\t\t\t\trv = 0;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\nunlock:\n\tspin_unlock(&dlm_node_addrs_spin);\n\treturn rv;\n}"
  },
  {
    "function_name": "nodeid_to_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "313-359",
    "snippet": "static int nodeid_to_addr(int nodeid, struct sockaddr_storage *sas_out,\n\t\t\t  struct sockaddr *sa_out, bool try_new_addr)\n{\n\tstruct sockaddr_storage sas;\n\tstruct dlm_node_addr *na;\n\n\tif (!dlm_local_count)\n\t\treturn -1;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tna = find_node_addr(nodeid);\n\tif (na && na->addr_count) {\n\t\tif (try_new_addr) {\n\t\t\tna->curr_addr_index++;\n\t\t\tif (na->curr_addr_index == na->addr_count)\n\t\t\t\tna->curr_addr_index = 0;\n\t\t}\n\n\t\tmemcpy(&sas, na->addr[na->curr_addr_index ],\n\t\t\tsizeof(struct sockaddr_storage));\n\t}\n\tspin_unlock(&dlm_node_addrs_spin);\n\n\tif (!na)\n\t\treturn -EEXIST;\n\n\tif (!na->addr_count)\n\t\treturn -ENOENT;\n\n\tif (sas_out)\n\t\tmemcpy(sas_out, &sas, sizeof(struct sockaddr_storage));\n\n\tif (!sa_out)\n\t\treturn 0;\n\n\tif (dlm_local_addr[0]->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4  = (struct sockaddr_in *) &sas;\n\t\tstruct sockaddr_in *ret4 = (struct sockaddr_in *) sa_out;\n\t\tret4->sin_addr.s_addr = in4->sin_addr.s_addr;\n\t} else {\n\t\tstruct sockaddr_in6 *in6  = (struct sockaddr_in6 *) &sas;\n\t\tstruct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) sa_out;\n\t\tret6->sin6_addr = in6->sin6_addr;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(dlm_node_addrs_spin);",
      "static struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];",
      "static int dlm_local_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sas_out",
            "&sas",
            "sizeof(struct sockaddr_storage)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_node_addrs_spin"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&sas",
            "na->addr[na->curr_addr_index ]",
            "sizeof(struct sockaddr_storage)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_node_addr",
          "args": [
            "nodeid"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "find_node_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "275-284",
          "snippet": "static struct dlm_node_addr *find_node_addr(int nodeid)\n{\n\tstruct dlm_node_addr *na;\n\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (na->nodeid == nodeid)\n\t\t\treturn na;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dlm_node_addrs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic LIST_HEAD(dlm_node_addrs);\n\nstatic struct dlm_node_addr *find_node_addr(int nodeid)\n{\n\tstruct dlm_node_addr *na;\n\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (na->nodeid == nodeid)\n\t\t\treturn na;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_node_addrs_spin"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_SPINLOCK(dlm_node_addrs_spin);\nstatic struct sockaddr_storage *dlm_local_addr[DLM_MAX_ADDR_COUNT];\nstatic int dlm_local_count;\n\nstatic int nodeid_to_addr(int nodeid, struct sockaddr_storage *sas_out,\n\t\t\t  struct sockaddr *sa_out, bool try_new_addr)\n{\n\tstruct sockaddr_storage sas;\n\tstruct dlm_node_addr *na;\n\n\tif (!dlm_local_count)\n\t\treturn -1;\n\n\tspin_lock(&dlm_node_addrs_spin);\n\tna = find_node_addr(nodeid);\n\tif (na && na->addr_count) {\n\t\tif (try_new_addr) {\n\t\t\tna->curr_addr_index++;\n\t\t\tif (na->curr_addr_index == na->addr_count)\n\t\t\t\tna->curr_addr_index = 0;\n\t\t}\n\n\t\tmemcpy(&sas, na->addr[na->curr_addr_index ],\n\t\t\tsizeof(struct sockaddr_storage));\n\t}\n\tspin_unlock(&dlm_node_addrs_spin);\n\n\tif (!na)\n\t\treturn -EEXIST;\n\n\tif (!na->addr_count)\n\t\treturn -ENOENT;\n\n\tif (sas_out)\n\t\tmemcpy(sas_out, &sas, sizeof(struct sockaddr_storage));\n\n\tif (!sa_out)\n\t\treturn 0;\n\n\tif (dlm_local_addr[0]->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4  = (struct sockaddr_in *) &sas;\n\t\tstruct sockaddr_in *ret4 = (struct sockaddr_in *) sa_out;\n\t\tret4->sin_addr.s_addr = in4->sin_addr.s_addr;\n\t} else {\n\t\tstruct sockaddr_in6 *in6  = (struct sockaddr_in6 *) &sas;\n\t\tstruct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) sa_out;\n\t\tret6->sin6_addr = in6->sin6_addr;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "addr_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "286-311",
    "snippet": "static int addr_compare(struct sockaddr_storage *x, struct sockaddr_storage *y)\n{\n\tswitch (x->ss_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *sinx = (struct sockaddr_in *)x;\n\t\tstruct sockaddr_in *siny = (struct sockaddr_in *)y;\n\t\tif (sinx->sin_addr.s_addr != siny->sin_addr.s_addr)\n\t\t\treturn 0;\n\t\tif (sinx->sin_port != siny->sin_port)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *sinx = (struct sockaddr_in6 *)x;\n\t\tstruct sockaddr_in6 *siny = (struct sockaddr_in6 *)y;\n\t\tif (!ipv6_addr_equal(&sinx->sin6_addr, &siny->sin6_addr))\n\t\t\treturn 0;\n\t\tif (sinx->sin6_port != siny->sin6_port)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ipv6_addr_equal",
          "args": [
            "&sinx->sin6_addr",
            "&siny->sin6_addr"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic int addr_compare(struct sockaddr_storage *x, struct sockaddr_storage *y)\n{\n\tswitch (x->ss_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *sinx = (struct sockaddr_in *)x;\n\t\tstruct sockaddr_in *siny = (struct sockaddr_in *)y;\n\t\tif (sinx->sin_addr.s_addr != siny->sin_addr.s_addr)\n\t\t\treturn 0;\n\t\tif (sinx->sin_port != siny->sin_port)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *sinx = (struct sockaddr_in6 *)x;\n\t\tstruct sockaddr_in6 *siny = (struct sockaddr_in6 *)y;\n\t\tif (!ipv6_addr_equal(&sinx->sin6_addr, &siny->sin6_addr))\n\t\t\treturn 0;\n\t\tif (sinx->sin6_port != siny->sin6_port)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "find_node_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "275-284",
    "snippet": "static struct dlm_node_addr *find_node_addr(int nodeid)\n{\n\tstruct dlm_node_addr *na;\n\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (na->nodeid == nodeid)\n\t\t\treturn na;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(dlm_node_addrs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "na",
            "&dlm_node_addrs",
            "list"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic LIST_HEAD(dlm_node_addrs);\n\nstatic struct dlm_node_addr *find_node_addr(int nodeid)\n{\n\tstruct dlm_node_addr *na;\n\n\tlist_for_each_entry(na, &dlm_node_addrs, list) {\n\t\tif (na->nodeid == nodeid)\n\t\t\treturn na;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "assoc2con",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "256-273",
    "snippet": "static struct connection *assoc2con(int assoc_id)\n{\n\tint i;\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\n\tfor (i = 0 ; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry(con, &connection_hash[i], list) {\n\t\t\tif (con->sctp_assoc == assoc_id) {\n\t\t\t\tmutex_unlock(&connections_lock);\n\t\t\t\treturn con;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&connections_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CONN_HASH_SIZE 32"
    ],
    "globals_used": [
      "static struct hlist_head connection_hash[CONN_HASH_SIZE];",
      "static DEFINE_MUTEX(connections_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&connections_lock"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&connections_lock"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "con",
            "&connection_hash[i]",
            "list"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&connections_lock"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CONN_HASH_SIZE 32\n\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *assoc2con(int assoc_id)\n{\n\tint i;\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\n\tfor (i = 0 ; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry(con, &connection_hash[i], list) {\n\t\t\tif (con->sctp_assoc == assoc_id) {\n\t\t\t\tmutex_unlock(&connections_lock);\n\t\t\t\treturn con;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&connections_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "nodeid2con",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "244-253",
    "snippet": "static struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(connections_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&connections_lock"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nodeid2con",
          "args": [
            "nodeid",
            "allocation"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "__nodeid2con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "196-229",
          "snippet": "static struct connection *__nodeid2con(int nodeid, gfp_t alloc)\n{\n\tstruct connection *con = NULL;\n\tint r;\n\n\tcon = __find_con(nodeid);\n\tif (con || !alloc)\n\t\treturn con;\n\n\tcon = kmem_cache_zalloc(con_cache, alloc);\n\tif (!con)\n\t\treturn NULL;\n\n\tr = nodeid_hash(nodeid);\n\thlist_add_head(&con->list, &connection_hash[r]);\n\n\tcon->nodeid = nodeid;\n\tmutex_init(&con->sock_mutex);\n\tINIT_LIST_HEAD(&con->writequeue);\n\tspin_lock_init(&con->writequeue_lock);\n\tINIT_WORK(&con->swork, process_send_sockets);\n\tINIT_WORK(&con->rwork, process_recv_sockets);\n\n\t/* Setup action pointers for child sockets */\n\tif (con->nodeid) {\n\t\tstruct connection *zerocon = __find_con(0);\n\n\t\tcon->connect_action = zerocon->connect_action;\n\t\tif (!con->rx_action)\n\t\t\tcon->rx_action = zerocon->rx_action;\n\t}\n\n\treturn con;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head connection_hash[CONN_HASH_SIZE];",
            "static struct kmem_cache *con_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\nstatic struct kmem_cache *con_cache;\n\nstatic struct connection *__nodeid2con(int nodeid, gfp_t alloc)\n{\n\tstruct connection *con = NULL;\n\tint r;\n\n\tcon = __find_con(nodeid);\n\tif (con || !alloc)\n\t\treturn con;\n\n\tcon = kmem_cache_zalloc(con_cache, alloc);\n\tif (!con)\n\t\treturn NULL;\n\n\tr = nodeid_hash(nodeid);\n\thlist_add_head(&con->list, &connection_hash[r]);\n\n\tcon->nodeid = nodeid;\n\tmutex_init(&con->sock_mutex);\n\tINIT_LIST_HEAD(&con->writequeue);\n\tspin_lock_init(&con->writequeue_lock);\n\tINIT_WORK(&con->swork, process_send_sockets);\n\tINIT_WORK(&con->rwork, process_recv_sockets);\n\n\t/* Setup action pointers for child sockets */\n\tif (con->nodeid) {\n\t\tstruct connection *zerocon = __find_con(0);\n\n\t\tcon->connect_action = zerocon->connect_action;\n\t\tif (!con->rx_action)\n\t\t\tcon->rx_action = zerocon->rx_action;\n\t}\n\n\treturn con;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&connections_lock"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic DEFINE_MUTEX(connections_lock);\n\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\n{\n\tstruct connection *con;\n\n\tmutex_lock(&connections_lock);\n\tcon = __nodeid2con(nodeid, allocation);\n\tmutex_unlock(&connections_lock);\n\n\treturn con;\n}"
  },
  {
    "function_name": "foreach_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "232-242",
    "snippet": "static void foreach_conn(void (*conn_func)(struct connection *c))\n{\n\tint i;\n\tstruct hlist_node *n;\n\tstruct connection *con;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_safe(con, n, &connection_hash[i], list)\n\t\t\tconn_func(con);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CONN_HASH_SIZE 32"
    ],
    "globals_used": [
      "static struct hlist_head connection_hash[CONN_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "conn_func",
          "args": [
            "con"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "con",
            "n",
            "&connection_hash[i]",
            "list"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CONN_HASH_SIZE 32\n\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\n\nstatic void foreach_conn(void (*conn_func)(struct connection *c))\n{\n\tint i;\n\tstruct hlist_node *n;\n\tstruct connection *con;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_safe(con, n, &connection_hash[i], list)\n\t\t\tconn_func(con);\n\t}\n}"
  },
  {
    "function_name": "__nodeid2con",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "196-229",
    "snippet": "static struct connection *__nodeid2con(int nodeid, gfp_t alloc)\n{\n\tstruct connection *con = NULL;\n\tint r;\n\n\tcon = __find_con(nodeid);\n\tif (con || !alloc)\n\t\treturn con;\n\n\tcon = kmem_cache_zalloc(con_cache, alloc);\n\tif (!con)\n\t\treturn NULL;\n\n\tr = nodeid_hash(nodeid);\n\thlist_add_head(&con->list, &connection_hash[r]);\n\n\tcon->nodeid = nodeid;\n\tmutex_init(&con->sock_mutex);\n\tINIT_LIST_HEAD(&con->writequeue);\n\tspin_lock_init(&con->writequeue_lock);\n\tINIT_WORK(&con->swork, process_send_sockets);\n\tINIT_WORK(&con->rwork, process_recv_sockets);\n\n\t/* Setup action pointers for child sockets */\n\tif (con->nodeid) {\n\t\tstruct connection *zerocon = __find_con(0);\n\n\t\tcon->connect_action = zerocon->connect_action;\n\t\tif (!con->rx_action)\n\t\t\tcon->rx_action = zerocon->rx_action;\n\t}\n\n\treturn con;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head connection_hash[CONN_HASH_SIZE];",
      "static struct kmem_cache *con_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__find_con",
          "args": [
            "0"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__find_con",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "178-190",
          "snippet": "static struct connection *__find_con(int nodeid)\n{\n\tint r;\n\tstruct connection *con;\n\n\tr = nodeid_hash(nodeid);\n\n\thlist_for_each_entry(con, &connection_hash[r], list) {\n\t\tif (con->nodeid == nodeid)\n\t\t\treturn con;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head connection_hash[CONN_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\n\nstatic struct connection *__find_con(int nodeid)\n{\n\tint r;\n\tstruct connection *con;\n\n\tr = nodeid_hash(nodeid);\n\n\thlist_for_each_entry(con, &connection_hash[r], list) {\n\t\tif (con->nodeid == nodeid)\n\t\t\treturn con;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&con->rwork",
            "process_recv_sockets"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&con->swork",
            "process_send_sockets"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&con->writequeue_lock"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&con->writequeue"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&con->sock_mutex"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&con->list",
            "&connection_hash[r]"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeid_hash",
          "args": [
            "nodeid"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "173-176",
          "snippet": "static inline int nodeid_hash(int nodeid)\n{\n\treturn nodeid & (CONN_HASH_SIZE-1);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CONN_HASH_SIZE 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CONN_HASH_SIZE 32\n\nstatic inline int nodeid_hash(int nodeid)\n{\n\treturn nodeid & (CONN_HASH_SIZE-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "con_cache",
            "alloc"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\nstatic struct kmem_cache *con_cache;\n\nstatic struct connection *__nodeid2con(int nodeid, gfp_t alloc)\n{\n\tstruct connection *con = NULL;\n\tint r;\n\n\tcon = __find_con(nodeid);\n\tif (con || !alloc)\n\t\treturn con;\n\n\tcon = kmem_cache_zalloc(con_cache, alloc);\n\tif (!con)\n\t\treturn NULL;\n\n\tr = nodeid_hash(nodeid);\n\thlist_add_head(&con->list, &connection_hash[r]);\n\n\tcon->nodeid = nodeid;\n\tmutex_init(&con->sock_mutex);\n\tINIT_LIST_HEAD(&con->writequeue);\n\tspin_lock_init(&con->writequeue_lock);\n\tINIT_WORK(&con->swork, process_send_sockets);\n\tINIT_WORK(&con->rwork, process_recv_sockets);\n\n\t/* Setup action pointers for child sockets */\n\tif (con->nodeid) {\n\t\tstruct connection *zerocon = __find_con(0);\n\n\t\tcon->connect_action = zerocon->connect_action;\n\t\tif (!con->rx_action)\n\t\t\tcon->rx_action = zerocon->rx_action;\n\t}\n\n\treturn con;\n}"
  },
  {
    "function_name": "__find_con",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "178-190",
    "snippet": "static struct connection *__find_con(int nodeid)\n{\n\tint r;\n\tstruct connection *con;\n\n\tr = nodeid_hash(nodeid);\n\n\thlist_for_each_entry(con, &connection_hash[r], list) {\n\t\tif (con->nodeid == nodeid)\n\t\t\treturn con;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head connection_hash[CONN_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "con",
            "&connection_hash[r]",
            "list"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeid_hash",
          "args": [
            "nodeid"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "173-176",
          "snippet": "static inline int nodeid_hash(int nodeid)\n{\n\treturn nodeid & (CONN_HASH_SIZE-1);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CONN_HASH_SIZE 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CONN_HASH_SIZE 32\n\nstatic inline int nodeid_hash(int nodeid)\n{\n\treturn nodeid & (CONN_HASH_SIZE-1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\n\nstatic struct connection *__find_con(int nodeid)\n{\n\tint r;\n\tstruct connection *con;\n\n\tr = nodeid_hash(nodeid);\n\n\thlist_for_each_entry(con, &connection_hash[r], list) {\n\t\tif (con->nodeid == nodeid)\n\t\t\treturn con;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nodeid_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "173-176",
    "snippet": "static inline int nodeid_hash(int nodeid)\n{\n\treturn nodeid & (CONN_HASH_SIZE-1);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [
      "#define CONN_HASH_SIZE 32"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CONN_HASH_SIZE 32\n\nstatic inline int nodeid_hash(int nodeid)\n{\n\treturn nodeid & (CONN_HASH_SIZE-1);\n}"
  },
  {
    "function_name": "cbuf_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "98-101",
    "snippet": "static bool cbuf_empty(struct cbuf *cb)\n{\n\treturn cb->len == 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic bool cbuf_empty(struct cbuf *cb)\n{\n\treturn cb->len == 0;\n}"
  },
  {
    "function_name": "cbuf_eat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "91-96",
    "snippet": "static void cbuf_eat(struct cbuf *cb, int n)\n{\n\tcb->len  -= n;\n\tcb->base += n;\n\tcb->base &= cb->mask;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void cbuf_eat(struct cbuf *cb, int n)\n{\n\tcb->len  -= n;\n\tcb->base += n;\n\tcb->base &= cb->mask;\n}"
  },
  {
    "function_name": "cbuf_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "85-89",
    "snippet": "static void cbuf_init(struct cbuf *cb, int size)\n{\n\tcb->base = cb->len = 0;\n\tcb->mask = size-1;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void cbuf_init(struct cbuf *cb, int size)\n{\n\tcb->base = cb->len = 0;\n\tcb->mask = size-1;\n}"
  },
  {
    "function_name": "cbuf_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "80-83",
    "snippet": "static int cbuf_data(struct cbuf *cb)\n{\n\treturn ((cb->base + cb->len) & cb->mask);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic int cbuf_data(struct cbuf *cb)\n{\n\treturn ((cb->base + cb->len) & cb->mask);\n}"
  },
  {
    "function_name": "cbuf_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
    "lines": "75-78",
    "snippet": "static void cbuf_add(struct cbuf *cb, int n)\n{\n\tcb->len += n;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\"",
      "#include <net/ipv6.h>",
      "#include <net/sctp/sctp.h>",
      "#include <linux/slab.h>",
      "#include <linux/sctp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <net/tcp.h>",
      "#include <net/sock.h>",
      "#include <asm/ioctls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic void cbuf_add(struct cbuf *cb, int n)\n{\n\tcb->len += n;\n}"
  }
]