[
  {
    "function_name": "sysfs_rename_link_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
    "lines": "165-196",
    "snippet": "int sysfs_rename_link_ns(struct kobject *kobj, struct kobject *targ,\n\t\t\t const char *old, const char *new, const void *new_ns)\n{\n\tstruct kernfs_node *parent, *kn = NULL;\n\tconst void *old_ns = NULL;\n\tint result;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tif (targ->sd)\n\t\told_ns = targ->sd->ns;\n\n\tresult = -ENOENT;\n\tkn = kernfs_find_and_get_ns(parent, old, old_ns);\n\tif (!kn)\n\t\tgoto out;\n\n\tresult = -EINVAL;\n\tif (kernfs_type(kn) != KERNFS_LINK)\n\t\tgoto out;\n\tif (kn->symlink.target_kn->priv != targ)\n\t\tgoto out;\n\n\tresult = kernfs_rename_ns(kn, parent, new, new_ns);\n\nout:\n\tkernfs_put(kn);\n\treturn result;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/security.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_rename_ns",
          "args": [
            "kn",
            "parent",
            "new",
            "new_ns"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_rename_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1236-1302",
          "snippet": "int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,\n\t\t     const char *new_name, const void *new_ns)\n{\n\tstruct kernfs_node *old_parent;\n\tconst char *old_name = NULL;\n\tint error;\n\n\t/* can't move or rename root */\n\tif (!kn->parent)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kernfs_mutex);\n\n\terror = -ENOENT;\n\tif (!kernfs_active(kn) || !kernfs_active(new_parent))\n\t\tgoto out;\n\n\terror = 0;\n\tif ((kn->parent == new_parent) && (kn->ns == new_ns) &&\n\t    (strcmp(kn->name, new_name) == 0))\n\t\tgoto out;\t/* nothing to rename */\n\n\terror = -EEXIST;\n\tif (kernfs_find_ns(new_parent, new_name, new_ns))\n\t\tgoto out;\n\n\t/* rename kernfs_node */\n\tif (strcmp(kn->name, new_name) != 0) {\n\t\terror = -ENOMEM;\n\t\tnew_name = kstrdup_const(new_name, GFP_KERNEL);\n\t\tif (!new_name)\n\t\t\tgoto out;\n\t} else {\n\t\tnew_name = NULL;\n\t}\n\n\t/*\n\t * Move to the appropriate place in the appropriate directories rbtree.\n\t */\n\tkernfs_unlink_sibling(kn);\n\tkernfs_get(new_parent);\n\n\t/* rename_lock protects ->parent and ->name accessors */\n\tspin_lock_irq(&kernfs_rename_lock);\n\n\told_parent = kn->parent;\n\tkn->parent = new_parent;\n\n\tkn->ns = new_ns;\n\tif (new_name) {\n\t\told_name = kn->name;\n\t\tkn->name = new_name;\n\t}\n\n\tspin_unlock_irq(&kernfs_rename_lock);\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\tkernfs_link_sibling(kn);\n\n\tkernfs_put(old_parent);\n\tkfree_const(old_name);\n\n\terror = 0;\n out:\n\tmutex_unlock(&kernfs_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kernfs_rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\n\nint kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,\n\t\t     const char *new_name, const void *new_ns)\n{\n\tstruct kernfs_node *old_parent;\n\tconst char *old_name = NULL;\n\tint error;\n\n\t/* can't move or rename root */\n\tif (!kn->parent)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kernfs_mutex);\n\n\terror = -ENOENT;\n\tif (!kernfs_active(kn) || !kernfs_active(new_parent))\n\t\tgoto out;\n\n\terror = 0;\n\tif ((kn->parent == new_parent) && (kn->ns == new_ns) &&\n\t    (strcmp(kn->name, new_name) == 0))\n\t\tgoto out;\t/* nothing to rename */\n\n\terror = -EEXIST;\n\tif (kernfs_find_ns(new_parent, new_name, new_ns))\n\t\tgoto out;\n\n\t/* rename kernfs_node */\n\tif (strcmp(kn->name, new_name) != 0) {\n\t\terror = -ENOMEM;\n\t\tnew_name = kstrdup_const(new_name, GFP_KERNEL);\n\t\tif (!new_name)\n\t\t\tgoto out;\n\t} else {\n\t\tnew_name = NULL;\n\t}\n\n\t/*\n\t * Move to the appropriate place in the appropriate directories rbtree.\n\t */\n\tkernfs_unlink_sibling(kn);\n\tkernfs_get(new_parent);\n\n\t/* rename_lock protects ->parent and ->name accessors */\n\tspin_lock_irq(&kernfs_rename_lock);\n\n\told_parent = kn->parent;\n\tkn->parent = new_parent;\n\n\tkn->ns = new_ns;\n\tif (new_name) {\n\t\told_name = kn->name;\n\t\tkn->name = new_name;\n\t}\n\n\tspin_unlock_irq(&kernfs_rename_lock);\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\tkernfs_link_sibling(kn);\n\n\tkernfs_put(old_parent);\n\tkfree_const(old_name);\n\n\terror = 0;\n out:\n\tmutex_unlock(&kernfs_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get_ns",
          "args": [
            "parent",
            "old",
            "old_ns"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_find_and_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "674-685",
          "snippet": "struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,\n\t\t\t\t\t   const char *name, const void *ns)\n{\n\tstruct kernfs_node *kn;\n\n\tmutex_lock(&kernfs_mutex);\n\tkn = kernfs_find_ns(parent, name, ns);\n\tkernfs_get(kn);\n\tmutex_unlock(&kernfs_mutex);\n\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,\n\t\t\t\t\t   const char *name, const void *ns)\n{\n\tstruct kernfs_node *kn;\n\n\tmutex_lock(&kernfs_mutex);\n\tkn = kernfs_find_ns(parent, name, ns);\n\tkernfs_get(kn);\n\tmutex_unlock(&kernfs_mutex);\n\n\treturn kn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint sysfs_rename_link_ns(struct kobject *kobj, struct kobject *targ,\n\t\t\t const char *old, const char *new, const void *new_ns)\n{\n\tstruct kernfs_node *parent, *kn = NULL;\n\tconst void *old_ns = NULL;\n\tint result;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tif (targ->sd)\n\t\told_ns = targ->sd->ns;\n\n\tresult = -ENOENT;\n\tkn = kernfs_find_and_get_ns(parent, old, old_ns);\n\tif (!kn)\n\t\tgoto out;\n\n\tresult = -EINVAL;\n\tif (kernfs_type(kn) != KERNFS_LINK)\n\t\tgoto out;\n\tif (kn->symlink.target_kn->priv != targ)\n\t\tgoto out;\n\n\tresult = kernfs_rename_ns(kn, parent, new, new_ns);\n\nout:\n\tkernfs_put(kn);\n\treturn result;\n}"
  },
  {
    "function_name": "sysfs_remove_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
    "lines": "142-152",
    "snippet": "void sysfs_remove_link(struct kobject *kobj, const char *name)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tkernfs_remove_by_name(parent, name);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/security.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_remove_by_name",
          "args": [
            "parent",
            "name"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid sysfs_remove_link(struct kobject *kobj, const char *name)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tkernfs_remove_by_name(parent, name);\n}"
  },
  {
    "function_name": "sysfs_delete_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
    "lines": "120-135",
    "snippet": "void sysfs_delete_link(struct kobject *kobj, struct kobject *targ,\n\t\t\tconst char *name)\n{\n\tconst void *ns = NULL;\n\n\t/*\n\t * We don't own @target and it may be removed at any time.\n\t * Synchronize using sysfs_symlink_target_lock.  See\n\t * sysfs_remove_dir() for details.\n\t */\n\tspin_lock(&sysfs_symlink_target_lock);\n\tif (targ->sd && kernfs_ns_enabled(kobj->sd))\n\t\tns = targ->sd->ns;\n\tspin_unlock(&sysfs_symlink_target_lock);\n\tkernfs_remove_by_name_ns(kobj->sd, name, ns);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/security.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_remove_by_name_ns",
          "args": [
            "kobj->sd",
            "name",
            "ns"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_remove_by_name_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1204-1227",
          "snippet": "int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,\n\t\t\t     const void *ns)\n{\n\tstruct kernfs_node *kn;\n\n\tif (!parent) {\n\t\tWARN(1, KERN_WARNING \"kernfs: can not remove '%s', no directory\\n\",\n\t\t\tname);\n\t\treturn -ENOENT;\n\t}\n\n\tmutex_lock(&kernfs_mutex);\n\n\tkn = kernfs_find_ns(parent, name, ns);\n\tif (kn)\n\t\t__kernfs_remove(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\n\tif (kn)\n\t\treturn 0;\n\telse\n\t\treturn -ENOENT;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nint kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,\n\t\t\t     const void *ns)\n{\n\tstruct kernfs_node *kn;\n\n\tif (!parent) {\n\t\tWARN(1, KERN_WARNING \"kernfs: can not remove '%s', no directory\\n\",\n\t\t\tname);\n\t\treturn -ENOENT;\n\t}\n\n\tmutex_lock(&kernfs_mutex);\n\n\tkn = kernfs_find_ns(parent, name, ns);\n\tif (kn)\n\t\t__kernfs_remove(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\n\tif (kn)\n\t\treturn 0;\n\telse\n\t\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysfs_symlink_target_lock"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_ns_enabled",
          "args": [
            "kobj->sd"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysfs_symlink_target_lock"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid sysfs_delete_link(struct kobject *kobj, struct kobject *targ,\n\t\t\tconst char *name)\n{\n\tconst void *ns = NULL;\n\n\t/*\n\t * We don't own @target and it may be removed at any time.\n\t * Synchronize using sysfs_symlink_target_lock.  See\n\t * sysfs_remove_dir() for details.\n\t */\n\tspin_lock(&sysfs_symlink_target_lock);\n\tif (targ->sd && kernfs_ns_enabled(kobj->sd))\n\t\tns = targ->sd->ns;\n\tspin_unlock(&sysfs_symlink_target_lock);\n\tkernfs_remove_by_name_ns(kobj->sd, name, ns);\n}"
  },
  {
    "function_name": "sysfs_create_link_nowarn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
    "lines": "105-109",
    "snippet": "int sysfs_create_link_nowarn(struct kobject *kobj, struct kobject *target,\n\t\t\t     const char *name)\n{\n\treturn sysfs_do_create_link(kobj, target, name, 0);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/security.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_do_create_link",
          "args": [
            "kobj",
            "target",
            "name",
            "0"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_do_create_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
          "lines": "67-81",
          "snippet": "static int sysfs_do_create_link(struct kobject *kobj, struct kobject *target,\n\t\t\t\tconst char *name, int warn)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tif (!parent)\n\t\treturn -EFAULT;\n\n\treturn sysfs_do_create_link_sd(parent, target, name, warn);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int sysfs_do_create_link(struct kobject *kobj, struct kobject *target,\n\t\t\t\tconst char *name, int warn)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tif (!parent)\n\t\treturn -EFAULT;\n\n\treturn sysfs_do_create_link_sd(parent, target, name, warn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint sysfs_create_link_nowarn(struct kobject *kobj, struct kobject *target,\n\t\t\t     const char *name)\n{\n\treturn sysfs_do_create_link(kobj, target, name, 0);\n}"
  },
  {
    "function_name": "sysfs_create_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
    "lines": "89-93",
    "snippet": "int sysfs_create_link(struct kobject *kobj, struct kobject *target,\n\t\t      const char *name)\n{\n\treturn sysfs_do_create_link(kobj, target, name, 1);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/security.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_do_create_link",
          "args": [
            "kobj",
            "target",
            "name",
            "1"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_do_create_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
          "lines": "67-81",
          "snippet": "static int sysfs_do_create_link(struct kobject *kobj, struct kobject *target,\n\t\t\t\tconst char *name, int warn)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tif (!parent)\n\t\treturn -EFAULT;\n\n\treturn sysfs_do_create_link_sd(parent, target, name, warn);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int sysfs_do_create_link(struct kobject *kobj, struct kobject *target,\n\t\t\t\tconst char *name, int warn)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tif (!parent)\n\t\treturn -EFAULT;\n\n\treturn sysfs_do_create_link_sd(parent, target, name, warn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint sysfs_create_link(struct kobject *kobj, struct kobject *target,\n\t\t      const char *name)\n{\n\treturn sysfs_do_create_link(kobj, target, name, 1);\n}"
  },
  {
    "function_name": "sysfs_do_create_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
    "lines": "67-81",
    "snippet": "static int sysfs_do_create_link(struct kobject *kobj, struct kobject *target,\n\t\t\t\tconst char *name, int warn)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tif (!parent)\n\t\treturn -EFAULT;\n\n\treturn sysfs_do_create_link_sd(parent, target, name, warn);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/security.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_do_create_link_sd",
          "args": [
            "parent",
            "target",
            "name",
            "warn"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_do_create_link_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
          "lines": "21-53",
          "snippet": "static int sysfs_do_create_link_sd(struct kernfs_node *parent,\n\t\t\t\t   struct kobject *target_kobj,\n\t\t\t\t   const char *name, int warn)\n{\n\tstruct kernfs_node *kn, *target = NULL;\n\n\tBUG_ON(!name || !parent);\n\n\t/*\n\t * We don't own @target_kobj and it may be removed at any time.\n\t * Synchronize using sysfs_symlink_target_lock.  See\n\t * sysfs_remove_dir() for details.\n\t */\n\tspin_lock(&sysfs_symlink_target_lock);\n\tif (target_kobj->sd) {\n\t\ttarget = target_kobj->sd;\n\t\tkernfs_get(target);\n\t}\n\tspin_unlock(&sysfs_symlink_target_lock);\n\n\tif (!target)\n\t\treturn -ENOENT;\n\n\tkn = kernfs_create_link(parent, name, target);\n\tkernfs_put(target);\n\n\tif (!IS_ERR(kn))\n\t\treturn 0;\n\n\tif (warn && PTR_ERR(kn) == -EEXIST)\n\t\tsysfs_warn_dup(parent, name);\n\treturn PTR_ERR(kn);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int sysfs_do_create_link_sd(struct kernfs_node *parent,\n\t\t\t\t   struct kobject *target_kobj,\n\t\t\t\t   const char *name, int warn)\n{\n\tstruct kernfs_node *kn, *target = NULL;\n\n\tBUG_ON(!name || !parent);\n\n\t/*\n\t * We don't own @target_kobj and it may be removed at any time.\n\t * Synchronize using sysfs_symlink_target_lock.  See\n\t * sysfs_remove_dir() for details.\n\t */\n\tspin_lock(&sysfs_symlink_target_lock);\n\tif (target_kobj->sd) {\n\t\ttarget = target_kobj->sd;\n\t\tkernfs_get(target);\n\t}\n\tspin_unlock(&sysfs_symlink_target_lock);\n\n\tif (!target)\n\t\treturn -ENOENT;\n\n\tkn = kernfs_create_link(parent, name, target);\n\tkernfs_put(target);\n\n\tif (!IS_ERR(kn))\n\t\treturn 0;\n\n\tif (warn && PTR_ERR(kn) == -EEXIST)\n\t\tsysfs_warn_dup(parent, name);\n\treturn PTR_ERR(kn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int sysfs_do_create_link(struct kobject *kobj, struct kobject *target,\n\t\t\t\tconst char *name, int warn)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tif (!parent)\n\t\treturn -EFAULT;\n\n\treturn sysfs_do_create_link_sd(parent, target, name, warn);\n}"
  },
  {
    "function_name": "sysfs_create_link_sd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
    "lines": "61-65",
    "snippet": "int sysfs_create_link_sd(struct kernfs_node *kn, struct kobject *target,\n\t\t\t const char *name)\n{\n\treturn sysfs_do_create_link_sd(kn, target, name, 1);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/security.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_do_create_link_sd",
          "args": [
            "kn",
            "target",
            "name",
            "1"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_do_create_link_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
          "lines": "21-53",
          "snippet": "static int sysfs_do_create_link_sd(struct kernfs_node *parent,\n\t\t\t\t   struct kobject *target_kobj,\n\t\t\t\t   const char *name, int warn)\n{\n\tstruct kernfs_node *kn, *target = NULL;\n\n\tBUG_ON(!name || !parent);\n\n\t/*\n\t * We don't own @target_kobj and it may be removed at any time.\n\t * Synchronize using sysfs_symlink_target_lock.  See\n\t * sysfs_remove_dir() for details.\n\t */\n\tspin_lock(&sysfs_symlink_target_lock);\n\tif (target_kobj->sd) {\n\t\ttarget = target_kobj->sd;\n\t\tkernfs_get(target);\n\t}\n\tspin_unlock(&sysfs_symlink_target_lock);\n\n\tif (!target)\n\t\treturn -ENOENT;\n\n\tkn = kernfs_create_link(parent, name, target);\n\tkernfs_put(target);\n\n\tif (!IS_ERR(kn))\n\t\treturn 0;\n\n\tif (warn && PTR_ERR(kn) == -EEXIST)\n\t\tsysfs_warn_dup(parent, name);\n\treturn PTR_ERR(kn);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int sysfs_do_create_link_sd(struct kernfs_node *parent,\n\t\t\t\t   struct kobject *target_kobj,\n\t\t\t\t   const char *name, int warn)\n{\n\tstruct kernfs_node *kn, *target = NULL;\n\n\tBUG_ON(!name || !parent);\n\n\t/*\n\t * We don't own @target_kobj and it may be removed at any time.\n\t * Synchronize using sysfs_symlink_target_lock.  See\n\t * sysfs_remove_dir() for details.\n\t */\n\tspin_lock(&sysfs_symlink_target_lock);\n\tif (target_kobj->sd) {\n\t\ttarget = target_kobj->sd;\n\t\tkernfs_get(target);\n\t}\n\tspin_unlock(&sysfs_symlink_target_lock);\n\n\tif (!target)\n\t\treturn -ENOENT;\n\n\tkn = kernfs_create_link(parent, name, target);\n\tkernfs_put(target);\n\n\tif (!IS_ERR(kn))\n\t\treturn 0;\n\n\tif (warn && PTR_ERR(kn) == -EEXIST)\n\t\tsysfs_warn_dup(parent, name);\n\treturn PTR_ERR(kn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint sysfs_create_link_sd(struct kernfs_node *kn, struct kobject *target,\n\t\t\t const char *name)\n{\n\treturn sysfs_do_create_link_sd(kn, target, name, 1);\n}"
  },
  {
    "function_name": "sysfs_do_create_link_sd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
    "lines": "21-53",
    "snippet": "static int sysfs_do_create_link_sd(struct kernfs_node *parent,\n\t\t\t\t   struct kobject *target_kobj,\n\t\t\t\t   const char *name, int warn)\n{\n\tstruct kernfs_node *kn, *target = NULL;\n\n\tBUG_ON(!name || !parent);\n\n\t/*\n\t * We don't own @target_kobj and it may be removed at any time.\n\t * Synchronize using sysfs_symlink_target_lock.  See\n\t * sysfs_remove_dir() for details.\n\t */\n\tspin_lock(&sysfs_symlink_target_lock);\n\tif (target_kobj->sd) {\n\t\ttarget = target_kobj->sd;\n\t\tkernfs_get(target);\n\t}\n\tspin_unlock(&sysfs_symlink_target_lock);\n\n\tif (!target)\n\t\treturn -ENOENT;\n\n\tkn = kernfs_create_link(parent, name, target);\n\tkernfs_put(target);\n\n\tif (!IS_ERR(kn))\n\t\treturn 0;\n\n\tif (warn && PTR_ERR(kn) == -EEXIST)\n\t\tsysfs_warn_dup(parent, name);\n\treturn PTR_ERR(kn);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/security.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kobject.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kn"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_warn_dup",
          "args": [
            "parent",
            "name"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_warn_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/dir.c",
          "lines": "22-34",
          "snippet": "void sysfs_warn_dup(struct kernfs_node *parent, const char *name)\n{\n\tchar *buf, *path = NULL;\n\n\tbuf = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (buf)\n\t\tpath = kernfs_path(parent, buf, PATH_MAX);\n\n\tWARN(1, KERN_WARNING \"sysfs: cannot create duplicate filename '%s/%s'\\n\",\n\t     path, name);\n\n\tkfree(buf);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/slab.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nvoid sysfs_warn_dup(struct kernfs_node *parent, const char *name)\n{\n\tchar *buf, *path = NULL;\n\n\tbuf = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (buf)\n\t\tpath = kernfs_path(parent, buf, PATH_MAX);\n\n\tWARN(1, KERN_WARNING \"sysfs: cannot create duplicate filename '%s/%s'\\n\",\n\t     path, name);\n\n\tkfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kn"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kn"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "target"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_create_link",
          "args": [
            "parent",
            "name",
            "target"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_create_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/symlink.c",
          "lines": "25-47",
          "snippet": "struct kernfs_node *kernfs_create_link(struct kernfs_node *parent,\n\t\t\t\t       const char *name,\n\t\t\t\t       struct kernfs_node *target)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\n\tkn = kernfs_new_node(parent, name, S_IFLNK|S_IRWXUGO, KERNFS_LINK);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (kernfs_ns_enabled(parent))\n\t\tkn->ns = target->ns;\n\tkn->symlink.target_kn = target;\n\tkernfs_get(target);\t/* ref owned by symlink */\n\n\terror = kernfs_add_one(kn);\n\tif (!error)\n\t\treturn kn;\n\n\tkernfs_put(kn);\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/namei.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstruct kernfs_node *kernfs_create_link(struct kernfs_node *parent,\n\t\t\t\t       const char *name,\n\t\t\t\t       struct kernfs_node *target)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\n\tkn = kernfs_new_node(parent, name, S_IFLNK|S_IRWXUGO, KERNFS_LINK);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (kernfs_ns_enabled(parent))\n\t\tkn->ns = target->ns;\n\tkn->symlink.target_kn = target;\n\tkernfs_get(target);\t/* ref owned by symlink */\n\n\terror = kernfs_add_one(kn);\n\tif (!error)\n\t\treturn kn;\n\n\tkernfs_put(kn);\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysfs_symlink_target_lock"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "target"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysfs_symlink_target_lock"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!name || !parent"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int sysfs_do_create_link_sd(struct kernfs_node *parent,\n\t\t\t\t   struct kobject *target_kobj,\n\t\t\t\t   const char *name, int warn)\n{\n\tstruct kernfs_node *kn, *target = NULL;\n\n\tBUG_ON(!name || !parent);\n\n\t/*\n\t * We don't own @target_kobj and it may be removed at any time.\n\t * Synchronize using sysfs_symlink_target_lock.  See\n\t * sysfs_remove_dir() for details.\n\t */\n\tspin_lock(&sysfs_symlink_target_lock);\n\tif (target_kobj->sd) {\n\t\ttarget = target_kobj->sd;\n\t\tkernfs_get(target);\n\t}\n\tspin_unlock(&sysfs_symlink_target_lock);\n\n\tif (!target)\n\t\treturn -ENOENT;\n\n\tkn = kernfs_create_link(parent, name, target);\n\tkernfs_put(target);\n\n\tif (!IS_ERR(kn))\n\t\treturn 0;\n\n\tif (warn && PTR_ERR(kn) == -EEXIST)\n\t\tsysfs_warn_dup(parent, name);\n\treturn PTR_ERR(kn);\n}"
  }
]