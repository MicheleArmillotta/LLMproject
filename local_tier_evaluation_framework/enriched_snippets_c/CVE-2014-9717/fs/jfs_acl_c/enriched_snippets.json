[
  {
    "function_name": "jfs_init_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/acl.c",
    "lines": "137-161",
    "snippet": "int jfs_init_acl(tid_t tid, struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint rc = 0;\n\n\trc = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (rc)\n\t\treturn rc;\n\n\tif (default_acl) {\n\t\trc = __jfs_set_acl(tid, inode, ACL_TYPE_DEFAULT, default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!rc)\n\t\t\trc = __jfs_set_acl(tid, inode, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\n\tJFS_IP(inode)->mode2 = (JFS_IP(inode)->mode2 & 0xffff0000) |\n\t\t\t       inode->i_mode;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__jfs_set_acl",
          "args": [
            "tid",
            "inode",
            "ACL_TYPE_ACCESS",
            "acl"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "__jfs_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/acl.c",
          "lines": "75-120",
          "snippet": "static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_incore.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_create",
          "args": [
            "dir",
            "&inode->i_mode",
            "&default_acl",
            "&acl"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "545-598",
          "snippet": "int\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_incore.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint jfs_init_acl(tid_t tid, struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint rc = 0;\n\n\trc = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (rc)\n\t\treturn rc;\n\n\tif (default_acl) {\n\t\trc = __jfs_set_acl(tid, inode, ACL_TYPE_DEFAULT, default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!rc)\n\t\t\trc = __jfs_set_acl(tid, inode, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\n\tJFS_IP(inode)->mode2 = (JFS_IP(inode)->mode2 & 0xffff0000) |\n\t\t\t       inode->i_mode;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/acl.c",
    "lines": "122-135",
    "snippet": "int jfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc;\n\ttid_t tid;\n\n\ttid = txBegin(inode->i_sb, 0);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\trc = __jfs_set_acl(tid, inode, type, acl);\n\tif (!rc)\n\t\trc = txCommit(tid, 1, &inode, 0);\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(inode)->commit_mutex"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&inode",
            "0"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jfs_set_acl",
          "args": [
            "tid",
            "inode",
            "type",
            "acl"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "__jfs_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/acl.c",
          "lines": "75-120",
          "snippet": "static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_incore.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&JFS_IP(inode)->commit_mutex"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "inode->i_sb",
            "0"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_incore.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint jfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc;\n\ttid_t tid;\n\n\ttid = txBegin(inode->i_sb, 0);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\trc = __jfs_set_acl(tid, inode, type, acl);\n\tif (!rc)\n\t\trc = txCommit(tid, 1, &inode, 0);\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "__jfs_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/acl.c",
    "lines": "75-120",
    "snippet": "static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__jfs_setxattr",
          "args": [
            "tid",
            "inode",
            "ea_name",
            "value",
            "size",
            "0"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "__jfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "697-847",
          "snippet": "int __jfs_setxattr(tid_t tid, struct inode *inode, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea, *old_ea = NULL, *next_ea = NULL;\n\tstruct ea_buffer ea_buf;\n\tint old_ea_size = 0;\n\tint xattr_size;\n\tint new_size;\n\tint namelen = strlen(name);\n\tchar *os2name = NULL;\n\tint found = 0;\n\tint rc;\n\tint length;\n\n\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n\t\tos2name = kmalloc(namelen - XATTR_OS2_PREFIX_LEN + 1,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!os2name)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(os2name, name + XATTR_OS2_PREFIX_LEN);\n\t\tname = os2name;\n\t\tnamelen -= XATTR_OS2_PREFIX_LEN;\n\t}\n\n\tdown_write(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\trc = xattr_size;\n\t\tgoto out;\n\t}\n\n      again:\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\tnew_size = sizeof (struct jfs_ea_list);\n\n\tif (xattr_size) {\n\t\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist);\n\t\t     ea = NEXT_EA(ea)) {\n\t\t\tif ((namelen == ea->namelen) &&\n\t\t\t    (memcmp(name, ea->name, namelen) == 0)) {\n\t\t\t\tfound = 1;\n\t\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\told_ea = ea;\n\t\t\t\told_ea_size = EA_SIZE(ea);\n\t\t\t\tnext_ea = NEXT_EA(ea);\n\t\t\t} else\n\t\t\t\tnew_size += EA_SIZE(ea);\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\trc = -ENODATA;\n\t\t\tgoto release;\n\t\t}\n\t\tif (value == NULL) {\n\t\t\trc = 0;\n\t\t\tgoto release;\n\t\t}\n\t}\n\tif (value)\n\t\tnew_size += sizeof (struct jfs_ea) + namelen + 1 + value_len;\n\n\tif (new_size > ea_buf.max_size) {\n\t\t/*\n\t\t * We need to allocate more space for merged ea list.\n\t\t * We should only have loop to again: once.\n\t\t */\n\t\tea_release(inode, &ea_buf);\n\t\txattr_size = ea_get(inode, &ea_buf, new_size);\n\t\tif (xattr_size < 0) {\n\t\t\trc = xattr_size;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\n\t/* Remove old ea of the same name */\n\tif (found) {\n\t\t/* number of bytes following target EA */\n\t\tlength = (char *) END_EALIST(ealist) - (char *) next_ea;\n\t\tif (length > 0)\n\t\t\tmemmove(old_ea, next_ea, length);\n\t\txattr_size -= old_ea_size;\n\t}\n\n\t/* Add new entry to the end */\n\tif (value) {\n\t\tif (xattr_size == 0)\n\t\t\t/* Completely new ea list */\n\t\t\txattr_size = sizeof (struct jfs_ea_list);\n\n\t\t/*\n\t\t * The size of EA value is limitted by on-disk format up to\n\t\t *  __le16, there would be an overflow if the size is equal\n\t\t * to XATTR_SIZE_MAX (65536).  In order to avoid this issue,\n\t\t * we can pre-checkup the value size against USHRT_MAX, and\n\t\t * return -E2BIG in this case, which is consistent with the\n\t\t * VFS setxattr interface.\n\t\t */\n\t\tif (value_len >= USHRT_MAX) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto release;\n\t\t}\n\n\t\tea = (struct jfs_ea *) ((char *) ealist + xattr_size);\n\t\tea->flag = 0;\n\t\tea->namelen = namelen;\n\t\tea->valuelen = (cpu_to_le16(value_len));\n\t\tmemcpy(ea->name, name, namelen);\n\t\tea->name[namelen] = 0;\n\t\tif (value_len)\n\t\t\tmemcpy(&ea->name[namelen + 1], value, value_len);\n\t\txattr_size += EA_SIZE(ea);\n\t}\n\n\t/* DEBUG - If we did this right, these number match */\n\tif (xattr_size != new_size) {\n\t\tprintk(KERN_ERR\n\t\t       \"__jfs_setxattr: xattr_size = %d, new_size = %d\\n\",\n\t\t       xattr_size, new_size);\n\n\t\trc = -EINVAL;\n\t\tgoto release;\n\t}\n\n\t/*\n\t * If we're left with an empty list, there's no ea\n\t */\n\tif (new_size == sizeof (struct jfs_ea_list))\n\t\tnew_size = 0;\n\n\tealist->size = cpu_to_le32(new_size);\n\n\trc = ea_put(tid, inode, &ea_buf, new_size);\n\n\tgoto out;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_write(&JFS_IP(inode)->xattr_sem);\n\n\tkfree(os2name);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nint __jfs_setxattr(tid_t tid, struct inode *inode, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea, *old_ea = NULL, *next_ea = NULL;\n\tstruct ea_buffer ea_buf;\n\tint old_ea_size = 0;\n\tint xattr_size;\n\tint new_size;\n\tint namelen = strlen(name);\n\tchar *os2name = NULL;\n\tint found = 0;\n\tint rc;\n\tint length;\n\n\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n\t\tos2name = kmalloc(namelen - XATTR_OS2_PREFIX_LEN + 1,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!os2name)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(os2name, name + XATTR_OS2_PREFIX_LEN);\n\t\tname = os2name;\n\t\tnamelen -= XATTR_OS2_PREFIX_LEN;\n\t}\n\n\tdown_write(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\trc = xattr_size;\n\t\tgoto out;\n\t}\n\n      again:\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\tnew_size = sizeof (struct jfs_ea_list);\n\n\tif (xattr_size) {\n\t\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist);\n\t\t     ea = NEXT_EA(ea)) {\n\t\t\tif ((namelen == ea->namelen) &&\n\t\t\t    (memcmp(name, ea->name, namelen) == 0)) {\n\t\t\t\tfound = 1;\n\t\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\told_ea = ea;\n\t\t\t\told_ea_size = EA_SIZE(ea);\n\t\t\t\tnext_ea = NEXT_EA(ea);\n\t\t\t} else\n\t\t\t\tnew_size += EA_SIZE(ea);\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\trc = -ENODATA;\n\t\t\tgoto release;\n\t\t}\n\t\tif (value == NULL) {\n\t\t\trc = 0;\n\t\t\tgoto release;\n\t\t}\n\t}\n\tif (value)\n\t\tnew_size += sizeof (struct jfs_ea) + namelen + 1 + value_len;\n\n\tif (new_size > ea_buf.max_size) {\n\t\t/*\n\t\t * We need to allocate more space for merged ea list.\n\t\t * We should only have loop to again: once.\n\t\t */\n\t\tea_release(inode, &ea_buf);\n\t\txattr_size = ea_get(inode, &ea_buf, new_size);\n\t\tif (xattr_size < 0) {\n\t\t\trc = xattr_size;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\n\t/* Remove old ea of the same name */\n\tif (found) {\n\t\t/* number of bytes following target EA */\n\t\tlength = (char *) END_EALIST(ealist) - (char *) next_ea;\n\t\tif (length > 0)\n\t\t\tmemmove(old_ea, next_ea, length);\n\t\txattr_size -= old_ea_size;\n\t}\n\n\t/* Add new entry to the end */\n\tif (value) {\n\t\tif (xattr_size == 0)\n\t\t\t/* Completely new ea list */\n\t\t\txattr_size = sizeof (struct jfs_ea_list);\n\n\t\t/*\n\t\t * The size of EA value is limitted by on-disk format up to\n\t\t *  __le16, there would be an overflow if the size is equal\n\t\t * to XATTR_SIZE_MAX (65536).  In order to avoid this issue,\n\t\t * we can pre-checkup the value size against USHRT_MAX, and\n\t\t * return -E2BIG in this case, which is consistent with the\n\t\t * VFS setxattr interface.\n\t\t */\n\t\tif (value_len >= USHRT_MAX) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto release;\n\t\t}\n\n\t\tea = (struct jfs_ea *) ((char *) ealist + xattr_size);\n\t\tea->flag = 0;\n\t\tea->namelen = namelen;\n\t\tea->valuelen = (cpu_to_le16(value_len));\n\t\tmemcpy(ea->name, name, namelen);\n\t\tea->name[namelen] = 0;\n\t\tif (value_len)\n\t\t\tmemcpy(&ea->name[namelen + 1], value, value_len);\n\t\txattr_size += EA_SIZE(ea);\n\t}\n\n\t/* DEBUG - If we did this right, these number match */\n\tif (xattr_size != new_size) {\n\t\tprintk(KERN_ERR\n\t\t       \"__jfs_setxattr: xattr_size = %d, new_size = %d\\n\",\n\t\t       xattr_size, new_size);\n\n\t\trc = -EINVAL;\n\t\tgoto release;\n\t}\n\n\t/*\n\t * If we're left with an empty list, there's no ea\n\t */\n\tif (new_size == sizeof (struct jfs_ea_list))\n\t\tnew_size = 0;\n\n\tealist->size = cpu_to_le32(new_size);\n\n\trc = ea_put(tid, inode, &ea_buf, new_size);\n\n\tgoto out;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_write(&JFS_IP(inode)->xattr_sem);\n\n\tkfree(os2name);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_to_xattr",
          "args": [
            "&init_user_ns",
            "acl",
            "value",
            "size"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_to_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "731-767",
          "snippet": "int\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_size",
          "args": [
            "acl->a_count"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "acl",
            "&inode->i_mode"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "242-282",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_incore.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/acl.c",
    "lines": "30-73",
    "snippet": "struct posix_acl *jfs_get_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\tchar *ea_name;\n\tint size;\n\tchar *value = NULL;\n\n\tacl = get_cached_acl(inode, type);\n\tif (acl != ACL_NOT_CACHED)\n\t\treturn acl;\n\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tea_name = POSIX_ACL_XATTR_ACCESS;\n\t\t\tbreak;\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tea_name = POSIX_ACL_XATTR_DEFAULT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsize = __jfs_getxattr(inode, ea_name, NULL, 0);\n\n\tif (size > 0) {\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __jfs_getxattr(inode, ea_name, value, size);\n\t}\n\n\tif (size < 0) {\n\t\tif (size == -ENODATA)\n\t\t\tacl = NULL;\n\t\telse\n\t\t\tacl = ERR_PTR(size);\n\t} else {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t}\n\tkfree(value);\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\treturn acl;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_from_xattr",
          "args": [
            "&init_user_ns",
            "value",
            "size"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_from_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "662-725",
          "snippet": "struct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "size"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__jfs_getxattr",
          "args": [
            "inode",
            "ea_name",
            "value",
            "size"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "__jfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "885-934",
          "snippet": "ssize_t __jfs_getxattr(struct inode *inode, const char *name, void *data,\n\t\t       size_t buf_size)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea;\n\tstruct ea_buffer ea_buf;\n\tint xattr_size;\n\tssize_t size;\n\tint namelen = strlen(name);\n\tchar *value;\n\n\tdown_read(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\n\tif (xattr_size < 0) {\n\t\tsize = xattr_size;\n\t\tgoto out;\n\t}\n\n\tif (xattr_size == 0)\n\t\tgoto not_found;\n\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\n\t/* Find the named attribute */\n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea))\n\t\tif ((namelen == ea->namelen) &&\n\t\t    memcmp(name, ea->name, namelen) == 0) {\n\t\t\t/* Found it */\n\t\t\tsize = le16_to_cpu(ea->valuelen);\n\t\t\tif (!data)\n\t\t\t\tgoto release;\n\t\t\telse if (size > buf_size) {\n\t\t\t\tsize = -ERANGE;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tvalue = ((char *) &ea->name) + ea->namelen + 1;\n\t\t\tmemcpy(data, value, size);\n\t\t\tgoto release;\n\t\t}\n      not_found:\n\tsize = -ENODATA;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_read(&JFS_IP(inode)->xattr_sem);\n\n\treturn size;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nssize_t __jfs_getxattr(struct inode *inode, const char *name, void *data,\n\t\t       size_t buf_size)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea;\n\tstruct ea_buffer ea_buf;\n\tint xattr_size;\n\tssize_t size;\n\tint namelen = strlen(name);\n\tchar *value;\n\n\tdown_read(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\n\tif (xattr_size < 0) {\n\t\tsize = xattr_size;\n\t\tgoto out;\n\t}\n\n\tif (xattr_size == 0)\n\t\tgoto not_found;\n\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\n\t/* Find the named attribute */\n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea))\n\t\tif ((namelen == ea->namelen) &&\n\t\t    memcmp(name, ea->name, namelen) == 0) {\n\t\t\t/* Found it */\n\t\t\tsize = le16_to_cpu(ea->valuelen);\n\t\t\tif (!data)\n\t\t\t\tgoto release;\n\t\t\telse if (size > buf_size) {\n\t\t\t\tsize = -ERANGE;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tvalue = ((char *) &ea->name) + ea->namelen + 1;\n\t\t\tmemcpy(data, value, size);\n\t\t\tgoto release;\n\t\t}\n      not_found:\n\tsize = -ENODATA;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_read(&JFS_IP(inode)->xattr_sem);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cached_acl",
          "args": [
            "inode",
            "type"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "88-98",
          "snippet": "static struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(acl == ACL_NOT_CACHED);\n\treturn acl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_incore.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct posix_acl *jfs_get_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\tchar *ea_name;\n\tint size;\n\tchar *value = NULL;\n\n\tacl = get_cached_acl(inode, type);\n\tif (acl != ACL_NOT_CACHED)\n\t\treturn acl;\n\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tea_name = POSIX_ACL_XATTR_ACCESS;\n\t\t\tbreak;\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tea_name = POSIX_ACL_XATTR_DEFAULT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsize = __jfs_getxattr(inode, ea_name, NULL, 0);\n\n\tif (size > 0) {\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __jfs_getxattr(inode, ea_name, value, size);\n\t}\n\n\tif (size < 0) {\n\t\tif (size == -ENODATA)\n\t\t\tacl = NULL;\n\t\telse\n\t\t\tacl = ERR_PTR(size);\n\t} else {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t}\n\tkfree(value);\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\treturn acl;\n}"
  }
]