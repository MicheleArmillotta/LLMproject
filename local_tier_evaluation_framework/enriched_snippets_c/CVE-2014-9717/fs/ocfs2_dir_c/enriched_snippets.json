[
  {
    "function_name": "ocfs2_dx_dir_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "4436-4504",
    "snippet": "int ocfs2_dx_dir_truncate(struct inode *dir, struct buffer_head *di_bh)\n{\n\tint ret;\n\tunsigned int uninitialized_var(clen);\n\tu32 major_hash = UINT_MAX, p_cpos, uninitialized_var(cpos);\n\tu64 uninitialized_var(blkno);\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tif (!ocfs2_dir_indexed(dir))\n\t\treturn 0;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tif (ocfs2_dx_root_inline(dx_root))\n\t\tgoto remove_index;\n\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\n\t/* XXX: What if dr_clusters is too large? */\n\twhile (le32_to_cpu(dx_root->dr_clusters)) {\n\t\tret = ocfs2_dx_dir_lookup_rec(dir, &dx_root->dr_list,\n\t\t\t\t\t      major_hash, &cpos, &blkno, &clen);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tp_cpos = ocfs2_blocks_to_clusters(dir->i_sb, blkno);\n\n\t\tret = ocfs2_remove_btree_range(dir, &et, cpos, p_cpos, clen, 0,\n\t\t\t\t\t       &dealloc, 0, false);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos == 0)\n\t\t\tbreak;\n\n\t\tmajor_hash = cpos - 1;\n\t}\n\nremove_index:\n\tret = ocfs2_dx_dir_remove_index(dir, di_bh, dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_from_cache(INODE_CACHE(dir), dx_root_bh);\nout:\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tbrelse(dx_root_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dx_root_bh"
          ],
          "line": 4502
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "osb",
            "&dealloc"
          ],
          "line": 4500
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6472-6513",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "1"
          ],
          "line": 4499
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_from_cache",
          "args": [
            "INODE_CACHE(dir)",
            "dx_root_bh"
          ],
          "line": 4497
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "603-609",
          "snippet": "void ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 4497
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_remove_index",
          "args": [
            "dir",
            "di_bh",
            "dx_root_bh"
          ],
          "line": 4491
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_remove_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "4355-4434",
          "snippet": "static int ocfs2_dx_dir_remove_index(struct inode *dir,\n\t\t\t\t     struct buffer_head *di_bh,\n\t\t\t\t     struct buffer_head *dx_root_bh)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct inode *dx_alloc_inode = NULL;\n\tstruct buffer_head *dx_alloc_bh = NULL;\n\thandle_t *handle;\n\tu64 blk;\n\tu16 bit;\n\tu64 bg_blkno;\n\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\n\tdx_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(dx_root->dr_suballoc_slot));\n\tif (!dx_alloc_inode) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tmutex_lock(&dx_alloc_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(dx_alloc_inode, &dx_alloc_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_DX_ROOT_REMOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tOCFS2_I(dir)->ip_dyn_features &= ~OCFS2_INDEXED_DIR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(dir)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\tdi->i_dx_root = cpu_to_le64(0ULL);\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tblk = le64_to_cpu(dx_root->dr_blkno);\n\tbit = le16_to_cpu(dx_root->dr_suballoc_bit);\n\tif (dx_root->dr_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(dx_root->dr_suballoc_loc);\n\telse\n\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\tret = ocfs2_free_suballoc_bits(handle, dx_alloc_inode, dx_alloc_bh,\n\t\t\t\t       bit, bg_blkno, 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(dx_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&dx_alloc_inode->i_mutex);\n\tbrelse(dx_alloc_bh);\nout:\n\tiput(dx_alloc_inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_remove_index(struct inode *dir,\n\t\t\t\t     struct buffer_head *di_bh,\n\t\t\t\t     struct buffer_head *dx_root_bh)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct inode *dx_alloc_inode = NULL;\n\tstruct buffer_head *dx_alloc_bh = NULL;\n\thandle_t *handle;\n\tu64 blk;\n\tu16 bit;\n\tu64 bg_blkno;\n\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\n\tdx_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(dx_root->dr_suballoc_slot));\n\tif (!dx_alloc_inode) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tmutex_lock(&dx_alloc_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(dx_alloc_inode, &dx_alloc_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_DX_ROOT_REMOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tOCFS2_I(dir)->ip_dyn_features &= ~OCFS2_INDEXED_DIR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(dir)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\tdi->i_dx_root = cpu_to_le64(0ULL);\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tblk = le64_to_cpu(dx_root->dr_blkno);\n\tbit = le16_to_cpu(dx_root->dr_suballoc_bit);\n\tif (dx_root->dr_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(dx_root->dr_suballoc_loc);\n\telse\n\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\tret = ocfs2_free_suballoc_bits(handle, dx_alloc_inode, dx_alloc_bh,\n\t\t\t\t       bit, bg_blkno, 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(dx_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&dx_alloc_inode->i_mutex);\n\tbrelse(dx_alloc_bh);\nout:\n\tiput(dx_alloc_inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_btree_range",
          "args": [
            "dir",
            "&et",
            "cpos",
            "p_cpos",
            "clen",
            "0",
            "&dealloc",
            "0",
            "false"
          ],
          "line": 4477
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_btree_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5661-5773",
          "snippet": "int ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tmutex_unlock(&tl_inode->i_mutex);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tmutex_unlock(&tl_inode->i_mutex);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "dir->i_sb",
            "blkno"
          ],
          "line": 4475
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_lookup_rec",
          "args": [
            "dir",
            "&dx_root->dr_list",
            "major_hash",
            "&cpos",
            "&blkno",
            "&clen"
          ],
          "line": 4468
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_lookup_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "791-853",
          "snippet": "static int ocfs2_dx_dir_lookup_rec(struct inode *inode,\n\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t   u32 major_hash,\n\t\t\t\t   u32 *ret_cpos,\n\t\t\t\t   u64 *ret_phys_blkno,\n\t\t\t\t   unsigned int *ret_clen)\n{\n\tint ret = 0, i, found;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, major_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"btree tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= major_hash) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in btree\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = le64_to_cpu(rec->e_blkno);\n\tif (ret_cpos)\n\t\t*ret_cpos = le32_to_cpu(rec->e_cpos);\n\tif (ret_clen)\n\t\t*ret_clen = le16_to_cpu(rec->e_leaf_clusters);\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_lookup_rec(struct inode *inode,\n\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t   u32 major_hash,\n\t\t\t\t   u32 *ret_cpos,\n\t\t\t\t   u64 *ret_phys_blkno,\n\t\t\t\t   unsigned int *ret_clen)\n{\n\tint ret = 0, i, found;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, major_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"btree tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= major_hash) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in btree\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = le64_to_cpu(rec->e_blkno);\n\tif (ret_cpos)\n\t\t*ret_cpos = le32_to_cpu(rec->e_cpos);\n\tif (ret_clen)\n\t\t*ret_clen = le16_to_cpu(rec->e_leaf_clusters);\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dx_root->dr_clusters"
          ],
          "line": 4467
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dx_root_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(dir)",
            "dx_root_bh"
          ],
          "line": 4464
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dx_root_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "482-488",
          "snippet": "void ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};\n\nvoid ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_root_inline",
          "args": [
            "dx_root"
          ],
          "line": 4461
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_root_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "216-219",
          "snippet": "static inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_dx_root",
          "args": [
            "dir",
            "di",
            "&dx_root_bh"
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dx_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "617-632",
          "snippet": "static int ocfs2_read_dx_root(struct inode *dir, struct ocfs2_dinode *di,\n\t\t\t      struct buffer_head **dx_root_bh)\n{\n\tint ret;\n\tu64 blkno = le64_to_cpu(di->i_dx_root);\n\tstruct buffer_head *tmp = *dx_root_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_root);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_root_bh)\n\t\t*dx_root_bh = tmp;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dx_root(struct inode *dir, struct ocfs2_dinode *di,\n\t\t\t      struct buffer_head **dx_root_bh)\n{\n\tint ret;\n\tu64 blkno = le64_to_cpu(di->i_dx_root);\n\tstruct buffer_head *tmp = *dx_root_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_root);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_root_bh)\n\t\t*dx_root_bh = tmp;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_indexed",
          "args": [
            "dir"
          ],
          "line": 4451
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_indexed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "209-214",
          "snippet": "static int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&dealloc"
          ],
          "line": 4449
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "205-209",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 4442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_dx_dir_truncate(struct inode *dir, struct buffer_head *di_bh)\n{\n\tint ret;\n\tunsigned int uninitialized_var(clen);\n\tu32 major_hash = UINT_MAX, p_cpos, uninitialized_var(cpos);\n\tu64 uninitialized_var(blkno);\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tif (!ocfs2_dir_indexed(dir))\n\t\treturn 0;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tif (ocfs2_dx_root_inline(dx_root))\n\t\tgoto remove_index;\n\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\n\t/* XXX: What if dr_clusters is too large? */\n\twhile (le32_to_cpu(dx_root->dr_clusters)) {\n\t\tret = ocfs2_dx_dir_lookup_rec(dir, &dx_root->dr_list,\n\t\t\t\t\t      major_hash, &cpos, &blkno, &clen);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tp_cpos = ocfs2_blocks_to_clusters(dir->i_sb, blkno);\n\n\t\tret = ocfs2_remove_btree_range(dir, &et, cpos, p_cpos, clen, 0,\n\t\t\t\t\t       &dealloc, 0, false);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos == 0)\n\t\t\tbreak;\n\n\t\tmajor_hash = cpos - 1;\n\t}\n\nremove_index:\n\tret = ocfs2_dx_dir_remove_index(dir, di_bh, dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_from_cache(INODE_CACHE(dir), dx_root_bh);\nout:\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tbrelse(dx_root_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_remove_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "4355-4434",
    "snippet": "static int ocfs2_dx_dir_remove_index(struct inode *dir,\n\t\t\t\t     struct buffer_head *di_bh,\n\t\t\t\t     struct buffer_head *dx_root_bh)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct inode *dx_alloc_inode = NULL;\n\tstruct buffer_head *dx_alloc_bh = NULL;\n\thandle_t *handle;\n\tu64 blk;\n\tu16 bit;\n\tu64 bg_blkno;\n\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\n\tdx_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(dx_root->dr_suballoc_slot));\n\tif (!dx_alloc_inode) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tmutex_lock(&dx_alloc_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(dx_alloc_inode, &dx_alloc_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_DX_ROOT_REMOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tOCFS2_I(dir)->ip_dyn_features &= ~OCFS2_INDEXED_DIR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(dir)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\tdi->i_dx_root = cpu_to_le64(0ULL);\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tblk = le64_to_cpu(dx_root->dr_blkno);\n\tbit = le16_to_cpu(dx_root->dr_suballoc_bit);\n\tif (dx_root->dr_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(dx_root->dr_suballoc_loc);\n\telse\n\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\tret = ocfs2_free_suballoc_bits(handle, dx_alloc_inode, dx_alloc_bh,\n\t\t\t\t       bit, bg_blkno, 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(dx_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&dx_alloc_inode->i_mutex);\n\tbrelse(dx_alloc_bh);\nout:\n\tiput(dx_alloc_inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "dx_alloc_inode"
          ],
          "line": 4432
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dx_alloc_bh"
          ],
          "line": 4430
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dx_alloc_inode->i_mutex"
          ],
          "line": 4429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "dx_alloc_inode",
            "1"
          ],
          "line": 4426
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 4423
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_suballoc_bits",
          "args": [
            "handle",
            "dx_alloc_inode",
            "dx_alloc_bh",
            "bit",
            "bg_blkno",
            "1"
          ],
          "line": 4417
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2519-2528",
          "snippet": "int ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_which_suballoc_group",
          "args": [
            "blk",
            "bit"
          ],
          "line": 4416
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_suballoc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "156-161",
          "snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dx_root->dr_suballoc_loc"
          ],
          "line": 4414
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dx_root->dr_suballoc_bit"
          ],
          "line": 4412
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 4409
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "dir",
            "1"
          ],
          "line": 4407
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "0ULL"
          ],
          "line": 4406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(dir)->ip_lock"
          ],
          "line": 4405
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 4405
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "OCFS2_I(dir)->ip_dyn_features"
          ],
          "line": 4404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(dir)->ip_lock"
          ],
          "line": 4402
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 4395
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 4395
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 4389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_DX_ROOT_REMOVE_CREDITS"
          ],
          "line": 4388
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "dx_alloc_inode",
            "&dx_alloc_bh",
            "1"
          ],
          "line": 4382
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dx_alloc_inode->i_mutex"
          ],
          "line": 4380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "EXTENT_ALLOC_SYSTEM_INODE",
            "le16_to_cpu(dx_root->dr_suballoc_slot)"
          ],
          "line": 4372
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 4360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_remove_index(struct inode *dir,\n\t\t\t\t     struct buffer_head *di_bh,\n\t\t\t\t     struct buffer_head *dx_root_bh)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct inode *dx_alloc_inode = NULL;\n\tstruct buffer_head *dx_alloc_bh = NULL;\n\thandle_t *handle;\n\tu64 blk;\n\tu16 bit;\n\tu64 bg_blkno;\n\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\n\tdx_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(dx_root->dr_suballoc_slot));\n\tif (!dx_alloc_inode) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tmutex_lock(&dx_alloc_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(dx_alloc_inode, &dx_alloc_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_DX_ROOT_REMOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tOCFS2_I(dir)->ip_dyn_features &= ~OCFS2_INDEXED_DIR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(dir)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\tdi->i_dx_root = cpu_to_le64(0ULL);\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tblk = le64_to_cpu(dx_root->dr_blkno);\n\tbit = le16_to_cpu(dx_root->dr_suballoc_bit);\n\tif (dx_root->dr_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(dx_root->dr_suballoc_loc);\n\telse\n\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\tret = ocfs2_free_suballoc_bits(handle, dx_alloc_inode, dx_alloc_bh,\n\t\t\t\t       bit, bg_blkno, 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(dx_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&dx_alloc_inode->i_mutex);\n\tbrelse(dx_alloc_bh);\nout:\n\tiput(dx_alloc_inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_prepare_dir_for_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "4278-4353",
    "snippet": "int ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 4351
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bh"
          ],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_dir",
          "args": [
            "osb",
            "dir",
            "parent_fe_bh",
            "blocks_wanted",
            "lookup",
            "&bh"
          ],
          "line": 4337
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3187-3374",
          "snippet": "static int ocfs2_extend_dir(struct ocfs2_super *osb,\n\t\t\t    struct inode *dir,\n\t\t\t    struct buffer_head *parent_fe_bh,\n\t\t\t    unsigned int blocks_wanted,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct buffer_head **new_de_bh)\n{\n\tint status = 0;\n\tint credits, num_free_extents, drop_alloc_sem = 0;\n\tloff_t dir_i_size;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tstruct ocfs2_extent_list *el = &fe->id2.i_list;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry * de;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_extent_tree et;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t/*\n\t\t * This would be a code error as an inline directory should\n\t\t * never have an index root.\n\t\t */\n\t\tBUG_ON(dx_root_bh);\n\n\t\tstatus = ocfs2_expand_inline_dir(dir, parent_fe_bh,\n\t\t\t\t\t\t blocks_wanted, lookup,\n\t\t\t\t\t\t &new_bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Expansion from inline to an indexed directory will\n\t\t * have given us this. */\n\t\tdx_root_bh = lookup->dl_dx_root_bh;\n\n\t\tif (blocks_wanted == 1) {\n\t\t\t/*\n\t\t\t * If the new dirent will fit inside the space\n\t\t\t * created by pushing out to one block, then\n\t\t\t * we can complete the operation\n\t\t\t * here. Otherwise we have to expand i_size\n\t\t\t * and format the 2nd block below.\n\t\t\t */\n\t\t\tBUG_ON(new_bh == NULL);\n\t\t\tgoto bail_bh;\n\t\t}\n\n\t\t/*\n\t\t * Get rid of 'new_bh' - we want to format the 2nd\n\t\t * data block and return that instead.\n\t\t */\n\t\tbrelse(new_bh);\n\t\tnew_bh = NULL;\n\n\t\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\t\tdrop_alloc_sem = 1;\n\t\tdir_i_size = i_size_read(dir);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t\tgoto do_extend;\n\t}\n\n\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\tdrop_alloc_sem = 1;\n\tdir_i_size = i_size_read(dir);\n\ttrace_ocfs2_extend_dir((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t       dir_i_size);\n\n\t/* dir->i_size is always block aligned. */\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tif (dir_i_size == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters)) {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(dir),\n\t\t\t\t\t      parent_fe_bh);\n\t\tnum_free_extents = ocfs2_num_free_extents(osb, &et);\n\t\tif (num_free_extents < 0) {\n\t\t\tstatus = num_free_extents;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!num_free_extents) {\n\t\t\tstatus = ocfs2_reserve_new_metadata(osb, el, &meta_ac);\n\t\t\tif (status < 0) {\n\t\t\t\tif (status != -ENOSPC)\n\t\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ocfs2_dir_resv_allowed(osb))\n\t\t\tdata_ac->ac_resv = &OCFS2_I(dir)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(sb, el);\n\t} else {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t}\n\ndo_extend:\n\tif (ocfs2_dir_indexed(dir))\n\t\tcredits++; /* For attaching the new dirent block to the\n\t\t\t    * dx_root */\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, dir, parent_fe_bh,\n\t\t\t\t     data_ac, meta_ac, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(dir), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, sb->s_blocksize);\n\n\tde = (struct ocfs2_dir_entry *) new_bh->b_data;\n\tde->inode = 0;\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tde->rec_len = cpu_to_le16(ocfs2_dir_trailer_blk_off(sb));\n\n\t\tocfs2_init_dir_trailer(dir, new_bh, le16_to_cpu(de->rec_len));\n\n\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\tstatus = ocfs2_dx_dir_link_trailer(dir, handle,\n\t\t\t\t\t\t\t   dx_root_bh, new_bh);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tde->rec_len = cpu_to_le16(sb->s_blocksize);\n\t}\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tdir_i_size += dir->i_sb->s_blocksize;\n\ti_size_write(dir, dir_i_size);\n\tdir->i_blocks = ocfs2_inode_sector_count(dir);\n\tstatus = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail_bh:\n\t*new_de_bh = new_bh;\n\tget_bh(*new_de_bh);\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\tif (drop_alloc_sem)\n\t\tup_write(&OCFS2_I(dir)->ip_alloc_sem);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tbrelse(new_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);",
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_extend_dir(struct ocfs2_super *osb,\n\t\t\t    struct inode *dir,\n\t\t\t    struct buffer_head *parent_fe_bh,\n\t\t\t    unsigned int blocks_wanted,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct buffer_head **new_de_bh)\n{\n\tint status = 0;\n\tint credits, num_free_extents, drop_alloc_sem = 0;\n\tloff_t dir_i_size;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tstruct ocfs2_extent_list *el = &fe->id2.i_list;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry * de;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_extent_tree et;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t/*\n\t\t * This would be a code error as an inline directory should\n\t\t * never have an index root.\n\t\t */\n\t\tBUG_ON(dx_root_bh);\n\n\t\tstatus = ocfs2_expand_inline_dir(dir, parent_fe_bh,\n\t\t\t\t\t\t blocks_wanted, lookup,\n\t\t\t\t\t\t &new_bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Expansion from inline to an indexed directory will\n\t\t * have given us this. */\n\t\tdx_root_bh = lookup->dl_dx_root_bh;\n\n\t\tif (blocks_wanted == 1) {\n\t\t\t/*\n\t\t\t * If the new dirent will fit inside the space\n\t\t\t * created by pushing out to one block, then\n\t\t\t * we can complete the operation\n\t\t\t * here. Otherwise we have to expand i_size\n\t\t\t * and format the 2nd block below.\n\t\t\t */\n\t\t\tBUG_ON(new_bh == NULL);\n\t\t\tgoto bail_bh;\n\t\t}\n\n\t\t/*\n\t\t * Get rid of 'new_bh' - we want to format the 2nd\n\t\t * data block and return that instead.\n\t\t */\n\t\tbrelse(new_bh);\n\t\tnew_bh = NULL;\n\n\t\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\t\tdrop_alloc_sem = 1;\n\t\tdir_i_size = i_size_read(dir);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t\tgoto do_extend;\n\t}\n\n\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\tdrop_alloc_sem = 1;\n\tdir_i_size = i_size_read(dir);\n\ttrace_ocfs2_extend_dir((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t       dir_i_size);\n\n\t/* dir->i_size is always block aligned. */\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tif (dir_i_size == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters)) {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(dir),\n\t\t\t\t\t      parent_fe_bh);\n\t\tnum_free_extents = ocfs2_num_free_extents(osb, &et);\n\t\tif (num_free_extents < 0) {\n\t\t\tstatus = num_free_extents;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!num_free_extents) {\n\t\t\tstatus = ocfs2_reserve_new_metadata(osb, el, &meta_ac);\n\t\t\tif (status < 0) {\n\t\t\t\tif (status != -ENOSPC)\n\t\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ocfs2_dir_resv_allowed(osb))\n\t\t\tdata_ac->ac_resv = &OCFS2_I(dir)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(sb, el);\n\t} else {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t}\n\ndo_extend:\n\tif (ocfs2_dir_indexed(dir))\n\t\tcredits++; /* For attaching the new dirent block to the\n\t\t\t    * dx_root */\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, dir, parent_fe_bh,\n\t\t\t\t     data_ac, meta_ac, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(dir), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, sb->s_blocksize);\n\n\tde = (struct ocfs2_dir_entry *) new_bh->b_data;\n\tde->inode = 0;\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tde->rec_len = cpu_to_le16(ocfs2_dir_trailer_blk_off(sb));\n\n\t\tocfs2_init_dir_trailer(dir, new_bh, le16_to_cpu(de->rec_len));\n\n\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\tstatus = ocfs2_dx_dir_link_trailer(dir, handle,\n\t\t\t\t\t\t\t   dx_root_bh, new_bh);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tde->rec_len = cpu_to_le16(sb->s_blocksize);\n\t}\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tdir_i_size += dir->i_sb->s_blocksize;\n\ti_size_write(dir, dir_i_size);\n\tdir->i_blocks = ocfs2_inode_sector_count(dir);\n\tstatus = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail_bh:\n\t*new_de_bh = new_bh;\n\tget_bh(*new_de_bh);\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\tif (drop_alloc_sem)\n\t\tup_write(&OCFS2_I(dir)->ip_alloc_sem);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tbrelse(new_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bh"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_dir_space_el",
          "args": [
            "dir",
            "name",
            "namelen",
            "&bh"
          ],
          "line": 4324
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_dir_space_el",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3447-3519",
          "snippet": "static int ocfs2_find_dir_space_el(struct inode *dir, const char *name,\n\t\t\t\t   int namelen, struct buffer_head **ret_de_bh)\n{\n\tunsigned long offset;\n\tstruct buffer_head *bh = NULL;\n\tunsigned short rec_len;\n\tstruct ocfs2_dir_entry *de;\n\tstruct super_block *sb = dir->i_sb;\n\tint status;\n\tint blocksize = dir->i_sb->s_blocksize;\n\n\tstatus = ocfs2_read_dir_block(dir, 0, &bh, 0);\n\tif (status)\n\t\tgoto bail;\n\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\toffset = 0;\n\tde = (struct ocfs2_dir_entry *) bh->b_data;\n\twhile (1) {\n\t\tif ((char *)de >= sb->s_blocksize + bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\n\t\t\tif (i_size_read(dir) <= offset) {\n\t\t\t\t/*\n\t\t\t\t * Caller will have to expand this\n\t\t\t\t * directory.\n\t\t\t\t */\n\t\t\t\tstatus = -ENOSPC;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tstatus = ocfs2_read_dir_block(dir,\n\t\t\t\t\t     offset >> sb->s_blocksize_bits,\n\t\t\t\t\t     &bh, 0);\n\t\t\tif (status)\n\t\t\t\tgoto bail;\n\n\t\t\t/* move to next block */\n\t\t\tde = (struct ocfs2_dir_entry *) bh->b_data;\n\t\t}\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tstatus = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ocfs2_skip_dir_trailer(dir, de, offset % blocksize,\n\t\t\t\t\t   blocksize))\n\t\t\tgoto next;\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\t/* Ok, we found a spot. Return this bh and let\n\t\t\t * the caller actually fill it in. */\n\t\t\t*ret_de_bh = bh;\n\t\t\tget_bh(*ret_de_bh);\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\nnext:\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)((char *) de + le16_to_cpu(de->rec_len));\n\t}\n\nbail:\n\tbrelse(bh);\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_find_dir_space_el(struct inode *dir, const char *name,\n\t\t\t\t   int namelen, struct buffer_head **ret_de_bh)\n{\n\tunsigned long offset;\n\tstruct buffer_head *bh = NULL;\n\tunsigned short rec_len;\n\tstruct ocfs2_dir_entry *de;\n\tstruct super_block *sb = dir->i_sb;\n\tint status;\n\tint blocksize = dir->i_sb->s_blocksize;\n\n\tstatus = ocfs2_read_dir_block(dir, 0, &bh, 0);\n\tif (status)\n\t\tgoto bail;\n\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\toffset = 0;\n\tde = (struct ocfs2_dir_entry *) bh->b_data;\n\twhile (1) {\n\t\tif ((char *)de >= sb->s_blocksize + bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\n\t\t\tif (i_size_read(dir) <= offset) {\n\t\t\t\t/*\n\t\t\t\t * Caller will have to expand this\n\t\t\t\t * directory.\n\t\t\t\t */\n\t\t\t\tstatus = -ENOSPC;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tstatus = ocfs2_read_dir_block(dir,\n\t\t\t\t\t     offset >> sb->s_blocksize_bits,\n\t\t\t\t\t     &bh, 0);\n\t\t\tif (status)\n\t\t\t\tgoto bail;\n\n\t\t\t/* move to next block */\n\t\t\tde = (struct ocfs2_dir_entry *) bh->b_data;\n\t\t}\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tstatus = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ocfs2_skip_dir_trailer(dir, de, offset % blocksize,\n\t\t\t\t\t   blocksize))\n\t\t\tgoto next;\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\t/* Ok, we found a spot. Return this bh and let\n\t\t\t * the caller actually fill it in. */\n\t\t\t*ret_de_bh = bh;\n\t\t\tget_bh(*ret_de_bh);\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\nnext:\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)((char *) de + le16_to_cpu(de->rec_len));\n\t}\n\nbail:\n\tbrelse(bh);\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_dir_space_id",
          "args": [
            "dir",
            "parent_fe_bh",
            "name",
            "namelen",
            "&bh",
            "&blocks_wanted"
          ],
          "line": 4321
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_dir_space_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3376-3445",
          "snippet": "static int ocfs2_find_dir_space_id(struct inode *dir, struct buffer_head *di_bh,\n\t\t\t\t   const char *name, int namelen,\n\t\t\t\t   struct buffer_head **ret_de_bh,\n\t\t\t\t   unsigned int *blocks_wanted)\n{\n\tint ret;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dir_entry *de, *last_de = NULL;\n\tchar *de_buf, *limit;\n\tunsigned long offset = 0;\n\tunsigned int rec_len, new_rec_len, free_space = dir->i_sb->s_blocksize;\n\n\t/*\n\t * This calculates how many free bytes we'd have in block zero, should\n\t * this function force expansion to an extent tree.\n\t */\n\tif (ocfs2_new_dir_wants_trailer(dir))\n\t\tfree_space = ocfs2_dir_trailer_blk_off(sb) - i_size_read(dir);\n\telse\n\t\tfree_space = dir->i_sb->s_blocksize - i_size_read(dir);\n\n\tde_buf = di->id2.i_data.id_data;\n\tlimit = de_buf + i_size_read(dir);\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (!ocfs2_check_dir_entry(dir, de, di_bh, offset)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * No need to check for a trailing dirent record here as\n\t\t * they're not used for inline dirs.\n\t\t */\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\t/* Ok, we found a spot. Return this bh and let\n\t\t\t * the caller actually fill it in. */\n\t\t\t*ret_de_bh = di_bh;\n\t\t\tget_bh(*ret_de_bh);\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_de = de;\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\toffset += le16_to_cpu(de->rec_len);\n\t}\n\n\t/*\n\t * We're going to require expansion of the directory - figure\n\t * out how many blocks we'll need so that a place for the\n\t * dirent can be found.\n\t */\n\t*blocks_wanted = 1;\n\tnew_rec_len = le16_to_cpu(last_de->rec_len) + free_space;\n\tif (new_rec_len < (rec_len + OCFS2_DIR_REC_LEN(last_de->name_len)))\n\t\t*blocks_wanted = 2;\n\n\tret = -ENOSPC;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_find_dir_space_id(struct inode *dir, struct buffer_head *di_bh,\n\t\t\t\t   const char *name, int namelen,\n\t\t\t\t   struct buffer_head **ret_de_bh,\n\t\t\t\t   unsigned int *blocks_wanted)\n{\n\tint ret;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dir_entry *de, *last_de = NULL;\n\tchar *de_buf, *limit;\n\tunsigned long offset = 0;\n\tunsigned int rec_len, new_rec_len, free_space = dir->i_sb->s_blocksize;\n\n\t/*\n\t * This calculates how many free bytes we'd have in block zero, should\n\t * this function force expansion to an extent tree.\n\t */\n\tif (ocfs2_new_dir_wants_trailer(dir))\n\t\tfree_space = ocfs2_dir_trailer_blk_off(sb) - i_size_read(dir);\n\telse\n\t\tfree_space = dir->i_sb->s_blocksize - i_size_read(dir);\n\n\tde_buf = di->id2.i_data.id_data;\n\tlimit = de_buf + i_size_read(dir);\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (!ocfs2_check_dir_entry(dir, de, di_bh, offset)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * No need to check for a trailing dirent record here as\n\t\t * they're not used for inline dirs.\n\t\t */\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\t/* Ok, we found a spot. Return this bh and let\n\t\t\t * the caller actually fill it in. */\n\t\t\t*ret_de_bh = di_bh;\n\t\t\tget_bh(*ret_de_bh);\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_de = de;\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\toffset += le16_to_cpu(de->rec_len);\n\t}\n\n\t/*\n\t * We're going to require expansion of the directory - figure\n\t * out how many blocks we'll need so that a place for the\n\t * dirent can be found.\n\t */\n\t*blocks_wanted = 1;\n\tnew_rec_len = le16_to_cpu(last_de->rec_len) + free_space;\n\tif (new_rec_len < (rec_len + OCFS2_DIR_REC_LEN(last_de->name_len)))\n\t\t*blocks_wanted = 2;\n\n\tret = -ENOSPC;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 4320
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_dx_dir_for_insert",
          "args": [
            "dir",
            "parent_fe_bh",
            "name",
            "namelen",
            "lookup"
          ],
          "line": 4313
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_dx_dir_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "4176-4270",
          "snippet": "static int ocfs2_prepare_dx_dir_for_insert(struct inode *dir,\n\t\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   int namelen,\n\t\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, free_dx_root = 1;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct buffer_head *leaf_bh = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tif (le32_to_cpu(dx_root->dr_num_entries) == OCFS2_DX_ENTRIES_MAX) {\n\t\tret = -ENOSPC;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tret = ocfs2_inline_dx_has_space(dx_root_bh);\n\n\t\tif (ret == 0)\n\t\t\tgoto search_el;\n\n\t\t/*\n\t\t * We ran out of room in the root block. Expand it to\n\t\t * an extent, then allow ocfs2_find_dir_space_dx to do\n\t\t * the rest.\n\t\t */\n\t\tret = ocfs2_expand_inline_dx_root(dir, dx_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Insert preparation for an indexed directory is split into two\n\t * steps. The call to find_dir_space_dx reserves room in the index for\n\t * an additional item. If we run out of space there, it's a real error\n\t * we can't continue on.\n\t */\n\tret = ocfs2_find_dir_space_dx(osb, dir, di_bh, dx_root_bh, name,\n\t\t\t\t      namelen, lookup);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nsearch_el:\n\t/*\n\t * Next, we need to find space in the unindexed tree. This call\n\t * searches using the free space linked list. If the unindexed tree\n\t * lacks sufficient space, we'll expand it below. The expansion code\n\t * is smart enough to add any new blocks to the free space list.\n\t */\n\tret = ocfs2_search_dx_free_list(dir, dx_root_bh, namelen, lookup);\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Do this up here - ocfs2_extend_dir might need the dx_root */\n\tlookup->dl_dx_root_bh = dx_root_bh;\n\tfree_dx_root = 0;\n\n\tif (ret == -ENOSPC) {\n\t\tret = ocfs2_extend_dir(osb, dir, di_bh, 1, lookup, &leaf_bh);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We make the assumption here that new leaf blocks are added\n\t\t * to the front of our free list.\n\t\t */\n\t\tlookup->dl_prev_leaf_bh = NULL;\n\t\tlookup->dl_leaf_bh = leaf_bh;\n\t}\n\nout:\n\tif (free_dx_root)\n\t\tbrelse(dx_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_prepare_dx_dir_for_insert(struct inode *dir,\n\t\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   int namelen,\n\t\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, free_dx_root = 1;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct buffer_head *leaf_bh = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tif (le32_to_cpu(dx_root->dr_num_entries) == OCFS2_DX_ENTRIES_MAX) {\n\t\tret = -ENOSPC;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tret = ocfs2_inline_dx_has_space(dx_root_bh);\n\n\t\tif (ret == 0)\n\t\t\tgoto search_el;\n\n\t\t/*\n\t\t * We ran out of room in the root block. Expand it to\n\t\t * an extent, then allow ocfs2_find_dir_space_dx to do\n\t\t * the rest.\n\t\t */\n\t\tret = ocfs2_expand_inline_dx_root(dir, dx_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Insert preparation for an indexed directory is split into two\n\t * steps. The call to find_dir_space_dx reserves room in the index for\n\t * an additional item. If we run out of space there, it's a real error\n\t * we can't continue on.\n\t */\n\tret = ocfs2_find_dir_space_dx(osb, dir, di_bh, dx_root_bh, name,\n\t\t\t\t      namelen, lookup);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nsearch_el:\n\t/*\n\t * Next, we need to find space in the unindexed tree. This call\n\t * searches using the free space linked list. If the unindexed tree\n\t * lacks sufficient space, we'll expand it below. The expansion code\n\t * is smart enough to add any new blocks to the free space list.\n\t */\n\tret = ocfs2_search_dx_free_list(dir, dx_root_bh, namelen, lookup);\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Do this up here - ocfs2_extend_dir might need the dx_root */\n\tlookup->dl_dx_root_bh = dx_root_bh;\n\tfree_dx_root = 0;\n\n\tif (ret == -ENOSPC) {\n\t\tret = ocfs2_extend_dir(osb, dir, di_bh, 1, lookup, &leaf_bh);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We make the assumption here that new leaf blocks are added\n\t\t * to the front of our free list.\n\t\t */\n\t\tlookup->dl_prev_leaf_bh = NULL;\n\t\tlookup->dl_leaf_bh = leaf_bh;\n\t}\n\nout:\n\tif (free_dx_root)\n\t\tbrelse(dx_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_indexed",
          "args": [
            "dir"
          ],
          "line": 4312
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_indexed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "209-214",
          "snippet": "static int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_name_hash",
          "args": [
            "dir",
            "name",
            "namelen",
            "&lookup->dl_hinfo"
          ],
          "line": 4310
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "270-310",
          "snippet": "static void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t/*\n\t * XXX: Is this really necessary, if the index is never looked\n\t * at by readdir? Is a hash value of '0' a bad idea?\n\t */\n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t/*\n\t * This makes it very easy to debug indexing problems. We\n\t * should never allow this to be selected without hand editing\n\t * this file though.\n\t */\n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t/*\n\t * XXX: Is this really necessary, if the index is never looked\n\t * at by readdir? Is a hash value of '0' a bad idea?\n\t */\n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t/*\n\t * This makes it very easy to debug indexing problems. We\n\t * should never allow this to be selected without hand editing\n\t * this file though.\n\t */\n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_indexed_dirs",
          "args": [
            "osb"
          ],
          "line": 4309
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_indexed_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "532-537",
          "snippet": "static inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_prepare_dir_for_insert",
          "args": [
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "namelen"
          ],
          "line": 4289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do this up front to reduce confusion.\n\t *\n\t * The directory might start inline, then be turned into an\n\t * indexed one, in which case we'd need to hash deep inside\n\t * ocfs2_find_dir_space_id(). Since\n\t * ocfs2_prepare_dx_dir_for_insert() also needs this hash\n\t * done, there seems no point in spreading out the calls. We\n\t * can optimize away the case where the file system doesn't\n\t * support indexing.\n\t */\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t/*\n\t\t * We have to expand the directory to add this name.\n\t\t */\n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_prepare_dx_dir_for_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "4176-4270",
    "snippet": "static int ocfs2_prepare_dx_dir_for_insert(struct inode *dir,\n\t\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   int namelen,\n\t\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, free_dx_root = 1;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct buffer_head *leaf_bh = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tif (le32_to_cpu(dx_root->dr_num_entries) == OCFS2_DX_ENTRIES_MAX) {\n\t\tret = -ENOSPC;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tret = ocfs2_inline_dx_has_space(dx_root_bh);\n\n\t\tif (ret == 0)\n\t\t\tgoto search_el;\n\n\t\t/*\n\t\t * We ran out of room in the root block. Expand it to\n\t\t * an extent, then allow ocfs2_find_dir_space_dx to do\n\t\t * the rest.\n\t\t */\n\t\tret = ocfs2_expand_inline_dx_root(dir, dx_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Insert preparation for an indexed directory is split into two\n\t * steps. The call to find_dir_space_dx reserves room in the index for\n\t * an additional item. If we run out of space there, it's a real error\n\t * we can't continue on.\n\t */\n\tret = ocfs2_find_dir_space_dx(osb, dir, di_bh, dx_root_bh, name,\n\t\t\t\t      namelen, lookup);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nsearch_el:\n\t/*\n\t * Next, we need to find space in the unindexed tree. This call\n\t * searches using the free space linked list. If the unindexed tree\n\t * lacks sufficient space, we'll expand it below. The expansion code\n\t * is smart enough to add any new blocks to the free space list.\n\t */\n\tret = ocfs2_search_dx_free_list(dir, dx_root_bh, namelen, lookup);\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Do this up here - ocfs2_extend_dir might need the dx_root */\n\tlookup->dl_dx_root_bh = dx_root_bh;\n\tfree_dx_root = 0;\n\n\tif (ret == -ENOSPC) {\n\t\tret = ocfs2_extend_dir(osb, dir, di_bh, 1, lookup, &leaf_bh);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We make the assumption here that new leaf blocks are added\n\t\t * to the front of our free list.\n\t\t */\n\t\tlookup->dl_prev_leaf_bh = NULL;\n\t\tlookup->dl_leaf_bh = leaf_bh;\n\t}\n\nout:\n\tif (free_dx_root)\n\t\tbrelse(dx_root_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dx_root_bh"
          ],
          "line": 4268
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_dir",
          "args": [
            "osb",
            "dir",
            "di_bh",
            "1",
            "lookup",
            "&leaf_bh"
          ],
          "line": 4251
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3187-3374",
          "snippet": "static int ocfs2_extend_dir(struct ocfs2_super *osb,\n\t\t\t    struct inode *dir,\n\t\t\t    struct buffer_head *parent_fe_bh,\n\t\t\t    unsigned int blocks_wanted,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct buffer_head **new_de_bh)\n{\n\tint status = 0;\n\tint credits, num_free_extents, drop_alloc_sem = 0;\n\tloff_t dir_i_size;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tstruct ocfs2_extent_list *el = &fe->id2.i_list;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry * de;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_extent_tree et;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t/*\n\t\t * This would be a code error as an inline directory should\n\t\t * never have an index root.\n\t\t */\n\t\tBUG_ON(dx_root_bh);\n\n\t\tstatus = ocfs2_expand_inline_dir(dir, parent_fe_bh,\n\t\t\t\t\t\t blocks_wanted, lookup,\n\t\t\t\t\t\t &new_bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Expansion from inline to an indexed directory will\n\t\t * have given us this. */\n\t\tdx_root_bh = lookup->dl_dx_root_bh;\n\n\t\tif (blocks_wanted == 1) {\n\t\t\t/*\n\t\t\t * If the new dirent will fit inside the space\n\t\t\t * created by pushing out to one block, then\n\t\t\t * we can complete the operation\n\t\t\t * here. Otherwise we have to expand i_size\n\t\t\t * and format the 2nd block below.\n\t\t\t */\n\t\t\tBUG_ON(new_bh == NULL);\n\t\t\tgoto bail_bh;\n\t\t}\n\n\t\t/*\n\t\t * Get rid of 'new_bh' - we want to format the 2nd\n\t\t * data block and return that instead.\n\t\t */\n\t\tbrelse(new_bh);\n\t\tnew_bh = NULL;\n\n\t\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\t\tdrop_alloc_sem = 1;\n\t\tdir_i_size = i_size_read(dir);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t\tgoto do_extend;\n\t}\n\n\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\tdrop_alloc_sem = 1;\n\tdir_i_size = i_size_read(dir);\n\ttrace_ocfs2_extend_dir((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t       dir_i_size);\n\n\t/* dir->i_size is always block aligned. */\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tif (dir_i_size == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters)) {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(dir),\n\t\t\t\t\t      parent_fe_bh);\n\t\tnum_free_extents = ocfs2_num_free_extents(osb, &et);\n\t\tif (num_free_extents < 0) {\n\t\t\tstatus = num_free_extents;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!num_free_extents) {\n\t\t\tstatus = ocfs2_reserve_new_metadata(osb, el, &meta_ac);\n\t\t\tif (status < 0) {\n\t\t\t\tif (status != -ENOSPC)\n\t\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ocfs2_dir_resv_allowed(osb))\n\t\t\tdata_ac->ac_resv = &OCFS2_I(dir)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(sb, el);\n\t} else {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t}\n\ndo_extend:\n\tif (ocfs2_dir_indexed(dir))\n\t\tcredits++; /* For attaching the new dirent block to the\n\t\t\t    * dx_root */\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, dir, parent_fe_bh,\n\t\t\t\t     data_ac, meta_ac, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(dir), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, sb->s_blocksize);\n\n\tde = (struct ocfs2_dir_entry *) new_bh->b_data;\n\tde->inode = 0;\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tde->rec_len = cpu_to_le16(ocfs2_dir_trailer_blk_off(sb));\n\n\t\tocfs2_init_dir_trailer(dir, new_bh, le16_to_cpu(de->rec_len));\n\n\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\tstatus = ocfs2_dx_dir_link_trailer(dir, handle,\n\t\t\t\t\t\t\t   dx_root_bh, new_bh);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tde->rec_len = cpu_to_le16(sb->s_blocksize);\n\t}\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tdir_i_size += dir->i_sb->s_blocksize;\n\ti_size_write(dir, dir_i_size);\n\tdir->i_blocks = ocfs2_inode_sector_count(dir);\n\tstatus = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail_bh:\n\t*new_de_bh = new_bh;\n\tget_bh(*new_de_bh);\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\tif (drop_alloc_sem)\n\t\tup_write(&OCFS2_I(dir)->ip_alloc_sem);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tbrelse(new_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);",
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_extend_dir(struct ocfs2_super *osb,\n\t\t\t    struct inode *dir,\n\t\t\t    struct buffer_head *parent_fe_bh,\n\t\t\t    unsigned int blocks_wanted,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct buffer_head **new_de_bh)\n{\n\tint status = 0;\n\tint credits, num_free_extents, drop_alloc_sem = 0;\n\tloff_t dir_i_size;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tstruct ocfs2_extent_list *el = &fe->id2.i_list;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry * de;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_extent_tree et;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t/*\n\t\t * This would be a code error as an inline directory should\n\t\t * never have an index root.\n\t\t */\n\t\tBUG_ON(dx_root_bh);\n\n\t\tstatus = ocfs2_expand_inline_dir(dir, parent_fe_bh,\n\t\t\t\t\t\t blocks_wanted, lookup,\n\t\t\t\t\t\t &new_bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Expansion from inline to an indexed directory will\n\t\t * have given us this. */\n\t\tdx_root_bh = lookup->dl_dx_root_bh;\n\n\t\tif (blocks_wanted == 1) {\n\t\t\t/*\n\t\t\t * If the new dirent will fit inside the space\n\t\t\t * created by pushing out to one block, then\n\t\t\t * we can complete the operation\n\t\t\t * here. Otherwise we have to expand i_size\n\t\t\t * and format the 2nd block below.\n\t\t\t */\n\t\t\tBUG_ON(new_bh == NULL);\n\t\t\tgoto bail_bh;\n\t\t}\n\n\t\t/*\n\t\t * Get rid of 'new_bh' - we want to format the 2nd\n\t\t * data block and return that instead.\n\t\t */\n\t\tbrelse(new_bh);\n\t\tnew_bh = NULL;\n\n\t\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\t\tdrop_alloc_sem = 1;\n\t\tdir_i_size = i_size_read(dir);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t\tgoto do_extend;\n\t}\n\n\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\tdrop_alloc_sem = 1;\n\tdir_i_size = i_size_read(dir);\n\ttrace_ocfs2_extend_dir((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t       dir_i_size);\n\n\t/* dir->i_size is always block aligned. */\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tif (dir_i_size == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters)) {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(dir),\n\t\t\t\t\t      parent_fe_bh);\n\t\tnum_free_extents = ocfs2_num_free_extents(osb, &et);\n\t\tif (num_free_extents < 0) {\n\t\t\tstatus = num_free_extents;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!num_free_extents) {\n\t\t\tstatus = ocfs2_reserve_new_metadata(osb, el, &meta_ac);\n\t\t\tif (status < 0) {\n\t\t\t\tif (status != -ENOSPC)\n\t\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ocfs2_dir_resv_allowed(osb))\n\t\t\tdata_ac->ac_resv = &OCFS2_I(dir)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(sb, el);\n\t} else {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t}\n\ndo_extend:\n\tif (ocfs2_dir_indexed(dir))\n\t\tcredits++; /* For attaching the new dirent block to the\n\t\t\t    * dx_root */\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, dir, parent_fe_bh,\n\t\t\t\t     data_ac, meta_ac, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(dir), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, sb->s_blocksize);\n\n\tde = (struct ocfs2_dir_entry *) new_bh->b_data;\n\tde->inode = 0;\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tde->rec_len = cpu_to_le16(ocfs2_dir_trailer_blk_off(sb));\n\n\t\tocfs2_init_dir_trailer(dir, new_bh, le16_to_cpu(de->rec_len));\n\n\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\tstatus = ocfs2_dx_dir_link_trailer(dir, handle,\n\t\t\t\t\t\t\t   dx_root_bh, new_bh);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tde->rec_len = cpu_to_le16(sb->s_blocksize);\n\t}\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tdir_i_size += dir->i_sb->s_blocksize;\n\ti_size_write(dir, dir_i_size);\n\tdir->i_blocks = ocfs2_inode_sector_count(dir);\n\tstatus = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail_bh:\n\t*new_de_bh = new_bh;\n\tget_bh(*new_de_bh);\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\tif (drop_alloc_sem)\n\t\tup_write(&OCFS2_I(dir)->ip_alloc_sem);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tbrelse(new_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_search_dx_free_list",
          "args": [
            "dir",
            "dx_root_bh",
            "namelen",
            "lookup"
          ],
          "line": 4240
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_dx_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3997-4043",
          "snippet": "static int ocfs2_search_dx_free_list(struct inode *dir,\n\t\t\t\t     struct buffer_head *dx_root_bh,\n\t\t\t\t     int namelen,\n\t\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret = -ENOSPC;\n\tstruct buffer_head *leaf_bh = NULL, *prev_leaf_bh = NULL;\n\tstruct ocfs2_dir_block_trailer *db;\n\tu64 next_block;\n\tint rec_len = OCFS2_DIR_REC_LEN(namelen);\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tnext_block = le64_to_cpu(dx_root->dr_free_blk);\n\n\twhile (next_block) {\n\t\tbrelse(prev_leaf_bh);\n\t\tprev_leaf_bh = leaf_bh;\n\t\tleaf_bh = NULL;\n\n\t\tret = ocfs2_read_dir_block_direct(dir, next_block, &leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdb = ocfs2_trailer_from_bh(leaf_bh, dir->i_sb);\n\t\tif (rec_len <= le16_to_cpu(db->db_free_rec_len)) {\n\t\t\tlookup->dl_leaf_bh = leaf_bh;\n\t\t\tlookup->dl_prev_leaf_bh = prev_leaf_bh;\n\t\t\tleaf_bh = NULL;\n\t\t\tprev_leaf_bh = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tnext_block = le64_to_cpu(db->db_free_next);\n\t}\n\n\tif (!next_block)\n\t\tret = -ENOSPC;\n\nout:\n\n\tbrelse(leaf_bh);\n\tbrelse(prev_leaf_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_search_dx_free_list(struct inode *dir,\n\t\t\t\t     struct buffer_head *dx_root_bh,\n\t\t\t\t     int namelen,\n\t\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret = -ENOSPC;\n\tstruct buffer_head *leaf_bh = NULL, *prev_leaf_bh = NULL;\n\tstruct ocfs2_dir_block_trailer *db;\n\tu64 next_block;\n\tint rec_len = OCFS2_DIR_REC_LEN(namelen);\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tnext_block = le64_to_cpu(dx_root->dr_free_blk);\n\n\twhile (next_block) {\n\t\tbrelse(prev_leaf_bh);\n\t\tprev_leaf_bh = leaf_bh;\n\t\tleaf_bh = NULL;\n\n\t\tret = ocfs2_read_dir_block_direct(dir, next_block, &leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdb = ocfs2_trailer_from_bh(leaf_bh, dir->i_sb);\n\t\tif (rec_len <= le16_to_cpu(db->db_free_rec_len)) {\n\t\t\tlookup->dl_leaf_bh = leaf_bh;\n\t\t\tlookup->dl_prev_leaf_bh = prev_leaf_bh;\n\t\t\tleaf_bh = NULL;\n\t\t\tprev_leaf_bh = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tnext_block = le64_to_cpu(db->db_free_next);\n\t}\n\n\tif (!next_block)\n\t\tret = -ENOSPC;\n\nout:\n\n\tbrelse(leaf_bh);\n\tbrelse(prev_leaf_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_dir_space_dx",
          "args": [
            "osb",
            "dir",
            "di_bh",
            "dx_root_bh",
            "name",
            "namelen",
            "lookup"
          ],
          "line": 4226
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_dir_space_dx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3924-3995",
          "snippet": "static int ocfs2_find_dir_space_dx(struct ocfs2_super *osb, struct inode *dir,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   struct buffer_head *dx_root_bh,\n\t\t\t\t   const char *name, int namelen,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, rebalanced = 0;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *dx_leaf_bh = NULL;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tu64 blkno;\n\tu32 leaf_cpos;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\nrestart_search:\n\tret = ocfs2_dx_dir_lookup(dir, &dx_root->dr_list, &lookup->dl_hinfo,\n\t\t\t\t  &leaf_cpos, &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_dx_leaf(dir, blkno, &dx_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\n\tif (le16_to_cpu(dx_leaf->dl_list.de_num_used) >=\n\t    le16_to_cpu(dx_leaf->dl_list.de_count)) {\n\t\tif (rebalanced) {\n\t\t\t/*\n\t\t\t * Rebalancing should have provided us with\n\t\t\t * space in an appropriate leaf.\n\t\t\t *\n\t\t\t * XXX: Is this an abnormal condition then?\n\t\t\t * Should we print a message here?\n\t\t\t */\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_dx_dir_rebalance(osb, dir, dx_root_bh, dx_leaf_bh,\n\t\t\t\t\t     &lookup->dl_hinfo, leaf_cpos,\n\t\t\t\t\t     blkno);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Restart the lookup. The rebalance might have\n\t\t * changed which block our item fits into. Mark our\n\t\t * progress, so we only execute this once.\n\t\t */\n\t\tbrelse(dx_leaf_bh);\n\t\tdx_leaf_bh = NULL;\n\t\trebalanced = 1;\n\t\tgoto restart_search;\n\t}\n\n\tlookup->dl_dx_leaf_bh = dx_leaf_bh;\n\tdx_leaf_bh = NULL;\n\nout:\n\tbrelse(dx_leaf_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_find_dir_space_dx(struct ocfs2_super *osb, struct inode *dir,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   struct buffer_head *dx_root_bh,\n\t\t\t\t   const char *name, int namelen,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, rebalanced = 0;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *dx_leaf_bh = NULL;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tu64 blkno;\n\tu32 leaf_cpos;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\nrestart_search:\n\tret = ocfs2_dx_dir_lookup(dir, &dx_root->dr_list, &lookup->dl_hinfo,\n\t\t\t\t  &leaf_cpos, &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_dx_leaf(dir, blkno, &dx_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\n\tif (le16_to_cpu(dx_leaf->dl_list.de_num_used) >=\n\t    le16_to_cpu(dx_leaf->dl_list.de_count)) {\n\t\tif (rebalanced) {\n\t\t\t/*\n\t\t\t * Rebalancing should have provided us with\n\t\t\t * space in an appropriate leaf.\n\t\t\t *\n\t\t\t * XXX: Is this an abnormal condition then?\n\t\t\t * Should we print a message here?\n\t\t\t */\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_dx_dir_rebalance(osb, dir, dx_root_bh, dx_leaf_bh,\n\t\t\t\t\t     &lookup->dl_hinfo, leaf_cpos,\n\t\t\t\t\t     blkno);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Restart the lookup. The rebalance might have\n\t\t * changed which block our item fits into. Mark our\n\t\t * progress, so we only execute this once.\n\t\t */\n\t\tbrelse(dx_leaf_bh);\n\t\tdx_leaf_bh = NULL;\n\t\trebalanced = 1;\n\t\tgoto restart_search;\n\t}\n\n\tlookup->dl_dx_leaf_bh = dx_leaf_bh;\n\tdx_leaf_bh = NULL;\n\nout:\n\tbrelse(dx_leaf_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_expand_inline_dx_root",
          "args": [
            "dir",
            "dx_root_bh"
          ],
          "line": 4213
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_expand_inline_dx_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "4045-4159",
          "snippet": "static int ocfs2_expand_inline_dx_root(struct inode *dir,\n\t\t\t\t       struct buffer_head *dx_root_bh)\n{\n\tint ret, num_dx_leaves, i, j, did_quota = 0;\n\tstruct buffer_head **dx_leaves = NULL;\n\tstruct ocfs2_extent_tree et;\n\tu64 insert_blkno;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\tstruct ocfs2_dx_entry *dx_entry;\n\tstruct ocfs2_dx_leaf *target_leaf;\n\n\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, &num_dx_leaves);\n\tif (!dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_calc_dxi_expand_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\t/*\n\t * We do this up front, before the allocation, so that a\n\t * failure to add the dx_root_bh to the journal won't result\n\t * us losing clusters.\n\t */\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_dx_dir_new_cluster(dir, 0, handle, data_ac, dx_leaves,\n\t\t\t\t\t num_dx_leaves, &insert_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Transfer the entries from our dx_root into the appropriate\n\t * block\n\t */\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\tfor (i = 0; i < le16_to_cpu(entry_list->de_num_used); i++) {\n\t\tdx_entry = &entry_list->de_entries[i];\n\n\t\tj = __ocfs2_dx_dir_hash_idx(osb,\n\t\t\t\t\t    le32_to_cpu(dx_entry->dx_minor_hash));\n\t\ttarget_leaf = (struct ocfs2_dx_leaf *)dx_leaves[j]->b_data;\n\n\t\tocfs2_dx_dir_leaf_insert_tail(target_leaf, dx_entry);\n\n\t\t/* Each leaf has been passed to the journal already\n\t\t * via __ocfs2_dx_dir_new_cluster() */\n\t}\n\n\tdx_root->dr_flags &= ~OCFS2_DX_FLAG_INLINE;\n\tmemset(&dx_root->dr_list, 0, osb->sb->s_blocksize -\n\t       offsetof(struct ocfs2_dx_root_block, dr_list));\n\tdx_root->dr_list.l_count =\n\t\tcpu_to_le16(ocfs2_extent_recs_per_dx_root(osb->sb));\n\n\t/* This should never fail considering we start with an empty\n\t * dx_root. */\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\tret = ocfs2_insert_extent(handle, &et, 0, insert_blkno, 1, 0, NULL);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tdid_quota = 0;\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(dir->i_sb, 1));\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tif (dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++)\n\t\t\tbrelse(dx_leaves[i]);\n\t\tkfree(dx_leaves);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_expand_inline_dx_root(struct inode *dir,\n\t\t\t\t       struct buffer_head *dx_root_bh)\n{\n\tint ret, num_dx_leaves, i, j, did_quota = 0;\n\tstruct buffer_head **dx_leaves = NULL;\n\tstruct ocfs2_extent_tree et;\n\tu64 insert_blkno;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\tstruct ocfs2_dx_entry *dx_entry;\n\tstruct ocfs2_dx_leaf *target_leaf;\n\n\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, &num_dx_leaves);\n\tif (!dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_calc_dxi_expand_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\t/*\n\t * We do this up front, before the allocation, so that a\n\t * failure to add the dx_root_bh to the journal won't result\n\t * us losing clusters.\n\t */\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_dx_dir_new_cluster(dir, 0, handle, data_ac, dx_leaves,\n\t\t\t\t\t num_dx_leaves, &insert_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Transfer the entries from our dx_root into the appropriate\n\t * block\n\t */\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\tfor (i = 0; i < le16_to_cpu(entry_list->de_num_used); i++) {\n\t\tdx_entry = &entry_list->de_entries[i];\n\n\t\tj = __ocfs2_dx_dir_hash_idx(osb,\n\t\t\t\t\t    le32_to_cpu(dx_entry->dx_minor_hash));\n\t\ttarget_leaf = (struct ocfs2_dx_leaf *)dx_leaves[j]->b_data;\n\n\t\tocfs2_dx_dir_leaf_insert_tail(target_leaf, dx_entry);\n\n\t\t/* Each leaf has been passed to the journal already\n\t\t * via __ocfs2_dx_dir_new_cluster() */\n\t}\n\n\tdx_root->dr_flags &= ~OCFS2_DX_FLAG_INLINE;\n\tmemset(&dx_root->dr_list, 0, osb->sb->s_blocksize -\n\t       offsetof(struct ocfs2_dx_root_block, dr_list));\n\tdx_root->dr_list.l_count =\n\t\tcpu_to_le16(ocfs2_extent_recs_per_dx_root(osb->sb));\n\n\t/* This should never fail considering we start with an empty\n\t * dx_root. */\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\tret = ocfs2_insert_extent(handle, &et, 0, insert_blkno, 1, 0, NULL);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tdid_quota = 0;\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(dir->i_sb, 1));\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tif (dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++)\n\t\t\tbrelse(dx_leaves[i]);\n\t\tkfree(dx_leaves);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inline_dx_has_space",
          "args": [
            "dx_root_bh"
          ],
          "line": 4203
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inline_dx_has_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "4161-4174",
          "snippet": "static int ocfs2_inline_dx_has_space(struct buffer_head *dx_root_bh)\n{\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\tif (le16_to_cpu(entry_list->de_num_used) >=\n\t    le16_to_cpu(entry_list->de_count))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_inline_dx_has_space(struct buffer_head *dx_root_bh)\n{\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\tif (le16_to_cpu(entry_list->de_num_used) >=\n\t    le16_to_cpu(entry_list->de_count))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_root_inline",
          "args": [
            "dx_root"
          ],
          "line": 4202
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_root_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "216-219",
          "snippet": "static inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dx_root->dr_num_entries"
          ],
          "line": 4196
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_dx_root",
          "args": [
            "dir",
            "di",
            "&dx_root_bh"
          ],
          "line": 4189
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dx_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "617-632",
          "snippet": "static int ocfs2_read_dx_root(struct inode *dir, struct ocfs2_dinode *di,\n\t\t\t      struct buffer_head **dx_root_bh)\n{\n\tint ret;\n\tu64 blkno = le64_to_cpu(di->i_dx_root);\n\tstruct buffer_head *tmp = *dx_root_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_root);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_root_bh)\n\t\t*dx_root_bh = tmp;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dx_root(struct inode *dir, struct ocfs2_dinode *di,\n\t\t\t      struct buffer_head **dx_root_bh)\n{\n\tint ret;\n\tu64 blkno = le64_to_cpu(di->i_dx_root);\n\tstruct buffer_head *tmp = *dx_root_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_root);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_root_bh)\n\t\t*dx_root_bh = tmp;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 4183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_prepare_dx_dir_for_insert(struct inode *dir,\n\t\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   int namelen,\n\t\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, free_dx_root = 1;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct buffer_head *leaf_bh = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tif (le32_to_cpu(dx_root->dr_num_entries) == OCFS2_DX_ENTRIES_MAX) {\n\t\tret = -ENOSPC;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tret = ocfs2_inline_dx_has_space(dx_root_bh);\n\n\t\tif (ret == 0)\n\t\t\tgoto search_el;\n\n\t\t/*\n\t\t * We ran out of room in the root block. Expand it to\n\t\t * an extent, then allow ocfs2_find_dir_space_dx to do\n\t\t * the rest.\n\t\t */\n\t\tret = ocfs2_expand_inline_dx_root(dir, dx_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Insert preparation for an indexed directory is split into two\n\t * steps. The call to find_dir_space_dx reserves room in the index for\n\t * an additional item. If we run out of space there, it's a real error\n\t * we can't continue on.\n\t */\n\tret = ocfs2_find_dir_space_dx(osb, dir, di_bh, dx_root_bh, name,\n\t\t\t\t      namelen, lookup);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nsearch_el:\n\t/*\n\t * Next, we need to find space in the unindexed tree. This call\n\t * searches using the free space linked list. If the unindexed tree\n\t * lacks sufficient space, we'll expand it below. The expansion code\n\t * is smart enough to add any new blocks to the free space list.\n\t */\n\tret = ocfs2_search_dx_free_list(dir, dx_root_bh, namelen, lookup);\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Do this up here - ocfs2_extend_dir might need the dx_root */\n\tlookup->dl_dx_root_bh = dx_root_bh;\n\tfree_dx_root = 0;\n\n\tif (ret == -ENOSPC) {\n\t\tret = ocfs2_extend_dir(osb, dir, di_bh, 1, lookup, &leaf_bh);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We make the assumption here that new leaf blocks are added\n\t\t * to the front of our free list.\n\t\t */\n\t\tlookup->dl_prev_leaf_bh = NULL;\n\t\tlookup->dl_leaf_bh = leaf_bh;\n\t}\n\nout:\n\tif (free_dx_root)\n\t\tbrelse(dx_root_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_inline_dx_has_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "4161-4174",
    "snippet": "static int ocfs2_inline_dx_has_space(struct buffer_head *dx_root_bh)\n{\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\tif (le16_to_cpu(entry_list->de_num_used) >=\n\t    le16_to_cpu(entry_list->de_count))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry_list->de_count"
          ],
          "line": 4170
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_inline_dx_has_space(struct buffer_head *dx_root_bh)\n{\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\tif (le16_to_cpu(entry_list->de_num_used) >=\n\t    le16_to_cpu(entry_list->de_count))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_expand_inline_dx_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "4045-4159",
    "snippet": "static int ocfs2_expand_inline_dx_root(struct inode *dir,\n\t\t\t\t       struct buffer_head *dx_root_bh)\n{\n\tint ret, num_dx_leaves, i, j, did_quota = 0;\n\tstruct buffer_head **dx_leaves = NULL;\n\tstruct ocfs2_extent_tree et;\n\tu64 insert_blkno;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\tstruct ocfs2_dx_entry *dx_entry;\n\tstruct ocfs2_dx_leaf *target_leaf;\n\n\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, &num_dx_leaves);\n\tif (!dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_calc_dxi_expand_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\t/*\n\t * We do this up front, before the allocation, so that a\n\t * failure to add the dx_root_bh to the journal won't result\n\t * us losing clusters.\n\t */\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_dx_dir_new_cluster(dir, 0, handle, data_ac, dx_leaves,\n\t\t\t\t\t num_dx_leaves, &insert_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Transfer the entries from our dx_root into the appropriate\n\t * block\n\t */\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\tfor (i = 0; i < le16_to_cpu(entry_list->de_num_used); i++) {\n\t\tdx_entry = &entry_list->de_entries[i];\n\n\t\tj = __ocfs2_dx_dir_hash_idx(osb,\n\t\t\t\t\t    le32_to_cpu(dx_entry->dx_minor_hash));\n\t\ttarget_leaf = (struct ocfs2_dx_leaf *)dx_leaves[j]->b_data;\n\n\t\tocfs2_dx_dir_leaf_insert_tail(target_leaf, dx_entry);\n\n\t\t/* Each leaf has been passed to the journal already\n\t\t * via __ocfs2_dx_dir_new_cluster() */\n\t}\n\n\tdx_root->dr_flags &= ~OCFS2_DX_FLAG_INLINE;\n\tmemset(&dx_root->dr_list, 0, osb->sb->s_blocksize -\n\t       offsetof(struct ocfs2_dx_root_block, dr_list));\n\tdx_root->dr_list.l_count =\n\t\tcpu_to_le16(ocfs2_extent_recs_per_dx_root(osb->sb));\n\n\t/* This should never fail considering we start with an empty\n\t * dx_root. */\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\tret = ocfs2_insert_extent(handle, &et, 0, insert_blkno, 1, 0, NULL);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tdid_quota = 0;\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(dir->i_sb, 1));\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tif (dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++)\n\t\t\tbrelse(dx_leaves[i]);\n\t\tkfree(dx_leaves);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dx_leaves"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dx_leaves[i]"
          ],
          "line": 4155
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "data_ac"
          ],
          "line": 4151
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 4147
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "dir",
            "ocfs2_clusters_to_bytes(dir->i_sb, 1)"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "dir->i_sb",
            "1"
          ],
          "line": 4145
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "dx_root_bh"
          ],
          "line": 4140
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "dir",
            "1"
          ],
          "line": 4139
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_extent",
          "args": [
            "handle",
            "&et",
            "0",
            "insert_blkno",
            "1",
            "0",
            "NULL"
          ],
          "line": 4134
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4665-4726",
          "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dx_root_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(dir)",
            "dx_root_bh"
          ],
          "line": 4133
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dx_root_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "482-488",
          "snippet": "void ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};\n\nvoid ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 4133
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_extent_recs_per_dx_root(osb->sb)"
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_recs_per_dx_root",
          "args": [
            "osb->sb"
          ],
          "line": 4129
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_recs_per_dx_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1329-1337",
          "snippet": "static inline int ocfs2_extent_recs_per_dx_root(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_dx_root_block, dr_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extent_recs_per_dx_root(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_dx_root_block, dr_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dx_root->dr_list",
            "0",
            "osb->sb->s_blocksize -\n\t       offsetof(struct ocfs2_dx_root_block, dr_list)"
          ],
          "line": 4126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_leaf_insert_tail",
          "args": [
            "target_leaf",
            "dx_entry"
          ],
          "line": 4119
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_leaf_insert_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1454-1463",
          "snippet": "static void ocfs2_dx_dir_leaf_insert_tail(struct ocfs2_dx_leaf *dx_leaf,\n\t\t\t\t\t  struct ocfs2_dx_entry *dx_new_entry)\n{\n\tint i;\n\n\ti = le16_to_cpu(dx_leaf->dl_list.de_num_used);\n\tdx_leaf->dl_list.de_entries[i] = *dx_new_entry;\n\n\tle16_add_cpu(&dx_leaf->dl_list.de_num_used, 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dx_dir_leaf_insert_tail(struct ocfs2_dx_leaf *dx_leaf,\n\t\t\t\t\t  struct ocfs2_dx_entry *dx_new_entry)\n{\n\tint i;\n\n\ti = le16_to_cpu(dx_leaf->dl_list.de_num_used);\n\tdx_leaf->dl_list.de_entries[i] = *dx_new_entry;\n\n\tle16_add_cpu(&dx_leaf->dl_list.de_num_used, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_dx_dir_hash_idx",
          "args": [
            "osb",
            "le32_to_cpu(dx_entry->dx_minor_hash)"
          ],
          "line": 4115
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_dx_dir_hash_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "859-863",
          "snippet": "static inline unsigned int __ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t\t   u32 minor_hash)\n{\n\treturn minor_hash & osb->osb_dx_mask;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int __ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t\t   u32 minor_hash)\n{\n\treturn minor_hash & osb->osb_dx_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dx_entry->dx_minor_hash"
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry_list->de_num_used"
          ],
          "line": 4112
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_dx_dir_new_cluster",
          "args": [
            "dir",
            "0",
            "handle",
            "data_ac",
            "dx_leaves",
            "num_dx_leaves",
            "&insert_blkno"
          ],
          "line": 4098
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_dx_dir_new_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2468-2506",
          "snippet": "static int __ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t      u32 cpos, handle_t *handle,\n\t\t\t\t      struct ocfs2_alloc_context *data_ac,\n\t\t\t\t      struct buffer_head **dx_leaves,\n\t\t\t\t      int num_dx_leaves, u64 *ret_phys_blkno)\n{\n\tint ret;\n\tu32 phys, num;\n\tu64 phys_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\t/*\n\t * XXX: For create, this should claim cluster for the index\n\t * *before* the unindexed insert so that we have a better\n\t * chance of contiguousness as the directory grows in number\n\t * of entries.\n\t */\n\tret = __ocfs2_claim_clusters(handle, data_ac, 1, 1, &phys, &num);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Format the new cluster first. That way, we're inserting\n\t * valid data.\n\t */\n\tphys_blkno = ocfs2_clusters_to_blocks(osb->sb, phys);\n\tret = ocfs2_dx_dir_format_cluster(osb, handle, dir, dx_leaves,\n\t\t\t\t\t  num_dx_leaves, phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_phys_blkno = phys_blkno;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int __ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t      u32 cpos, handle_t *handle,\n\t\t\t\t      struct ocfs2_alloc_context *data_ac,\n\t\t\t\t      struct buffer_head **dx_leaves,\n\t\t\t\t      int num_dx_leaves, u64 *ret_phys_blkno)\n{\n\tint ret;\n\tu32 phys, num;\n\tu64 phys_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\t/*\n\t * XXX: For create, this should claim cluster for the index\n\t * *before* the unindexed insert so that we have a better\n\t * chance of contiguousness as the directory grows in number\n\t * of entries.\n\t */\n\tret = __ocfs2_claim_clusters(handle, data_ac, 1, 1, &phys, &num);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Format the new cluster first. That way, we're inserting\n\t * valid data.\n\t */\n\tphys_blkno = ocfs2_clusters_to_blocks(osb->sb, phys);\n\tret = ocfs2_dx_dir_format_cluster(osb, handle, dir, dx_leaves,\n\t\t\t\t\t  num_dx_leaves, phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_phys_blkno = phys_blkno;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dr",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "dx_root_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 4091
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "753-757",
          "snippet": "int ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};\n\nint ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_space_nodirty",
          "args": [
            "dir",
            "ocfs2_clusters_to_bytes(osb->sb, 1)"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_calc_dxi_expand_credits(osb->sb)"
          ],
          "line": 4073
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_dxi_expand_credits",
          "args": [
            "osb->sb"
          ],
          "line": 4073
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_dxi_expand_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "499-507",
          "snippet": "static inline int ocfs2_calc_dxi_expand_credits(struct super_block *sb)\n{\n\tint credits = 1 + OCFS2_SUBALLOC_ALLOC;\n\n\tcredits += ocfs2_clusters_to_blocks(sb, 1);\n\tcredits += ocfs2_quota_trans_credits(sb);\n\n\treturn credits;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_dxi_expand_credits(struct super_block *sb)\n{\n\tint credits = 1 + OCFS2_SUBALLOC_ALLOC;\n\n\tcredits += ocfs2_clusters_to_blocks(sb, 1);\n\tcredits += ocfs2_quota_trans_credits(sb);\n\n\treturn credits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_kmalloc_leaves",
          "args": [
            "osb->sb",
            "&num_dx_leaves"
          ],
          "line": 4066
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters",
          "args": [
            "osb",
            "1",
            "&data_ac"
          ],
          "line": 4060
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1228-1234",
          "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 4053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_expand_inline_dx_root(struct inode *dir,\n\t\t\t\t       struct buffer_head *dx_root_bh)\n{\n\tint ret, num_dx_leaves, i, j, did_quota = 0;\n\tstruct buffer_head **dx_leaves = NULL;\n\tstruct ocfs2_extent_tree et;\n\tu64 insert_blkno;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\tstruct ocfs2_dx_entry *dx_entry;\n\tstruct ocfs2_dx_leaf *target_leaf;\n\n\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, &num_dx_leaves);\n\tif (!dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_calc_dxi_expand_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\t/*\n\t * We do this up front, before the allocation, so that a\n\t * failure to add the dx_root_bh to the journal won't result\n\t * us losing clusters.\n\t */\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_dx_dir_new_cluster(dir, 0, handle, data_ac, dx_leaves,\n\t\t\t\t\t num_dx_leaves, &insert_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Transfer the entries from our dx_root into the appropriate\n\t * block\n\t */\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\tfor (i = 0; i < le16_to_cpu(entry_list->de_num_used); i++) {\n\t\tdx_entry = &entry_list->de_entries[i];\n\n\t\tj = __ocfs2_dx_dir_hash_idx(osb,\n\t\t\t\t\t    le32_to_cpu(dx_entry->dx_minor_hash));\n\t\ttarget_leaf = (struct ocfs2_dx_leaf *)dx_leaves[j]->b_data;\n\n\t\tocfs2_dx_dir_leaf_insert_tail(target_leaf, dx_entry);\n\n\t\t/* Each leaf has been passed to the journal already\n\t\t * via __ocfs2_dx_dir_new_cluster() */\n\t}\n\n\tdx_root->dr_flags &= ~OCFS2_DX_FLAG_INLINE;\n\tmemset(&dx_root->dr_list, 0, osb->sb->s_blocksize -\n\t       offsetof(struct ocfs2_dx_root_block, dr_list));\n\tdx_root->dr_list.l_count =\n\t\tcpu_to_le16(ocfs2_extent_recs_per_dx_root(osb->sb));\n\n\t/* This should never fail considering we start with an empty\n\t * dx_root. */\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\tret = ocfs2_insert_extent(handle, &et, 0, insert_blkno, 1, 0, NULL);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tdid_quota = 0;\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(dir->i_sb, 1));\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tif (dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++)\n\t\t\tbrelse(dx_leaves[i]);\n\t\tkfree(dx_leaves);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_search_dx_free_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3997-4043",
    "snippet": "static int ocfs2_search_dx_free_list(struct inode *dir,\n\t\t\t\t     struct buffer_head *dx_root_bh,\n\t\t\t\t     int namelen,\n\t\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret = -ENOSPC;\n\tstruct buffer_head *leaf_bh = NULL, *prev_leaf_bh = NULL;\n\tstruct ocfs2_dir_block_trailer *db;\n\tu64 next_block;\n\tint rec_len = OCFS2_DIR_REC_LEN(namelen);\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tnext_block = le64_to_cpu(dx_root->dr_free_blk);\n\n\twhile (next_block) {\n\t\tbrelse(prev_leaf_bh);\n\t\tprev_leaf_bh = leaf_bh;\n\t\tleaf_bh = NULL;\n\n\t\tret = ocfs2_read_dir_block_direct(dir, next_block, &leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdb = ocfs2_trailer_from_bh(leaf_bh, dir->i_sb);\n\t\tif (rec_len <= le16_to_cpu(db->db_free_rec_len)) {\n\t\t\tlookup->dl_leaf_bh = leaf_bh;\n\t\t\tlookup->dl_prev_leaf_bh = prev_leaf_bh;\n\t\t\tleaf_bh = NULL;\n\t\t\tprev_leaf_bh = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tnext_block = le64_to_cpu(db->db_free_next);\n\t}\n\n\tif (!next_block)\n\t\tret = -ENOSPC;\n\nout:\n\n\tbrelse(leaf_bh);\n\tbrelse(prev_leaf_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "prev_leaf_bh"
          ],
          "line": 4041
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "db->db_free_next"
          ],
          "line": 4032
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "db->db_free_rec_len"
          ],
          "line": 4024
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_trailer_from_bh",
          "args": [
            "leaf_bh",
            "dir->i_sb"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_dir_block_direct",
          "args": [
            "dir",
            "next_block",
            "&leaf_bh"
          ],
          "line": 4017
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dir_block_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "559-586",
          "snippet": "static int ocfs2_read_dir_block_direct(struct inode *dir, u64 phys,\n\t\t\t\t       struct buffer_head **bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), phys, &tmp,\n\t\t\t       ocfs2_validate_dir_block);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tret = ocfs2_check_dir_trailer(dir, tmp);\n\t\tif (ret) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!ret && !*bh)\n\t\t*bh = tmp;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dir_block_direct(struct inode *dir, u64 phys,\n\t\t\t\t       struct buffer_head **bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), phys, &tmp,\n\t\t\t       ocfs2_validate_dir_block);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tret = ocfs2_check_dir_trailer(dir, tmp);\n\t\tif (ret) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!ret && !*bh)\n\t\t*bh = tmp;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "namelen"
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_search_dx_free_list(struct inode *dir,\n\t\t\t\t     struct buffer_head *dx_root_bh,\n\t\t\t\t     int namelen,\n\t\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret = -ENOSPC;\n\tstruct buffer_head *leaf_bh = NULL, *prev_leaf_bh = NULL;\n\tstruct ocfs2_dir_block_trailer *db;\n\tu64 next_block;\n\tint rec_len = OCFS2_DIR_REC_LEN(namelen);\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tnext_block = le64_to_cpu(dx_root->dr_free_blk);\n\n\twhile (next_block) {\n\t\tbrelse(prev_leaf_bh);\n\t\tprev_leaf_bh = leaf_bh;\n\t\tleaf_bh = NULL;\n\n\t\tret = ocfs2_read_dir_block_direct(dir, next_block, &leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdb = ocfs2_trailer_from_bh(leaf_bh, dir->i_sb);\n\t\tif (rec_len <= le16_to_cpu(db->db_free_rec_len)) {\n\t\t\tlookup->dl_leaf_bh = leaf_bh;\n\t\t\tlookup->dl_prev_leaf_bh = prev_leaf_bh;\n\t\t\tleaf_bh = NULL;\n\t\t\tprev_leaf_bh = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tnext_block = le64_to_cpu(db->db_free_next);\n\t}\n\n\tif (!next_block)\n\t\tret = -ENOSPC;\n\nout:\n\n\tbrelse(leaf_bh);\n\tbrelse(prev_leaf_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_dir_space_dx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3924-3995",
    "snippet": "static int ocfs2_find_dir_space_dx(struct ocfs2_super *osb, struct inode *dir,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   struct buffer_head *dx_root_bh,\n\t\t\t\t   const char *name, int namelen,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, rebalanced = 0;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *dx_leaf_bh = NULL;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tu64 blkno;\n\tu32 leaf_cpos;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\nrestart_search:\n\tret = ocfs2_dx_dir_lookup(dir, &dx_root->dr_list, &lookup->dl_hinfo,\n\t\t\t\t  &leaf_cpos, &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_dx_leaf(dir, blkno, &dx_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\n\tif (le16_to_cpu(dx_leaf->dl_list.de_num_used) >=\n\t    le16_to_cpu(dx_leaf->dl_list.de_count)) {\n\t\tif (rebalanced) {\n\t\t\t/*\n\t\t\t * Rebalancing should have provided us with\n\t\t\t * space in an appropriate leaf.\n\t\t\t *\n\t\t\t * XXX: Is this an abnormal condition then?\n\t\t\t * Should we print a message here?\n\t\t\t */\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_dx_dir_rebalance(osb, dir, dx_root_bh, dx_leaf_bh,\n\t\t\t\t\t     &lookup->dl_hinfo, leaf_cpos,\n\t\t\t\t\t     blkno);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Restart the lookup. The rebalance might have\n\t\t * changed which block our item fits into. Mark our\n\t\t * progress, so we only execute this once.\n\t\t */\n\t\tbrelse(dx_leaf_bh);\n\t\tdx_leaf_bh = NULL;\n\t\trebalanced = 1;\n\t\tgoto restart_search;\n\t}\n\n\tlookup->dl_dx_leaf_bh = dx_leaf_bh;\n\tdx_leaf_bh = NULL;\n\nout:\n\tbrelse(dx_leaf_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dx_leaf_bh"
          ],
          "line": 3993
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_rebalance",
          "args": [
            "osb",
            "dir",
            "dx_root_bh",
            "dx_leaf_bh",
            "&lookup->dl_hinfo",
            "leaf_cpos",
            "blkno"
          ],
          "line": 3969
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_rebalance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3729-3922",
          "snippet": "static int ocfs2_dx_dir_rebalance(struct ocfs2_super *osb, struct inode *dir,\n\t\t\t\t  struct buffer_head *dx_root_bh,\n\t\t\t\t  struct buffer_head *dx_leaf_bh,\n\t\t\t\t  struct ocfs2_dx_hinfo *hinfo, u32 leaf_cpos,\n\t\t\t\t  u64 leaf_blkno)\n{\n\tstruct ocfs2_dx_leaf *dx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\tint credits, ret, i, num_used, did_quota = 0;\n\tu32 cpos, split_hash, insert_hash = hinfo->major_hash;\n\tu64 orig_leaves_start;\n\tint num_dx_leaves;\n\tstruct buffer_head **orig_dx_leaves = NULL;\n\tstruct buffer_head **new_dx_leaves = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL, *meta_ac = NULL;\n\tstruct ocfs2_extent_tree et;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_leaf *tmp_dx_leaf = NULL;\n\n\ttrace_ocfs2_dx_dir_rebalance((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t     (unsigned long long)leaf_blkno,\n\t\t\t\t     insert_hash);\n\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\t/*\n\t * XXX: This is a rather large limit. We should use a more\n\t * realistic value.\n\t */\n\tif (le32_to_cpu(dx_root->dr_clusters) == UINT_MAX)\n\t\treturn -ENOSPC;\n\n\tnum_used = le16_to_cpu(dx_leaf->dl_list.de_num_used);\n\tif (num_used < le16_to_cpu(dx_leaf->dl_list.de_count)) {\n\t\tmlog(ML_ERROR, \"DX Dir: %llu, Asked to rebalance empty leaf: \"\n\t\t     \"%llu, %d\\n\", (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t     (unsigned long long)leaf_blkno, num_used);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\torig_dx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, &num_dx_leaves);\n\tif (!orig_dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_dx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, NULL);\n\tif (!new_dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_allocators(dir, &et, 1, 0, &data_ac, &meta_ac);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcredits = ocfs2_dx_dir_rebalance_credits(osb, dx_root);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\t\t\t       ocfs2_clusters_to_bytes(dir->i_sb, 1));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), dx_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * This block is changing anyway, so we can sort it in place.\n\t */\n\tsort(dx_leaf->dl_list.de_entries, num_used,\n\t     sizeof(struct ocfs2_dx_entry), dx_leaf_sort_cmp,\n\t     dx_leaf_sort_swap);\n\n\tocfs2_journal_dirty(handle, dx_leaf_bh);\n\n\tret = ocfs2_dx_dir_find_leaf_split(dx_leaf, leaf_cpos, insert_hash,\n\t\t\t\t\t   &split_hash);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto  out_commit;\n\t}\n\n\ttrace_ocfs2_dx_dir_rebalance_split(leaf_cpos, split_hash, insert_hash);\n\n\t/*\n\t * We have to carefully order operations here. There are items\n\t * which want to be in the new cluster before insert, but in\n\t * order to put those items in the new cluster, we alter the\n\t * old cluster. A failure to insert gets nasty.\n\t *\n\t * So, start by reserving writes to the old\n\t * cluster. ocfs2_dx_dir_new_cluster will reserve writes on\n\t * the new cluster for us, before inserting it. The insert\n\t * won't happen if there's an error before that. Once the\n\t * insert is done then, we can transfer from one leaf into the\n\t * other without fear of hitting any error.\n\t */\n\n\t/*\n\t * The leaf transfer wants some scratch space so that we don't\n\t * wind up doing a bunch of expensive memmove().\n\t */\n\ttmp_dx_leaf = kmalloc(osb->sb->s_blocksize, GFP_NOFS);\n\tif (!tmp_dx_leaf) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\torig_leaves_start = ocfs2_block_to_cluster_start(dir->i_sb, leaf_blkno);\n\tret = ocfs2_read_dx_leaves(dir, orig_leaves_start, num_dx_leaves,\n\t\t\t\t   orig_dx_leaves);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tcpos = split_hash;\n\tret = ocfs2_dx_dir_new_cluster(dir, &et, cpos, handle,\n\t\t\t\t       data_ac, meta_ac, new_dx_leaves,\n\t\t\t\t       num_dx_leaves);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      orig_dx_leaves[i],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      new_dx_leaves[i],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tocfs2_dx_dir_transfer_leaf(dir, split_hash, handle, tmp_dx_leaf,\n\t\t\t\t   orig_dx_leaves, new_dx_leaves, num_dx_leaves);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir,\n\t\t\t\tocfs2_clusters_to_bytes(dir->i_sb, 1));\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (orig_dx_leaves || new_dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\t\tif (orig_dx_leaves)\n\t\t\t\tbrelse(orig_dx_leaves[i]);\n\t\t\tif (new_dx_leaves)\n\t\t\t\tbrelse(new_dx_leaves[i]);\n\t\t}\n\t\tkfree(orig_dx_leaves);\n\t\tkfree(new_dx_leaves);\n\t}\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tkfree(tmp_dx_leaf);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_rebalance(struct ocfs2_super *osb, struct inode *dir,\n\t\t\t\t  struct buffer_head *dx_root_bh,\n\t\t\t\t  struct buffer_head *dx_leaf_bh,\n\t\t\t\t  struct ocfs2_dx_hinfo *hinfo, u32 leaf_cpos,\n\t\t\t\t  u64 leaf_blkno)\n{\n\tstruct ocfs2_dx_leaf *dx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\tint credits, ret, i, num_used, did_quota = 0;\n\tu32 cpos, split_hash, insert_hash = hinfo->major_hash;\n\tu64 orig_leaves_start;\n\tint num_dx_leaves;\n\tstruct buffer_head **orig_dx_leaves = NULL;\n\tstruct buffer_head **new_dx_leaves = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL, *meta_ac = NULL;\n\tstruct ocfs2_extent_tree et;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_leaf *tmp_dx_leaf = NULL;\n\n\ttrace_ocfs2_dx_dir_rebalance((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t     (unsigned long long)leaf_blkno,\n\t\t\t\t     insert_hash);\n\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\t/*\n\t * XXX: This is a rather large limit. We should use a more\n\t * realistic value.\n\t */\n\tif (le32_to_cpu(dx_root->dr_clusters) == UINT_MAX)\n\t\treturn -ENOSPC;\n\n\tnum_used = le16_to_cpu(dx_leaf->dl_list.de_num_used);\n\tif (num_used < le16_to_cpu(dx_leaf->dl_list.de_count)) {\n\t\tmlog(ML_ERROR, \"DX Dir: %llu, Asked to rebalance empty leaf: \"\n\t\t     \"%llu, %d\\n\", (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t     (unsigned long long)leaf_blkno, num_used);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\torig_dx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, &num_dx_leaves);\n\tif (!orig_dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_dx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, NULL);\n\tif (!new_dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_allocators(dir, &et, 1, 0, &data_ac, &meta_ac);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcredits = ocfs2_dx_dir_rebalance_credits(osb, dx_root);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\t\t\t       ocfs2_clusters_to_bytes(dir->i_sb, 1));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), dx_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * This block is changing anyway, so we can sort it in place.\n\t */\n\tsort(dx_leaf->dl_list.de_entries, num_used,\n\t     sizeof(struct ocfs2_dx_entry), dx_leaf_sort_cmp,\n\t     dx_leaf_sort_swap);\n\n\tocfs2_journal_dirty(handle, dx_leaf_bh);\n\n\tret = ocfs2_dx_dir_find_leaf_split(dx_leaf, leaf_cpos, insert_hash,\n\t\t\t\t\t   &split_hash);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto  out_commit;\n\t}\n\n\ttrace_ocfs2_dx_dir_rebalance_split(leaf_cpos, split_hash, insert_hash);\n\n\t/*\n\t * We have to carefully order operations here. There are items\n\t * which want to be in the new cluster before insert, but in\n\t * order to put those items in the new cluster, we alter the\n\t * old cluster. A failure to insert gets nasty.\n\t *\n\t * So, start by reserving writes to the old\n\t * cluster. ocfs2_dx_dir_new_cluster will reserve writes on\n\t * the new cluster for us, before inserting it. The insert\n\t * won't happen if there's an error before that. Once the\n\t * insert is done then, we can transfer from one leaf into the\n\t * other without fear of hitting any error.\n\t */\n\n\t/*\n\t * The leaf transfer wants some scratch space so that we don't\n\t * wind up doing a bunch of expensive memmove().\n\t */\n\ttmp_dx_leaf = kmalloc(osb->sb->s_blocksize, GFP_NOFS);\n\tif (!tmp_dx_leaf) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\torig_leaves_start = ocfs2_block_to_cluster_start(dir->i_sb, leaf_blkno);\n\tret = ocfs2_read_dx_leaves(dir, orig_leaves_start, num_dx_leaves,\n\t\t\t\t   orig_dx_leaves);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tcpos = split_hash;\n\tret = ocfs2_dx_dir_new_cluster(dir, &et, cpos, handle,\n\t\t\t\t       data_ac, meta_ac, new_dx_leaves,\n\t\t\t\t       num_dx_leaves);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      orig_dx_leaves[i],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      new_dx_leaves[i],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tocfs2_dx_dir_transfer_leaf(dir, split_hash, handle, tmp_dx_leaf,\n\t\t\t\t   orig_dx_leaves, new_dx_leaves, num_dx_leaves);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir,\n\t\t\t\tocfs2_clusters_to_bytes(dir->i_sb, 1));\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (orig_dx_leaves || new_dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\t\tif (orig_dx_leaves)\n\t\t\t\tbrelse(orig_dx_leaves[i]);\n\t\t\tif (new_dx_leaves)\n\t\t\t\tbrelse(new_dx_leaves[i]);\n\t\t}\n\t\tkfree(orig_dx_leaves);\n\t\tkfree(new_dx_leaves);\n\t}\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tkfree(tmp_dx_leaf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dx_leaf->dl_list.de_count"
          ],
          "line": 3956
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_dx_leaf",
          "args": [
            "dir",
            "blkno",
            "&dx_leaf_bh"
          ],
          "line": 3947
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dx_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "659-673",
          "snippet": "static int ocfs2_read_dx_leaf(struct inode *dir, u64 blkno,\n\t\t\t      struct buffer_head **dx_leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *dx_leaf_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_leaf);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_leaf_bh)\n\t\t*dx_leaf_bh = tmp;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dx_leaf(struct inode *dir, u64 blkno,\n\t\t\t      struct buffer_head **dx_leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *dx_leaf_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_leaf);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_leaf_bh)\n\t\t*dx_leaf_bh = tmp;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_lookup",
          "args": [
            "dir",
            "&dx_root->dr_list",
            "&lookup->dl_hinfo",
            "&leaf_cpos",
            "&blkno"
          ],
          "line": 3940
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "871-916",
          "snippet": "static int ocfs2_dx_dir_lookup(struct inode *inode,\n\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t       u32 *ret_cpos,\n\t\t\t       u64 *ret_phys_blkno)\n{\n\tint ret = 0;\n\tunsigned int cend, uninitialized_var(clen);\n\tu32 uninitialized_var(cpos);\n\tu64 uninitialized_var(blkno);\n\tu32 name_hash = hinfo->major_hash;\n\n\tret = ocfs2_dx_dir_lookup_rec(inode, el, name_hash, &cpos, &blkno,\n\t\t\t\t      &clen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcend = cpos + clen;\n\tif (name_hash >= cend) {\n\t\t/* We want the last cluster */\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, clen - 1);\n\t\tcpos += clen - 1;\n\t} else {\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t  name_hash - cpos);\n\t\tcpos = name_hash;\n\t}\n\n\t/*\n\t * We now have the cluster which should hold our entry. To\n\t * find the exact block from the start of the cluster to\n\t * search, we take the lower bits of the hash.\n\t */\n\tblkno += ocfs2_dx_dir_hash_idx(OCFS2_SB(inode->i_sb), hinfo);\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = blkno;\n\tif (ret_cpos)\n\t\t*ret_cpos = cpos;\n\nout:\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_lookup(struct inode *inode,\n\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t       u32 *ret_cpos,\n\t\t\t       u64 *ret_phys_blkno)\n{\n\tint ret = 0;\n\tunsigned int cend, uninitialized_var(clen);\n\tu32 uninitialized_var(cpos);\n\tu64 uninitialized_var(blkno);\n\tu32 name_hash = hinfo->major_hash;\n\n\tret = ocfs2_dx_dir_lookup_rec(inode, el, name_hash, &cpos, &blkno,\n\t\t\t\t      &clen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcend = cpos + clen;\n\tif (name_hash >= cend) {\n\t\t/* We want the last cluster */\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, clen - 1);\n\t\tcpos += clen - 1;\n\t} else {\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t  name_hash - cpos);\n\t\tcpos = name_hash;\n\t}\n\n\t/*\n\t * We now have the cluster which should hold our entry. To\n\t * find the exact block from the start of the cluster to\n\t * search, we take the lower bits of the hash.\n\t */\n\tblkno += ocfs2_dx_dir_hash_idx(OCFS2_SB(inode->i_sb), hinfo);\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = blkno;\n\tif (ret_cpos)\n\t\t*ret_cpos = cpos;\n\nout:\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_find_dir_space_dx(struct ocfs2_super *osb, struct inode *dir,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   struct buffer_head *dx_root_bh,\n\t\t\t\t   const char *name, int namelen,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, rebalanced = 0;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *dx_leaf_bh = NULL;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tu64 blkno;\n\tu32 leaf_cpos;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\nrestart_search:\n\tret = ocfs2_dx_dir_lookup(dir, &dx_root->dr_list, &lookup->dl_hinfo,\n\t\t\t\t  &leaf_cpos, &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_dx_leaf(dir, blkno, &dx_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\n\tif (le16_to_cpu(dx_leaf->dl_list.de_num_used) >=\n\t    le16_to_cpu(dx_leaf->dl_list.de_count)) {\n\t\tif (rebalanced) {\n\t\t\t/*\n\t\t\t * Rebalancing should have provided us with\n\t\t\t * space in an appropriate leaf.\n\t\t\t *\n\t\t\t * XXX: Is this an abnormal condition then?\n\t\t\t * Should we print a message here?\n\t\t\t */\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_dx_dir_rebalance(osb, dir, dx_root_bh, dx_leaf_bh,\n\t\t\t\t\t     &lookup->dl_hinfo, leaf_cpos,\n\t\t\t\t\t     blkno);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Restart the lookup. The rebalance might have\n\t\t * changed which block our item fits into. Mark our\n\t\t * progress, so we only execute this once.\n\t\t */\n\t\tbrelse(dx_leaf_bh);\n\t\tdx_leaf_bh = NULL;\n\t\trebalanced = 1;\n\t\tgoto restart_search;\n\t}\n\n\tlookup->dl_dx_leaf_bh = dx_leaf_bh;\n\tdx_leaf_bh = NULL;\n\nout:\n\tbrelse(dx_leaf_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_rebalance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3729-3922",
    "snippet": "static int ocfs2_dx_dir_rebalance(struct ocfs2_super *osb, struct inode *dir,\n\t\t\t\t  struct buffer_head *dx_root_bh,\n\t\t\t\t  struct buffer_head *dx_leaf_bh,\n\t\t\t\t  struct ocfs2_dx_hinfo *hinfo, u32 leaf_cpos,\n\t\t\t\t  u64 leaf_blkno)\n{\n\tstruct ocfs2_dx_leaf *dx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\tint credits, ret, i, num_used, did_quota = 0;\n\tu32 cpos, split_hash, insert_hash = hinfo->major_hash;\n\tu64 orig_leaves_start;\n\tint num_dx_leaves;\n\tstruct buffer_head **orig_dx_leaves = NULL;\n\tstruct buffer_head **new_dx_leaves = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL, *meta_ac = NULL;\n\tstruct ocfs2_extent_tree et;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_leaf *tmp_dx_leaf = NULL;\n\n\ttrace_ocfs2_dx_dir_rebalance((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t     (unsigned long long)leaf_blkno,\n\t\t\t\t     insert_hash);\n\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\t/*\n\t * XXX: This is a rather large limit. We should use a more\n\t * realistic value.\n\t */\n\tif (le32_to_cpu(dx_root->dr_clusters) == UINT_MAX)\n\t\treturn -ENOSPC;\n\n\tnum_used = le16_to_cpu(dx_leaf->dl_list.de_num_used);\n\tif (num_used < le16_to_cpu(dx_leaf->dl_list.de_count)) {\n\t\tmlog(ML_ERROR, \"DX Dir: %llu, Asked to rebalance empty leaf: \"\n\t\t     \"%llu, %d\\n\", (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t     (unsigned long long)leaf_blkno, num_used);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\torig_dx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, &num_dx_leaves);\n\tif (!orig_dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_dx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, NULL);\n\tif (!new_dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_allocators(dir, &et, 1, 0, &data_ac, &meta_ac);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcredits = ocfs2_dx_dir_rebalance_credits(osb, dx_root);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\t\t\t       ocfs2_clusters_to_bytes(dir->i_sb, 1));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), dx_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * This block is changing anyway, so we can sort it in place.\n\t */\n\tsort(dx_leaf->dl_list.de_entries, num_used,\n\t     sizeof(struct ocfs2_dx_entry), dx_leaf_sort_cmp,\n\t     dx_leaf_sort_swap);\n\n\tocfs2_journal_dirty(handle, dx_leaf_bh);\n\n\tret = ocfs2_dx_dir_find_leaf_split(dx_leaf, leaf_cpos, insert_hash,\n\t\t\t\t\t   &split_hash);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto  out_commit;\n\t}\n\n\ttrace_ocfs2_dx_dir_rebalance_split(leaf_cpos, split_hash, insert_hash);\n\n\t/*\n\t * We have to carefully order operations here. There are items\n\t * which want to be in the new cluster before insert, but in\n\t * order to put those items in the new cluster, we alter the\n\t * old cluster. A failure to insert gets nasty.\n\t *\n\t * So, start by reserving writes to the old\n\t * cluster. ocfs2_dx_dir_new_cluster will reserve writes on\n\t * the new cluster for us, before inserting it. The insert\n\t * won't happen if there's an error before that. Once the\n\t * insert is done then, we can transfer from one leaf into the\n\t * other without fear of hitting any error.\n\t */\n\n\t/*\n\t * The leaf transfer wants some scratch space so that we don't\n\t * wind up doing a bunch of expensive memmove().\n\t */\n\ttmp_dx_leaf = kmalloc(osb->sb->s_blocksize, GFP_NOFS);\n\tif (!tmp_dx_leaf) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\torig_leaves_start = ocfs2_block_to_cluster_start(dir->i_sb, leaf_blkno);\n\tret = ocfs2_read_dx_leaves(dir, orig_leaves_start, num_dx_leaves,\n\t\t\t\t   orig_dx_leaves);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tcpos = split_hash;\n\tret = ocfs2_dx_dir_new_cluster(dir, &et, cpos, handle,\n\t\t\t\t       data_ac, meta_ac, new_dx_leaves,\n\t\t\t\t       num_dx_leaves);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      orig_dx_leaves[i],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      new_dx_leaves[i],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tocfs2_dx_dir_transfer_leaf(dir, split_hash, handle, tmp_dx_leaf,\n\t\t\t\t   orig_dx_leaves, new_dx_leaves, num_dx_leaves);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir,\n\t\t\t\tocfs2_clusters_to_bytes(dir->i_sb, 1));\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (orig_dx_leaves || new_dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\t\tif (orig_dx_leaves)\n\t\t\t\tbrelse(orig_dx_leaves[i]);\n\t\t\tif (new_dx_leaves)\n\t\t\t\tbrelse(new_dx_leaves[i]);\n\t\t}\n\t\tkfree(orig_dx_leaves);\n\t\tkfree(new_dx_leaves);\n\t}\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tkfree(tmp_dx_leaf);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp_dx_leaf"
          ],
          "line": 3920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "data_ac"
          ],
          "line": 3918
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_dx_leaves"
          ],
          "line": 3912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orig_dx_leaves"
          ],
          "line": 3911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_dx_leaves[i]"
          ],
          "line": 3909
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 3901
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "dir",
            "1"
          ],
          "line": 3900
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "dir",
            "ocfs2_clusters_to_bytes(dir->i_sb, 1)"
          ],
          "line": 3897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "dir->i_sb",
            "1"
          ],
          "line": 3898
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_transfer_leaf",
          "args": [
            "dir",
            "split_hash",
            "handle",
            "tmp_dx_leaf",
            "orig_dx_leaves",
            "new_dx_leaves",
            "num_dx_leaves"
          ],
          "line": 3892
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_transfer_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3671-3713",
          "snippet": "static void ocfs2_dx_dir_transfer_leaf(struct inode *dir, u32 split_hash,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct ocfs2_dx_leaf *tmp_dx_leaf,\n\t\t\t\t       struct buffer_head **orig_dx_leaves,\n\t\t\t\t       struct buffer_head **new_dx_leaves,\n\t\t\t\t       int num_dx_leaves)\n{\n\tint i, j, num_used;\n\tu32 major_hash;\n\tstruct ocfs2_dx_leaf *orig_dx_leaf, *new_dx_leaf;\n\tstruct ocfs2_dx_entry_list *orig_list, *new_list, *tmp_list;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ttmp_list = &tmp_dx_leaf->dl_list;\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\torig_dx_leaf = (struct ocfs2_dx_leaf *) orig_dx_leaves[i]->b_data;\n\t\torig_list = &orig_dx_leaf->dl_list;\n\t\tnew_dx_leaf = (struct ocfs2_dx_leaf *) new_dx_leaves[i]->b_data;\n\t\tnew_list = &new_dx_leaf->dl_list;\n\n\t\tnum_used = le16_to_cpu(orig_list->de_num_used);\n\n\t\tmemcpy(tmp_dx_leaf, orig_dx_leaf, dir->i_sb->s_blocksize);\n\t\ttmp_list->de_num_used = cpu_to_le16(0);\n\t\tmemset(&tmp_list->de_entries, 0, sizeof(*dx_entry)*num_used);\n\n\t\tfor (j = 0; j < num_used; j++) {\n\t\t\tdx_entry = &orig_list->de_entries[j];\n\t\t\tmajor_hash = le32_to_cpu(dx_entry->dx_major_hash);\n\t\t\tif (major_hash >= split_hash)\n\t\t\t\tocfs2_dx_dir_leaf_insert_tail(new_dx_leaf,\n\t\t\t\t\t\t\t      dx_entry);\n\t\t\telse\n\t\t\t\tocfs2_dx_dir_leaf_insert_tail(tmp_dx_leaf,\n\t\t\t\t\t\t\t      dx_entry);\n\t\t}\n\t\tmemcpy(orig_dx_leaf, tmp_dx_leaf, dir->i_sb->s_blocksize);\n\n\t\tocfs2_journal_dirty(handle, orig_dx_leaves[i]);\n\t\tocfs2_journal_dirty(handle, new_dx_leaves[i]);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_dx_dir_transfer_leaf(struct inode *dir, u32 split_hash,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct ocfs2_dx_leaf *tmp_dx_leaf,\n\t\t\t\t       struct buffer_head **orig_dx_leaves,\n\t\t\t\t       struct buffer_head **new_dx_leaves,\n\t\t\t\t       int num_dx_leaves)\n{\n\tint i, j, num_used;\n\tu32 major_hash;\n\tstruct ocfs2_dx_leaf *orig_dx_leaf, *new_dx_leaf;\n\tstruct ocfs2_dx_entry_list *orig_list, *new_list, *tmp_list;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ttmp_list = &tmp_dx_leaf->dl_list;\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\torig_dx_leaf = (struct ocfs2_dx_leaf *) orig_dx_leaves[i]->b_data;\n\t\torig_list = &orig_dx_leaf->dl_list;\n\t\tnew_dx_leaf = (struct ocfs2_dx_leaf *) new_dx_leaves[i]->b_data;\n\t\tnew_list = &new_dx_leaf->dl_list;\n\n\t\tnum_used = le16_to_cpu(orig_list->de_num_used);\n\n\t\tmemcpy(tmp_dx_leaf, orig_dx_leaf, dir->i_sb->s_blocksize);\n\t\ttmp_list->de_num_used = cpu_to_le16(0);\n\t\tmemset(&tmp_list->de_entries, 0, sizeof(*dx_entry)*num_used);\n\n\t\tfor (j = 0; j < num_used; j++) {\n\t\t\tdx_entry = &orig_list->de_entries[j];\n\t\t\tmajor_hash = le32_to_cpu(dx_entry->dx_major_hash);\n\t\t\tif (major_hash >= split_hash)\n\t\t\t\tocfs2_dx_dir_leaf_insert_tail(new_dx_leaf,\n\t\t\t\t\t\t\t      dx_entry);\n\t\t\telse\n\t\t\t\tocfs2_dx_dir_leaf_insert_tail(tmp_dx_leaf,\n\t\t\t\t\t\t\t      dx_entry);\n\t\t}\n\t\tmemcpy(orig_dx_leaf, tmp_dx_leaf, dir->i_sb->s_blocksize);\n\n\t\tocfs2_journal_dirty(handle, orig_dx_leaves[i]);\n\t\tocfs2_journal_dirty(handle, new_dx_leaves[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dl",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "new_dx_leaves[i]",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 3883
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "759-763",
          "snippet": "int ocfs2_journal_access_dl(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dl_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dl_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_leaf, dl_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dl_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_leaf, dl_check),\n};\n\nint ocfs2_journal_access_dl(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dl_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 3883
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_new_cluster",
          "args": [
            "dir",
            "&et",
            "cpos",
            "handle",
            "data_ac",
            "meta_ac",
            "new_dx_leaves",
            "num_dx_leaves"
          ],
          "line": 3866
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_new_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2508-2532",
          "snippet": "static int ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    u32 cpos, handle_t *handle,\n\t\t\t\t    struct ocfs2_alloc_context *data_ac,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct buffer_head **dx_leaves,\n\t\t\t\t    int num_dx_leaves)\n{\n\tint ret;\n\tu64 phys_blkno;\n\n\tret = __ocfs2_dx_dir_new_cluster(dir, cpos, handle, data_ac, dx_leaves,\n\t\t\t\t\t num_dx_leaves, &phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_insert_extent(handle, et, cpos, phys_blkno, 1, 0,\n\t\t\t\t  meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    u32 cpos, handle_t *handle,\n\t\t\t\t    struct ocfs2_alloc_context *data_ac,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct buffer_head **dx_leaves,\n\t\t\t\t    int num_dx_leaves)\n{\n\tint ret;\n\tu64 phys_blkno;\n\n\tret = __ocfs2_dx_dir_new_cluster(dir, cpos, handle, data_ac, dx_leaves,\n\t\t\t\t\t num_dx_leaves, &phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_insert_extent(handle, et, cpos, phys_blkno, 1, 0,\n\t\t\t\t  meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_dx_leaves",
          "args": [
            "dir",
            "orig_leaves_start",
            "num_dx_leaves",
            "orig_dx_leaves"
          ],
          "line": 3858
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dx_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "679-690",
          "snippet": "static int ocfs2_read_dx_leaves(struct inode *dir, u64 start, int num,\n\t\t\t\tstruct buffer_head **dx_leaf_bhs)\n{\n\tint ret;\n\n\tret = ocfs2_read_blocks(INODE_CACHE(dir), start, num, dx_leaf_bhs, 0,\n\t\t\t\tocfs2_validate_dx_leaf);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dx_leaves(struct inode *dir, u64 start, int num,\n\t\t\t\tstruct buffer_head **dx_leaf_bhs)\n{\n\tint ret;\n\n\tret = ocfs2_read_blocks(INODE_CACHE(dir), start, num, dx_leaf_bhs, 0,\n\t\t\t\tocfs2_validate_dx_leaf);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_to_cluster_start",
          "args": [
            "dir->i_sb",
            "leaf_blkno"
          ],
          "line": 3857
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_to_cluster_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "765-773",
          "snippet": "static inline u64 ocfs2_block_to_cluster_start(struct super_block *sb,\n\t\t\t\t\t       u64 blocks)\n{\n\tint bits = OCFS2_SB(sb)->s_clustersize_bits - sb->s_blocksize_bits;\n\tunsigned int clusters;\n\n\tclusters = ocfs2_blocks_to_clusters(sb, blocks);\n\treturn (u64)clusters << bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_block_to_cluster_start(struct super_block *sb,\n\t\t\t\t\t       u64 blocks)\n{\n\tint bits = OCFS2_SB(sb)->s_clustersize_bits - sb->s_blocksize_bits;\n\tunsigned int clusters;\n\n\tclusters = ocfs2_blocks_to_clusters(sb, blocks);\n\treturn (u64)clusters << bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "osb->sb->s_blocksize",
            "GFP_NOFS"
          ],
          "line": 3850
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dx_dir_rebalance_split",
          "args": [
            "leaf_cpos",
            "split_hash",
            "insert_hash"
          ],
          "line": 3830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_find_leaf_split",
          "args": [
            "dx_leaf",
            "leaf_cpos",
            "insert_hash",
            "&split_hash"
          ],
          "line": 3823
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_find_leaf_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3582-3660",
          "snippet": "static int ocfs2_dx_dir_find_leaf_split(struct ocfs2_dx_leaf *dx_leaf,\n\t\t\t\t\tu32 leaf_cpos, u32 insert_hash,\n\t\t\t\t\tu32 *split_hash)\n{\n\tstruct ocfs2_dx_entry_list *dl_list = &dx_leaf->dl_list;\n\tint i, num_used = le16_to_cpu(dl_list->de_num_used);\n\tint allsame;\n\n\t/*\n\t * There's a couple rare, but nasty corner cases we have to\n\t * check for here. All of them involve a leaf where all value\n\t * have the same hash, which is what we look for first.\n\t *\n\t * Most of the time, all of the above is false, and we simply\n\t * pick the median value for a split.\n\t */\n\tallsame = ocfs2_dx_leaf_same_major(dx_leaf);\n\tif (allsame) {\n\t\tu32 val = le32_to_cpu(dl_list->de_entries[0].dx_major_hash);\n\n\t\tif (val == insert_hash) {\n\t\t\t/*\n\t\t\t * No matter where we would choose to split,\n\t\t\t * the new entry would want to occupy the same\n\t\t\t * block as these. Since there's no space left\n\t\t\t * in their existing block, we know there\n\t\t\t * won't be space after the split.\n\t\t\t */\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tif (val == leaf_cpos) {\n\t\t\t/*\n\t\t\t * Because val is the same as leaf_cpos (which\n\t\t\t * is the smallest value this leaf can have),\n\t\t\t * yet is not equal to insert_hash, then we\n\t\t\t * know that insert_hash *must* be larger than\n\t\t\t * val (and leaf_cpos). At least cpos+1 in value.\n\t\t\t *\n\t\t\t * We also know then, that there cannot be an\n\t\t\t * adjacent extent (otherwise we'd be looking\n\t\t\t * at it). Choosing this value gives us a\n\t\t\t * chance to get some contiguousness.\n\t\t\t */\n\t\t\t*split_hash = leaf_cpos + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (val > insert_hash) {\n\t\t\t/*\n\t\t\t * val can not be the same as insert hash, and\n\t\t\t * also must be larger than leaf_cpos. Also,\n\t\t\t * we know that there can't be a leaf between\n\t\t\t * cpos and val, otherwise the entries with\n\t\t\t * hash 'val' would be there.\n\t\t\t */\n\t\t\t*split_hash = val;\n\t\t\treturn 0;\n\t\t}\n\n\t\t*split_hash = insert_hash;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Since the records are sorted and the checks above\n\t * guaranteed that not all records in this block are the same,\n\t * we simple travel forward, from the median, and pick the 1st\n\t * record whose value is larger than leaf_cpos.\n\t */\n\tfor (i = (num_used / 2); i < num_used; i++)\n\t\tif (le32_to_cpu(dl_list->de_entries[i].dx_major_hash) >\n\t\t    leaf_cpos)\n\t\t\tbreak;\n\n\tBUG_ON(i == num_used); /* Should be impossible */\n\t*split_hash = le32_to_cpu(dl_list->de_entries[i].dx_major_hash);\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dx_dir_find_leaf_split(struct ocfs2_dx_leaf *dx_leaf,\n\t\t\t\t\tu32 leaf_cpos, u32 insert_hash,\n\t\t\t\t\tu32 *split_hash)\n{\n\tstruct ocfs2_dx_entry_list *dl_list = &dx_leaf->dl_list;\n\tint i, num_used = le16_to_cpu(dl_list->de_num_used);\n\tint allsame;\n\n\t/*\n\t * There's a couple rare, but nasty corner cases we have to\n\t * check for here. All of them involve a leaf where all value\n\t * have the same hash, which is what we look for first.\n\t *\n\t * Most of the time, all of the above is false, and we simply\n\t * pick the median value for a split.\n\t */\n\tallsame = ocfs2_dx_leaf_same_major(dx_leaf);\n\tif (allsame) {\n\t\tu32 val = le32_to_cpu(dl_list->de_entries[0].dx_major_hash);\n\n\t\tif (val == insert_hash) {\n\t\t\t/*\n\t\t\t * No matter where we would choose to split,\n\t\t\t * the new entry would want to occupy the same\n\t\t\t * block as these. Since there's no space left\n\t\t\t * in their existing block, we know there\n\t\t\t * won't be space after the split.\n\t\t\t */\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tif (val == leaf_cpos) {\n\t\t\t/*\n\t\t\t * Because val is the same as leaf_cpos (which\n\t\t\t * is the smallest value this leaf can have),\n\t\t\t * yet is not equal to insert_hash, then we\n\t\t\t * know that insert_hash *must* be larger than\n\t\t\t * val (and leaf_cpos). At least cpos+1 in value.\n\t\t\t *\n\t\t\t * We also know then, that there cannot be an\n\t\t\t * adjacent extent (otherwise we'd be looking\n\t\t\t * at it). Choosing this value gives us a\n\t\t\t * chance to get some contiguousness.\n\t\t\t */\n\t\t\t*split_hash = leaf_cpos + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (val > insert_hash) {\n\t\t\t/*\n\t\t\t * val can not be the same as insert hash, and\n\t\t\t * also must be larger than leaf_cpos. Also,\n\t\t\t * we know that there can't be a leaf between\n\t\t\t * cpos and val, otherwise the entries with\n\t\t\t * hash 'val' would be there.\n\t\t\t */\n\t\t\t*split_hash = val;\n\t\t\treturn 0;\n\t\t}\n\n\t\t*split_hash = insert_hash;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Since the records are sorted and the checks above\n\t * guaranteed that not all records in this block are the same,\n\t * we simple travel forward, from the median, and pick the 1st\n\t * record whose value is larger than leaf_cpos.\n\t */\n\tfor (i = (num_used / 2); i < num_used; i++)\n\t\tif (le32_to_cpu(dl_list->de_entries[i].dx_major_hash) >\n\t\t    leaf_cpos)\n\t\t\tbreak;\n\n\tBUG_ON(i == num_used); /* Should be impossible */\n\t*split_hash = le32_to_cpu(dl_list->de_entries[i].dx_major_hash);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "dx_leaf_bh"
          ],
          "line": 3821
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "dx_leaf->dl_list.de_entries",
            "num_used",
            "sizeof(struct ocfs2_dx_entry)",
            "dx_leaf_sort_cmp",
            "dx_leaf_sort_swap"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_space_nodirty",
          "args": [
            "dir",
            "ocfs2_clusters_to_bytes(dir->i_sb, 1)"
          ],
          "line": 3801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 3793
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_rebalance_credits",
          "args": [
            "osb",
            "dx_root"
          ],
          "line": 3792
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_rebalance_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3715-3723",
          "snippet": "static int ocfs2_dx_dir_rebalance_credits(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_root_block *dx_root)\n{\n\tint credits = ocfs2_clusters_to_blocks(osb->sb, 2);\n\n\tcredits += ocfs2_calc_extend_credits(osb->sb, &dx_root->dr_list);\n\tcredits += ocfs2_quota_trans_credits(osb->sb);\n\treturn credits;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dx_dir_rebalance_credits(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_root_block *dx_root)\n{\n\tint credits = ocfs2_clusters_to_blocks(osb->sb, 2);\n\n\tcredits += ocfs2_calc_extend_credits(osb->sb, &dx_root->dr_list);\n\tcredits += ocfs2_quota_trans_credits(osb->sb);\n\treturn credits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_allocators",
          "args": [
            "dir",
            "&et",
            "1",
            "0",
            "&data_ac",
            "&meta_ac"
          ],
          "line": 3785
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_allocators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2674-2743",
          "snippet": "int ocfs2_lock_allocators(struct inode *inode,\n\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t  u32 clusters_to_add, u32 extents_to_split,\n\t\t\t  struct ocfs2_alloc_context **data_ac,\n\t\t\t  struct ocfs2_alloc_context **meta_ac)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = clusters_to_add + 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*meta_ac = NULL;\n\tif (data_ac)\n\t\t*data_ac = NULL;\n\n\tBUG_ON(clusters_to_add != 0 && data_ac == NULL);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Sparse allocation file systems need to be more conservative\n\t * with reserving room for expansion - the actual allocation\n\t * happens while we've got a journal handle open so re-taking\n\t * a cluster lock (because we ran out of room for another\n\t * extent) will violate ordering rules.\n\t *\n\t * Most of the time we'll only be seeing this 1 cluster at a time\n\t * anyway.\n\t *\n\t * Always lock for any unwritten extents - we might want to\n\t * add blocks during a split.\n\t */\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed)) {\n\t\tret = ocfs2_reserve_new_metadata(osb, et->et_root_el, meta_ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_to_add == 0)\n\t\tgoto out;\n\n\tret = ocfs2_reserve_clusters(osb, clusters_to_add, data_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\n\t\t/*\n\t\t * We cannot have an error and a non null *data_ac.\n\t\t */\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_lock_allocators(struct inode *inode,\n\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t  u32 clusters_to_add, u32 extents_to_split,\n\t\t\t  struct ocfs2_alloc_context **data_ac,\n\t\t\t  struct ocfs2_alloc_context **meta_ac)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = clusters_to_add + 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*meta_ac = NULL;\n\tif (data_ac)\n\t\t*data_ac = NULL;\n\n\tBUG_ON(clusters_to_add != 0 && data_ac == NULL);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Sparse allocation file systems need to be more conservative\n\t * with reserving room for expansion - the actual allocation\n\t * happens while we've got a journal handle open so re-taking\n\t * a cluster lock (because we ran out of room for another\n\t * extent) will violate ordering rules.\n\t *\n\t * Most of the time we'll only be seeing this 1 cluster at a time\n\t * anyway.\n\t *\n\t * Always lock for any unwritten extents - we might want to\n\t * add blocks during a split.\n\t */\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed)) {\n\t\tret = ocfs2_reserve_new_metadata(osb, et->et_root_el, meta_ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_to_add == 0)\n\t\tgoto out;\n\n\tret = ocfs2_reserve_clusters(osb, clusters_to_add, data_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\n\t\t/*\n\t\t * We cannot have an error and a non null *data_ac.\n\t\t */\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"DX Dir: %llu, Asked to rebalance empty leaf: \"\n\t\t     \"%llu, %d\\n\"",
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "(unsigned long long)leaf_blkno",
            "num_used"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 3765
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dx_leaf->dl_list.de_count"
          ],
          "line": 3763
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dx_root->dr_clusters"
          ],
          "line": 3759
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dx_root_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(dir)",
            "dx_root_bh"
          ],
          "line": 3752
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dx_root_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "482-488",
          "snippet": "void ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};\n\nvoid ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dx_dir_rebalance",
          "args": [
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "(unsigned long long)leaf_blkno",
            "insert_hash"
          ],
          "line": 3748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_rebalance(struct ocfs2_super *osb, struct inode *dir,\n\t\t\t\t  struct buffer_head *dx_root_bh,\n\t\t\t\t  struct buffer_head *dx_leaf_bh,\n\t\t\t\t  struct ocfs2_dx_hinfo *hinfo, u32 leaf_cpos,\n\t\t\t\t  u64 leaf_blkno)\n{\n\tstruct ocfs2_dx_leaf *dx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\tint credits, ret, i, num_used, did_quota = 0;\n\tu32 cpos, split_hash, insert_hash = hinfo->major_hash;\n\tu64 orig_leaves_start;\n\tint num_dx_leaves;\n\tstruct buffer_head **orig_dx_leaves = NULL;\n\tstruct buffer_head **new_dx_leaves = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL, *meta_ac = NULL;\n\tstruct ocfs2_extent_tree et;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_leaf *tmp_dx_leaf = NULL;\n\n\ttrace_ocfs2_dx_dir_rebalance((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t     (unsigned long long)leaf_blkno,\n\t\t\t\t     insert_hash);\n\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\t/*\n\t * XXX: This is a rather large limit. We should use a more\n\t * realistic value.\n\t */\n\tif (le32_to_cpu(dx_root->dr_clusters) == UINT_MAX)\n\t\treturn -ENOSPC;\n\n\tnum_used = le16_to_cpu(dx_leaf->dl_list.de_num_used);\n\tif (num_used < le16_to_cpu(dx_leaf->dl_list.de_count)) {\n\t\tmlog(ML_ERROR, \"DX Dir: %llu, Asked to rebalance empty leaf: \"\n\t\t     \"%llu, %d\\n\", (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t     (unsigned long long)leaf_blkno, num_used);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\torig_dx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, &num_dx_leaves);\n\tif (!orig_dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_dx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, NULL);\n\tif (!new_dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_allocators(dir, &et, 1, 0, &data_ac, &meta_ac);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcredits = ocfs2_dx_dir_rebalance_credits(osb, dx_root);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\t\t\t       ocfs2_clusters_to_bytes(dir->i_sb, 1));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), dx_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * This block is changing anyway, so we can sort it in place.\n\t */\n\tsort(dx_leaf->dl_list.de_entries, num_used,\n\t     sizeof(struct ocfs2_dx_entry), dx_leaf_sort_cmp,\n\t     dx_leaf_sort_swap);\n\n\tocfs2_journal_dirty(handle, dx_leaf_bh);\n\n\tret = ocfs2_dx_dir_find_leaf_split(dx_leaf, leaf_cpos, insert_hash,\n\t\t\t\t\t   &split_hash);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto  out_commit;\n\t}\n\n\ttrace_ocfs2_dx_dir_rebalance_split(leaf_cpos, split_hash, insert_hash);\n\n\t/*\n\t * We have to carefully order operations here. There are items\n\t * which want to be in the new cluster before insert, but in\n\t * order to put those items in the new cluster, we alter the\n\t * old cluster. A failure to insert gets nasty.\n\t *\n\t * So, start by reserving writes to the old\n\t * cluster. ocfs2_dx_dir_new_cluster will reserve writes on\n\t * the new cluster for us, before inserting it. The insert\n\t * won't happen if there's an error before that. Once the\n\t * insert is done then, we can transfer from one leaf into the\n\t * other without fear of hitting any error.\n\t */\n\n\t/*\n\t * The leaf transfer wants some scratch space so that we don't\n\t * wind up doing a bunch of expensive memmove().\n\t */\n\ttmp_dx_leaf = kmalloc(osb->sb->s_blocksize, GFP_NOFS);\n\tif (!tmp_dx_leaf) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\torig_leaves_start = ocfs2_block_to_cluster_start(dir->i_sb, leaf_blkno);\n\tret = ocfs2_read_dx_leaves(dir, orig_leaves_start, num_dx_leaves,\n\t\t\t\t   orig_dx_leaves);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tcpos = split_hash;\n\tret = ocfs2_dx_dir_new_cluster(dir, &et, cpos, handle,\n\t\t\t\t       data_ac, meta_ac, new_dx_leaves,\n\t\t\t\t       num_dx_leaves);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      orig_dx_leaves[i],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      new_dx_leaves[i],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tocfs2_dx_dir_transfer_leaf(dir, split_hash, handle, tmp_dx_leaf,\n\t\t\t\t   orig_dx_leaves, new_dx_leaves, num_dx_leaves);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir,\n\t\t\t\tocfs2_clusters_to_bytes(dir->i_sb, 1));\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (orig_dx_leaves || new_dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\t\tif (orig_dx_leaves)\n\t\t\t\tbrelse(orig_dx_leaves[i]);\n\t\t\tif (new_dx_leaves)\n\t\t\t\tbrelse(new_dx_leaves[i]);\n\t\t}\n\t\tkfree(orig_dx_leaves);\n\t\tkfree(new_dx_leaves);\n\t}\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tkfree(tmp_dx_leaf);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_rebalance_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3715-3723",
    "snippet": "static int ocfs2_dx_dir_rebalance_credits(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_root_block *dx_root)\n{\n\tint credits = ocfs2_clusters_to_blocks(osb->sb, 2);\n\n\tcredits += ocfs2_calc_extend_credits(osb->sb, &dx_root->dr_list);\n\tcredits += ocfs2_quota_trans_credits(osb->sb);\n\treturn credits;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_quota_trans_credits",
          "args": [
            "osb->sb"
          ],
          "line": 3721
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_quota_trans_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "378-387",
          "snippet": "static inline int ocfs2_quota_trans_credits(struct super_block *sb)\n{\n\tint credits = 0;\n\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\treturn credits;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_QWRITE_CREDITS (OCFS2_QINFO_WRITE_CREDITS + \\\n\t\t\t      OCFS2_QUOTA_BLOCK_UPDATE_CREDITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_QWRITE_CREDITS (OCFS2_QINFO_WRITE_CREDITS + \\\n\t\t\t      OCFS2_QUOTA_BLOCK_UPDATE_CREDITS)\n\nstatic inline int ocfs2_quota_trans_credits(struct super_block *sb)\n{\n\tint credits = 0;\n\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\treturn credits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_extend_credits",
          "args": [
            "osb->sb",
            "&dx_root->dr_list"
          ],
          "line": 3720
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_extend_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "531-556",
          "snippet": "static inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "2"
          ],
          "line": 3718
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dx_dir_rebalance_credits(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_root_block *dx_root)\n{\n\tint credits = ocfs2_clusters_to_blocks(osb->sb, 2);\n\n\tcredits += ocfs2_calc_extend_credits(osb->sb, &dx_root->dr_list);\n\tcredits += ocfs2_quota_trans_credits(osb->sb);\n\treturn credits;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_transfer_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3671-3713",
    "snippet": "static void ocfs2_dx_dir_transfer_leaf(struct inode *dir, u32 split_hash,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct ocfs2_dx_leaf *tmp_dx_leaf,\n\t\t\t\t       struct buffer_head **orig_dx_leaves,\n\t\t\t\t       struct buffer_head **new_dx_leaves,\n\t\t\t\t       int num_dx_leaves)\n{\n\tint i, j, num_used;\n\tu32 major_hash;\n\tstruct ocfs2_dx_leaf *orig_dx_leaf, *new_dx_leaf;\n\tstruct ocfs2_dx_entry_list *orig_list, *new_list, *tmp_list;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ttmp_list = &tmp_dx_leaf->dl_list;\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\torig_dx_leaf = (struct ocfs2_dx_leaf *) orig_dx_leaves[i]->b_data;\n\t\torig_list = &orig_dx_leaf->dl_list;\n\t\tnew_dx_leaf = (struct ocfs2_dx_leaf *) new_dx_leaves[i]->b_data;\n\t\tnew_list = &new_dx_leaf->dl_list;\n\n\t\tnum_used = le16_to_cpu(orig_list->de_num_used);\n\n\t\tmemcpy(tmp_dx_leaf, orig_dx_leaf, dir->i_sb->s_blocksize);\n\t\ttmp_list->de_num_used = cpu_to_le16(0);\n\t\tmemset(&tmp_list->de_entries, 0, sizeof(*dx_entry)*num_used);\n\n\t\tfor (j = 0; j < num_used; j++) {\n\t\t\tdx_entry = &orig_list->de_entries[j];\n\t\t\tmajor_hash = le32_to_cpu(dx_entry->dx_major_hash);\n\t\t\tif (major_hash >= split_hash)\n\t\t\t\tocfs2_dx_dir_leaf_insert_tail(new_dx_leaf,\n\t\t\t\t\t\t\t      dx_entry);\n\t\t\telse\n\t\t\t\tocfs2_dx_dir_leaf_insert_tail(tmp_dx_leaf,\n\t\t\t\t\t\t\t      dx_entry);\n\t\t}\n\t\tmemcpy(orig_dx_leaf, tmp_dx_leaf, dir->i_sb->s_blocksize);\n\n\t\tocfs2_journal_dirty(handle, orig_dx_leaves[i]);\n\t\tocfs2_journal_dirty(handle, new_dx_leaves[i]);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "new_dx_leaves[i]"
          ],
          "line": 3711
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "orig_dx_leaf",
            "tmp_dx_leaf",
            "dir->i_sb->s_blocksize"
          ],
          "line": 3708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_leaf_insert_tail",
          "args": [
            "tmp_dx_leaf",
            "dx_entry"
          ],
          "line": 3705
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_leaf_insert_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1454-1463",
          "snippet": "static void ocfs2_dx_dir_leaf_insert_tail(struct ocfs2_dx_leaf *dx_leaf,\n\t\t\t\t\t  struct ocfs2_dx_entry *dx_new_entry)\n{\n\tint i;\n\n\ti = le16_to_cpu(dx_leaf->dl_list.de_num_used);\n\tdx_leaf->dl_list.de_entries[i] = *dx_new_entry;\n\n\tle16_add_cpu(&dx_leaf->dl_list.de_num_used, 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dx_dir_leaf_insert_tail(struct ocfs2_dx_leaf *dx_leaf,\n\t\t\t\t\t  struct ocfs2_dx_entry *dx_new_entry)\n{\n\tint i;\n\n\ti = le16_to_cpu(dx_leaf->dl_list.de_num_used);\n\tdx_leaf->dl_list.de_entries[i] = *dx_new_entry;\n\n\tle16_add_cpu(&dx_leaf->dl_list.de_num_used, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dx_entry->dx_major_hash"
          ],
          "line": 3700
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tmp_list->de_entries",
            "0",
            "sizeof(*dx_entry)*num_used"
          ],
          "line": 3696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0"
          ],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp_dx_leaf",
            "orig_dx_leaf",
            "dir->i_sb->s_blocksize"
          ],
          "line": 3694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "orig_list->de_num_used"
          ],
          "line": 3692
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_dx_dir_transfer_leaf(struct inode *dir, u32 split_hash,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct ocfs2_dx_leaf *tmp_dx_leaf,\n\t\t\t\t       struct buffer_head **orig_dx_leaves,\n\t\t\t\t       struct buffer_head **new_dx_leaves,\n\t\t\t\t       int num_dx_leaves)\n{\n\tint i, j, num_used;\n\tu32 major_hash;\n\tstruct ocfs2_dx_leaf *orig_dx_leaf, *new_dx_leaf;\n\tstruct ocfs2_dx_entry_list *orig_list, *new_list, *tmp_list;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ttmp_list = &tmp_dx_leaf->dl_list;\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\torig_dx_leaf = (struct ocfs2_dx_leaf *) orig_dx_leaves[i]->b_data;\n\t\torig_list = &orig_dx_leaf->dl_list;\n\t\tnew_dx_leaf = (struct ocfs2_dx_leaf *) new_dx_leaves[i]->b_data;\n\t\tnew_list = &new_dx_leaf->dl_list;\n\n\t\tnum_used = le16_to_cpu(orig_list->de_num_used);\n\n\t\tmemcpy(tmp_dx_leaf, orig_dx_leaf, dir->i_sb->s_blocksize);\n\t\ttmp_list->de_num_used = cpu_to_le16(0);\n\t\tmemset(&tmp_list->de_entries, 0, sizeof(*dx_entry)*num_used);\n\n\t\tfor (j = 0; j < num_used; j++) {\n\t\t\tdx_entry = &orig_list->de_entries[j];\n\t\t\tmajor_hash = le32_to_cpu(dx_entry->dx_major_hash);\n\t\t\tif (major_hash >= split_hash)\n\t\t\t\tocfs2_dx_dir_leaf_insert_tail(new_dx_leaf,\n\t\t\t\t\t\t\t      dx_entry);\n\t\t\telse\n\t\t\t\tocfs2_dx_dir_leaf_insert_tail(tmp_dx_leaf,\n\t\t\t\t\t\t\t      dx_entry);\n\t\t}\n\t\tmemcpy(orig_dx_leaf, tmp_dx_leaf, dir->i_sb->s_blocksize);\n\n\t\tocfs2_journal_dirty(handle, orig_dx_leaves[i]);\n\t\tocfs2_journal_dirty(handle, new_dx_leaves[i]);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_find_leaf_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3582-3660",
    "snippet": "static int ocfs2_dx_dir_find_leaf_split(struct ocfs2_dx_leaf *dx_leaf,\n\t\t\t\t\tu32 leaf_cpos, u32 insert_hash,\n\t\t\t\t\tu32 *split_hash)\n{\n\tstruct ocfs2_dx_entry_list *dl_list = &dx_leaf->dl_list;\n\tint i, num_used = le16_to_cpu(dl_list->de_num_used);\n\tint allsame;\n\n\t/*\n\t * There's a couple rare, but nasty corner cases we have to\n\t * check for here. All of them involve a leaf where all value\n\t * have the same hash, which is what we look for first.\n\t *\n\t * Most of the time, all of the above is false, and we simply\n\t * pick the median value for a split.\n\t */\n\tallsame = ocfs2_dx_leaf_same_major(dx_leaf);\n\tif (allsame) {\n\t\tu32 val = le32_to_cpu(dl_list->de_entries[0].dx_major_hash);\n\n\t\tif (val == insert_hash) {\n\t\t\t/*\n\t\t\t * No matter where we would choose to split,\n\t\t\t * the new entry would want to occupy the same\n\t\t\t * block as these. Since there's no space left\n\t\t\t * in their existing block, we know there\n\t\t\t * won't be space after the split.\n\t\t\t */\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tif (val == leaf_cpos) {\n\t\t\t/*\n\t\t\t * Because val is the same as leaf_cpos (which\n\t\t\t * is the smallest value this leaf can have),\n\t\t\t * yet is not equal to insert_hash, then we\n\t\t\t * know that insert_hash *must* be larger than\n\t\t\t * val (and leaf_cpos). At least cpos+1 in value.\n\t\t\t *\n\t\t\t * We also know then, that there cannot be an\n\t\t\t * adjacent extent (otherwise we'd be looking\n\t\t\t * at it). Choosing this value gives us a\n\t\t\t * chance to get some contiguousness.\n\t\t\t */\n\t\t\t*split_hash = leaf_cpos + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (val > insert_hash) {\n\t\t\t/*\n\t\t\t * val can not be the same as insert hash, and\n\t\t\t * also must be larger than leaf_cpos. Also,\n\t\t\t * we know that there can't be a leaf between\n\t\t\t * cpos and val, otherwise the entries with\n\t\t\t * hash 'val' would be there.\n\t\t\t */\n\t\t\t*split_hash = val;\n\t\t\treturn 0;\n\t\t}\n\n\t\t*split_hash = insert_hash;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Since the records are sorted and the checks above\n\t * guaranteed that not all records in this block are the same,\n\t * we simple travel forward, from the median, and pick the 1st\n\t * record whose value is larger than leaf_cpos.\n\t */\n\tfor (i = (num_used / 2); i < num_used; i++)\n\t\tif (le32_to_cpu(dl_list->de_entries[i].dx_major_hash) >\n\t\t    leaf_cpos)\n\t\t\tbreak;\n\n\tBUG_ON(i == num_used); /* Should be impossible */\n\t*split_hash = le32_to_cpu(dl_list->de_entries[i].dx_major_hash);\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dl_list->de_entries[i].dx_major_hash"
          ],
          "line": 3658
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i == num_used"
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_leaf_same_major",
          "args": [
            "dx_leaf"
          ],
          "line": 3598
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_leaf_same_major",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3558-3570",
          "snippet": "static int ocfs2_dx_leaf_same_major(struct ocfs2_dx_leaf *dx_leaf)\n{\n\tstruct ocfs2_dx_entry_list *dl_list = &dx_leaf->dl_list;\n\tint i, num = le16_to_cpu(dl_list->de_num_used);\n\n\tfor (i = 0; i < (num - 1); i++) {\n\t\tif (le32_to_cpu(dl_list->de_entries[i].dx_major_hash) !=\n\t\t    le32_to_cpu(dl_list->de_entries[i + 1].dx_major_hash))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dx_leaf_same_major(struct ocfs2_dx_leaf *dx_leaf)\n{\n\tstruct ocfs2_dx_entry_list *dl_list = &dx_leaf->dl_list;\n\tint i, num = le16_to_cpu(dl_list->de_num_used);\n\n\tfor (i = 0; i < (num - 1); i++) {\n\t\tif (le32_to_cpu(dl_list->de_entries[i].dx_major_hash) !=\n\t\t    le32_to_cpu(dl_list->de_entries[i + 1].dx_major_hash))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dl_list->de_num_used"
          ],
          "line": 3587
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dx_dir_find_leaf_split(struct ocfs2_dx_leaf *dx_leaf,\n\t\t\t\t\tu32 leaf_cpos, u32 insert_hash,\n\t\t\t\t\tu32 *split_hash)\n{\n\tstruct ocfs2_dx_entry_list *dl_list = &dx_leaf->dl_list;\n\tint i, num_used = le16_to_cpu(dl_list->de_num_used);\n\tint allsame;\n\n\t/*\n\t * There's a couple rare, but nasty corner cases we have to\n\t * check for here. All of them involve a leaf where all value\n\t * have the same hash, which is what we look for first.\n\t *\n\t * Most of the time, all of the above is false, and we simply\n\t * pick the median value for a split.\n\t */\n\tallsame = ocfs2_dx_leaf_same_major(dx_leaf);\n\tif (allsame) {\n\t\tu32 val = le32_to_cpu(dl_list->de_entries[0].dx_major_hash);\n\n\t\tif (val == insert_hash) {\n\t\t\t/*\n\t\t\t * No matter where we would choose to split,\n\t\t\t * the new entry would want to occupy the same\n\t\t\t * block as these. Since there's no space left\n\t\t\t * in their existing block, we know there\n\t\t\t * won't be space after the split.\n\t\t\t */\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tif (val == leaf_cpos) {\n\t\t\t/*\n\t\t\t * Because val is the same as leaf_cpos (which\n\t\t\t * is the smallest value this leaf can have),\n\t\t\t * yet is not equal to insert_hash, then we\n\t\t\t * know that insert_hash *must* be larger than\n\t\t\t * val (and leaf_cpos). At least cpos+1 in value.\n\t\t\t *\n\t\t\t * We also know then, that there cannot be an\n\t\t\t * adjacent extent (otherwise we'd be looking\n\t\t\t * at it). Choosing this value gives us a\n\t\t\t * chance to get some contiguousness.\n\t\t\t */\n\t\t\t*split_hash = leaf_cpos + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (val > insert_hash) {\n\t\t\t/*\n\t\t\t * val can not be the same as insert hash, and\n\t\t\t * also must be larger than leaf_cpos. Also,\n\t\t\t * we know that there can't be a leaf between\n\t\t\t * cpos and val, otherwise the entries with\n\t\t\t * hash 'val' would be there.\n\t\t\t */\n\t\t\t*split_hash = val;\n\t\t\treturn 0;\n\t\t}\n\n\t\t*split_hash = insert_hash;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Since the records are sorted and the checks above\n\t * guaranteed that not all records in this block are the same,\n\t * we simple travel forward, from the median, and pick the 1st\n\t * record whose value is larger than leaf_cpos.\n\t */\n\tfor (i = (num_used / 2); i < num_used; i++)\n\t\tif (le32_to_cpu(dl_list->de_entries[i].dx_major_hash) >\n\t\t    leaf_cpos)\n\t\t\tbreak;\n\n\tBUG_ON(i == num_used); /* Should be impossible */\n\t*split_hash = le32_to_cpu(dl_list->de_entries[i].dx_major_hash);\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dx_leaf_same_major",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3558-3570",
    "snippet": "static int ocfs2_dx_leaf_same_major(struct ocfs2_dx_leaf *dx_leaf)\n{\n\tstruct ocfs2_dx_entry_list *dl_list = &dx_leaf->dl_list;\n\tint i, num = le16_to_cpu(dl_list->de_num_used);\n\n\tfor (i = 0; i < (num - 1); i++) {\n\t\tif (le32_to_cpu(dl_list->de_entries[i].dx_major_hash) !=\n\t\t    le32_to_cpu(dl_list->de_entries[i + 1].dx_major_hash))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dl_list->de_entries[i + 1].dx_major_hash"
          ],
          "line": 3565
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dl_list->de_num_used"
          ],
          "line": 3561
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dx_leaf_same_major(struct ocfs2_dx_leaf *dx_leaf)\n{\n\tstruct ocfs2_dx_entry_list *dl_list = &dx_leaf->dl_list;\n\tint i, num = le16_to_cpu(dl_list->de_num_used);\n\n\tfor (i = 0; i < (num - 1); i++) {\n\t\tif (le32_to_cpu(dl_list->de_entries[i].dx_major_hash) !=\n\t\t    le32_to_cpu(dl_list->de_entries[i + 1].dx_major_hash))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "dx_leaf_sort_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3545-3556",
    "snippet": "static void dx_leaf_sort_swap(void *a, void *b, int size)\n{\n\tstruct ocfs2_dx_entry *entry1 = a;\n\tstruct ocfs2_dx_entry *entry2 = b;\n\tstruct ocfs2_dx_entry tmp;\n\n\tBUG_ON(size != sizeof(*entry1));\n\n\ttmp = *entry1;\n\t*entry1 = *entry2;\n\t*entry2 = tmp;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "size != sizeof(*entry1)"
          ],
          "line": 3551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void dx_leaf_sort_swap(void *a, void *b, int size)\n{\n\tstruct ocfs2_dx_entry *entry1 = a;\n\tstruct ocfs2_dx_entry *entry2 = b;\n\tstruct ocfs2_dx_entry tmp;\n\n\tBUG_ON(size != sizeof(*entry1));\n\n\ttmp = *entry1;\n\t*entry1 = *entry2;\n\t*entry2 = tmp;\n}"
  },
  {
    "function_name": "dx_leaf_sort_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3521-3543",
    "snippet": "static int dx_leaf_sort_cmp(const void *a, const void *b)\n{\n\tconst struct ocfs2_dx_entry *entry1 = a;\n\tconst struct ocfs2_dx_entry *entry2 = b;\n\tu32 major_hash1 = le32_to_cpu(entry1->dx_major_hash);\n\tu32 major_hash2 = le32_to_cpu(entry2->dx_major_hash);\n\tu32 minor_hash1 = le32_to_cpu(entry1->dx_minor_hash);\n\tu32 minor_hash2 = le32_to_cpu(entry2->dx_minor_hash);\n\n\tif (major_hash1 > major_hash2)\n\t\treturn 1;\n\tif (major_hash1 < major_hash2)\n\t\treturn -1;\n\n\t/*\n\t * It is not strictly necessary to sort by minor\n\t */\n\tif (minor_hash1 > minor_hash2)\n\t\treturn 1;\n\tif (minor_hash1 < minor_hash2)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry2->dx_minor_hash"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int dx_leaf_sort_cmp(const void *a, const void *b)\n{\n\tconst struct ocfs2_dx_entry *entry1 = a;\n\tconst struct ocfs2_dx_entry *entry2 = b;\n\tu32 major_hash1 = le32_to_cpu(entry1->dx_major_hash);\n\tu32 major_hash2 = le32_to_cpu(entry2->dx_major_hash);\n\tu32 minor_hash1 = le32_to_cpu(entry1->dx_minor_hash);\n\tu32 minor_hash2 = le32_to_cpu(entry2->dx_minor_hash);\n\n\tif (major_hash1 > major_hash2)\n\t\treturn 1;\n\tif (major_hash1 < major_hash2)\n\t\treturn -1;\n\n\t/*\n\t * It is not strictly necessary to sort by minor\n\t */\n\tif (minor_hash1 > minor_hash2)\n\t\treturn 1;\n\tif (minor_hash1 < minor_hash2)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_find_dir_space_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3447-3519",
    "snippet": "static int ocfs2_find_dir_space_el(struct inode *dir, const char *name,\n\t\t\t\t   int namelen, struct buffer_head **ret_de_bh)\n{\n\tunsigned long offset;\n\tstruct buffer_head *bh = NULL;\n\tunsigned short rec_len;\n\tstruct ocfs2_dir_entry *de;\n\tstruct super_block *sb = dir->i_sb;\n\tint status;\n\tint blocksize = dir->i_sb->s_blocksize;\n\n\tstatus = ocfs2_read_dir_block(dir, 0, &bh, 0);\n\tif (status)\n\t\tgoto bail;\n\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\toffset = 0;\n\tde = (struct ocfs2_dir_entry *) bh->b_data;\n\twhile (1) {\n\t\tif ((char *)de >= sb->s_blocksize + bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\n\t\t\tif (i_size_read(dir) <= offset) {\n\t\t\t\t/*\n\t\t\t\t * Caller will have to expand this\n\t\t\t\t * directory.\n\t\t\t\t */\n\t\t\t\tstatus = -ENOSPC;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tstatus = ocfs2_read_dir_block(dir,\n\t\t\t\t\t     offset >> sb->s_blocksize_bits,\n\t\t\t\t\t     &bh, 0);\n\t\t\tif (status)\n\t\t\t\tgoto bail;\n\n\t\t\t/* move to next block */\n\t\t\tde = (struct ocfs2_dir_entry *) bh->b_data;\n\t\t}\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tstatus = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ocfs2_skip_dir_trailer(dir, de, offset % blocksize,\n\t\t\t\t\t   blocksize))\n\t\t\tgoto next;\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\t/* Ok, we found a spot. Return this bh and let\n\t\t\t * the caller actually fill it in. */\n\t\t\t*ret_de_bh = bh;\n\t\t\tget_bh(*ret_de_bh);\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\nnext:\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)((char *) de + le16_to_cpu(de->rec_len));\n\t}\n\nbail:\n\tbrelse(bh);\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 3514
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 3510
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "*ret_de_bh"
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dirent_would_fit",
          "args": [
            "de",
            "rec_len"
          ],
          "line": 3500
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dirent_would_fit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1433-1452",
          "snippet": "static inline int ocfs2_dirent_would_fit(struct ocfs2_dir_entry *de,\n\t\t\t\t\t unsigned int new_rec_len)\n{\n\tunsigned int de_really_used;\n\n\t/* Check whether this is an empty record with enough space */\n\tif (le64_to_cpu(de->inode) == 0 &&\n\t    le16_to_cpu(de->rec_len) >= new_rec_len)\n\t\treturn 1;\n\n\t/*\n\t * Record might have free space at the end which we can\n\t * use.\n\t */\n\tde_really_used = OCFS2_DIR_REC_LEN(de->name_len);\n\tif (le16_to_cpu(de->rec_len) >= (de_really_used + new_rec_len))\n\t    return 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_dirent_would_fit(struct ocfs2_dir_entry *de,\n\t\t\t\t\t unsigned int new_rec_len)\n{\n\tunsigned int de_really_used;\n\n\t/* Check whether this is an empty record with enough space */\n\tif (le64_to_cpu(de->inode) == 0 &&\n\t    le16_to_cpu(de->rec_len) >= new_rec_len)\n\t\treturn 1;\n\n\t/*\n\t * Record might have free space at the end which we can\n\t * use.\n\t */\n\tde_really_used = OCFS2_DIR_REC_LEN(de->name_len);\n\tif (le16_to_cpu(de->rec_len) >= (de_really_used + new_rec_len))\n\t    return 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_skip_dir_trailer",
          "args": [
            "dir",
            "de",
            "offset % blocksize",
            "blocksize"
          ],
          "line": 3496
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_skip_dir_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "136-150",
          "snippet": "static int ocfs2_skip_dir_trailer(struct inode *dir,\n\t\t\t\t  struct ocfs2_dir_entry *de,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  unsigned long blklen)\n{\n\tunsigned long toff = blklen - sizeof(struct ocfs2_dir_block_trailer);\n\n\tif (!ocfs2_supports_dir_trailer(dir))\n\t\treturn 0;\n\n\tif (offset != toff)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_skip_dir_trailer(struct inode *dir,\n\t\t\t\t  struct ocfs2_dir_entry *de,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  unsigned long blklen)\n{\n\tunsigned long toff = blklen - sizeof(struct ocfs2_dir_block_trailer);\n\n\tif (!ocfs2_supports_dir_trailer(dir))\n\t\treturn 0;\n\n\tif (offset != toff)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_match",
          "args": [
            "namelen",
            "name",
            "de"
          ],
          "line": 3491
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "344-353",
          "snippet": "static inline int ocfs2_match(int len,\n\t\t\t      const char * const name,\n\t\t\t      struct ocfs2_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_match(int len,\n\t\t\t      const char * const name,\n\t\t\t      struct ocfs2_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_entry",
          "args": [
            "dir",
            "de",
            "bh",
            "offset"
          ],
          "line": 3487
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "316-342",
          "snippet": "static int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_dir_block",
          "args": [
            "dir",
            "offset >> sb->s_blocksize_bits",
            "&bh",
            "0"
          ],
          "line": 3478
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dir_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "522-552",
          "snippet": "static int ocfs2_read_dir_block(struct inode *inode, u64 v_block,\n\t\t\t\tstruct buffer_head **bh, int flags)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, flags,\n\t\t\t\t    ocfs2_validate_dir_block);\n\tif (rc) {\n\t\tmlog_errno(rc);\n\t\tgoto out;\n\t}\n\n\tif (!(flags & OCFS2_BH_READAHEAD) &&\n\t    ocfs2_supports_dir_trailer(inode)) {\n\t\trc = ocfs2_check_dir_trailer(inode, tmp);\n\t\tif (rc) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc ? -EIO : 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dir_block(struct inode *inode, u64 v_block,\n\t\t\t\tstruct buffer_head **bh, int flags)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, flags,\n\t\t\t\t    ocfs2_validate_dir_block);\n\tif (rc) {\n\t\tmlog_errno(rc);\n\t\tgoto out;\n\t}\n\n\tif (!(flags & OCFS2_BH_READAHEAD) &&\n\t    ocfs2_supports_dir_trailer(inode)) {\n\t\trc = ocfs2_check_dir_trailer(inode, tmp);\n\t\tif (rc) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc ? -EIO : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "namelen"
          ],
          "line": 3462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_find_dir_space_el(struct inode *dir, const char *name,\n\t\t\t\t   int namelen, struct buffer_head **ret_de_bh)\n{\n\tunsigned long offset;\n\tstruct buffer_head *bh = NULL;\n\tunsigned short rec_len;\n\tstruct ocfs2_dir_entry *de;\n\tstruct super_block *sb = dir->i_sb;\n\tint status;\n\tint blocksize = dir->i_sb->s_blocksize;\n\n\tstatus = ocfs2_read_dir_block(dir, 0, &bh, 0);\n\tif (status)\n\t\tgoto bail;\n\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\toffset = 0;\n\tde = (struct ocfs2_dir_entry *) bh->b_data;\n\twhile (1) {\n\t\tif ((char *)de >= sb->s_blocksize + bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\n\t\t\tif (i_size_read(dir) <= offset) {\n\t\t\t\t/*\n\t\t\t\t * Caller will have to expand this\n\t\t\t\t * directory.\n\t\t\t\t */\n\t\t\t\tstatus = -ENOSPC;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tstatus = ocfs2_read_dir_block(dir,\n\t\t\t\t\t     offset >> sb->s_blocksize_bits,\n\t\t\t\t\t     &bh, 0);\n\t\t\tif (status)\n\t\t\t\tgoto bail;\n\n\t\t\t/* move to next block */\n\t\t\tde = (struct ocfs2_dir_entry *) bh->b_data;\n\t\t}\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tstatus = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ocfs2_skip_dir_trailer(dir, de, offset % blocksize,\n\t\t\t\t\t   blocksize))\n\t\t\tgoto next;\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\t/* Ok, we found a spot. Return this bh and let\n\t\t\t * the caller actually fill it in. */\n\t\t\t*ret_de_bh = bh;\n\t\t\tget_bh(*ret_de_bh);\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\nnext:\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)((char *) de + le16_to_cpu(de->rec_len));\n\t}\n\nbail:\n\tbrelse(bh);\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_find_dir_space_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3376-3445",
    "snippet": "static int ocfs2_find_dir_space_id(struct inode *dir, struct buffer_head *di_bh,\n\t\t\t\t   const char *name, int namelen,\n\t\t\t\t   struct buffer_head **ret_de_bh,\n\t\t\t\t   unsigned int *blocks_wanted)\n{\n\tint ret;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dir_entry *de, *last_de = NULL;\n\tchar *de_buf, *limit;\n\tunsigned long offset = 0;\n\tunsigned int rec_len, new_rec_len, free_space = dir->i_sb->s_blocksize;\n\n\t/*\n\t * This calculates how many free bytes we'd have in block zero, should\n\t * this function force expansion to an extent tree.\n\t */\n\tif (ocfs2_new_dir_wants_trailer(dir))\n\t\tfree_space = ocfs2_dir_trailer_blk_off(sb) - i_size_read(dir);\n\telse\n\t\tfree_space = dir->i_sb->s_blocksize - i_size_read(dir);\n\n\tde_buf = di->id2.i_data.id_data;\n\tlimit = de_buf + i_size_read(dir);\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (!ocfs2_check_dir_entry(dir, de, di_bh, offset)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * No need to check for a trailing dirent record here as\n\t\t * they're not used for inline dirs.\n\t\t */\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\t/* Ok, we found a spot. Return this bh and let\n\t\t\t * the caller actually fill it in. */\n\t\t\t*ret_de_bh = di_bh;\n\t\t\tget_bh(*ret_de_bh);\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_de = de;\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\toffset += le16_to_cpu(de->rec_len);\n\t}\n\n\t/*\n\t * We're going to require expansion of the directory - figure\n\t * out how many blocks we'll need so that a place for the\n\t * dirent can be found.\n\t */\n\t*blocks_wanted = 1;\n\tnew_rec_len = le16_to_cpu(last_de->rec_len) + free_space;\n\tif (new_rec_len < (rec_len + OCFS2_DIR_REC_LEN(last_de->name_len)))\n\t\t*blocks_wanted = 2;\n\n\tret = -ENOSPC;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "last_de->name_len"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "last_de->rec_len"
          ],
          "line": 3438
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "*ret_de_bh"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dirent_would_fit",
          "args": [
            "de",
            "rec_len"
          ],
          "line": 3418
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dirent_would_fit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1433-1452",
          "snippet": "static inline int ocfs2_dirent_would_fit(struct ocfs2_dir_entry *de,\n\t\t\t\t\t unsigned int new_rec_len)\n{\n\tunsigned int de_really_used;\n\n\t/* Check whether this is an empty record with enough space */\n\tif (le64_to_cpu(de->inode) == 0 &&\n\t    le16_to_cpu(de->rec_len) >= new_rec_len)\n\t\treturn 1;\n\n\t/*\n\t * Record might have free space at the end which we can\n\t * use.\n\t */\n\tde_really_used = OCFS2_DIR_REC_LEN(de->name_len);\n\tif (le16_to_cpu(de->rec_len) >= (de_really_used + new_rec_len))\n\t    return 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_dirent_would_fit(struct ocfs2_dir_entry *de,\n\t\t\t\t\t unsigned int new_rec_len)\n{\n\tunsigned int de_really_used;\n\n\t/* Check whether this is an empty record with enough space */\n\tif (le64_to_cpu(de->inode) == 0 &&\n\t    le16_to_cpu(de->rec_len) >= new_rec_len)\n\t\treturn 1;\n\n\t/*\n\t * Record might have free space at the end which we can\n\t * use.\n\t */\n\tde_really_used = OCFS2_DIR_REC_LEN(de->name_len);\n\tif (le16_to_cpu(de->rec_len) >= (de_really_used + new_rec_len))\n\t    return 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_match",
          "args": [
            "namelen",
            "name",
            "de"
          ],
          "line": 3409
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "344-353",
          "snippet": "static inline int ocfs2_match(int len,\n\t\t\t      const char * const name,\n\t\t\t      struct ocfs2_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_match(int len,\n\t\t\t      const char * const name,\n\t\t\t      struct ocfs2_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_entry",
          "args": [
            "dir",
            "de",
            "di_bh",
            "offset"
          ],
          "line": 3405
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "316-342",
          "snippet": "static int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "namelen"
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_trailer_blk_off",
          "args": [
            "sb"
          ],
          "line": 3394
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_trailer_blk_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "114-117",
          "snippet": "static inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_new_dir_wants_trailer",
          "args": [
            "dir"
          ],
          "line": 3393
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_dir_wants_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "106-112",
          "snippet": "static int ocfs2_new_dir_wants_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\treturn ocfs2_meta_ecc(osb) ||\n\t\tocfs2_supports_indexed_dirs(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_new_dir_wants_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\treturn ocfs2_meta_ecc(osb) ||\n\t\tocfs2_supports_indexed_dirs(osb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_find_dir_space_id(struct inode *dir, struct buffer_head *di_bh,\n\t\t\t\t   const char *name, int namelen,\n\t\t\t\t   struct buffer_head **ret_de_bh,\n\t\t\t\t   unsigned int *blocks_wanted)\n{\n\tint ret;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dir_entry *de, *last_de = NULL;\n\tchar *de_buf, *limit;\n\tunsigned long offset = 0;\n\tunsigned int rec_len, new_rec_len, free_space = dir->i_sb->s_blocksize;\n\n\t/*\n\t * This calculates how many free bytes we'd have in block zero, should\n\t * this function force expansion to an extent tree.\n\t */\n\tif (ocfs2_new_dir_wants_trailer(dir))\n\t\tfree_space = ocfs2_dir_trailer_blk_off(sb) - i_size_read(dir);\n\telse\n\t\tfree_space = dir->i_sb->s_blocksize - i_size_read(dir);\n\n\tde_buf = di->id2.i_data.id_data;\n\tlimit = de_buf + i_size_read(dir);\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (!ocfs2_check_dir_entry(dir, de, di_bh, offset)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * No need to check for a trailing dirent record here as\n\t\t * they're not used for inline dirs.\n\t\t */\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\t/* Ok, we found a spot. Return this bh and let\n\t\t\t * the caller actually fill it in. */\n\t\t\t*ret_de_bh = di_bh;\n\t\t\tget_bh(*ret_de_bh);\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_de = de;\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\toffset += le16_to_cpu(de->rec_len);\n\t}\n\n\t/*\n\t * We're going to require expansion of the directory - figure\n\t * out how many blocks we'll need so that a place for the\n\t * dirent can be found.\n\t */\n\t*blocks_wanted = 1;\n\tnew_rec_len = le16_to_cpu(last_de->rec_len) + free_space;\n\tif (new_rec_len < (rec_len + OCFS2_DIR_REC_LEN(last_de->name_len)))\n\t\t*blocks_wanted = 2;\n\n\tret = -ENOSPC;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_extend_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3187-3374",
    "snippet": "static int ocfs2_extend_dir(struct ocfs2_super *osb,\n\t\t\t    struct inode *dir,\n\t\t\t    struct buffer_head *parent_fe_bh,\n\t\t\t    unsigned int blocks_wanted,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct buffer_head **new_de_bh)\n{\n\tint status = 0;\n\tint credits, num_free_extents, drop_alloc_sem = 0;\n\tloff_t dir_i_size;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tstruct ocfs2_extent_list *el = &fe->id2.i_list;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry * de;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_extent_tree et;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t/*\n\t\t * This would be a code error as an inline directory should\n\t\t * never have an index root.\n\t\t */\n\t\tBUG_ON(dx_root_bh);\n\n\t\tstatus = ocfs2_expand_inline_dir(dir, parent_fe_bh,\n\t\t\t\t\t\t blocks_wanted, lookup,\n\t\t\t\t\t\t &new_bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Expansion from inline to an indexed directory will\n\t\t * have given us this. */\n\t\tdx_root_bh = lookup->dl_dx_root_bh;\n\n\t\tif (blocks_wanted == 1) {\n\t\t\t/*\n\t\t\t * If the new dirent will fit inside the space\n\t\t\t * created by pushing out to one block, then\n\t\t\t * we can complete the operation\n\t\t\t * here. Otherwise we have to expand i_size\n\t\t\t * and format the 2nd block below.\n\t\t\t */\n\t\t\tBUG_ON(new_bh == NULL);\n\t\t\tgoto bail_bh;\n\t\t}\n\n\t\t/*\n\t\t * Get rid of 'new_bh' - we want to format the 2nd\n\t\t * data block and return that instead.\n\t\t */\n\t\tbrelse(new_bh);\n\t\tnew_bh = NULL;\n\n\t\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\t\tdrop_alloc_sem = 1;\n\t\tdir_i_size = i_size_read(dir);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t\tgoto do_extend;\n\t}\n\n\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\tdrop_alloc_sem = 1;\n\tdir_i_size = i_size_read(dir);\n\ttrace_ocfs2_extend_dir((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t       dir_i_size);\n\n\t/* dir->i_size is always block aligned. */\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tif (dir_i_size == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters)) {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(dir),\n\t\t\t\t\t      parent_fe_bh);\n\t\tnum_free_extents = ocfs2_num_free_extents(osb, &et);\n\t\tif (num_free_extents < 0) {\n\t\t\tstatus = num_free_extents;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!num_free_extents) {\n\t\t\tstatus = ocfs2_reserve_new_metadata(osb, el, &meta_ac);\n\t\t\tif (status < 0) {\n\t\t\t\tif (status != -ENOSPC)\n\t\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ocfs2_dir_resv_allowed(osb))\n\t\t\tdata_ac->ac_resv = &OCFS2_I(dir)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(sb, el);\n\t} else {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t}\n\ndo_extend:\n\tif (ocfs2_dir_indexed(dir))\n\t\tcredits++; /* For attaching the new dirent block to the\n\t\t\t    * dx_root */\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, dir, parent_fe_bh,\n\t\t\t\t     data_ac, meta_ac, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(dir), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, sb->s_blocksize);\n\n\tde = (struct ocfs2_dir_entry *) new_bh->b_data;\n\tde->inode = 0;\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tde->rec_len = cpu_to_le16(ocfs2_dir_trailer_blk_off(sb));\n\n\t\tocfs2_init_dir_trailer(dir, new_bh, le16_to_cpu(de->rec_len));\n\n\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\tstatus = ocfs2_dx_dir_link_trailer(dir, handle,\n\t\t\t\t\t\t\t   dx_root_bh, new_bh);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tde->rec_len = cpu_to_le16(sb->s_blocksize);\n\t}\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tdir_i_size += dir->i_sb->s_blocksize;\n\ti_size_write(dir, dir_i_size);\n\tdir->i_blocks = ocfs2_inode_sector_count(dir);\n\tstatus = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail_bh:\n\t*new_de_bh = new_bh;\n\tget_bh(*new_de_bh);\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\tif (drop_alloc_sem)\n\t\tup_write(&OCFS2_I(dir)->ip_alloc_sem);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tbrelse(new_bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);",
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 3371
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "meta_ac"
          ],
          "line": 3369
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&OCFS2_I(dir)->ip_alloc_sem"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 3362
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "*new_de_bh"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "dir",
            "parent_fe_bh"
          ],
          "line": 3351
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1250-1289",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "dir"
          ],
          "line": 3350
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "dir",
            "dir_i_size"
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "new_bh"
          ],
          "line": 3346
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "dir",
            "1"
          ],
          "line": 3345
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sb->s_blocksize"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_link_trailer",
          "args": [
            "dir",
            "handle",
            "dx_root_bh",
            "new_bh"
          ],
          "line": 3335
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_link_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "170-194",
          "snippet": "static int ocfs2_dx_dir_link_trailer(struct inode *dir, handle_t *handle,\n\t\t\t\t     struct buffer_head *dx_root_bh,\n\t\t\t\t     struct buffer_head *dirdata_bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\ttrailer = ocfs2_trailer_from_bh(dirdata_bh, dir->i_sb);\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\ttrailer->db_free_next = dx_root->dr_free_blk;\n\tdx_root->dr_free_blk = cpu_to_le64(dirdata_bh->b_blocknr);\n\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_link_trailer(struct inode *dir, handle_t *handle,\n\t\t\t\t     struct buffer_head *dx_root_bh,\n\t\t\t\t     struct buffer_head *dirdata_bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\ttrailer = ocfs2_trailer_from_bh(dirdata_bh, dir->i_sb);\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\ttrailer->db_free_next = dx_root->dr_free_blk;\n\tdx_root->dr_free_blk = cpu_to_le64(dirdata_bh->b_blocknr);\n\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_indexed",
          "args": [
            "dir"
          ],
          "line": 3334
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_indexed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "209-214",
          "snippet": "static int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dir_trailer",
          "args": [
            "dir",
            "new_bh",
            "le16_to_cpu(de->rec_len)"
          ],
          "line": 3332
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dir_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "152-164",
          "snippet": "static void ocfs2_init_dir_trailer(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh, u16 rec_len)\n{\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, inode->i_sb);\n\tstrcpy(trailer->db_signature, OCFS2_DIR_TRAILER_SIGNATURE);\n\ttrailer->db_compat_rec_len =\n\t\t\tcpu_to_le16(sizeof(struct ocfs2_dir_block_trailer));\n\ttrailer->db_parent_dinode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\ttrailer->db_blkno = cpu_to_le64(bh->b_blocknr);\n\ttrailer->db_free_rec_len = cpu_to_le16(rec_len);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_init_dir_trailer(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh, u16 rec_len)\n{\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, inode->i_sb);\n\tstrcpy(trailer->db_signature, OCFS2_DIR_TRAILER_SIGNATURE);\n\ttrailer->db_compat_rec_len =\n\t\t\tcpu_to_le16(sizeof(struct ocfs2_dir_block_trailer));\n\ttrailer->db_parent_dinode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\ttrailer->db_blkno = cpu_to_le64(bh->b_blocknr);\n\ttrailer->db_free_rec_len = cpu_to_le16(rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 3332
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_dir_trailer_blk_off(sb)"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_trailer_blk_off",
          "args": [
            "sb"
          ],
          "line": 3330
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_trailer_blk_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "114-117",
          "snippet": "static inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_dir_trailer",
          "args": [
            "dir"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_dir_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "88-96",
          "snippet": "static int ocfs2_supports_dir_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\treturn ocfs2_meta_ecc(osb) || ocfs2_dir_indexed(dir);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_supports_dir_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\treturn ocfs2_meta_ecc(osb) || ocfs2_dir_indexed(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_bh->b_data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_db",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "new_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 3319
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "735-739",
          "snippet": "int ocfs2_journal_access_db(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &db_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers db_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_db_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers db_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_db_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_db(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &db_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 3319
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(dir)",
            "new_bh"
          ],
          "line": 3317
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_do_extend_dir",
          "args": [
            "osb->sb",
            "handle",
            "dir",
            "parent_fe_bh",
            "data_ac",
            "meta_ac",
            "&new_bh"
          ],
          "line": 3310
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_do_extend_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3122-3175",
          "snippet": "static int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh)\n{\n\tint status;\n\tint extend, did_quota = 0;\n\tu64 p_blkno, v_blkno;\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\textend = (i_size_read(dir) == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters));\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tif (extend) {\n\t\tu32 offset = OCFS2_I(dir)->ip_clusters;\n\n\t\tstatus = dquot_alloc_space_nodirty(dir,\n\t\t\t\t\tocfs2_clusters_to_bytes(sb, 1));\n\t\tif (status)\n\t\t\tgoto bail;\n\t\tdid_quota = 1;\n\n\t\tstatus = ocfs2_add_inode_data(OCFS2_SB(sb), dir, &offset,\n\t\t\t\t\t      1, 0, parent_fe_bh, handle,\n\t\t\t\t\t      data_ac, meta_ac, NULL);\n\t\tBUG_ON(status == -EAGAIN);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tv_blkno = ocfs2_blocks_for_bytes(sb, i_size_read(dir));\n\tstatus = ocfs2_extent_map_get_blocks(dir, v_blkno, &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*new_bh = sb_getblk(sb, p_blkno);\n\tif (!*new_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = 0;\nbail:\n\tif (did_quota && status < 0)\n\t\tdquot_free_space_nodirty(dir, ocfs2_clusters_to_bytes(sb, 1));\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);",
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh)\n{\n\tint status;\n\tint extend, did_quota = 0;\n\tu64 p_blkno, v_blkno;\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\textend = (i_size_read(dir) == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters));\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tif (extend) {\n\t\tu32 offset = OCFS2_I(dir)->ip_clusters;\n\n\t\tstatus = dquot_alloc_space_nodirty(dir,\n\t\t\t\t\tocfs2_clusters_to_bytes(sb, 1));\n\t\tif (status)\n\t\t\tgoto bail;\n\t\tdid_quota = 1;\n\n\t\tstatus = ocfs2_add_inode_data(OCFS2_SB(sb), dir, &offset,\n\t\t\t\t\t      1, 0, parent_fe_bh, handle,\n\t\t\t\t\t      data_ac, meta_ac, NULL);\n\t\tBUG_ON(status == -EAGAIN);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tv_blkno = ocfs2_blocks_for_bytes(sb, i_size_read(dir));\n\tstatus = ocfs2_extent_map_get_blocks(dir, v_blkno, &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*new_bh = sb_getblk(sb, p_blkno);\n\tif (!*new_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = 0;\nbail:\n\tif (did_quota && status < 0)\n\t\tdquot_free_space_nodirty(dir, ocfs2_clusters_to_bytes(sb, 1));\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 3302
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(dir)->ip_lock"
          ],
          "line": 3293
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_extend_credits",
          "args": [
            "sb",
            "el"
          ],
          "line": 3291
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_extend_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "531-556",
          "snippet": "static inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_resv_allowed",
          "args": [
            "osb"
          ],
          "line": 3288
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_resv_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "47-50",
          "snippet": "int ocfs2_dir_resv_allowed(struct ocfs2_super *osb)\n{\n\treturn (osb->osb_resv_level && osb->osb_dir_resv_level);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_dir_resv_allowed(struct ocfs2_super *osb)\n{\n\treturn (osb->osb_resv_level && osb->osb_dir_resv_level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters",
          "args": [
            "osb",
            "1",
            "&data_ac"
          ],
          "line": 3281
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1228-1234",
          "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata",
          "args": [
            "osb",
            "el",
            "&meta_ac"
          ],
          "line": 3273
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1051-1058",
          "snippet": "int ocfs2_reserve_new_metadata(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_extent_list *root_el,\n\t\t\t       struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_new_metadata_blocks(osb,\n\t\t\t\t\tocfs2_extend_meta_needed(root_el),\n\t\t\t\t\tac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_extent_list *root_el,\n\t\t\t       struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_new_metadata_blocks(osb,\n\t\t\t\t\tocfs2_extend_meta_needed(root_el),\n\t\t\t\t\tac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_num_free_extents",
          "args": [
            "osb",
            "&et"
          ],
          "line": 3265
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_num_free_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "959-990",
          "snippet": "int ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(dir)",
            "parent_fe_bh"
          ],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "458-464",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "sb",
            "OCFS2_I(dir)->ip_clusters"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(dir)->ip_lock"
          ],
          "line": 3260
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_extend_dir",
          "args": [
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "dir_i_size"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&OCFS2_I(dir)->ip_alloc_sem"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&OCFS2_I(dir)->ip_alloc_sem"
          ],
          "line": 3246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_bh == NULL"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_expand_inline_dir",
          "args": [
            "dir",
            "parent_fe_bh",
            "blocks_wanted",
            "lookup",
            "&new_bh"
          ],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_expand_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2805-3119",
          "snippet": "static int ocfs2_expand_inline_dir(struct inode *dir, struct buffer_head *di_bh,\n\t\t\t\t   unsigned int blocks_wanted,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t   struct buffer_head **first_block_bh)\n{\n\tu32 alloc, dx_alloc, bit_off, len, num_dx_entries = 0;\n\tstruct super_block *sb = dir->i_sb;\n\tint ret, i, num_dx_leaves = 0, dx_inline = 0,\n\t\tcredits = ocfs2_inline_to_extents_credits(sb);\n\tu64 dx_insert_blkno, blkno,\n\t\tbytes = blocks_wanted << sb->s_blocksize_bits;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(dir);\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct buffer_head *dirdata_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct buffer_head **dx_leaves = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\thandle_t *handle;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_extent_tree dx_et;\n\tint did_quota = 0, bytes_allocated = 0;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(dir), di_bh);\n\n\talloc = ocfs2_clusters_for_bytes(sb, bytes);\n\tdx_alloc = 0;\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tcredits += ocfs2_add_dir_index_credits(sb);\n\n\t\tdx_inline = ocfs2_new_dx_should_be_inline(dir, di_bh);\n\t\tif (!dx_inline) {\n\t\t\t/* Add one more cluster for an index leaf */\n\t\t\tdx_alloc++;\n\t\t\tdx_leaves = ocfs2_dx_dir_kmalloc_leaves(sb,\n\t\t\t\t\t\t\t\t&num_dx_leaves);\n\t\t\tif (!dx_leaves) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* This gets us the dx_root */\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We should never need more than 2 clusters for the unindexed\n\t * tree - maximum dirent size is far less than one block. In\n\t * fact, the only time we'd need more than one cluster is if\n\t * blocksize == clustersize and the dirent won't fit in the\n\t * extra space that the expansion to a single block gives. As\n\t * of today, that only happens on 4k/4k file systems.\n\t */\n\tBUG_ON(alloc > 2);\n\n\tret = ocfs2_reserve_clusters(osb, alloc + dx_alloc, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Prepare for worst case allocation scenario of two separate\n\t * extents in the unindexed tree.\n\t */\n\tif (alloc == 2)\n\t\tcredits += OCFS2_SUBALLOC_ALLOC;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\tocfs2_clusters_to_bytes(osb->sb, alloc + dx_alloc));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\tif (ocfs2_supports_indexed_dirs(osb) && !dx_inline) {\n\t\t/*\n\t\t * Allocate our index cluster first, to maximize the\n\t\t * possibility that unindexed leaves grow\n\t\t * contiguously.\n\t\t */\n\t\tret = __ocfs2_dx_dir_new_cluster(dir, 0, handle, data_ac,\n\t\t\t\t\t\t dx_leaves, num_dx_leaves,\n\t\t\t\t\t\t &dx_insert_blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\t}\n\n\t/*\n\t * Try to claim as many clusters as the bitmap can give though\n\t * if we only get one now, that's enough to continue. The rest\n\t * will be claimed after the conversion to extents.\n\t */\n\tif (ocfs2_dir_resv_allowed(osb))\n\t\tdata_ac->ac_resv = &oi->ip_la_data_resv;\n\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off, &len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\n\t/*\n\t * Operations are carefully ordered so that we set up the new\n\t * data block first. The conversion from inline data to\n\t * extents follows.\n\t */\n\tblkno = ocfs2_clusters_to_blocks(dir->i_sb, bit_off);\n\tdirdata_bh = sb_getblk(sb, blkno);\n\tif (!dirdata_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), dirdata_bh);\n\n\tret = ocfs2_journal_access_db(handle, INODE_CACHE(dir), dirdata_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(dirdata_bh->b_data, di->id2.i_data.id_data, i_size_read(dir));\n\tmemset(dirdata_bh->b_data + i_size_read(dir), 0,\n\t       sb->s_blocksize - i_size_read(dir));\n\ti = ocfs2_expand_last_dirent(dirdata_bh->b_data, i_size_read(dir), dir);\n\tif (ocfs2_new_dir_wants_trailer(dir)) {\n\t\t/*\n\t\t * Prepare the dir trailer up front. It will otherwise look\n\t\t * like a valid dirent. Even if inserting the index fails\n\t\t * (unlikely), then all we'll have done is given first dir\n\t\t * block a small amount of fragmentation.\n\t\t */\n\t\tocfs2_init_dir_trailer(dir, dirdata_bh, i);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, dirdata_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb) && !dx_inline) {\n\t\t/*\n\t\t * Dx dirs with an external cluster need to do this up\n\t\t * front. Inline dx root's get handled later, after\n\t\t * we've allocated our root block. We get passed back\n\t\t * a total number of items so that dr_num_entries can\n\t\t * be correctly set once the dx_root has been\n\t\t * allocated.\n\t\t */\n\t\tret = ocfs2_dx_dir_index_block(dir, handle, dx_leaves,\n\t\t\t\t\t       num_dx_leaves, &num_dx_entries,\n\t\t\t\t\t       dirdata_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\t/*\n\t * Set extent, i_size, etc on the directory. After this, the\n\t * inode should contain the same exact dirents as before and\n\t * be fully accessible from system calls.\n\t *\n\t * We let the later dirent insert modify c/mtime - to the user\n\t * the data hasn't changed.\n\t */\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_dinode_new_extent_list(dir, di);\n\n\ti_size_write(dir, sb->s_blocksize);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\n\tdi->i_size = cpu_to_le64(sb->s_blocksize);\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(dir->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(dir->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\n\t/*\n\t * This should never fail as our extent list is empty and all\n\t * related blocks have been journaled already.\n\t */\n\tret = ocfs2_insert_extent(handle, &et, 0, blkno, len,\n\t\t\t\t  0, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Set i_blocks after the extent insert for the most up to\n\t * date ip_clusters value.\n\t */\n\tdir->i_blocks = ocfs2_inode_sector_count(dir);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tret = ocfs2_dx_dir_attach_index(osb, handle, dir, di_bh,\n\t\t\t\t\t\tdirdata_bh, meta_ac, dx_inline,\n\t\t\t\t\t\tnum_dx_entries, &dx_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tif (dx_inline) {\n\t\t\tocfs2_dx_dir_index_root_block(dir, dx_root_bh,\n\t\t\t\t\t\t      dirdata_bh);\n\t\t} else {\n\t\t\tocfs2_init_dx_root_extent_tree(&dx_et,\n\t\t\t\t\t\t       INODE_CACHE(dir),\n\t\t\t\t\t\t       dx_root_bh);\n\t\t\tret = ocfs2_insert_extent(handle, &dx_et, 0,\n\t\t\t\t\t\t  dx_insert_blkno, 1, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t}\n\n\t/*\n\t * We asked for two clusters, but only got one in the 1st\n\t * pass. Claim the 2nd cluster as a separate extent.\n\t */\n\tif (alloc > len) {\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tblkno = ocfs2_clusters_to_blocks(dir->i_sb, bit_off);\n\n\t\tret = ocfs2_insert_extent(handle, &et, 1,\n\t\t\t\t\t  blkno, len, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\t}\n\n\t*first_block_bh = dirdata_bh;\n\tdirdata_bh = NULL;\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tunsigned int off;\n\n\t\tif (!dx_inline) {\n\t\t\t/*\n\t\t\t * We need to return the correct block within the\n\t\t\t * cluster which should hold our entry.\n\t\t\t */\n\t\t\toff = ocfs2_dx_dir_hash_idx(OCFS2_SB(dir->i_sb),\n\t\t\t\t\t\t    &lookup->dl_hinfo);\n\t\t\tget_bh(dx_leaves[off]);\n\t\t\tlookup->dl_dx_leaf_bh = dx_leaves[off];\n\t\t}\n\t\tlookup->dl_dx_root_bh = dx_root_bh;\n\t\tdx_root_bh = NULL;\n\t}\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir, bytes_allocated);\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++)\n\t\t\tbrelse(dx_leaves[i]);\n\t\tkfree(dx_leaves);\n\t}\n\n\tbrelse(dirdata_bh);\n\tbrelse(dx_root_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_expand_inline_dir(struct inode *dir, struct buffer_head *di_bh,\n\t\t\t\t   unsigned int blocks_wanted,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t   struct buffer_head **first_block_bh)\n{\n\tu32 alloc, dx_alloc, bit_off, len, num_dx_entries = 0;\n\tstruct super_block *sb = dir->i_sb;\n\tint ret, i, num_dx_leaves = 0, dx_inline = 0,\n\t\tcredits = ocfs2_inline_to_extents_credits(sb);\n\tu64 dx_insert_blkno, blkno,\n\t\tbytes = blocks_wanted << sb->s_blocksize_bits;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(dir);\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct buffer_head *dirdata_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct buffer_head **dx_leaves = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\thandle_t *handle;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_extent_tree dx_et;\n\tint did_quota = 0, bytes_allocated = 0;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(dir), di_bh);\n\n\talloc = ocfs2_clusters_for_bytes(sb, bytes);\n\tdx_alloc = 0;\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tcredits += ocfs2_add_dir_index_credits(sb);\n\n\t\tdx_inline = ocfs2_new_dx_should_be_inline(dir, di_bh);\n\t\tif (!dx_inline) {\n\t\t\t/* Add one more cluster for an index leaf */\n\t\t\tdx_alloc++;\n\t\t\tdx_leaves = ocfs2_dx_dir_kmalloc_leaves(sb,\n\t\t\t\t\t\t\t\t&num_dx_leaves);\n\t\t\tif (!dx_leaves) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* This gets us the dx_root */\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We should never need more than 2 clusters for the unindexed\n\t * tree - maximum dirent size is far less than one block. In\n\t * fact, the only time we'd need more than one cluster is if\n\t * blocksize == clustersize and the dirent won't fit in the\n\t * extra space that the expansion to a single block gives. As\n\t * of today, that only happens on 4k/4k file systems.\n\t */\n\tBUG_ON(alloc > 2);\n\n\tret = ocfs2_reserve_clusters(osb, alloc + dx_alloc, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Prepare for worst case allocation scenario of two separate\n\t * extents in the unindexed tree.\n\t */\n\tif (alloc == 2)\n\t\tcredits += OCFS2_SUBALLOC_ALLOC;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\tocfs2_clusters_to_bytes(osb->sb, alloc + dx_alloc));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\tif (ocfs2_supports_indexed_dirs(osb) && !dx_inline) {\n\t\t/*\n\t\t * Allocate our index cluster first, to maximize the\n\t\t * possibility that unindexed leaves grow\n\t\t * contiguously.\n\t\t */\n\t\tret = __ocfs2_dx_dir_new_cluster(dir, 0, handle, data_ac,\n\t\t\t\t\t\t dx_leaves, num_dx_leaves,\n\t\t\t\t\t\t &dx_insert_blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\t}\n\n\t/*\n\t * Try to claim as many clusters as the bitmap can give though\n\t * if we only get one now, that's enough to continue. The rest\n\t * will be claimed after the conversion to extents.\n\t */\n\tif (ocfs2_dir_resv_allowed(osb))\n\t\tdata_ac->ac_resv = &oi->ip_la_data_resv;\n\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off, &len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\n\t/*\n\t * Operations are carefully ordered so that we set up the new\n\t * data block first. The conversion from inline data to\n\t * extents follows.\n\t */\n\tblkno = ocfs2_clusters_to_blocks(dir->i_sb, bit_off);\n\tdirdata_bh = sb_getblk(sb, blkno);\n\tif (!dirdata_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), dirdata_bh);\n\n\tret = ocfs2_journal_access_db(handle, INODE_CACHE(dir), dirdata_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(dirdata_bh->b_data, di->id2.i_data.id_data, i_size_read(dir));\n\tmemset(dirdata_bh->b_data + i_size_read(dir), 0,\n\t       sb->s_blocksize - i_size_read(dir));\n\ti = ocfs2_expand_last_dirent(dirdata_bh->b_data, i_size_read(dir), dir);\n\tif (ocfs2_new_dir_wants_trailer(dir)) {\n\t\t/*\n\t\t * Prepare the dir trailer up front. It will otherwise look\n\t\t * like a valid dirent. Even if inserting the index fails\n\t\t * (unlikely), then all we'll have done is given first dir\n\t\t * block a small amount of fragmentation.\n\t\t */\n\t\tocfs2_init_dir_trailer(dir, dirdata_bh, i);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, dirdata_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb) && !dx_inline) {\n\t\t/*\n\t\t * Dx dirs with an external cluster need to do this up\n\t\t * front. Inline dx root's get handled later, after\n\t\t * we've allocated our root block. We get passed back\n\t\t * a total number of items so that dr_num_entries can\n\t\t * be correctly set once the dx_root has been\n\t\t * allocated.\n\t\t */\n\t\tret = ocfs2_dx_dir_index_block(dir, handle, dx_leaves,\n\t\t\t\t\t       num_dx_leaves, &num_dx_entries,\n\t\t\t\t\t       dirdata_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\t/*\n\t * Set extent, i_size, etc on the directory. After this, the\n\t * inode should contain the same exact dirents as before and\n\t * be fully accessible from system calls.\n\t *\n\t * We let the later dirent insert modify c/mtime - to the user\n\t * the data hasn't changed.\n\t */\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_dinode_new_extent_list(dir, di);\n\n\ti_size_write(dir, sb->s_blocksize);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\n\tdi->i_size = cpu_to_le64(sb->s_blocksize);\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(dir->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(dir->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\n\t/*\n\t * This should never fail as our extent list is empty and all\n\t * related blocks have been journaled already.\n\t */\n\tret = ocfs2_insert_extent(handle, &et, 0, blkno, len,\n\t\t\t\t  0, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Set i_blocks after the extent insert for the most up to\n\t * date ip_clusters value.\n\t */\n\tdir->i_blocks = ocfs2_inode_sector_count(dir);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tret = ocfs2_dx_dir_attach_index(osb, handle, dir, di_bh,\n\t\t\t\t\t\tdirdata_bh, meta_ac, dx_inline,\n\t\t\t\t\t\tnum_dx_entries, &dx_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tif (dx_inline) {\n\t\t\tocfs2_dx_dir_index_root_block(dir, dx_root_bh,\n\t\t\t\t\t\t      dirdata_bh);\n\t\t} else {\n\t\t\tocfs2_init_dx_root_extent_tree(&dx_et,\n\t\t\t\t\t\t       INODE_CACHE(dir),\n\t\t\t\t\t\t       dx_root_bh);\n\t\t\tret = ocfs2_insert_extent(handle, &dx_et, 0,\n\t\t\t\t\t\t  dx_insert_blkno, 1, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t}\n\n\t/*\n\t * We asked for two clusters, but only got one in the 1st\n\t * pass. Claim the 2nd cluster as a separate extent.\n\t */\n\tif (alloc > len) {\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tblkno = ocfs2_clusters_to_blocks(dir->i_sb, bit_off);\n\n\t\tret = ocfs2_insert_extent(handle, &et, 1,\n\t\t\t\t\t  blkno, len, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\t}\n\n\t*first_block_bh = dirdata_bh;\n\tdirdata_bh = NULL;\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tunsigned int off;\n\n\t\tif (!dx_inline) {\n\t\t\t/*\n\t\t\t * We need to return the correct block within the\n\t\t\t * cluster which should hold our entry.\n\t\t\t */\n\t\t\toff = ocfs2_dx_dir_hash_idx(OCFS2_SB(dir->i_sb),\n\t\t\t\t\t\t    &lookup->dl_hinfo);\n\t\t\tget_bh(dx_leaves[off]);\n\t\t\tlookup->dl_dx_leaf_bh = dx_leaves[off];\n\t\t}\n\t\tlookup->dl_dx_root_bh = dx_root_bh;\n\t\tdx_root_bh = NULL;\n\t}\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir, bytes_allocated);\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++)\n\t\t\tbrelse(dx_leaves[i]);\n\t\tkfree(dx_leaves);\n\t}\n\n\tbrelse(dirdata_bh);\n\tbrelse(dx_root_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dx_root_bh"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_extend_dir(struct ocfs2_super *osb,\n\t\t\t    struct inode *dir,\n\t\t\t    struct buffer_head *parent_fe_bh,\n\t\t\t    unsigned int blocks_wanted,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct buffer_head **new_de_bh)\n{\n\tint status = 0;\n\tint credits, num_free_extents, drop_alloc_sem = 0;\n\tloff_t dir_i_size;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tstruct ocfs2_extent_list *el = &fe->id2.i_list;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry * de;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_extent_tree et;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t/*\n\t\t * This would be a code error as an inline directory should\n\t\t * never have an index root.\n\t\t */\n\t\tBUG_ON(dx_root_bh);\n\n\t\tstatus = ocfs2_expand_inline_dir(dir, parent_fe_bh,\n\t\t\t\t\t\t blocks_wanted, lookup,\n\t\t\t\t\t\t &new_bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Expansion from inline to an indexed directory will\n\t\t * have given us this. */\n\t\tdx_root_bh = lookup->dl_dx_root_bh;\n\n\t\tif (blocks_wanted == 1) {\n\t\t\t/*\n\t\t\t * If the new dirent will fit inside the space\n\t\t\t * created by pushing out to one block, then\n\t\t\t * we can complete the operation\n\t\t\t * here. Otherwise we have to expand i_size\n\t\t\t * and format the 2nd block below.\n\t\t\t */\n\t\t\tBUG_ON(new_bh == NULL);\n\t\t\tgoto bail_bh;\n\t\t}\n\n\t\t/*\n\t\t * Get rid of 'new_bh' - we want to format the 2nd\n\t\t * data block and return that instead.\n\t\t */\n\t\tbrelse(new_bh);\n\t\tnew_bh = NULL;\n\n\t\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\t\tdrop_alloc_sem = 1;\n\t\tdir_i_size = i_size_read(dir);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t\tgoto do_extend;\n\t}\n\n\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\tdrop_alloc_sem = 1;\n\tdir_i_size = i_size_read(dir);\n\ttrace_ocfs2_extend_dir((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t       dir_i_size);\n\n\t/* dir->i_size is always block aligned. */\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tif (dir_i_size == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters)) {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(dir),\n\t\t\t\t\t      parent_fe_bh);\n\t\tnum_free_extents = ocfs2_num_free_extents(osb, &et);\n\t\tif (num_free_extents < 0) {\n\t\t\tstatus = num_free_extents;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!num_free_extents) {\n\t\t\tstatus = ocfs2_reserve_new_metadata(osb, el, &meta_ac);\n\t\t\tif (status < 0) {\n\t\t\t\tif (status != -ENOSPC)\n\t\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ocfs2_dir_resv_allowed(osb))\n\t\t\tdata_ac->ac_resv = &OCFS2_I(dir)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(sb, el);\n\t} else {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t}\n\ndo_extend:\n\tif (ocfs2_dir_indexed(dir))\n\t\tcredits++; /* For attaching the new dirent block to the\n\t\t\t    * dx_root */\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, dir, parent_fe_bh,\n\t\t\t\t     data_ac, meta_ac, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(dir), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, sb->s_blocksize);\n\n\tde = (struct ocfs2_dir_entry *) new_bh->b_data;\n\tde->inode = 0;\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tde->rec_len = cpu_to_le16(ocfs2_dir_trailer_blk_off(sb));\n\n\t\tocfs2_init_dir_trailer(dir, new_bh, le16_to_cpu(de->rec_len));\n\n\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\tstatus = ocfs2_dx_dir_link_trailer(dir, handle,\n\t\t\t\t\t\t\t   dx_root_bh, new_bh);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tde->rec_len = cpu_to_le16(sb->s_blocksize);\n\t}\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tdir_i_size += dir->i_sb->s_blocksize;\n\ti_size_write(dir, dir_i_size);\n\tdir->i_blocks = ocfs2_inode_sector_count(dir);\n\tstatus = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail_bh:\n\t*new_de_bh = new_bh;\n\tget_bh(*new_de_bh);\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\tif (drop_alloc_sem)\n\t\tup_write(&OCFS2_I(dir)->ip_alloc_sem);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tbrelse(new_bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_do_extend_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "3122-3175",
    "snippet": "static int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh)\n{\n\tint status;\n\tint extend, did_quota = 0;\n\tu64 p_blkno, v_blkno;\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\textend = (i_size_read(dir) == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters));\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tif (extend) {\n\t\tu32 offset = OCFS2_I(dir)->ip_clusters;\n\n\t\tstatus = dquot_alloc_space_nodirty(dir,\n\t\t\t\t\tocfs2_clusters_to_bytes(sb, 1));\n\t\tif (status)\n\t\t\tgoto bail;\n\t\tdid_quota = 1;\n\n\t\tstatus = ocfs2_add_inode_data(OCFS2_SB(sb), dir, &offset,\n\t\t\t\t\t      1, 0, parent_fe_bh, handle,\n\t\t\t\t\t      data_ac, meta_ac, NULL);\n\t\tBUG_ON(status == -EAGAIN);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tv_blkno = ocfs2_blocks_for_bytes(sb, i_size_read(dir));\n\tstatus = ocfs2_extent_map_get_blocks(dir, v_blkno, &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*new_bh = sb_getblk(sb, p_blkno);\n\tif (!*new_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = 0;\nbail:\n\tif (did_quota && status < 0)\n\t\tdquot_free_space_nodirty(dir, ocfs2_clusters_to_bytes(sb, 1));\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);",
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "dir",
            "ocfs2_clusters_to_bytes(sb, 1)"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "sb",
            "1"
          ],
          "line": 3173
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "p_blkno"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "dir",
            "v_blkno",
            "&p_blkno",
            "NULL",
            "NULL"
          ],
          "line": 3158
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "671-705",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_for_bytes",
          "args": [
            "sb",
            "i_size_read(dir)"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "752-757",
          "snippet": "static inline u64 ocfs2_blocks_for_bytes(struct super_block *sb,\n\t\t\t\t\t u64 bytes)\n{\n\tbytes += sb->s_blocksize - 1;\n\treturn bytes >> sb->s_blocksize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_blocks_for_bytes(struct super_block *sb,\n\t\t\t\t\t u64 bytes)\n{\n\tbytes += sb->s_blocksize - 1;\n\treturn bytes >> sb->s_blocksize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "status == -EAGAIN"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_inode_data",
          "args": [
            "OCFS2_SB(sb)",
            "dir",
            "&offset",
            "1",
            "0",
            "parent_fe_bh",
            "handle",
            "data_ac",
            "meta_ac",
            "NULL"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_inode_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "538-558",
          "snippet": "int ocfs2_add_inode_data(struct ocfs2_super *osb,\n\t\t\t struct inode *inode,\n\t\t\t u32 *logical_offset,\n\t\t\t u32 clusters_to_add,\n\t\t\t int mark_unwritten,\n\t\t\t struct buffer_head *fe_bh,\n\t\t\t handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t enum ocfs2_alloc_restarted *reason_ret)\n{\n\tint ret;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), fe_bh);\n\tret = ocfs2_add_clusters_in_btree(handle, &et, logical_offset,\n\t\t\t\t\t  clusters_to_add, mark_unwritten,\n\t\t\t\t\t  data_ac, meta_ac, reason_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_add_inode_data(struct ocfs2_super *osb,\n\t\t\t struct inode *inode,\n\t\t\t u32 *logical_offset,\n\t\t\t u32 clusters_to_add,\n\t\t\t int mark_unwritten,\n\t\t\t struct buffer_head *fe_bh,\n\t\t\t handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t enum ocfs2_alloc_restarted *reason_ret)\n{\n\tint ret;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), fe_bh);\n\tret = ocfs2_add_clusters_in_btree(handle, &et, logical_offset,\n\t\t\t\t\t  clusters_to_add, mark_unwritten,\n\t\t\t\t\t  data_ac, meta_ac, reason_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_space_nodirty",
          "args": [
            "dir",
            "ocfs2_clusters_to_bytes(sb, 1)"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 3139
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(dir)->ip_lock"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(dir)->ip_lock"
          ],
          "line": 3134
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh)\n{\n\tint status;\n\tint extend, did_quota = 0;\n\tu64 p_blkno, v_blkno;\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\textend = (i_size_read(dir) == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters));\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tif (extend) {\n\t\tu32 offset = OCFS2_I(dir)->ip_clusters;\n\n\t\tstatus = dquot_alloc_space_nodirty(dir,\n\t\t\t\t\tocfs2_clusters_to_bytes(sb, 1));\n\t\tif (status)\n\t\t\tgoto bail;\n\t\tdid_quota = 1;\n\n\t\tstatus = ocfs2_add_inode_data(OCFS2_SB(sb), dir, &offset,\n\t\t\t\t\t      1, 0, parent_fe_bh, handle,\n\t\t\t\t\t      data_ac, meta_ac, NULL);\n\t\tBUG_ON(status == -EAGAIN);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tv_blkno = ocfs2_blocks_for_bytes(sb, i_size_read(dir));\n\tstatus = ocfs2_extent_map_get_blocks(dir, v_blkno, &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*new_bh = sb_getblk(sb, p_blkno);\n\tif (!*new_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = 0;\nbail:\n\tif (did_quota && status < 0)\n\t\tdquot_free_space_nodirty(dir, ocfs2_clusters_to_bytes(sb, 1));\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_expand_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2805-3119",
    "snippet": "static int ocfs2_expand_inline_dir(struct inode *dir, struct buffer_head *di_bh,\n\t\t\t\t   unsigned int blocks_wanted,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t   struct buffer_head **first_block_bh)\n{\n\tu32 alloc, dx_alloc, bit_off, len, num_dx_entries = 0;\n\tstruct super_block *sb = dir->i_sb;\n\tint ret, i, num_dx_leaves = 0, dx_inline = 0,\n\t\tcredits = ocfs2_inline_to_extents_credits(sb);\n\tu64 dx_insert_blkno, blkno,\n\t\tbytes = blocks_wanted << sb->s_blocksize_bits;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(dir);\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct buffer_head *dirdata_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct buffer_head **dx_leaves = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\thandle_t *handle;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_extent_tree dx_et;\n\tint did_quota = 0, bytes_allocated = 0;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(dir), di_bh);\n\n\talloc = ocfs2_clusters_for_bytes(sb, bytes);\n\tdx_alloc = 0;\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tcredits += ocfs2_add_dir_index_credits(sb);\n\n\t\tdx_inline = ocfs2_new_dx_should_be_inline(dir, di_bh);\n\t\tif (!dx_inline) {\n\t\t\t/* Add one more cluster for an index leaf */\n\t\t\tdx_alloc++;\n\t\t\tdx_leaves = ocfs2_dx_dir_kmalloc_leaves(sb,\n\t\t\t\t\t\t\t\t&num_dx_leaves);\n\t\t\tif (!dx_leaves) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* This gets us the dx_root */\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We should never need more than 2 clusters for the unindexed\n\t * tree - maximum dirent size is far less than one block. In\n\t * fact, the only time we'd need more than one cluster is if\n\t * blocksize == clustersize and the dirent won't fit in the\n\t * extra space that the expansion to a single block gives. As\n\t * of today, that only happens on 4k/4k file systems.\n\t */\n\tBUG_ON(alloc > 2);\n\n\tret = ocfs2_reserve_clusters(osb, alloc + dx_alloc, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Prepare for worst case allocation scenario of two separate\n\t * extents in the unindexed tree.\n\t */\n\tif (alloc == 2)\n\t\tcredits += OCFS2_SUBALLOC_ALLOC;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\tocfs2_clusters_to_bytes(osb->sb, alloc + dx_alloc));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\tif (ocfs2_supports_indexed_dirs(osb) && !dx_inline) {\n\t\t/*\n\t\t * Allocate our index cluster first, to maximize the\n\t\t * possibility that unindexed leaves grow\n\t\t * contiguously.\n\t\t */\n\t\tret = __ocfs2_dx_dir_new_cluster(dir, 0, handle, data_ac,\n\t\t\t\t\t\t dx_leaves, num_dx_leaves,\n\t\t\t\t\t\t &dx_insert_blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\t}\n\n\t/*\n\t * Try to claim as many clusters as the bitmap can give though\n\t * if we only get one now, that's enough to continue. The rest\n\t * will be claimed after the conversion to extents.\n\t */\n\tif (ocfs2_dir_resv_allowed(osb))\n\t\tdata_ac->ac_resv = &oi->ip_la_data_resv;\n\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off, &len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\n\t/*\n\t * Operations are carefully ordered so that we set up the new\n\t * data block first. The conversion from inline data to\n\t * extents follows.\n\t */\n\tblkno = ocfs2_clusters_to_blocks(dir->i_sb, bit_off);\n\tdirdata_bh = sb_getblk(sb, blkno);\n\tif (!dirdata_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), dirdata_bh);\n\n\tret = ocfs2_journal_access_db(handle, INODE_CACHE(dir), dirdata_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(dirdata_bh->b_data, di->id2.i_data.id_data, i_size_read(dir));\n\tmemset(dirdata_bh->b_data + i_size_read(dir), 0,\n\t       sb->s_blocksize - i_size_read(dir));\n\ti = ocfs2_expand_last_dirent(dirdata_bh->b_data, i_size_read(dir), dir);\n\tif (ocfs2_new_dir_wants_trailer(dir)) {\n\t\t/*\n\t\t * Prepare the dir trailer up front. It will otherwise look\n\t\t * like a valid dirent. Even if inserting the index fails\n\t\t * (unlikely), then all we'll have done is given first dir\n\t\t * block a small amount of fragmentation.\n\t\t */\n\t\tocfs2_init_dir_trailer(dir, dirdata_bh, i);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, dirdata_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb) && !dx_inline) {\n\t\t/*\n\t\t * Dx dirs with an external cluster need to do this up\n\t\t * front. Inline dx root's get handled later, after\n\t\t * we've allocated our root block. We get passed back\n\t\t * a total number of items so that dr_num_entries can\n\t\t * be correctly set once the dx_root has been\n\t\t * allocated.\n\t\t */\n\t\tret = ocfs2_dx_dir_index_block(dir, handle, dx_leaves,\n\t\t\t\t\t       num_dx_leaves, &num_dx_entries,\n\t\t\t\t\t       dirdata_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\t/*\n\t * Set extent, i_size, etc on the directory. After this, the\n\t * inode should contain the same exact dirents as before and\n\t * be fully accessible from system calls.\n\t *\n\t * We let the later dirent insert modify c/mtime - to the user\n\t * the data hasn't changed.\n\t */\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_dinode_new_extent_list(dir, di);\n\n\ti_size_write(dir, sb->s_blocksize);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\n\tdi->i_size = cpu_to_le64(sb->s_blocksize);\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(dir->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(dir->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\n\t/*\n\t * This should never fail as our extent list is empty and all\n\t * related blocks have been journaled already.\n\t */\n\tret = ocfs2_insert_extent(handle, &et, 0, blkno, len,\n\t\t\t\t  0, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Set i_blocks after the extent insert for the most up to\n\t * date ip_clusters value.\n\t */\n\tdir->i_blocks = ocfs2_inode_sector_count(dir);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tret = ocfs2_dx_dir_attach_index(osb, handle, dir, di_bh,\n\t\t\t\t\t\tdirdata_bh, meta_ac, dx_inline,\n\t\t\t\t\t\tnum_dx_entries, &dx_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tif (dx_inline) {\n\t\t\tocfs2_dx_dir_index_root_block(dir, dx_root_bh,\n\t\t\t\t\t\t      dirdata_bh);\n\t\t} else {\n\t\t\tocfs2_init_dx_root_extent_tree(&dx_et,\n\t\t\t\t\t\t       INODE_CACHE(dir),\n\t\t\t\t\t\t       dx_root_bh);\n\t\t\tret = ocfs2_insert_extent(handle, &dx_et, 0,\n\t\t\t\t\t\t  dx_insert_blkno, 1, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t}\n\n\t/*\n\t * We asked for two clusters, but only got one in the 1st\n\t * pass. Claim the 2nd cluster as a separate extent.\n\t */\n\tif (alloc > len) {\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tblkno = ocfs2_clusters_to_blocks(dir->i_sb, bit_off);\n\n\t\tret = ocfs2_insert_extent(handle, &et, 1,\n\t\t\t\t\t  blkno, len, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\t}\n\n\t*first_block_bh = dirdata_bh;\n\tdirdata_bh = NULL;\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tunsigned int off;\n\n\t\tif (!dx_inline) {\n\t\t\t/*\n\t\t\t * We need to return the correct block within the\n\t\t\t * cluster which should hold our entry.\n\t\t\t */\n\t\t\toff = ocfs2_dx_dir_hash_idx(OCFS2_SB(dir->i_sb),\n\t\t\t\t\t\t    &lookup->dl_hinfo);\n\t\t\tget_bh(dx_leaves[off]);\n\t\t\tlookup->dl_dx_leaf_bh = dx_leaves[off];\n\t\t}\n\t\tlookup->dl_dx_root_bh = dx_root_bh;\n\t\tdx_root_bh = NULL;\n\t}\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir, bytes_allocated);\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++)\n\t\t\tbrelse(dx_leaves[i]);\n\t\tkfree(dx_leaves);\n\t}\n\n\tbrelse(dirdata_bh);\n\tbrelse(dx_root_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dx_root_bh"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dx_leaves"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "meta_ac"
          ],
          "line": 3107
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 3100
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "dir",
            "bytes_allocated"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "dx_leaves[off]"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_hash_idx",
          "args": [
            "OCFS2_SB(dir->i_sb)",
            "&lookup->dl_hinfo"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_hash_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "865-869",
          "snippet": "static inline unsigned int ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_hinfo *hinfo)\n{\n\treturn __ocfs2_dx_dir_hash_idx(osb, hinfo->minor_hash);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_hinfo *hinfo)\n{\n\treturn __ocfs2_dx_dir_hash_idx(osb, hinfo->minor_hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_indexed_dirs",
          "args": [
            "osb"
          ],
          "line": 3079
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_indexed_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "532-537",
          "snippet": "static inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "dir->i_sb",
            "1"
          ],
          "line": 3074
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_extent",
          "args": [
            "handle",
            "&et",
            "1",
            "blkno",
            "len",
            "0",
            "NULL"
          ],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4665-4726",
          "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "dir->i_sb",
            "bit_off"
          ],
          "line": 3066
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_clusters",
          "args": [
            "handle",
            "data_ac",
            "1",
            "&bit_off",
            "&len"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2373-2383",
          "snippet": "int ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dx_root_extent_tree",
          "args": [
            "&dx_et",
            "INODE_CACHE(dir)",
            "dx_root_bh"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dx_root_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "482-488",
          "snippet": "void ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};\n\nvoid ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_index_root_block",
          "args": [
            "dir",
            "dx_root_bh",
            "dirdata_bh"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_index_root_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2674-2710",
          "snippet": "static void ocfs2_dx_dir_index_root_block(struct inode *dir,\n\t\t\t\t\t struct buffer_head *dx_root_bh,\n\t\t\t\t\t struct buffer_head *dirent_bh)\n{\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tu64 dirent_blk = dirent_bh->b_blocknr;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tde_buf = dirent_bh->b_data;\n\tlimit = de_buf + dir->i_sb->s_blocksize;\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (!de->name_len || !de->inode)\n\t\t\tgoto inc;\n\n\t\tocfs2_dx_dir_name_hash(dir, de->name, de->name_len, &hinfo);\n\n\t\ttrace_ocfs2_dx_dir_index_root_block(\n\t\t\t\t(unsigned long long)dir->i_ino,\n\t\t\t\thinfo.major_hash, hinfo.minor_hash,\n\t\t\t\tde->name_len, de->name,\n\t\t\t\tle16_to_cpu(dx_root->dr_entries.de_num_used));\n\n\t\tocfs2_dx_entry_list_insert(&dx_root->dr_entries, &hinfo,\n\t\t\t\t\t   dirent_blk);\n\n\t\tle32_add_cpu(&dx_root->dr_num_entries, 1);\ninc:\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_dx_dir_index_root_block(struct inode *dir,\n\t\t\t\t\t struct buffer_head *dx_root_bh,\n\t\t\t\t\t struct buffer_head *dirent_bh)\n{\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tu64 dirent_blk = dirent_bh->b_blocknr;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tde_buf = dirent_bh->b_data;\n\tlimit = de_buf + dir->i_sb->s_blocksize;\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (!de->name_len || !de->inode)\n\t\t\tgoto inc;\n\n\t\tocfs2_dx_dir_name_hash(dir, de->name, de->name_len, &hinfo);\n\n\t\ttrace_ocfs2_dx_dir_index_root_block(\n\t\t\t\t(unsigned long long)dir->i_ino,\n\t\t\t\thinfo.major_hash, hinfo.minor_hash,\n\t\t\t\tde->name_len, de->name,\n\t\t\t\tle16_to_cpu(dx_root->dr_entries.de_num_used));\n\n\t\tocfs2_dx_entry_list_insert(&dx_root->dr_entries, &hinfo,\n\t\t\t\t\t   dirent_blk);\n\n\t\tle32_add_cpu(&dx_root->dr_num_entries, 1);\ninc:\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_attach_index",
          "args": [
            "osb",
            "handle",
            "dir",
            "di_bh",
            "dirdata_bh",
            "meta_ac",
            "dx_inline",
            "num_dx_entries",
            "&dx_root_bh"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_attach_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2323-2413",
          "snippet": "static int ocfs2_dx_dir_attach_index(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle, struct inode *dir,\n\t\t\t\t     struct buffer_head *di_bh,\n\t\t\t\t     struct buffer_head *dirdata_bh,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     int dx_inline, u32 num_entries,\n\t\t\t\t     struct buffer_head **ret_dx_root_bh)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tu16 dr_suballoc_bit;\n\tu64 suballoc_loc, dr_blkno;\n\tunsigned int num_bits;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_trailer_from_bh(dirdata_bh, dir->i_sb);\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &dr_suballoc_bit, &num_bits, &dr_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_dx_dir_attach_index(\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)dr_blkno);\n\n\tdx_root_bh = sb_getblk(osb->sb, dr_blkno);\n\tif (dx_root_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), dx_root_bh);\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tmemset(dx_root, 0, osb->sb->s_blocksize);\n\tstrcpy(dx_root->dr_signature, OCFS2_DX_ROOT_SIGNATURE);\n\tdx_root->dr_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tdx_root->dr_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tdx_root->dr_suballoc_bit = cpu_to_le16(dr_suballoc_bit);\n\tdx_root->dr_fs_generation = cpu_to_le32(osb->fs_generation);\n\tdx_root->dr_blkno = cpu_to_le64(dr_blkno);\n\tdx_root->dr_dir_blkno = cpu_to_le64(OCFS2_I(dir)->ip_blkno);\n\tdx_root->dr_num_entries = cpu_to_le32(num_entries);\n\tif (le16_to_cpu(trailer->db_free_rec_len))\n\t\tdx_root->dr_free_blk = cpu_to_le64(dirdata_bh->b_blocknr);\n\telse\n\t\tdx_root->dr_free_blk = cpu_to_le64(0);\n\n\tif (dx_inline) {\n\t\tdx_root->dr_flags |= OCFS2_DX_FLAG_INLINE;\n\t\tdx_root->dr_entries.de_count =\n\t\t\tcpu_to_le16(ocfs2_dx_entries_per_root(osb->sb));\n\t} else {\n\t\tdx_root->dr_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_dx_root(osb->sb));\n\t}\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi->i_dx_root = cpu_to_le64(dr_blkno);\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tOCFS2_I(dir)->ip_dyn_features |= OCFS2_INDEXED_DIR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(dir)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\t*ret_dx_root_bh = dx_root_bh;\n\tdx_root_bh = NULL;\n\nout:\n\tbrelse(dx_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_attach_index(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle, struct inode *dir,\n\t\t\t\t     struct buffer_head *di_bh,\n\t\t\t\t     struct buffer_head *dirdata_bh,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     int dx_inline, u32 num_entries,\n\t\t\t\t     struct buffer_head **ret_dx_root_bh)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tu16 dr_suballoc_bit;\n\tu64 suballoc_loc, dr_blkno;\n\tunsigned int num_bits;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_trailer_from_bh(dirdata_bh, dir->i_sb);\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &dr_suballoc_bit, &num_bits, &dr_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_dx_dir_attach_index(\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)dr_blkno);\n\n\tdx_root_bh = sb_getblk(osb->sb, dr_blkno);\n\tif (dx_root_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), dx_root_bh);\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tmemset(dx_root, 0, osb->sb->s_blocksize);\n\tstrcpy(dx_root->dr_signature, OCFS2_DX_ROOT_SIGNATURE);\n\tdx_root->dr_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tdx_root->dr_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tdx_root->dr_suballoc_bit = cpu_to_le16(dr_suballoc_bit);\n\tdx_root->dr_fs_generation = cpu_to_le32(osb->fs_generation);\n\tdx_root->dr_blkno = cpu_to_le64(dr_blkno);\n\tdx_root->dr_dir_blkno = cpu_to_le64(OCFS2_I(dir)->ip_blkno);\n\tdx_root->dr_num_entries = cpu_to_le32(num_entries);\n\tif (le16_to_cpu(trailer->db_free_rec_len))\n\t\tdx_root->dr_free_blk = cpu_to_le64(dirdata_bh->b_blocknr);\n\telse\n\t\tdx_root->dr_free_blk = cpu_to_le64(0);\n\n\tif (dx_inline) {\n\t\tdx_root->dr_flags |= OCFS2_DX_FLAG_INLINE;\n\t\tdx_root->dr_entries.de_count =\n\t\t\tcpu_to_le16(ocfs2_dx_entries_per_root(osb->sb));\n\t} else {\n\t\tdx_root->dr_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_dx_root(osb->sb));\n\t}\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi->i_dx_root = cpu_to_le64(dr_blkno);\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tOCFS2_I(dir)->ip_dyn_features |= OCFS2_INDEXED_DIR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(dir)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\t*ret_dx_root_bh = dx_root_bh;\n\tdx_root_bh = NULL;\n\nout:\n\tbrelse(dx_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "dir"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "dir",
            "1"
          ],
          "line": 3011
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dir->i_ctime.tv_nsec"
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "dir->i_ctime.tv_sec"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "sb->s_blocksize"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "dir",
            "sb->s_blocksize"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dinode_new_extent_list",
          "args": [
            "dir",
            "di"
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dinode_new_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6806-6814",
          "snippet": "void ocfs2_dinode_new_extent_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\tdi->id2.i_list.l_tree_depth = 0;\n\tdi->id2.i_list.l_next_free_rec = 0;\n\tdi->id2.i_list.l_count = cpu_to_le16(\n\t\tocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dinode_new_extent_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\tdi->id2.i_list.l_tree_depth = 0;\n\tdi->id2.i_list.l_next_free_rec = 0;\n\tdi->id2.i_list.l_count = cpu_to_le16(\n\t\tocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "oi->ip_dyn_features"
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 2998
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_index_block",
          "args": [
            "dir",
            "handle",
            "dx_leaves",
            "num_dx_leaves",
            "&num_dx_entries",
            "dirdata_bh"
          ],
          "line": 2974
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_index_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2625-2669",
          "snippet": "static int ocfs2_dx_dir_index_block(struct inode *dir,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct buffer_head **dx_leaves,\n\t\t\t\t    int num_dx_leaves,\n\t\t\t\t    u32 *num_dx_entries,\n\t\t\t\t    struct buffer_head *dirent_bh)\n{\n\tint ret = 0, namelen, i;\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dir_entry *de;\n\tstruct buffer_head *dx_leaf_bh;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tu64 dirent_blk = dirent_bh->b_blocknr;\n\n\tde_buf = dirent_bh->b_data;\n\tlimit = de_buf + dir->i_sb->s_blocksize;\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tnamelen = de->name_len;\n\t\tif (!namelen || !de->inode)\n\t\t\tgoto inc;\n\n\t\tocfs2_dx_dir_name_hash(dir, de->name, namelen, &hinfo);\n\n\t\ti = ocfs2_dx_dir_hash_idx(OCFS2_SB(dir->i_sb), &hinfo);\n\t\tdx_leaf_bh = dx_leaves[i];\n\n\t\tret = __ocfs2_dx_dir_leaf_insert(dir, handle, &hinfo,\n\t\t\t\t\t\t dirent_blk, dx_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t*num_dx_entries = *num_dx_entries + 1;\n\ninc:\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_index_block(struct inode *dir,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct buffer_head **dx_leaves,\n\t\t\t\t    int num_dx_leaves,\n\t\t\t\t    u32 *num_dx_entries,\n\t\t\t\t    struct buffer_head *dirent_bh)\n{\n\tint ret = 0, namelen, i;\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dir_entry *de;\n\tstruct buffer_head *dx_leaf_bh;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tu64 dirent_blk = dirent_bh->b_blocknr;\n\n\tde_buf = dirent_bh->b_data;\n\tlimit = de_buf + dir->i_sb->s_blocksize;\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tnamelen = de->name_len;\n\t\tif (!namelen || !de->inode)\n\t\t\tgoto inc;\n\n\t\tocfs2_dx_dir_name_hash(dir, de->name, namelen, &hinfo);\n\n\t\ti = ocfs2_dx_dir_hash_idx(OCFS2_SB(dir->i_sb), &hinfo);\n\t\tdx_leaf_bh = dx_leaves[i];\n\n\t\tret = __ocfs2_dx_dir_leaf_insert(dir, handle, &hinfo,\n\t\t\t\t\t\t dirent_blk, dx_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t*num_dx_entries = *num_dx_entries + 1;\n\ninc:\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dir_trailer",
          "args": [
            "dir",
            "dirdata_bh",
            "i"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dir_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "152-164",
          "snippet": "static void ocfs2_init_dir_trailer(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh, u16 rec_len)\n{\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, inode->i_sb);\n\tstrcpy(trailer->db_signature, OCFS2_DIR_TRAILER_SIGNATURE);\n\ttrailer->db_compat_rec_len =\n\t\t\tcpu_to_le16(sizeof(struct ocfs2_dir_block_trailer));\n\ttrailer->db_parent_dinode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\ttrailer->db_blkno = cpu_to_le64(bh->b_blocknr);\n\ttrailer->db_free_rec_len = cpu_to_le16(rec_len);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_init_dir_trailer(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh, u16 rec_len)\n{\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, inode->i_sb);\n\tstrcpy(trailer->db_signature, OCFS2_DIR_TRAILER_SIGNATURE);\n\ttrailer->db_compat_rec_len =\n\t\t\tcpu_to_le16(sizeof(struct ocfs2_dir_block_trailer));\n\ttrailer->db_parent_dinode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\ttrailer->db_blkno = cpu_to_le64(bh->b_blocknr);\n\ttrailer->db_free_rec_len = cpu_to_le16(rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_new_dir_wants_trailer",
          "args": [
            "dir"
          ],
          "line": 2952
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_dir_wants_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "106-112",
          "snippet": "static int ocfs2_new_dir_wants_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\treturn ocfs2_meta_ecc(osb) ||\n\t\tocfs2_supports_indexed_dirs(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_new_dir_wants_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\treturn ocfs2_meta_ecc(osb) ||\n\t\tocfs2_supports_indexed_dirs(osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_expand_last_dirent",
          "args": [
            "dirdata_bh->b_data",
            "i_size_read(dir)",
            "dir"
          ],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_expand_last_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2755-2795",
          "snippet": "static unsigned int ocfs2_expand_last_dirent(char *start, unsigned int old_size,\n\t\t\t\t\t     struct inode *dir)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dir_entry *prev_de;\n\tchar *de_buf, *limit;\n\tunsigned int new_size = sb->s_blocksize;\n\tunsigned int bytes, this_hole;\n\tunsigned int largest_hole = 0;\n\n\tif (ocfs2_new_dir_wants_trailer(dir))\n\t\tnew_size = ocfs2_dir_trailer_blk_off(sb);\n\n\tbytes = new_size - old_size;\n\n\tlimit = start + old_size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\tif (this_hole > largest_hole)\n\t\t\tlargest_hole = this_hole;\n\n\t\tprev_de = de;\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tle16_add_cpu(&prev_de->rec_len, bytes);\n\n\t/* We need to double check this after modification of the final\n\t * dirent. */\n\tthis_hole = ocfs2_figure_dirent_hole(prev_de);\n\tif (this_hole > largest_hole)\n\t\tlargest_hole = this_hole;\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic unsigned int ocfs2_expand_last_dirent(char *start, unsigned int old_size,\n\t\t\t\t\t     struct inode *dir)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dir_entry *prev_de;\n\tchar *de_buf, *limit;\n\tunsigned int new_size = sb->s_blocksize;\n\tunsigned int bytes, this_hole;\n\tunsigned int largest_hole = 0;\n\n\tif (ocfs2_new_dir_wants_trailer(dir))\n\t\tnew_size = ocfs2_dir_trailer_blk_off(sb);\n\n\tbytes = new_size - old_size;\n\n\tlimit = start + old_size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\tif (this_hole > largest_hole)\n\t\t\tlargest_hole = this_hole;\n\n\t\tprev_de = de;\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tle16_add_cpu(&prev_de->rec_len, bytes);\n\n\t/* We need to double check this after modification of the final\n\t * dirent. */\n\tthis_hole = ocfs2_figure_dirent_hole(prev_de);\n\tif (this_hole > largest_hole)\n\t\tlargest_hole = this_hole;\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dirdata_bh->b_data + i_size_read(dir)",
            "0",
            "sb->s_blocksize - i_size_read(dir)"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dirdata_bh->b_data",
            "di->id2.i_data.id_data",
            "i_size_read(dir)"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_db",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "dirdata_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 2941
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "735-739",
          "snippet": "int ocfs2_journal_access_db(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &db_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers db_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_db_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers db_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_db_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_db(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &db_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(dir)",
            "dirdata_bh"
          ],
          "line": 2939
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "blkno"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_resv_allowed",
          "args": [
            "osb"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_resv_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "47-50",
          "snippet": "int ocfs2_dir_resv_allowed(struct ocfs2_super *osb)\n{\n\treturn (osb->osb_resv_level && osb->osb_dir_resv_level);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_dir_resv_allowed(struct ocfs2_super *osb)\n{\n\treturn (osb->osb_resv_level && osb->osb_dir_resv_level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_dx_dir_new_cluster",
          "args": [
            "dir",
            "0",
            "handle",
            "data_ac",
            "dx_leaves",
            "num_dx_leaves",
            "&dx_insert_blkno"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_dx_dir_new_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2468-2506",
          "snippet": "static int __ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t      u32 cpos, handle_t *handle,\n\t\t\t\t      struct ocfs2_alloc_context *data_ac,\n\t\t\t\t      struct buffer_head **dx_leaves,\n\t\t\t\t      int num_dx_leaves, u64 *ret_phys_blkno)\n{\n\tint ret;\n\tu32 phys, num;\n\tu64 phys_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\t/*\n\t * XXX: For create, this should claim cluster for the index\n\t * *before* the unindexed insert so that we have a better\n\t * chance of contiguousness as the directory grows in number\n\t * of entries.\n\t */\n\tret = __ocfs2_claim_clusters(handle, data_ac, 1, 1, &phys, &num);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Format the new cluster first. That way, we're inserting\n\t * valid data.\n\t */\n\tphys_blkno = ocfs2_clusters_to_blocks(osb->sb, phys);\n\tret = ocfs2_dx_dir_format_cluster(osb, handle, dir, dx_leaves,\n\t\t\t\t\t  num_dx_leaves, phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_phys_blkno = phys_blkno;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int __ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t      u32 cpos, handle_t *handle,\n\t\t\t\t      struct ocfs2_alloc_context *data_ac,\n\t\t\t\t      struct buffer_head **dx_leaves,\n\t\t\t\t      int num_dx_leaves, u64 *ret_phys_blkno)\n{\n\tint ret;\n\tu32 phys, num;\n\tu64 phys_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\t/*\n\t * XXX: For create, this should claim cluster for the index\n\t * *before* the unindexed insert so that we have a better\n\t * chance of contiguousness as the directory grows in number\n\t * of entries.\n\t */\n\tret = __ocfs2_claim_clusters(handle, data_ac, 1, 1, &phys, &num);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Format the new cluster first. That way, we're inserting\n\t * valid data.\n\t */\n\tphys_blkno = ocfs2_clusters_to_blocks(osb->sb, phys);\n\tret = ocfs2_dx_dir_format_cluster(osb, handle, dir, dx_leaves,\n\t\t\t\t\t  num_dx_leaves, phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_phys_blkno = phys_blkno;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_space_nodirty",
          "args": [
            "dir",
            "ocfs2_clusters_to_bytes(osb->sb, alloc + dx_alloc)"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters",
          "args": [
            "osb",
            "alloc + dx_alloc",
            "&data_ac"
          ],
          "line": 2870
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1228-1234",
          "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "alloc > 2"
          ],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "osb",
            "1",
            "&meta_ac"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_kmalloc_leaves",
          "args": [
            "sb",
            "&num_dx_leaves"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_new_dx_should_be_inline",
          "args": [
            "dir",
            "di_bh"
          ],
          "line": 2839
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_dx_should_be_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2717-2739",
          "snippet": "static int ocfs2_new_dx_should_be_inline(struct inode *dir,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint dirent_count = 0;\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tde_buf = di->id2.i_data.id_data;\n\tlimit = de_buf + i_size_read(dir);\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (de->name_len && de->inode)\n\t\t\tdirent_count++;\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n\n\t/* We are careful to leave room for one extra record. */\n\treturn dirent_count < ocfs2_dx_entries_per_root(dir->i_sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_new_dx_should_be_inline(struct inode *dir,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint dirent_count = 0;\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tde_buf = di->id2.i_data.id_data;\n\tlimit = de_buf + i_size_read(dir);\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (de->name_len && de->inode)\n\t\t\tdirent_count++;\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n\n\t/* We are careful to leave room for one extra record. */\n\treturn dirent_count < ocfs2_dx_entries_per_root(dir->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_add_dir_index_credits",
          "args": [
            "sb"
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_dir_index_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "422-428",
          "snippet": "static inline int ocfs2_add_dir_index_credits(struct super_block *sb)\n{\n\t/* 1 block for index, 2 allocs (data, metadata), 1 clusters\n\t * worth of blocks for initial extent. */\n\treturn 1 + 2 * OCFS2_SUBALLOC_ALLOC +\n\t\tocfs2_clusters_to_blocks(sb, 1);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_add_dir_index_credits(struct super_block *sb)\n{\n\t/* 1 block for index, 2 allocs (data, metadata), 1 clusters\n\t * worth of blocks for initial extent. */\n\treturn 1 + 2 * OCFS2_SUBALLOC_ALLOC +\n\t\tocfs2_clusters_to_blocks(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "sb",
            "bytes"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(dir)",
            "di_bh"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "458-464",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inline_to_extents_credits",
          "args": [
            "sb"
          ],
          "line": 2813
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inline_to_extents_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "399-403",
          "snippet": "static inline int ocfs2_inline_to_extents_credits(struct super_block *sb)\n{\n\treturn OCFS2_SUBALLOC_ALLOC + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)",
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_inline_to_extents_credits(struct super_block *sb)\n{\n\treturn OCFS2_SUBALLOC_ALLOC + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_expand_inline_dir(struct inode *dir, struct buffer_head *di_bh,\n\t\t\t\t   unsigned int blocks_wanted,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t   struct buffer_head **first_block_bh)\n{\n\tu32 alloc, dx_alloc, bit_off, len, num_dx_entries = 0;\n\tstruct super_block *sb = dir->i_sb;\n\tint ret, i, num_dx_leaves = 0, dx_inline = 0,\n\t\tcredits = ocfs2_inline_to_extents_credits(sb);\n\tu64 dx_insert_blkno, blkno,\n\t\tbytes = blocks_wanted << sb->s_blocksize_bits;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(dir);\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct buffer_head *dirdata_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct buffer_head **dx_leaves = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\thandle_t *handle;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_extent_tree dx_et;\n\tint did_quota = 0, bytes_allocated = 0;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(dir), di_bh);\n\n\talloc = ocfs2_clusters_for_bytes(sb, bytes);\n\tdx_alloc = 0;\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tcredits += ocfs2_add_dir_index_credits(sb);\n\n\t\tdx_inline = ocfs2_new_dx_should_be_inline(dir, di_bh);\n\t\tif (!dx_inline) {\n\t\t\t/* Add one more cluster for an index leaf */\n\t\t\tdx_alloc++;\n\t\t\tdx_leaves = ocfs2_dx_dir_kmalloc_leaves(sb,\n\t\t\t\t\t\t\t\t&num_dx_leaves);\n\t\t\tif (!dx_leaves) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* This gets us the dx_root */\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We should never need more than 2 clusters for the unindexed\n\t * tree - maximum dirent size is far less than one block. In\n\t * fact, the only time we'd need more than one cluster is if\n\t * blocksize == clustersize and the dirent won't fit in the\n\t * extra space that the expansion to a single block gives. As\n\t * of today, that only happens on 4k/4k file systems.\n\t */\n\tBUG_ON(alloc > 2);\n\n\tret = ocfs2_reserve_clusters(osb, alloc + dx_alloc, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Prepare for worst case allocation scenario of two separate\n\t * extents in the unindexed tree.\n\t */\n\tif (alloc == 2)\n\t\tcredits += OCFS2_SUBALLOC_ALLOC;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\tocfs2_clusters_to_bytes(osb->sb, alloc + dx_alloc));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\tif (ocfs2_supports_indexed_dirs(osb) && !dx_inline) {\n\t\t/*\n\t\t * Allocate our index cluster first, to maximize the\n\t\t * possibility that unindexed leaves grow\n\t\t * contiguously.\n\t\t */\n\t\tret = __ocfs2_dx_dir_new_cluster(dir, 0, handle, data_ac,\n\t\t\t\t\t\t dx_leaves, num_dx_leaves,\n\t\t\t\t\t\t &dx_insert_blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\t}\n\n\t/*\n\t * Try to claim as many clusters as the bitmap can give though\n\t * if we only get one now, that's enough to continue. The rest\n\t * will be claimed after the conversion to extents.\n\t */\n\tif (ocfs2_dir_resv_allowed(osb))\n\t\tdata_ac->ac_resv = &oi->ip_la_data_resv;\n\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off, &len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\n\t/*\n\t * Operations are carefully ordered so that we set up the new\n\t * data block first. The conversion from inline data to\n\t * extents follows.\n\t */\n\tblkno = ocfs2_clusters_to_blocks(dir->i_sb, bit_off);\n\tdirdata_bh = sb_getblk(sb, blkno);\n\tif (!dirdata_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), dirdata_bh);\n\n\tret = ocfs2_journal_access_db(handle, INODE_CACHE(dir), dirdata_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(dirdata_bh->b_data, di->id2.i_data.id_data, i_size_read(dir));\n\tmemset(dirdata_bh->b_data + i_size_read(dir), 0,\n\t       sb->s_blocksize - i_size_read(dir));\n\ti = ocfs2_expand_last_dirent(dirdata_bh->b_data, i_size_read(dir), dir);\n\tif (ocfs2_new_dir_wants_trailer(dir)) {\n\t\t/*\n\t\t * Prepare the dir trailer up front. It will otherwise look\n\t\t * like a valid dirent. Even if inserting the index fails\n\t\t * (unlikely), then all we'll have done is given first dir\n\t\t * block a small amount of fragmentation.\n\t\t */\n\t\tocfs2_init_dir_trailer(dir, dirdata_bh, i);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, dirdata_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb) && !dx_inline) {\n\t\t/*\n\t\t * Dx dirs with an external cluster need to do this up\n\t\t * front. Inline dx root's get handled later, after\n\t\t * we've allocated our root block. We get passed back\n\t\t * a total number of items so that dr_num_entries can\n\t\t * be correctly set once the dx_root has been\n\t\t * allocated.\n\t\t */\n\t\tret = ocfs2_dx_dir_index_block(dir, handle, dx_leaves,\n\t\t\t\t\t       num_dx_leaves, &num_dx_entries,\n\t\t\t\t\t       dirdata_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\t/*\n\t * Set extent, i_size, etc on the directory. After this, the\n\t * inode should contain the same exact dirents as before and\n\t * be fully accessible from system calls.\n\t *\n\t * We let the later dirent insert modify c/mtime - to the user\n\t * the data hasn't changed.\n\t */\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_dinode_new_extent_list(dir, di);\n\n\ti_size_write(dir, sb->s_blocksize);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\n\tdi->i_size = cpu_to_le64(sb->s_blocksize);\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(dir->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(dir->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\n\t/*\n\t * This should never fail as our extent list is empty and all\n\t * related blocks have been journaled already.\n\t */\n\tret = ocfs2_insert_extent(handle, &et, 0, blkno, len,\n\t\t\t\t  0, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Set i_blocks after the extent insert for the most up to\n\t * date ip_clusters value.\n\t */\n\tdir->i_blocks = ocfs2_inode_sector_count(dir);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tret = ocfs2_dx_dir_attach_index(osb, handle, dir, di_bh,\n\t\t\t\t\t\tdirdata_bh, meta_ac, dx_inline,\n\t\t\t\t\t\tnum_dx_entries, &dx_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tif (dx_inline) {\n\t\t\tocfs2_dx_dir_index_root_block(dir, dx_root_bh,\n\t\t\t\t\t\t      dirdata_bh);\n\t\t} else {\n\t\t\tocfs2_init_dx_root_extent_tree(&dx_et,\n\t\t\t\t\t\t       INODE_CACHE(dir),\n\t\t\t\t\t\t       dx_root_bh);\n\t\t\tret = ocfs2_insert_extent(handle, &dx_et, 0,\n\t\t\t\t\t\t  dx_insert_blkno, 1, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t}\n\n\t/*\n\t * We asked for two clusters, but only got one in the 1st\n\t * pass. Claim the 2nd cluster as a separate extent.\n\t */\n\tif (alloc > len) {\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tblkno = ocfs2_clusters_to_blocks(dir->i_sb, bit_off);\n\n\t\tret = ocfs2_insert_extent(handle, &et, 1,\n\t\t\t\t\t  blkno, len, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\t}\n\n\t*first_block_bh = dirdata_bh;\n\tdirdata_bh = NULL;\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tunsigned int off;\n\n\t\tif (!dx_inline) {\n\t\t\t/*\n\t\t\t * We need to return the correct block within the\n\t\t\t * cluster which should hold our entry.\n\t\t\t */\n\t\t\toff = ocfs2_dx_dir_hash_idx(OCFS2_SB(dir->i_sb),\n\t\t\t\t\t\t    &lookup->dl_hinfo);\n\t\t\tget_bh(dx_leaves[off]);\n\t\t\tlookup->dl_dx_leaf_bh = dx_leaves[off];\n\t\t}\n\t\tlookup->dl_dx_root_bh = dx_root_bh;\n\t\tdx_root_bh = NULL;\n\t}\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir, bytes_allocated);\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++)\n\t\t\tbrelse(dx_leaves[i]);\n\t\tkfree(dx_leaves);\n\t}\n\n\tbrelse(dirdata_bh);\n\tbrelse(dx_root_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_expand_last_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2755-2795",
    "snippet": "static unsigned int ocfs2_expand_last_dirent(char *start, unsigned int old_size,\n\t\t\t\t\t     struct inode *dir)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dir_entry *prev_de;\n\tchar *de_buf, *limit;\n\tunsigned int new_size = sb->s_blocksize;\n\tunsigned int bytes, this_hole;\n\tunsigned int largest_hole = 0;\n\n\tif (ocfs2_new_dir_wants_trailer(dir))\n\t\tnew_size = ocfs2_dir_trailer_blk_off(sb);\n\n\tbytes = new_size - old_size;\n\n\tlimit = start + old_size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\tif (this_hole > largest_hole)\n\t\t\tlargest_hole = this_hole;\n\n\t\tprev_de = de;\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tle16_add_cpu(&prev_de->rec_len, bytes);\n\n\t/* We need to double check this after modification of the final\n\t * dirent. */\n\tthis_hole = ocfs2_figure_dirent_hole(prev_de);\n\tif (this_hole > largest_hole)\n\t\tlargest_hole = this_hole;\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_figure_dirent_hole",
          "args": [
            "prev_de"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_figure_dirent_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1199-1210",
          "snippet": "static unsigned int ocfs2_figure_dirent_hole(struct ocfs2_dir_entry *de)\n{\n\tunsigned int hole;\n\n\tif (le64_to_cpu(de->inode) == 0)\n\t\thole = le16_to_cpu(de->rec_len);\n\telse\n\t\thole = le16_to_cpu(de->rec_len) -\n\t\t\tOCFS2_DIR_REC_LEN(de->name_len);\n\n\treturn hole;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic unsigned int ocfs2_figure_dirent_hole(struct ocfs2_dir_entry *de)\n{\n\tunsigned int hole;\n\n\tif (le64_to_cpu(de->inode) == 0)\n\t\thole = le16_to_cpu(de->rec_len);\n\telse\n\t\thole = le16_to_cpu(de->rec_len) -\n\t\t\tOCFS2_DIR_REC_LEN(de->name_len);\n\n\treturn hole;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&prev_de->rec_len",
            "bytes"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_trailer_blk_off",
          "args": [
            "sb"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_trailer_blk_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "114-117",
          "snippet": "static inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_new_dir_wants_trailer",
          "args": [
            "dir"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_dir_wants_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "106-112",
          "snippet": "static int ocfs2_new_dir_wants_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\treturn ocfs2_meta_ecc(osb) ||\n\t\tocfs2_supports_indexed_dirs(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_new_dir_wants_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\treturn ocfs2_meta_ecc(osb) ||\n\t\tocfs2_supports_indexed_dirs(osb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic unsigned int ocfs2_expand_last_dirent(char *start, unsigned int old_size,\n\t\t\t\t\t     struct inode *dir)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dir_entry *prev_de;\n\tchar *de_buf, *limit;\n\tunsigned int new_size = sb->s_blocksize;\n\tunsigned int bytes, this_hole;\n\tunsigned int largest_hole = 0;\n\n\tif (ocfs2_new_dir_wants_trailer(dir))\n\t\tnew_size = ocfs2_dir_trailer_blk_off(sb);\n\n\tbytes = new_size - old_size;\n\n\tlimit = start + old_size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\tif (this_hole > largest_hole)\n\t\t\tlargest_hole = this_hole;\n\n\t\tprev_de = de;\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tle16_add_cpu(&prev_de->rec_len, bytes);\n\n\t/* We need to double check this after modification of the final\n\t * dirent. */\n\tthis_hole = ocfs2_figure_dirent_hole(prev_de);\n\tif (this_hole > largest_hole)\n\t\tlargest_hole = this_hole;\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_new_dx_should_be_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2717-2739",
    "snippet": "static int ocfs2_new_dx_should_be_inline(struct inode *dir,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint dirent_count = 0;\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tde_buf = di->id2.i_data.id_data;\n\tlimit = de_buf + i_size_read(dir);\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (de->name_len && de->inode)\n\t\t\tdirent_count++;\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n\n\t/* We are careful to leave room for one extra record. */\n\treturn dirent_count < ocfs2_dx_entries_per_root(dir->i_sb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_dx_entries_per_root",
          "args": [
            "dir->i_sb"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_entries_per_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1379-1387",
          "snippet": "static inline int ocfs2_dx_entries_per_root(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_dx_root_block, dr_entries.de_entries);\n\n\treturn size / sizeof(struct ocfs2_dx_entry);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_dx_entries_per_root(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_dx_root_block, dr_entries.de_entries);\n\n\treturn size / sizeof(struct ocfs2_dx_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_new_dx_should_be_inline(struct inode *dir,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint dirent_count = 0;\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tde_buf = di->id2.i_data.id_data;\n\tlimit = de_buf + i_size_read(dir);\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (de->name_len && de->inode)\n\t\t\tdirent_count++;\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n\n\t/* We are careful to leave room for one extra record. */\n\treturn dirent_count < ocfs2_dx_entries_per_root(dir->i_sb);\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_index_root_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2674-2710",
    "snippet": "static void ocfs2_dx_dir_index_root_block(struct inode *dir,\n\t\t\t\t\t struct buffer_head *dx_root_bh,\n\t\t\t\t\t struct buffer_head *dirent_bh)\n{\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tu64 dirent_blk = dirent_bh->b_blocknr;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tde_buf = dirent_bh->b_data;\n\tlimit = de_buf + dir->i_sb->s_blocksize;\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (!de->name_len || !de->inode)\n\t\t\tgoto inc;\n\n\t\tocfs2_dx_dir_name_hash(dir, de->name, de->name_len, &hinfo);\n\n\t\ttrace_ocfs2_dx_dir_index_root_block(\n\t\t\t\t(unsigned long long)dir->i_ino,\n\t\t\t\thinfo.major_hash, hinfo.minor_hash,\n\t\t\t\tde->name_len, de->name,\n\t\t\t\tle16_to_cpu(dx_root->dr_entries.de_num_used));\n\n\t\tocfs2_dx_entry_list_insert(&dx_root->dr_entries, &hinfo,\n\t\t\t\t\t   dirent_blk);\n\n\t\tle32_add_cpu(&dx_root->dr_num_entries, 1);\ninc:\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dx_root->dr_num_entries",
            "1"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_entry_list_insert",
          "args": [
            "&dx_root->dr_entries",
            "&hinfo",
            "dirent_blk"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_entry_list_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1465-1481",
          "snippet": "static void ocfs2_dx_entry_list_insert(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t       u64 dirent_blk)\n{\n\tint i;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ti = le16_to_cpu(entry_list->de_num_used);\n\tdx_entry = &entry_list->de_entries[i];\n\n\tmemset(dx_entry, 0, sizeof(*dx_entry));\n\tdx_entry->dx_major_hash = cpu_to_le32(hinfo->major_hash);\n\tdx_entry->dx_minor_hash = cpu_to_le32(hinfo->minor_hash);\n\tdx_entry->dx_dirent_blk = cpu_to_le64(dirent_blk);\n\n\tle16_add_cpu(&entry_list->de_num_used, 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dx_entry_list_insert(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t       u64 dirent_blk)\n{\n\tint i;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ti = le16_to_cpu(entry_list->de_num_used);\n\tdx_entry = &entry_list->de_entries[i];\n\n\tmemset(dx_entry, 0, sizeof(*dx_entry));\n\tdx_entry->dx_major_hash = cpu_to_le32(hinfo->major_hash);\n\tdx_entry->dx_minor_hash = cpu_to_le32(hinfo->minor_hash);\n\tdx_entry->dx_dirent_blk = cpu_to_le64(dirent_blk);\n\n\tle16_add_cpu(&entry_list->de_num_used, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dx_dir_index_root_block",
          "args": [
            "(unsigned long long)dir->i_ino",
            "hinfo.major_hash",
            "hinfo.minor_hash",
            "de->name_len",
            "de->name",
            "le16_to_cpu(dx_root->dr_entries.de_num_used)"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_name_hash",
          "args": [
            "dir",
            "de->name",
            "de->name_len",
            "&hinfo"
          ],
          "line": 2695
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "270-310",
          "snippet": "static void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t/*\n\t * XXX: Is this really necessary, if the index is never looked\n\t * at by readdir? Is a hash value of '0' a bad idea?\n\t */\n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t/*\n\t * This makes it very easy to debug indexing problems. We\n\t * should never allow this to be selected without hand editing\n\t * this file though.\n\t */\n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t/*\n\t * XXX: Is this really necessary, if the index is never looked\n\t * at by readdir? Is a hash value of '0' a bad idea?\n\t */\n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t/*\n\t * This makes it very easy to debug indexing problems. We\n\t * should never allow this to be selected without hand editing\n\t * this file though.\n\t */\n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_dx_dir_index_root_block(struct inode *dir,\n\t\t\t\t\t struct buffer_head *dx_root_bh,\n\t\t\t\t\t struct buffer_head *dirent_bh)\n{\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tu64 dirent_blk = dirent_bh->b_blocknr;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tde_buf = dirent_bh->b_data;\n\tlimit = de_buf + dir->i_sb->s_blocksize;\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (!de->name_len || !de->inode)\n\t\t\tgoto inc;\n\n\t\tocfs2_dx_dir_name_hash(dir, de->name, de->name_len, &hinfo);\n\n\t\ttrace_ocfs2_dx_dir_index_root_block(\n\t\t\t\t(unsigned long long)dir->i_ino,\n\t\t\t\thinfo.major_hash, hinfo.minor_hash,\n\t\t\t\tde->name_len, de->name,\n\t\t\t\tle16_to_cpu(dx_root->dr_entries.de_num_used));\n\n\t\tocfs2_dx_entry_list_insert(&dx_root->dr_entries, &hinfo,\n\t\t\t\t\t   dirent_blk);\n\n\t\tle32_add_cpu(&dx_root->dr_num_entries, 1);\ninc:\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_index_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2625-2669",
    "snippet": "static int ocfs2_dx_dir_index_block(struct inode *dir,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct buffer_head **dx_leaves,\n\t\t\t\t    int num_dx_leaves,\n\t\t\t\t    u32 *num_dx_entries,\n\t\t\t\t    struct buffer_head *dirent_bh)\n{\n\tint ret = 0, namelen, i;\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dir_entry *de;\n\tstruct buffer_head *dx_leaf_bh;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tu64 dirent_blk = dirent_bh->b_blocknr;\n\n\tde_buf = dirent_bh->b_data;\n\tlimit = de_buf + dir->i_sb->s_blocksize;\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tnamelen = de->name_len;\n\t\tif (!namelen || !de->inode)\n\t\t\tgoto inc;\n\n\t\tocfs2_dx_dir_name_hash(dir, de->name, namelen, &hinfo);\n\n\t\ti = ocfs2_dx_dir_hash_idx(OCFS2_SB(dir->i_sb), &hinfo);\n\t\tdx_leaf_bh = dx_leaves[i];\n\n\t\tret = __ocfs2_dx_dir_leaf_insert(dir, handle, &hinfo,\n\t\t\t\t\t\t dirent_blk, dx_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t*num_dx_entries = *num_dx_entries + 1;\n\ninc:\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 2664
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_dx_dir_leaf_insert",
          "args": [
            "dir",
            "handle",
            "&hinfo",
            "dirent_blk",
            "dx_leaf_bh"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_dx_dir_leaf_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1483-1504",
          "snippet": "static int __ocfs2_dx_dir_leaf_insert(struct inode *dir, handle_t *handle,\n\t\t\t\t      struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t      u64 dirent_blk,\n\t\t\t\t      struct buffer_head *dx_leaf_bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\n\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), dx_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\tocfs2_dx_entry_list_insert(&dx_leaf->dl_list, hinfo, dirent_blk);\n\tocfs2_journal_dirty(handle, dx_leaf_bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int __ocfs2_dx_dir_leaf_insert(struct inode *dir, handle_t *handle,\n\t\t\t\t      struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t      u64 dirent_blk,\n\t\t\t\t      struct buffer_head *dx_leaf_bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\n\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), dx_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\tocfs2_dx_entry_list_insert(&dx_leaf->dl_list, hinfo, dirent_blk);\n\tocfs2_journal_dirty(handle, dx_leaf_bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_hash_idx",
          "args": [
            "OCFS2_SB(dir->i_sb)",
            "&hinfo"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_hash_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "865-869",
          "snippet": "static inline unsigned int ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_hinfo *hinfo)\n{\n\treturn __ocfs2_dx_dir_hash_idx(osb, hinfo->minor_hash);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_hinfo *hinfo)\n{\n\treturn __ocfs2_dx_dir_hash_idx(osb, hinfo->minor_hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_name_hash",
          "args": [
            "dir",
            "de->name",
            "namelen",
            "&hinfo"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "270-310",
          "snippet": "static void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t/*\n\t * XXX: Is this really necessary, if the index is never looked\n\t * at by readdir? Is a hash value of '0' a bad idea?\n\t */\n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t/*\n\t * This makes it very easy to debug indexing problems. We\n\t * should never allow this to be selected without hand editing\n\t * this file though.\n\t */\n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t/*\n\t * XXX: Is this really necessary, if the index is never looked\n\t * at by readdir? Is a hash value of '0' a bad idea?\n\t */\n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t/*\n\t * This makes it very easy to debug indexing problems. We\n\t * should never allow this to be selected without hand editing\n\t * this file though.\n\t */\n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_index_block(struct inode *dir,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct buffer_head **dx_leaves,\n\t\t\t\t    int num_dx_leaves,\n\t\t\t\t    u32 *num_dx_entries,\n\t\t\t\t    struct buffer_head *dirent_bh)\n{\n\tint ret = 0, namelen, i;\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dir_entry *de;\n\tstruct buffer_head *dx_leaf_bh;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tu64 dirent_blk = dirent_bh->b_blocknr;\n\n\tde_buf = dirent_bh->b_data;\n\tlimit = de_buf + dir->i_sb->s_blocksize;\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tnamelen = de->name_len;\n\t\tif (!namelen || !de->inode)\n\t\t\tgoto inc;\n\n\t\tocfs2_dx_dir_name_hash(dir, de->name, namelen, &hinfo);\n\n\t\ti = ocfs2_dx_dir_hash_idx(OCFS2_SB(dir->i_sb), &hinfo);\n\t\tdx_leaf_bh = dx_leaves[i];\n\n\t\tret = __ocfs2_dx_dir_leaf_insert(dir, handle, &hinfo,\n\t\t\t\t\t\t dirent_blk, dx_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t*num_dx_entries = *num_dx_entries + 1;\n\ninc:\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_fill_new_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2603-2623",
    "snippet": "int ocfs2_fill_new_dir(struct ocfs2_super *osb,\n\t\t       handle_t *handle,\n\t\t       struct inode *parent,\n\t\t       struct inode *inode,\n\t\t       struct buffer_head *fe_bh,\n\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t       struct ocfs2_alloc_context *meta_ac)\n\n{\n\tBUG_ON(!ocfs2_supports_inline_data(osb) && data_ac == NULL);\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_fill_new_dir_id(osb, handle, parent, inode, fe_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\treturn ocfs2_fill_new_dir_dx(osb, handle, parent, inode, fe_bh,\n\t\t\t\t\t     data_ac, meta_ac);\n\n\treturn ocfs2_fill_new_dir_el(osb, handle, parent, inode, fe_bh,\n\t\t\t\t     data_ac, NULL);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_fill_new_dir_el",
          "args": [
            "osb",
            "handle",
            "parent",
            "inode",
            "fe_bh",
            "data_ac",
            "NULL"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fill_new_dir_el",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2253-2321",
          "snippet": "static int ocfs2_fill_new_dir_el(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *fe_bh,\n\t\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t\t struct buffer_head **ret_new_bh)\n{\n\tint status;\n\tunsigned int size = osb->sb->s_blocksize;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry *de;\n\n\tif (ocfs2_new_dir_wants_trailer(inode))\n\t\tsize = ocfs2_dir_trailer_blk_off(parent->i_sb);\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, inode, fe_bh,\n\t\t\t\t     data_ac, NULL, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(inode), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, osb->sb->s_blocksize);\n\n\tde = ocfs2_fill_initial_dirents(inode, parent, new_bh->b_data, size);\n\tif (ocfs2_new_dir_wants_trailer(inode)) {\n\t\tint size = le16_to_cpu(de->rec_len);\n\n\t\t/*\n\t\t * Figure out the size of the hole left over after\n\t\t * insertion of '.' and '..'. The trailer wants this\n\t\t * information.\n\t\t */\n\t\tsize -= OCFS2_DIR_REC_LEN(2);\n\t\tsize -= sizeof(struct ocfs2_dir_block_trailer);\n\n\t\tocfs2_init_dir_trailer(inode, new_bh, size);\n\t}\n\n\tocfs2_journal_dirty(handle, new_bh);\n\n\ti_size_write(inode, inode->i_sb->s_blocksize);\n\tset_nlink(inode, 2);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (ret_new_bh) {\n\t\t*ret_new_bh = new_bh;\n\t\tnew_bh = NULL;\n\t}\nbail:\n\tbrelse(new_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);",
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_fill_new_dir_el(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *fe_bh,\n\t\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t\t struct buffer_head **ret_new_bh)\n{\n\tint status;\n\tunsigned int size = osb->sb->s_blocksize;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry *de;\n\n\tif (ocfs2_new_dir_wants_trailer(inode))\n\t\tsize = ocfs2_dir_trailer_blk_off(parent->i_sb);\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, inode, fe_bh,\n\t\t\t\t     data_ac, NULL, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(inode), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, osb->sb->s_blocksize);\n\n\tde = ocfs2_fill_initial_dirents(inode, parent, new_bh->b_data, size);\n\tif (ocfs2_new_dir_wants_trailer(inode)) {\n\t\tint size = le16_to_cpu(de->rec_len);\n\n\t\t/*\n\t\t * Figure out the size of the hole left over after\n\t\t * insertion of '.' and '..'. The trailer wants this\n\t\t * information.\n\t\t */\n\t\tsize -= OCFS2_DIR_REC_LEN(2);\n\t\tsize -= sizeof(struct ocfs2_dir_block_trailer);\n\n\t\tocfs2_init_dir_trailer(inode, new_bh, size);\n\t}\n\n\tocfs2_journal_dirty(handle, new_bh);\n\n\ti_size_write(inode, inode->i_sb->s_blocksize);\n\tset_nlink(inode, 2);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (ret_new_bh) {\n\t\t*ret_new_bh = new_bh;\n\t\tnew_bh = NULL;\n\t}\nbail:\n\tbrelse(new_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_fill_new_dir_dx",
          "args": [
            "osb",
            "handle",
            "parent",
            "inode",
            "fe_bh",
            "data_ac",
            "meta_ac"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fill_new_dir_dx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2548-2601",
          "snippet": "static int ocfs2_fill_new_dir_dx(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *di_bh,\n\t\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t\t struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct buffer_head *leaf_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\t/*\n\t * Our strategy is to create the directory as though it were\n\t * unindexed, then add the index block. This works with very\n\t * little complication since the state of a new directory is a\n\t * very well known quantity.\n\t *\n\t * Essentially, we have two dirents (\".\" and \"..\"), in the 1st\n\t * block which need indexing. These are easily inserted into\n\t * the index block.\n\t */\n\n\tret = ocfs2_fill_new_dir_el(osb, handle, parent, inode, di_bh,\n\t\t\t\t    data_ac, &leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_dx_dir_attach_index(osb, handle, inode, di_bh, leaf_bh,\n\t\t\t\t\tmeta_ac, 1, 2, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\t/* Buffer has been journaled for us by ocfs2_dx_dir_attach_index */\n\tocfs2_dx_dir_name_hash(inode, \".\", 1, &hinfo);\n\tocfs2_dx_entry_list_insert(entry_list, &hinfo, leaf_bh->b_blocknr);\n\n\tocfs2_dx_dir_name_hash(inode, \"..\", 2, &hinfo);\n\tocfs2_dx_entry_list_insert(entry_list, &hinfo, leaf_bh->b_blocknr);\n\nout:\n\tbrelse(dx_root_bh);\n\tbrelse(leaf_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_fill_new_dir_dx(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *di_bh,\n\t\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t\t struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct buffer_head *leaf_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\t/*\n\t * Our strategy is to create the directory as though it were\n\t * unindexed, then add the index block. This works with very\n\t * little complication since the state of a new directory is a\n\t * very well known quantity.\n\t *\n\t * Essentially, we have two dirents (\".\" and \"..\"), in the 1st\n\t * block which need indexing. These are easily inserted into\n\t * the index block.\n\t */\n\n\tret = ocfs2_fill_new_dir_el(osb, handle, parent, inode, di_bh,\n\t\t\t\t    data_ac, &leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_dx_dir_attach_index(osb, handle, inode, di_bh, leaf_bh,\n\t\t\t\t\tmeta_ac, 1, 2, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\t/* Buffer has been journaled for us by ocfs2_dx_dir_attach_index */\n\tocfs2_dx_dir_name_hash(inode, \".\", 1, &hinfo);\n\tocfs2_dx_entry_list_insert(entry_list, &hinfo, leaf_bh->b_blocknr);\n\n\tocfs2_dx_dir_name_hash(inode, \"..\", 2, &hinfo);\n\tocfs2_dx_entry_list_insert(entry_list, &hinfo, leaf_bh->b_blocknr);\n\nout:\n\tbrelse(dx_root_bh);\n\tbrelse(leaf_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_indexed_dirs",
          "args": [
            "osb"
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_indexed_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "532-537",
          "snippet": "static inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_fill_new_dir_id",
          "args": [
            "osb",
            "handle",
            "parent",
            "inode",
            "fe_bh"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fill_new_dir_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2220-2251",
          "snippet": "static int ocfs2_fill_new_dir_id(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *data = &di->id2.i_data;\n\tunsigned int size = le16_to_cpu(data->id_count);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_fill_initial_dirents(inode, parent, data->id_data, size);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\ti_size_write(inode, size);\n\tset_nlink(inode, 2);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\n\tret = ocfs2_mark_inode_dirty(handle, inode, di_bh);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_fill_new_dir_id(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *data = &di->id2.i_data;\n\tunsigned int size = le16_to_cpu(data->id_count);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_fill_initial_dirents(inode, parent, data->id_data, size);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\ti_size_write(inode, size);\n\tset_nlink(inode, 2);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\n\tret = ocfs2_mark_inode_dirty(handle, inode, di_bh);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2614
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_supports_inline_data(osb) && data_ac == NULL"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_inline_data",
          "args": [
            "osb"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "511-516",
          "snippet": "static inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_fill_new_dir(struct ocfs2_super *osb,\n\t\t       handle_t *handle,\n\t\t       struct inode *parent,\n\t\t       struct inode *inode,\n\t\t       struct buffer_head *fe_bh,\n\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t       struct ocfs2_alloc_context *meta_ac)\n\n{\n\tBUG_ON(!ocfs2_supports_inline_data(osb) && data_ac == NULL);\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_fill_new_dir_id(osb, handle, parent, inode, fe_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\treturn ocfs2_fill_new_dir_dx(osb, handle, parent, inode, fe_bh,\n\t\t\t\t\t     data_ac, meta_ac);\n\n\treturn ocfs2_fill_new_dir_el(osb, handle, parent, inode, fe_bh,\n\t\t\t\t     data_ac, NULL);\n}"
  },
  {
    "function_name": "ocfs2_fill_new_dir_dx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2548-2601",
    "snippet": "static int ocfs2_fill_new_dir_dx(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *di_bh,\n\t\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t\t struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct buffer_head *leaf_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\t/*\n\t * Our strategy is to create the directory as though it were\n\t * unindexed, then add the index block. This works with very\n\t * little complication since the state of a new directory is a\n\t * very well known quantity.\n\t *\n\t * Essentially, we have two dirents (\".\" and \"..\"), in the 1st\n\t * block which need indexing. These are easily inserted into\n\t * the index block.\n\t */\n\n\tret = ocfs2_fill_new_dir_el(osb, handle, parent, inode, di_bh,\n\t\t\t\t    data_ac, &leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_dx_dir_attach_index(osb, handle, inode, di_bh, leaf_bh,\n\t\t\t\t\tmeta_ac, 1, 2, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\t/* Buffer has been journaled for us by ocfs2_dx_dir_attach_index */\n\tocfs2_dx_dir_name_hash(inode, \".\", 1, &hinfo);\n\tocfs2_dx_entry_list_insert(entry_list, &hinfo, leaf_bh->b_blocknr);\n\n\tocfs2_dx_dir_name_hash(inode, \"..\", 2, &hinfo);\n\tocfs2_dx_entry_list_insert(entry_list, &hinfo, leaf_bh->b_blocknr);\n\nout:\n\tbrelse(dx_root_bh);\n\tbrelse(leaf_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "leaf_bh"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_entry_list_insert",
          "args": [
            "entry_list",
            "&hinfo",
            "leaf_bh->b_blocknr"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_entry_list_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1465-1481",
          "snippet": "static void ocfs2_dx_entry_list_insert(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t       u64 dirent_blk)\n{\n\tint i;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ti = le16_to_cpu(entry_list->de_num_used);\n\tdx_entry = &entry_list->de_entries[i];\n\n\tmemset(dx_entry, 0, sizeof(*dx_entry));\n\tdx_entry->dx_major_hash = cpu_to_le32(hinfo->major_hash);\n\tdx_entry->dx_minor_hash = cpu_to_le32(hinfo->minor_hash);\n\tdx_entry->dx_dirent_blk = cpu_to_le64(dirent_blk);\n\n\tle16_add_cpu(&entry_list->de_num_used, 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dx_entry_list_insert(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t       u64 dirent_blk)\n{\n\tint i;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ti = le16_to_cpu(entry_list->de_num_used);\n\tdx_entry = &entry_list->de_entries[i];\n\n\tmemset(dx_entry, 0, sizeof(*dx_entry));\n\tdx_entry->dx_major_hash = cpu_to_le32(hinfo->major_hash);\n\tdx_entry->dx_minor_hash = cpu_to_le32(hinfo->minor_hash);\n\tdx_entry->dx_dirent_blk = cpu_to_le64(dirent_blk);\n\n\tle16_add_cpu(&entry_list->de_num_used, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_name_hash",
          "args": [
            "inode",
            "\"..\"",
            "2",
            "&hinfo"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "270-310",
          "snippet": "static void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t/*\n\t * XXX: Is this really necessary, if the index is never looked\n\t * at by readdir? Is a hash value of '0' a bad idea?\n\t */\n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t/*\n\t * This makes it very easy to debug indexing problems. We\n\t * should never allow this to be selected without hand editing\n\t * this file though.\n\t */\n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t/*\n\t * XXX: Is this really necessary, if the index is never looked\n\t * at by readdir? Is a hash value of '0' a bad idea?\n\t */\n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t/*\n\t * This makes it very easy to debug indexing problems. We\n\t * should never allow this to be selected without hand editing\n\t * this file though.\n\t */\n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_attach_index",
          "args": [
            "osb",
            "handle",
            "inode",
            "di_bh",
            "leaf_bh",
            "meta_ac",
            "1",
            "2",
            "&dx_root_bh"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_attach_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2323-2413",
          "snippet": "static int ocfs2_dx_dir_attach_index(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle, struct inode *dir,\n\t\t\t\t     struct buffer_head *di_bh,\n\t\t\t\t     struct buffer_head *dirdata_bh,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     int dx_inline, u32 num_entries,\n\t\t\t\t     struct buffer_head **ret_dx_root_bh)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tu16 dr_suballoc_bit;\n\tu64 suballoc_loc, dr_blkno;\n\tunsigned int num_bits;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_trailer_from_bh(dirdata_bh, dir->i_sb);\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &dr_suballoc_bit, &num_bits, &dr_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_dx_dir_attach_index(\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)dr_blkno);\n\n\tdx_root_bh = sb_getblk(osb->sb, dr_blkno);\n\tif (dx_root_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), dx_root_bh);\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tmemset(dx_root, 0, osb->sb->s_blocksize);\n\tstrcpy(dx_root->dr_signature, OCFS2_DX_ROOT_SIGNATURE);\n\tdx_root->dr_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tdx_root->dr_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tdx_root->dr_suballoc_bit = cpu_to_le16(dr_suballoc_bit);\n\tdx_root->dr_fs_generation = cpu_to_le32(osb->fs_generation);\n\tdx_root->dr_blkno = cpu_to_le64(dr_blkno);\n\tdx_root->dr_dir_blkno = cpu_to_le64(OCFS2_I(dir)->ip_blkno);\n\tdx_root->dr_num_entries = cpu_to_le32(num_entries);\n\tif (le16_to_cpu(trailer->db_free_rec_len))\n\t\tdx_root->dr_free_blk = cpu_to_le64(dirdata_bh->b_blocknr);\n\telse\n\t\tdx_root->dr_free_blk = cpu_to_le64(0);\n\n\tif (dx_inline) {\n\t\tdx_root->dr_flags |= OCFS2_DX_FLAG_INLINE;\n\t\tdx_root->dr_entries.de_count =\n\t\t\tcpu_to_le16(ocfs2_dx_entries_per_root(osb->sb));\n\t} else {\n\t\tdx_root->dr_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_dx_root(osb->sb));\n\t}\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi->i_dx_root = cpu_to_le64(dr_blkno);\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tOCFS2_I(dir)->ip_dyn_features |= OCFS2_INDEXED_DIR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(dir)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\t*ret_dx_root_bh = dx_root_bh;\n\tdx_root_bh = NULL;\n\nout:\n\tbrelse(dx_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_attach_index(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle, struct inode *dir,\n\t\t\t\t     struct buffer_head *di_bh,\n\t\t\t\t     struct buffer_head *dirdata_bh,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     int dx_inline, u32 num_entries,\n\t\t\t\t     struct buffer_head **ret_dx_root_bh)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tu16 dr_suballoc_bit;\n\tu64 suballoc_loc, dr_blkno;\n\tunsigned int num_bits;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_trailer_from_bh(dirdata_bh, dir->i_sb);\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &dr_suballoc_bit, &num_bits, &dr_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_dx_dir_attach_index(\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)dr_blkno);\n\n\tdx_root_bh = sb_getblk(osb->sb, dr_blkno);\n\tif (dx_root_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), dx_root_bh);\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tmemset(dx_root, 0, osb->sb->s_blocksize);\n\tstrcpy(dx_root->dr_signature, OCFS2_DX_ROOT_SIGNATURE);\n\tdx_root->dr_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tdx_root->dr_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tdx_root->dr_suballoc_bit = cpu_to_le16(dr_suballoc_bit);\n\tdx_root->dr_fs_generation = cpu_to_le32(osb->fs_generation);\n\tdx_root->dr_blkno = cpu_to_le64(dr_blkno);\n\tdx_root->dr_dir_blkno = cpu_to_le64(OCFS2_I(dir)->ip_blkno);\n\tdx_root->dr_num_entries = cpu_to_le32(num_entries);\n\tif (le16_to_cpu(trailer->db_free_rec_len))\n\t\tdx_root->dr_free_blk = cpu_to_le64(dirdata_bh->b_blocknr);\n\telse\n\t\tdx_root->dr_free_blk = cpu_to_le64(0);\n\n\tif (dx_inline) {\n\t\tdx_root->dr_flags |= OCFS2_DX_FLAG_INLINE;\n\t\tdx_root->dr_entries.de_count =\n\t\t\tcpu_to_le16(ocfs2_dx_entries_per_root(osb->sb));\n\t} else {\n\t\tdx_root->dr_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_dx_root(osb->sb));\n\t}\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi->i_dx_root = cpu_to_le64(dr_blkno);\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tOCFS2_I(dir)->ip_dyn_features |= OCFS2_INDEXED_DIR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(dir)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\t*ret_dx_root_bh = dx_root_bh;\n\tdx_root_bh = NULL;\n\nout:\n\tbrelse(dx_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_fill_new_dir_el",
          "args": [
            "osb",
            "handle",
            "parent",
            "inode",
            "di_bh",
            "data_ac",
            "&leaf_bh"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fill_new_dir_el",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2253-2321",
          "snippet": "static int ocfs2_fill_new_dir_el(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *fe_bh,\n\t\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t\t struct buffer_head **ret_new_bh)\n{\n\tint status;\n\tunsigned int size = osb->sb->s_blocksize;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry *de;\n\n\tif (ocfs2_new_dir_wants_trailer(inode))\n\t\tsize = ocfs2_dir_trailer_blk_off(parent->i_sb);\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, inode, fe_bh,\n\t\t\t\t     data_ac, NULL, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(inode), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, osb->sb->s_blocksize);\n\n\tde = ocfs2_fill_initial_dirents(inode, parent, new_bh->b_data, size);\n\tif (ocfs2_new_dir_wants_trailer(inode)) {\n\t\tint size = le16_to_cpu(de->rec_len);\n\n\t\t/*\n\t\t * Figure out the size of the hole left over after\n\t\t * insertion of '.' and '..'. The trailer wants this\n\t\t * information.\n\t\t */\n\t\tsize -= OCFS2_DIR_REC_LEN(2);\n\t\tsize -= sizeof(struct ocfs2_dir_block_trailer);\n\n\t\tocfs2_init_dir_trailer(inode, new_bh, size);\n\t}\n\n\tocfs2_journal_dirty(handle, new_bh);\n\n\ti_size_write(inode, inode->i_sb->s_blocksize);\n\tset_nlink(inode, 2);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (ret_new_bh) {\n\t\t*ret_new_bh = new_bh;\n\t\tnew_bh = NULL;\n\t}\nbail:\n\tbrelse(new_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);",
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_fill_new_dir_el(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *fe_bh,\n\t\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t\t struct buffer_head **ret_new_bh)\n{\n\tint status;\n\tunsigned int size = osb->sb->s_blocksize;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry *de;\n\n\tif (ocfs2_new_dir_wants_trailer(inode))\n\t\tsize = ocfs2_dir_trailer_blk_off(parent->i_sb);\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, inode, fe_bh,\n\t\t\t\t     data_ac, NULL, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(inode), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, osb->sb->s_blocksize);\n\n\tde = ocfs2_fill_initial_dirents(inode, parent, new_bh->b_data, size);\n\tif (ocfs2_new_dir_wants_trailer(inode)) {\n\t\tint size = le16_to_cpu(de->rec_len);\n\n\t\t/*\n\t\t * Figure out the size of the hole left over after\n\t\t * insertion of '.' and '..'. The trailer wants this\n\t\t * information.\n\t\t */\n\t\tsize -= OCFS2_DIR_REC_LEN(2);\n\t\tsize -= sizeof(struct ocfs2_dir_block_trailer);\n\n\t\tocfs2_init_dir_trailer(inode, new_bh, size);\n\t}\n\n\tocfs2_journal_dirty(handle, new_bh);\n\n\ti_size_write(inode, inode->i_sb->s_blocksize);\n\tset_nlink(inode, 2);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (ret_new_bh) {\n\t\t*ret_new_bh = new_bh;\n\t\tnew_bh = NULL;\n\t}\nbail:\n\tbrelse(new_bh);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_fill_new_dir_dx(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *di_bh,\n\t\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t\t struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct buffer_head *leaf_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\t/*\n\t * Our strategy is to create the directory as though it were\n\t * unindexed, then add the index block. This works with very\n\t * little complication since the state of a new directory is a\n\t * very well known quantity.\n\t *\n\t * Essentially, we have two dirents (\".\" and \"..\"), in the 1st\n\t * block which need indexing. These are easily inserted into\n\t * the index block.\n\t */\n\n\tret = ocfs2_fill_new_dir_el(osb, handle, parent, inode, di_bh,\n\t\t\t\t    data_ac, &leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_dx_dir_attach_index(osb, handle, inode, di_bh, leaf_bh,\n\t\t\t\t\tmeta_ac, 1, 2, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\t/* Buffer has been journaled for us by ocfs2_dx_dir_attach_index */\n\tocfs2_dx_dir_name_hash(inode, \".\", 1, &hinfo);\n\tocfs2_dx_entry_list_insert(entry_list, &hinfo, leaf_bh->b_blocknr);\n\n\tocfs2_dx_dir_name_hash(inode, \"..\", 2, &hinfo);\n\tocfs2_dx_entry_list_insert(entry_list, &hinfo, leaf_bh->b_blocknr);\n\nout:\n\tbrelse(dx_root_bh);\n\tbrelse(leaf_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_kmalloc_leaves",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2534-2546",
    "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "num_dx_leaves",
            "sizeof(struct buffer_head *)",
            "GFP_NOFS"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "1"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_new_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2508-2532",
    "snippet": "static int ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    u32 cpos, handle_t *handle,\n\t\t\t\t    struct ocfs2_alloc_context *data_ac,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct buffer_head **dx_leaves,\n\t\t\t\t    int num_dx_leaves)\n{\n\tint ret;\n\tu64 phys_blkno;\n\n\tret = __ocfs2_dx_dir_new_cluster(dir, cpos, handle, data_ac, dx_leaves,\n\t\t\t\t\t num_dx_leaves, &phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_insert_extent(handle, et, cpos, phys_blkno, 1, 0,\n\t\t\t\t  meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_extent",
          "args": [
            "handle",
            "et",
            "cpos",
            "phys_blkno",
            "1",
            "0",
            "meta_ac"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4665-4726",
          "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_dx_dir_new_cluster",
          "args": [
            "dir",
            "cpos",
            "handle",
            "data_ac",
            "dx_leaves",
            "num_dx_leaves",
            "&phys_blkno"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_dx_dir_new_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2468-2506",
          "snippet": "static int __ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t      u32 cpos, handle_t *handle,\n\t\t\t\t      struct ocfs2_alloc_context *data_ac,\n\t\t\t\t      struct buffer_head **dx_leaves,\n\t\t\t\t      int num_dx_leaves, u64 *ret_phys_blkno)\n{\n\tint ret;\n\tu32 phys, num;\n\tu64 phys_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\t/*\n\t * XXX: For create, this should claim cluster for the index\n\t * *before* the unindexed insert so that we have a better\n\t * chance of contiguousness as the directory grows in number\n\t * of entries.\n\t */\n\tret = __ocfs2_claim_clusters(handle, data_ac, 1, 1, &phys, &num);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Format the new cluster first. That way, we're inserting\n\t * valid data.\n\t */\n\tphys_blkno = ocfs2_clusters_to_blocks(osb->sb, phys);\n\tret = ocfs2_dx_dir_format_cluster(osb, handle, dir, dx_leaves,\n\t\t\t\t\t  num_dx_leaves, phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_phys_blkno = phys_blkno;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int __ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t      u32 cpos, handle_t *handle,\n\t\t\t\t      struct ocfs2_alloc_context *data_ac,\n\t\t\t\t      struct buffer_head **dx_leaves,\n\t\t\t\t      int num_dx_leaves, u64 *ret_phys_blkno)\n{\n\tint ret;\n\tu32 phys, num;\n\tu64 phys_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\t/*\n\t * XXX: For create, this should claim cluster for the index\n\t * *before* the unindexed insert so that we have a better\n\t * chance of contiguousness as the directory grows in number\n\t * of entries.\n\t */\n\tret = __ocfs2_claim_clusters(handle, data_ac, 1, 1, &phys, &num);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Format the new cluster first. That way, we're inserting\n\t * valid data.\n\t */\n\tphys_blkno = ocfs2_clusters_to_blocks(osb->sb, phys);\n\tret = ocfs2_dx_dir_format_cluster(osb, handle, dir, dx_leaves,\n\t\t\t\t\t  num_dx_leaves, phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_phys_blkno = phys_blkno;\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    u32 cpos, handle_t *handle,\n\t\t\t\t    struct ocfs2_alloc_context *data_ac,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct buffer_head **dx_leaves,\n\t\t\t\t    int num_dx_leaves)\n{\n\tint ret;\n\tu64 phys_blkno;\n\n\tret = __ocfs2_dx_dir_new_cluster(dir, cpos, handle, data_ac, dx_leaves,\n\t\t\t\t\t num_dx_leaves, &phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_insert_extent(handle, et, cpos, phys_blkno, 1, 0,\n\t\t\t\t  meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_dx_dir_new_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2468-2506",
    "snippet": "static int __ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t      u32 cpos, handle_t *handle,\n\t\t\t\t      struct ocfs2_alloc_context *data_ac,\n\t\t\t\t      struct buffer_head **dx_leaves,\n\t\t\t\t      int num_dx_leaves, u64 *ret_phys_blkno)\n{\n\tint ret;\n\tu32 phys, num;\n\tu64 phys_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\t/*\n\t * XXX: For create, this should claim cluster for the index\n\t * *before* the unindexed insert so that we have a better\n\t * chance of contiguousness as the directory grows in number\n\t * of entries.\n\t */\n\tret = __ocfs2_claim_clusters(handle, data_ac, 1, 1, &phys, &num);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Format the new cluster first. That way, we're inserting\n\t * valid data.\n\t */\n\tphys_blkno = ocfs2_clusters_to_blocks(osb->sb, phys);\n\tret = ocfs2_dx_dir_format_cluster(osb, handle, dir, dx_leaves,\n\t\t\t\t\t  num_dx_leaves, phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_phys_blkno = phys_blkno;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_format_cluster",
          "args": [
            "osb",
            "handle",
            "dir",
            "dx_leaves",
            "num_dx_leaves",
            "phys_blkno"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_format_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2415-2461",
          "snippet": "static int ocfs2_dx_dir_format_cluster(struct ocfs2_super *osb,\n\t\t\t\t       handle_t *handle, struct inode *dir,\n\t\t\t\t       struct buffer_head **dx_leaves,\n\t\t\t\t       int num_dx_leaves, u64 start_blk)\n{\n\tint ret, i;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct buffer_head *bh;\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\tbh = sb_getblk(osb->sb, start_blk + i);\n\t\tif (bh == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tdx_leaves[i] = bh;\n\n\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), bh);\n\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdx_leaf = (struct ocfs2_dx_leaf *) bh->b_data;\n\n\t\tmemset(dx_leaf, 0, osb->sb->s_blocksize);\n\t\tstrcpy(dx_leaf->dl_signature, OCFS2_DX_LEAF_SIGNATURE);\n\t\tdx_leaf->dl_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\tdx_leaf->dl_blkno = cpu_to_le64(bh->b_blocknr);\n\t\tdx_leaf->dl_list.de_count =\n\t\t\tcpu_to_le16(ocfs2_dx_entries_per_leaf(osb->sb));\n\n\t\ttrace_ocfs2_dx_dir_format_cluster(\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)bh->b_blocknr,\n\t\t\t\tle16_to_cpu(dx_leaf->dl_list.de_count));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_format_cluster(struct ocfs2_super *osb,\n\t\t\t\t       handle_t *handle, struct inode *dir,\n\t\t\t\t       struct buffer_head **dx_leaves,\n\t\t\t\t       int num_dx_leaves, u64 start_blk)\n{\n\tint ret, i;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct buffer_head *bh;\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\tbh = sb_getblk(osb->sb, start_blk + i);\n\t\tif (bh == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tdx_leaves[i] = bh;\n\n\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), bh);\n\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdx_leaf = (struct ocfs2_dx_leaf *) bh->b_data;\n\n\t\tmemset(dx_leaf, 0, osb->sb->s_blocksize);\n\t\tstrcpy(dx_leaf->dl_signature, OCFS2_DX_LEAF_SIGNATURE);\n\t\tdx_leaf->dl_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\tdx_leaf->dl_blkno = cpu_to_le64(bh->b_blocknr);\n\t\tdx_leaf->dl_list.de_count =\n\t\t\tcpu_to_le16(ocfs2_dx_entries_per_leaf(osb->sb));\n\n\t\ttrace_ocfs2_dx_dir_format_cluster(\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)bh->b_blocknr,\n\t\t\t\tle16_to_cpu(dx_leaf->dl_list.de_count));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "phys"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_claim_clusters",
          "args": [
            "handle",
            "data_ac",
            "1",
            "1",
            "&phys",
            "&num"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2302-2371",
          "snippet": "int __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int __ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t      u32 cpos, handle_t *handle,\n\t\t\t\t      struct ocfs2_alloc_context *data_ac,\n\t\t\t\t      struct buffer_head **dx_leaves,\n\t\t\t\t      int num_dx_leaves, u64 *ret_phys_blkno)\n{\n\tint ret;\n\tu32 phys, num;\n\tu64 phys_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\t/*\n\t * XXX: For create, this should claim cluster for the index\n\t * *before* the unindexed insert so that we have a better\n\t * chance of contiguousness as the directory grows in number\n\t * of entries.\n\t */\n\tret = __ocfs2_claim_clusters(handle, data_ac, 1, 1, &phys, &num);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Format the new cluster first. That way, we're inserting\n\t * valid data.\n\t */\n\tphys_blkno = ocfs2_clusters_to_blocks(osb->sb, phys);\n\tret = ocfs2_dx_dir_format_cluster(osb, handle, dir, dx_leaves,\n\t\t\t\t\t  num_dx_leaves, phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_phys_blkno = phys_blkno;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_format_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2415-2461",
    "snippet": "static int ocfs2_dx_dir_format_cluster(struct ocfs2_super *osb,\n\t\t\t\t       handle_t *handle, struct inode *dir,\n\t\t\t\t       struct buffer_head **dx_leaves,\n\t\t\t\t       int num_dx_leaves, u64 start_blk)\n{\n\tint ret, i;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct buffer_head *bh;\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\tbh = sb_getblk(osb->sb, start_blk + i);\n\t\tif (bh == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tdx_leaves[i] = bh;\n\n\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), bh);\n\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdx_leaf = (struct ocfs2_dx_leaf *) bh->b_data;\n\n\t\tmemset(dx_leaf, 0, osb->sb->s_blocksize);\n\t\tstrcpy(dx_leaf->dl_signature, OCFS2_DX_LEAF_SIGNATURE);\n\t\tdx_leaf->dl_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\tdx_leaf->dl_blkno = cpu_to_le64(bh->b_blocknr);\n\t\tdx_leaf->dl_list.de_count =\n\t\t\tcpu_to_le16(ocfs2_dx_entries_per_leaf(osb->sb));\n\n\t\ttrace_ocfs2_dx_dir_format_cluster(\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)bh->b_blocknr,\n\t\t\t\tle16_to_cpu(dx_leaf->dl_list.de_count));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dx_dir_format_cluster",
          "args": [
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "(unsigned long long)bh->b_blocknr",
            "le16_to_cpu(dx_leaf->dl_list.de_count)"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dx_leaf->dl_list.de_count"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_dx_entries_per_leaf(osb->sb)"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_entries_per_leaf",
          "args": [
            "osb->sb"
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_entries_per_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1369-1377",
          "snippet": "static inline int ocfs2_dx_entries_per_leaf(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_dx_leaf, dl_list.de_entries);\n\n\treturn size / sizeof(struct ocfs2_dx_entry);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_dx_entries_per_leaf(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_dx_leaf, dl_list.de_entries);\n\n\treturn size / sizeof(struct ocfs2_dx_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bh->b_blocknr"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "osb->fs_generation"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dx_leaf->dl_signature",
            "OCFS2_DX_LEAF_SIGNATURE"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dx_leaf",
            "0",
            "osb->sb->s_blocksize"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dl",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "759-763",
          "snippet": "int ocfs2_journal_access_dl(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dl_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dl_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_leaf, dl_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dl_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_leaf, dl_check),\n};\n\nint ocfs2_journal_access_dl(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dl_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(dir)",
            "bh"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "osb->sb",
            "start_blk + i"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_format_cluster(struct ocfs2_super *osb,\n\t\t\t\t       handle_t *handle, struct inode *dir,\n\t\t\t\t       struct buffer_head **dx_leaves,\n\t\t\t\t       int num_dx_leaves, u64 start_blk)\n{\n\tint ret, i;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct buffer_head *bh;\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\tbh = sb_getblk(osb->sb, start_blk + i);\n\t\tif (bh == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tdx_leaves[i] = bh;\n\n\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), bh);\n\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdx_leaf = (struct ocfs2_dx_leaf *) bh->b_data;\n\n\t\tmemset(dx_leaf, 0, osb->sb->s_blocksize);\n\t\tstrcpy(dx_leaf->dl_signature, OCFS2_DX_LEAF_SIGNATURE);\n\t\tdx_leaf->dl_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\tdx_leaf->dl_blkno = cpu_to_le64(bh->b_blocknr);\n\t\tdx_leaf->dl_list.de_count =\n\t\t\tcpu_to_le16(ocfs2_dx_entries_per_leaf(osb->sb));\n\n\t\ttrace_ocfs2_dx_dir_format_cluster(\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)bh->b_blocknr,\n\t\t\t\tle16_to_cpu(dx_leaf->dl_list.de_count));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_attach_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2323-2413",
    "snippet": "static int ocfs2_dx_dir_attach_index(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle, struct inode *dir,\n\t\t\t\t     struct buffer_head *di_bh,\n\t\t\t\t     struct buffer_head *dirdata_bh,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     int dx_inline, u32 num_entries,\n\t\t\t\t     struct buffer_head **ret_dx_root_bh)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tu16 dr_suballoc_bit;\n\tu64 suballoc_loc, dr_blkno;\n\tunsigned int num_bits;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_trailer_from_bh(dirdata_bh, dir->i_sb);\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &dr_suballoc_bit, &num_bits, &dr_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_dx_dir_attach_index(\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)dr_blkno);\n\n\tdx_root_bh = sb_getblk(osb->sb, dr_blkno);\n\tif (dx_root_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), dx_root_bh);\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tmemset(dx_root, 0, osb->sb->s_blocksize);\n\tstrcpy(dx_root->dr_signature, OCFS2_DX_ROOT_SIGNATURE);\n\tdx_root->dr_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tdx_root->dr_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tdx_root->dr_suballoc_bit = cpu_to_le16(dr_suballoc_bit);\n\tdx_root->dr_fs_generation = cpu_to_le32(osb->fs_generation);\n\tdx_root->dr_blkno = cpu_to_le64(dr_blkno);\n\tdx_root->dr_dir_blkno = cpu_to_le64(OCFS2_I(dir)->ip_blkno);\n\tdx_root->dr_num_entries = cpu_to_le32(num_entries);\n\tif (le16_to_cpu(trailer->db_free_rec_len))\n\t\tdx_root->dr_free_blk = cpu_to_le64(dirdata_bh->b_blocknr);\n\telse\n\t\tdx_root->dr_free_blk = cpu_to_le64(0);\n\n\tif (dx_inline) {\n\t\tdx_root->dr_flags |= OCFS2_DX_FLAG_INLINE;\n\t\tdx_root->dr_entries.de_count =\n\t\t\tcpu_to_le16(ocfs2_dx_entries_per_root(osb->sb));\n\t} else {\n\t\tdx_root->dr_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_dx_root(osb->sb));\n\t}\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi->i_dx_root = cpu_to_le64(dr_blkno);\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tOCFS2_I(dir)->ip_dyn_features |= OCFS2_INDEXED_DIR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(dir)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\t*ret_dx_root_bh = dx_root_bh;\n\tdx_root_bh = NULL;\n\nout:\n\tbrelse(dx_root_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dx_root_bh"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 2405
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(dir)->ip_lock"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "OCFS2_I(dir)->ip_dyn_features"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(dir)->ip_lock"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "dr_blkno"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_extent_recs_per_dx_root(osb->sb)"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_recs_per_dx_root",
          "args": [
            "osb->sb"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_recs_per_dx_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1329-1337",
          "snippet": "static inline int ocfs2_extent_recs_per_dx_root(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_dx_root_block, dr_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extent_recs_per_dx_root(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_dx_root_block, dr_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_dx_entries_per_root(osb->sb)"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_entries_per_root",
          "args": [
            "osb->sb"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_entries_per_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1379-1387",
          "snippet": "static inline int ocfs2_dx_entries_per_root(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_dx_root_block, dr_entries.de_entries);\n\n\treturn size / sizeof(struct ocfs2_dx_entry);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_dx_entries_per_root(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_dx_root_block, dr_entries.de_entries);\n\n\treturn size / sizeof(struct ocfs2_dx_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "0"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "dirdata_bh->b_blocknr"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "trailer->db_free_rec_len"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "num_entries"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "OCFS2_I(dir)->ip_blkno"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "dr_blkno"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "osb->fs_generation"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "dr_suballoc_bit"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "suballoc_loc"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "meta_ac->ac_alloc_slot"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dx_root->dr_signature",
            "OCFS2_DX_ROOT_SIGNATURE"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dx_root",
            "0",
            "osb->sb->s_blocksize"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dr",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "dx_root_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "753-757",
          "snippet": "int ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};\n\nint ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(dir)",
            "dx_root_bh"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "osb->sb",
            "dr_blkno"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dx_dir_attach_index",
          "args": [
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "(unsigned long long)dr_blkno"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_metadata",
          "args": [
            "handle",
            "meta_ac",
            "1",
            "&suballoc_loc",
            "&dr_suballoc_bit",
            "&num_bits",
            "&dr_blkno"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1993-2029",
          "snippet": "int ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_trailer_from_bh",
          "args": [
            "dirdata_bh",
            "dir->i_sb"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_attach_index(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle, struct inode *dir,\n\t\t\t\t     struct buffer_head *di_bh,\n\t\t\t\t     struct buffer_head *dirdata_bh,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     int dx_inline, u32 num_entries,\n\t\t\t\t     struct buffer_head **ret_dx_root_bh)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tu16 dr_suballoc_bit;\n\tu64 suballoc_loc, dr_blkno;\n\tunsigned int num_bits;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_trailer_from_bh(dirdata_bh, dir->i_sb);\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &dr_suballoc_bit, &num_bits, &dr_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_dx_dir_attach_index(\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)dr_blkno);\n\n\tdx_root_bh = sb_getblk(osb->sb, dr_blkno);\n\tif (dx_root_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), dx_root_bh);\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tmemset(dx_root, 0, osb->sb->s_blocksize);\n\tstrcpy(dx_root->dr_signature, OCFS2_DX_ROOT_SIGNATURE);\n\tdx_root->dr_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tdx_root->dr_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tdx_root->dr_suballoc_bit = cpu_to_le16(dr_suballoc_bit);\n\tdx_root->dr_fs_generation = cpu_to_le32(osb->fs_generation);\n\tdx_root->dr_blkno = cpu_to_le64(dr_blkno);\n\tdx_root->dr_dir_blkno = cpu_to_le64(OCFS2_I(dir)->ip_blkno);\n\tdx_root->dr_num_entries = cpu_to_le32(num_entries);\n\tif (le16_to_cpu(trailer->db_free_rec_len))\n\t\tdx_root->dr_free_blk = cpu_to_le64(dirdata_bh->b_blocknr);\n\telse\n\t\tdx_root->dr_free_blk = cpu_to_le64(0);\n\n\tif (dx_inline) {\n\t\tdx_root->dr_flags |= OCFS2_DX_FLAG_INLINE;\n\t\tdx_root->dr_entries.de_count =\n\t\t\tcpu_to_le16(ocfs2_dx_entries_per_root(osb->sb));\n\t} else {\n\t\tdx_root->dr_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_dx_root(osb->sb));\n\t}\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi->i_dx_root = cpu_to_le64(dr_blkno);\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tOCFS2_I(dir)->ip_dyn_features |= OCFS2_INDEXED_DIR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(dir)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\t*ret_dx_root_bh = dx_root_bh;\n\tdx_root_bh = NULL;\n\nout:\n\tbrelse(dx_root_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_fill_new_dir_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2253-2321",
    "snippet": "static int ocfs2_fill_new_dir_el(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *fe_bh,\n\t\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t\t struct buffer_head **ret_new_bh)\n{\n\tint status;\n\tunsigned int size = osb->sb->s_blocksize;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry *de;\n\n\tif (ocfs2_new_dir_wants_trailer(inode))\n\t\tsize = ocfs2_dir_trailer_blk_off(parent->i_sb);\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, inode, fe_bh,\n\t\t\t\t     data_ac, NULL, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(inode), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, osb->sb->s_blocksize);\n\n\tde = ocfs2_fill_initial_dirents(inode, parent, new_bh->b_data, size);\n\tif (ocfs2_new_dir_wants_trailer(inode)) {\n\t\tint size = le16_to_cpu(de->rec_len);\n\n\t\t/*\n\t\t * Figure out the size of the hole left over after\n\t\t * insertion of '.' and '..'. The trailer wants this\n\t\t * information.\n\t\t */\n\t\tsize -= OCFS2_DIR_REC_LEN(2);\n\t\tsize -= sizeof(struct ocfs2_dir_block_trailer);\n\n\t\tocfs2_init_dir_trailer(inode, new_bh, size);\n\t}\n\n\tocfs2_journal_dirty(handle, new_bh);\n\n\ti_size_write(inode, inode->i_sb->s_blocksize);\n\tset_nlink(inode, 2);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (ret_new_bh) {\n\t\t*ret_new_bh = new_bh;\n\t\tnew_bh = NULL;\n\t}\nbail:\n\tbrelse(new_bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);",
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "inode",
            "fe_bh"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1250-1289",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "inode"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "inode->i_sb->s_blocksize"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "new_bh"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dir_trailer",
          "args": [
            "inode",
            "new_bh",
            "size"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dir_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "152-164",
          "snippet": "static void ocfs2_init_dir_trailer(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh, u16 rec_len)\n{\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, inode->i_sb);\n\tstrcpy(trailer->db_signature, OCFS2_DIR_TRAILER_SIGNATURE);\n\ttrailer->db_compat_rec_len =\n\t\t\tcpu_to_le16(sizeof(struct ocfs2_dir_block_trailer));\n\ttrailer->db_parent_dinode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\ttrailer->db_blkno = cpu_to_le64(bh->b_blocknr);\n\ttrailer->db_free_rec_len = cpu_to_le16(rec_len);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_init_dir_trailer(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh, u16 rec_len)\n{\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, inode->i_sb);\n\tstrcpy(trailer->db_signature, OCFS2_DIR_TRAILER_SIGNATURE);\n\ttrailer->db_compat_rec_len =\n\t\t\tcpu_to_le16(sizeof(struct ocfs2_dir_block_trailer));\n\ttrailer->db_parent_dinode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\ttrailer->db_blkno = cpu_to_le64(bh->b_blocknr);\n\ttrailer->db_free_rec_len = cpu_to_le16(rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "2"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_new_dir_wants_trailer",
          "args": [
            "inode"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_dir_wants_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "106-112",
          "snippet": "static int ocfs2_new_dir_wants_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\treturn ocfs2_meta_ecc(osb) ||\n\t\tocfs2_supports_indexed_dirs(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_new_dir_wants_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\treturn ocfs2_meta_ecc(osb) ||\n\t\tocfs2_supports_indexed_dirs(osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_fill_initial_dirents",
          "args": [
            "inode",
            "parent",
            "new_bh->b_data",
            "size"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fill_initial_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2192-2214",
          "snippet": "static struct ocfs2_dir_entry *ocfs2_fill_initial_dirents(struct inode *inode,\n\t\t\t\t\t\t\t  struct inode *parent,\n\t\t\t\t\t\t\t  char *start,\n\t\t\t\t\t\t\t  unsigned int size)\n{\n\tstruct ocfs2_dir_entry *de = (struct ocfs2_dir_entry *)start;\n\n\tde->inode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\tde->name_len = 1;\n\tde->rec_len =\n\t\tcpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\tstrcpy(de->name, \".\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\tde = (struct ocfs2_dir_entry *) ((char *)de + le16_to_cpu(de->rec_len));\n\tde->inode = cpu_to_le64(OCFS2_I(parent)->ip_blkno);\n\tde->rec_len = cpu_to_le16(size - OCFS2_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tstrcpy(de->name, \"..\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\treturn de;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic struct ocfs2_dir_entry *ocfs2_fill_initial_dirents(struct inode *inode,\n\t\t\t\t\t\t\t  struct inode *parent,\n\t\t\t\t\t\t\t  char *start,\n\t\t\t\t\t\t\t  unsigned int size)\n{\n\tstruct ocfs2_dir_entry *de = (struct ocfs2_dir_entry *)start;\n\n\tde->inode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\tde->name_len = 1;\n\tde->rec_len =\n\t\tcpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\tstrcpy(de->name, \".\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\tde = (struct ocfs2_dir_entry *) ((char *)de + le16_to_cpu(de->rec_len));\n\tde->inode = cpu_to_le64(OCFS2_I(parent)->ip_blkno);\n\tde->rec_len = cpu_to_le16(size - OCFS2_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tstrcpy(de->name, \"..\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_bh->b_data",
            "0",
            "osb->sb->s_blocksize"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_db",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "new_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "735-739",
          "snippet": "int ocfs2_journal_access_db(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &db_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers db_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_db_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers db_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_db_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_db(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &db_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(inode)",
            "new_bh"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_do_extend_dir",
          "args": [
            "osb->sb",
            "handle",
            "inode",
            "fe_bh",
            "data_ac",
            "NULL",
            "&new_bh"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_do_extend_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3122-3175",
          "snippet": "static int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh)\n{\n\tint status;\n\tint extend, did_quota = 0;\n\tu64 p_blkno, v_blkno;\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\textend = (i_size_read(dir) == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters));\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tif (extend) {\n\t\tu32 offset = OCFS2_I(dir)->ip_clusters;\n\n\t\tstatus = dquot_alloc_space_nodirty(dir,\n\t\t\t\t\tocfs2_clusters_to_bytes(sb, 1));\n\t\tif (status)\n\t\t\tgoto bail;\n\t\tdid_quota = 1;\n\n\t\tstatus = ocfs2_add_inode_data(OCFS2_SB(sb), dir, &offset,\n\t\t\t\t\t      1, 0, parent_fe_bh, handle,\n\t\t\t\t\t      data_ac, meta_ac, NULL);\n\t\tBUG_ON(status == -EAGAIN);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tv_blkno = ocfs2_blocks_for_bytes(sb, i_size_read(dir));\n\tstatus = ocfs2_extent_map_get_blocks(dir, v_blkno, &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*new_bh = sb_getblk(sb, p_blkno);\n\tif (!*new_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = 0;\nbail:\n\tif (did_quota && status < 0)\n\t\tdquot_free_space_nodirty(dir, ocfs2_clusters_to_bytes(sb, 1));\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);",
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh)\n{\n\tint status;\n\tint extend, did_quota = 0;\n\tu64 p_blkno, v_blkno;\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\textend = (i_size_read(dir) == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters));\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tif (extend) {\n\t\tu32 offset = OCFS2_I(dir)->ip_clusters;\n\n\t\tstatus = dquot_alloc_space_nodirty(dir,\n\t\t\t\t\tocfs2_clusters_to_bytes(sb, 1));\n\t\tif (status)\n\t\t\tgoto bail;\n\t\tdid_quota = 1;\n\n\t\tstatus = ocfs2_add_inode_data(OCFS2_SB(sb), dir, &offset,\n\t\t\t\t\t      1, 0, parent_fe_bh, handle,\n\t\t\t\t\t      data_ac, meta_ac, NULL);\n\t\tBUG_ON(status == -EAGAIN);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tv_blkno = ocfs2_blocks_for_bytes(sb, i_size_read(dir));\n\tstatus = ocfs2_extent_map_get_blocks(dir, v_blkno, &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*new_bh = sb_getblk(sb, p_blkno);\n\tif (!*new_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = 0;\nbail:\n\tif (did_quota && status < 0)\n\t\tdquot_free_space_nodirty(dir, ocfs2_clusters_to_bytes(sb, 1));\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_trailer_blk_off",
          "args": [
            "parent->i_sb"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_trailer_blk_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "114-117",
          "snippet": "static inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_fill_new_dir_el(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *fe_bh,\n\t\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t\t struct buffer_head **ret_new_bh)\n{\n\tint status;\n\tunsigned int size = osb->sb->s_blocksize;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry *de;\n\n\tif (ocfs2_new_dir_wants_trailer(inode))\n\t\tsize = ocfs2_dir_trailer_blk_off(parent->i_sb);\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, inode, fe_bh,\n\t\t\t\t     data_ac, NULL, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(inode), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, osb->sb->s_blocksize);\n\n\tde = ocfs2_fill_initial_dirents(inode, parent, new_bh->b_data, size);\n\tif (ocfs2_new_dir_wants_trailer(inode)) {\n\t\tint size = le16_to_cpu(de->rec_len);\n\n\t\t/*\n\t\t * Figure out the size of the hole left over after\n\t\t * insertion of '.' and '..'. The trailer wants this\n\t\t * information.\n\t\t */\n\t\tsize -= OCFS2_DIR_REC_LEN(2);\n\t\tsize -= sizeof(struct ocfs2_dir_block_trailer);\n\n\t\tocfs2_init_dir_trailer(inode, new_bh, size);\n\t}\n\n\tocfs2_journal_dirty(handle, new_bh);\n\n\ti_size_write(inode, inode->i_sb->s_blocksize);\n\tset_nlink(inode, 2);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (ret_new_bh) {\n\t\t*ret_new_bh = new_bh;\n\t\tnew_bh = NULL;\n\t}\nbail:\n\tbrelse(new_bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_fill_new_dir_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2220-2251",
    "snippet": "static int ocfs2_fill_new_dir_id(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *data = &di->id2.i_data;\n\tunsigned int size = le16_to_cpu(data->id_count);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_fill_initial_dirents(inode, parent, data->id_data, size);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\ti_size_write(inode, size);\n\tset_nlink(inode, 2);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\n\tret = ocfs2_mark_inode_dirty(handle, inode, di_bh);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "inode",
            "di_bh"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1250-1289",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "inode"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "size"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_fill_initial_dirents",
          "args": [
            "inode",
            "parent",
            "data->id_data",
            "size"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fill_initial_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2192-2214",
          "snippet": "static struct ocfs2_dir_entry *ocfs2_fill_initial_dirents(struct inode *inode,\n\t\t\t\t\t\t\t  struct inode *parent,\n\t\t\t\t\t\t\t  char *start,\n\t\t\t\t\t\t\t  unsigned int size)\n{\n\tstruct ocfs2_dir_entry *de = (struct ocfs2_dir_entry *)start;\n\n\tde->inode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\tde->name_len = 1;\n\tde->rec_len =\n\t\tcpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\tstrcpy(de->name, \".\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\tde = (struct ocfs2_dir_entry *) ((char *)de + le16_to_cpu(de->rec_len));\n\tde->inode = cpu_to_le64(OCFS2_I(parent)->ip_blkno);\n\tde->rec_len = cpu_to_le16(size - OCFS2_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tstrcpy(de->name, \"..\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\treturn de;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic struct ocfs2_dir_entry *ocfs2_fill_initial_dirents(struct inode *inode,\n\t\t\t\t\t\t\t  struct inode *parent,\n\t\t\t\t\t\t\t  char *start,\n\t\t\t\t\t\t\t  unsigned int size)\n{\n\tstruct ocfs2_dir_entry *de = (struct ocfs2_dir_entry *)start;\n\n\tde->inode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\tde->name_len = 1;\n\tde->rec_len =\n\t\tcpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\tstrcpy(de->name, \".\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\tde = (struct ocfs2_dir_entry *) ((char *)de + le16_to_cpu(de->rec_len));\n\tde->inode = cpu_to_le64(OCFS2_I(parent)->ip_blkno);\n\tde->rec_len = cpu_to_le16(size - OCFS2_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tstrcpy(de->name, \"..\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "data->id_count"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_fill_new_dir_id(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *data = &di->id2.i_data;\n\tunsigned int size = le16_to_cpu(data->id_count);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_fill_initial_dirents(inode, parent, data->id_data, size);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\ti_size_write(inode, size);\n\tset_nlink(inode, 2);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\n\tret = ocfs2_mark_inode_dirty(handle, inode, di_bh);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_fill_initial_dirents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2192-2214",
    "snippet": "static struct ocfs2_dir_entry *ocfs2_fill_initial_dirents(struct inode *inode,\n\t\t\t\t\t\t\t  struct inode *parent,\n\t\t\t\t\t\t\t  char *start,\n\t\t\t\t\t\t\t  unsigned int size)\n{\n\tstruct ocfs2_dir_entry *de = (struct ocfs2_dir_entry *)start;\n\n\tde->inode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\tde->name_len = 1;\n\tde->rec_len =\n\t\tcpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\tstrcpy(de->name, \".\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\tde = (struct ocfs2_dir_entry *) ((char *)de + le16_to_cpu(de->rec_len));\n\tde->inode = cpu_to_le64(OCFS2_I(parent)->ip_blkno);\n\tde->rec_len = cpu_to_le16(size - OCFS2_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tstrcpy(de->name, \"..\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\treturn de;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_set_de_type",
          "args": [
            "de",
            "S_IFDIR"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1630-1634",
          "snippet": "static inline void ocfs2_set_de_type(struct ocfs2_dir_entry *de,\n\t\t\t\t    umode_t mode)\n{\n\tde->file_type = ocfs2_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}",
          "includes": [],
          "macros_used": [
            "#define S_SHIFT\t\t\t12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define S_SHIFT\t\t\t12\n\nstatic inline void ocfs2_set_de_type(struct ocfs2_dir_entry *de,\n\t\t\t\t    umode_t mode)\n{\n\tde->file_type = ocfs2_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "de->name",
            "\"..\""
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "size - OCFS2_DIR_REC_LEN(1)"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "OCFS2_I(parent)->ip_blkno"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "parent"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "de->name",
            "\".\""
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "OCFS2_DIR_REC_LEN(de->name_len)"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "OCFS2_I(inode)->ip_blkno"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic struct ocfs2_dir_entry *ocfs2_fill_initial_dirents(struct inode *inode,\n\t\t\t\t\t\t\t  struct inode *parent,\n\t\t\t\t\t\t\t  char *start,\n\t\t\t\t\t\t\t  unsigned int size)\n{\n\tstruct ocfs2_dir_entry *de = (struct ocfs2_dir_entry *)start;\n\n\tde->inode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\tde->name_len = 1;\n\tde->rec_len =\n\t\tcpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\tstrcpy(de->name, \".\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\tde = (struct ocfs2_dir_entry *) ((char *)de + le16_to_cpu(de->rec_len));\n\tde->inode = cpu_to_le64(OCFS2_I(parent)->ip_blkno);\n\tde->rec_len = cpu_to_le16(size - OCFS2_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tstrcpy(de->name, \"..\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\treturn de;\n}"
  },
  {
    "function_name": "ocfs2_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2154-2185",
    "snippet": "int ocfs2_empty_dir(struct inode *inode)\n{\n\tint ret;\n\tstruct ocfs2_empty_dir_priv priv = {\n\t\t.ctx.actor = ocfs2_empty_dir_filldir,\n\t};\n\n\tif (ocfs2_dir_indexed(inode)) {\n\t\tret = ocfs2_empty_dir_dx(inode, &priv);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\t/*\n\t\t * We still run ocfs2_dir_foreach to get the checks\n\t\t * for \".\" and \"..\".\n\t\t */\n\t}\n\n\tret = ocfs2_dir_foreach(inode, &priv.ctx);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (!priv.seen_dot || !priv.seen_dot_dot) {\n\t\tmlog(ML_ERROR, \"bad directory (dir #%llu) - no `.' or `..'\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\t/*\n\t\t * XXX: Is it really safe to allow an unlink to continue?\n\t\t */\n\t\treturn 1;\n\t}\n\n\treturn !priv.seen_other;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"bad directory (dir #%llu) - no `.' or `..'\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_foreach",
          "args": [
            "inode",
            "&priv.ctx"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1951-1956",
          "snippet": "int ocfs2_dir_foreach(struct inode *inode, struct dir_context *ctx)\n{\n\tu64 version = inode->i_version;\n\tocfs2_dir_foreach_blk(inode, &version, ctx, true);\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_dir_foreach(struct inode *inode, struct dir_context *ctx)\n{\n\tu64 version = inode->i_version;\n\tocfs2_dir_foreach_blk(inode, &version, ctx, true);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_empty_dir_dx",
          "args": [
            "inode",
            "&priv"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_empty_dir_dx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2113-2145",
          "snippet": "static int ocfs2_empty_dir_dx(struct inode *inode,\n\t\t\t      struct ocfs2_empty_dir_priv *priv)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tpriv->dx_dir = 1;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_read_dx_root(inode, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tif (le32_to_cpu(dx_root->dr_num_entries) != 2)\n\t\tpriv->seen_other = 1;\n\nout:\n\tbrelse(di_bh);\n\tbrelse(dx_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_empty_dir_dx(struct inode *inode,\n\t\t\t      struct ocfs2_empty_dir_priv *priv)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tpriv->dx_dir = 1;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_read_dx_root(inode, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tif (le32_to_cpu(dx_root->dr_num_entries) != 2)\n\t\tpriv->seen_other = 1;\n\nout:\n\tbrelse(di_bh);\n\tbrelse(dx_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_indexed",
          "args": [
            "inode"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_indexed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "209-214",
          "snippet": "static int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_empty_dir(struct inode *inode)\n{\n\tint ret;\n\tstruct ocfs2_empty_dir_priv priv = {\n\t\t.ctx.actor = ocfs2_empty_dir_filldir,\n\t};\n\n\tif (ocfs2_dir_indexed(inode)) {\n\t\tret = ocfs2_empty_dir_dx(inode, &priv);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\t/*\n\t\t * We still run ocfs2_dir_foreach to get the checks\n\t\t * for \".\" and \"..\".\n\t\t */\n\t}\n\n\tret = ocfs2_dir_foreach(inode, &priv.ctx);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (!priv.seen_dot || !priv.seen_dot_dot) {\n\t\tmlog(ML_ERROR, \"bad directory (dir #%llu) - no `.' or `..'\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\t/*\n\t\t * XXX: Is it really safe to allow an unlink to continue?\n\t\t */\n\t\treturn 1;\n\t}\n\n\treturn !priv.seen_other;\n}"
  },
  {
    "function_name": "ocfs2_empty_dir_dx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2113-2145",
    "snippet": "static int ocfs2_empty_dir_dx(struct inode *inode,\n\t\t\t      struct ocfs2_empty_dir_priv *priv)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tpriv->dx_dir = 1;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_read_dx_root(inode, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tif (le32_to_cpu(dx_root->dr_num_entries) != 2)\n\t\tpriv->seen_other = 1;\n\nout:\n\tbrelse(di_bh);\n\tbrelse(dx_root_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dx_root_bh"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dx_root->dr_num_entries"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_dx_root",
          "args": [
            "inode",
            "di",
            "&dx_root_bh"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dx_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "617-632",
          "snippet": "static int ocfs2_read_dx_root(struct inode *dir, struct ocfs2_dinode *di,\n\t\t\t      struct buffer_head **dx_root_bh)\n{\n\tint ret;\n\tu64 blkno = le64_to_cpu(di->i_dx_root);\n\tstruct buffer_head *tmp = *dx_root_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_root);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_root_bh)\n\t\t*dx_root_bh = tmp;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dx_root(struct inode *dir, struct ocfs2_dinode *di,\n\t\t\t      struct buffer_head **dx_root_bh)\n{\n\tint ret;\n\tu64 blkno = le64_to_cpu(di->i_dx_root);\n\tstruct buffer_head *tmp = *dx_root_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_root);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_root_bh)\n\t\t*dx_root_bh = tmp;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "&di_bh"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_empty_dir_dx(struct inode *inode,\n\t\t\t      struct ocfs2_empty_dir_priv *priv)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tpriv->dx_dir = 1;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_read_dx_root(inode, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tif (le32_to_cpu(dx_root->dr_num_entries) != 2)\n\t\tpriv->seen_other = 1;\n\nout:\n\tbrelse(di_bh);\n\tbrelse(dx_root_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_empty_dir_filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2076-2111",
    "snippet": "static int ocfs2_empty_dir_filldir(struct dir_context *ctx, const char *name,\n\t\t\t\t   int name_len, loff_t pos, u64 ino,\n\t\t\t\t   unsigned type)\n{\n\tstruct ocfs2_empty_dir_priv *p =\n\t\tcontainer_of(ctx, struct ocfs2_empty_dir_priv, ctx);\n\n\t/*\n\t * Check the positions of \".\" and \"..\" records to be sure\n\t * they're in the correct place.\n\t *\n\t * Indexed directories don't need to proceed past the first\n\t * two entries, so we end the scan after seeing '..'. Despite\n\t * that, we allow the scan to proceed In the event that we\n\t * have a corrupted indexed directory (no dot or dot dot\n\t * entries). This allows us to double check for existing\n\t * entries which might not have been found in the index.\n\t */\n\tif (name_len == 1 && !strncmp(\".\", name, 1) && pos == 0) {\n\t\tp->seen_dot = 1;\n\t\treturn 0;\n\t}\n\n\tif (name_len == 2 && !strncmp(\"..\", name, 2) &&\n\t    pos == OCFS2_DIR_REC_LEN(1)) {\n\t\tp->seen_dot_dot = 1;\n\n\t\tif (p->dx_dir && p->seen_dot)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\tp->seen_other = 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"..\"",
            "name",
            "2"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\".\"",
            "name",
            "1"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structocfs2_empty_dir_priv",
            "ctx"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_empty_dir_filldir(struct dir_context *ctx, const char *name,\n\t\t\t\t   int name_len, loff_t pos, u64 ino,\n\t\t\t\t   unsigned type)\n{\n\tstruct ocfs2_empty_dir_priv *p =\n\t\tcontainer_of(ctx, struct ocfs2_empty_dir_priv, ctx);\n\n\t/*\n\t * Check the positions of \".\" and \"..\" records to be sure\n\t * they're in the correct place.\n\t *\n\t * Indexed directories don't need to proceed past the first\n\t * two entries, so we end the scan after seeing '..'. Despite\n\t * that, we allow the scan to proceed In the event that we\n\t * have a corrupted indexed directory (no dot or dot dot\n\t * entries). This allows us to double check for existing\n\t * entries which might not have been found in the index.\n\t */\n\tif (name_len == 1 && !strncmp(\".\", name, 1) && pos == 0) {\n\t\tp->seen_dot = 1;\n\t\treturn 0;\n\t}\n\n\tif (name_len == 2 && !strncmp(\"..\", name, 2) &&\n\t    pos == OCFS2_DIR_REC_LEN(1)) {\n\t\tp->seen_dot_dot = 1;\n\n\t\tif (p->dx_dir && p->seen_dot)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\tp->seen_other = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "ocfs2_check_dir_for_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2046-2067",
    "snippet": "int ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tret = -EEXIST;\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0)\n\t\tgoto bail;\n\n\tret = 0;\nbail:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_dir_lookup_result",
          "args": [
            "&lookup"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_dir_lookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "201-207",
          "snippet": "void ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_entry",
          "args": [
            "name",
            "namelen",
            "dir",
            "&lookup"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1086-1111",
          "snippet": "int ocfs2_find_entry(const char *name, int namelen,\n\t\t     struct inode *dir, struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct buffer_head *bh;\n\tstruct ocfs2_dir_entry *res_dir = NULL;\n\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_find_entry_dx(name, namelen, dir, lookup);\n\n\t/*\n\t * The unindexed dir code only uses part of the lookup\n\t * structure, so there's no reason to push it down further\n\t * than this.\n\t */\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tbh = ocfs2_find_entry_id(name, namelen, dir, &res_dir);\n\telse\n\t\tbh = ocfs2_find_entry_el(name, namelen, dir, &res_dir);\n\n\tif (bh == NULL)\n\t\treturn -ENOENT;\n\n\tlookup->dl_leaf_bh = bh;\n\tlookup->dl_entry = res_dir;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_find_entry(const char *name, int namelen,\n\t\t     struct inode *dir, struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct buffer_head *bh;\n\tstruct ocfs2_dir_entry *res_dir = NULL;\n\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_find_entry_dx(name, namelen, dir, lookup);\n\n\t/*\n\t * The unindexed dir code only uses part of the lookup\n\t * structure, so there's no reason to push it down further\n\t * than this.\n\t */\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tbh = ocfs2_find_entry_id(name, namelen, dir, &res_dir);\n\telse\n\t\tbh = ocfs2_find_entry_el(name, namelen, dir, &res_dir);\n\n\tif (bh == NULL)\n\t\treturn -ENOENT;\n\n\tlookup->dl_leaf_bh = bh;\n\tlookup->dl_entry = res_dir;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_check_dir_for_entry",
          "args": [
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "namelen",
            "name"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tret = -EEXIST;\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0)\n\t\tgoto bail;\n\n\tret = 0;\nbail:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_lookup_ino_from_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2027-2037",
    "snippet": "int ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_dir_lookup_result",
          "args": [
            "&lookup"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_dir_lookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "201-207",
          "snippet": "void ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_files_on_disk",
          "args": [
            "name",
            "namelen",
            "blkno",
            "dir",
            "&lookup"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_files_on_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2000-2021",
          "snippet": "int ocfs2_find_files_on_disk(const char *name,\n\t\t\t     int namelen,\n\t\t\t     u64 *blkno,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint status = -ENOENT;\n\n\ttrace_ocfs2_find_files_on_disk(namelen, name, blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_find_entry(name, namelen, inode, lookup);\n\tif (status)\n\t\tgoto leave;\n\n\t*blkno = le64_to_cpu(lookup->dl_entry->inode);\n\n\tstatus = 0;\nleave:\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_find_files_on_disk(const char *name,\n\t\t\t     int namelen,\n\t\t\t     u64 *blkno,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint status = -ENOENT;\n\n\ttrace_ocfs2_find_files_on_disk(namelen, name, blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_find_entry(name, namelen, inode, lookup);\n\tif (status)\n\t\tgoto leave;\n\n\t*blkno = le64_to_cpu(lookup->dl_entry->inode);\n\n\tstatus = 0;\nleave:\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_files_on_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "2000-2021",
    "snippet": "int ocfs2_find_files_on_disk(const char *name,\n\t\t\t     int namelen,\n\t\t\t     u64 *blkno,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint status = -ENOENT;\n\n\ttrace_ocfs2_find_files_on_disk(namelen, name, blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_find_entry(name, namelen, inode, lookup);\n\tif (status)\n\t\tgoto leave;\n\n\t*blkno = le64_to_cpu(lookup->dl_entry->inode);\n\n\tstatus = 0;\nleave:\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "lookup->dl_entry->inode"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_entry",
          "args": [
            "name",
            "namelen",
            "inode",
            "lookup"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1086-1111",
          "snippet": "int ocfs2_find_entry(const char *name, int namelen,\n\t\t     struct inode *dir, struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct buffer_head *bh;\n\tstruct ocfs2_dir_entry *res_dir = NULL;\n\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_find_entry_dx(name, namelen, dir, lookup);\n\n\t/*\n\t * The unindexed dir code only uses part of the lookup\n\t * structure, so there's no reason to push it down further\n\t * than this.\n\t */\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tbh = ocfs2_find_entry_id(name, namelen, dir, &res_dir);\n\telse\n\t\tbh = ocfs2_find_entry_el(name, namelen, dir, &res_dir);\n\n\tif (bh == NULL)\n\t\treturn -ENOENT;\n\n\tlookup->dl_leaf_bh = bh;\n\tlookup->dl_entry = res_dir;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_find_entry(const char *name, int namelen,\n\t\t     struct inode *dir, struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct buffer_head *bh;\n\tstruct ocfs2_dir_entry *res_dir = NULL;\n\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_find_entry_dx(name, namelen, dir, lookup);\n\n\t/*\n\t * The unindexed dir code only uses part of the lookup\n\t * structure, so there's no reason to push it down further\n\t * than this.\n\t */\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tbh = ocfs2_find_entry_id(name, namelen, dir, &res_dir);\n\telse\n\t\tbh = ocfs2_find_entry_el(name, namelen, dir, &res_dir);\n\n\tif (bh == NULL)\n\t\treturn -ENOENT;\n\n\tlookup->dl_leaf_bh = bh;\n\tlookup->dl_entry = res_dir;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_find_files_on_disk",
          "args": [
            "namelen",
            "name",
            "blkno",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_find_files_on_disk(const char *name,\n\t\t\t     int namelen,\n\t\t\t     u64 *blkno,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint status = -ENOENT;\n\n\ttrace_ocfs2_find_files_on_disk(namelen, name, blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_find_entry(name, namelen, inode, lookup);\n\tif (status)\n\t\tgoto leave;\n\n\t*blkno = le64_to_cpu(lookup->dl_entry->inode);\n\n\tstatus = 0;\nleave:\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1962-1995",
    "snippet": "int ocfs2_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint error = 0;\n\tstruct inode *inode = file_inode(file);\n\tint lock_level = 0;\n\n\ttrace_ocfs2_readdir((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\terror = ocfs2_inode_lock_atime(inode, file->f_path.mnt, &lock_level);\n\tif (lock_level && error >= 0) {\n\t\t/* We release EX lock which used to update atime\n\t\t * and get PR lock again to reduce contention\n\t\t * on commonly accessed directories. */\n\t\tocfs2_inode_unlock(inode, 1);\n\t\tlock_level = 0;\n\t\terror = ocfs2_inode_lock(inode, NULL, 0);\n\t}\n\tif (error < 0) {\n\t\tif (error != -ENOENT)\n\t\t\tmlog_errno(error);\n\t\t/* we haven't got any yet, so propagate the error. */\n\t\tgoto bail_nolock;\n\t}\n\n\terror = ocfs2_dir_foreach_blk(inode, &file->f_version, ctx, false);\n\n\tocfs2_inode_unlock(inode, lock_level);\n\tif (error)\n\t\tmlog_errno(error);\n\nbail_nolock:\n\n\treturn error;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "error"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "lock_level"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_foreach_blk",
          "args": [
            "inode",
            "&file->f_version",
            "ctx",
            "false"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_foreach_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1938-1945",
          "snippet": "static int ocfs2_dir_foreach_blk(struct inode *inode, u64 *f_version,\n\t\t\t\t struct dir_context *ctx,\n\t\t\t\t bool persist)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_dir_foreach_blk_id(inode, f_version, ctx);\n\treturn ocfs2_dir_foreach_blk_el(inode, f_version, ctx, persist);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_foreach_blk(struct inode *inode, u64 *f_version,\n\t\t\t\t struct dir_context *ctx,\n\t\t\t\t bool persist)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_dir_foreach_blk_id(inode, f_version, ctx);\n\treturn ocfs2_dir_foreach_blk_el(inode, f_version, ctx, persist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "error"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "NULL",
            "0"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_readdir",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint error = 0;\n\tstruct inode *inode = file_inode(file);\n\tint lock_level = 0;\n\n\ttrace_ocfs2_readdir((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\terror = ocfs2_inode_lock_atime(inode, file->f_path.mnt, &lock_level);\n\tif (lock_level && error >= 0) {\n\t\t/* We release EX lock which used to update atime\n\t\t * and get PR lock again to reduce contention\n\t\t * on commonly accessed directories. */\n\t\tocfs2_inode_unlock(inode, 1);\n\t\tlock_level = 0;\n\t\terror = ocfs2_inode_lock(inode, NULL, 0);\n\t}\n\tif (error < 0) {\n\t\tif (error != -ENOENT)\n\t\t\tmlog_errno(error);\n\t\t/* we haven't got any yet, so propagate the error. */\n\t\tgoto bail_nolock;\n\t}\n\n\terror = ocfs2_dir_foreach_blk(inode, &file->f_version, ctx, false);\n\n\tocfs2_inode_unlock(inode, lock_level);\n\tif (error)\n\t\tmlog_errno(error);\n\nbail_nolock:\n\n\treturn error;\n}"
  },
  {
    "function_name": "ocfs2_dir_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1951-1956",
    "snippet": "int ocfs2_dir_foreach(struct inode *inode, struct dir_context *ctx)\n{\n\tu64 version = inode->i_version;\n\tocfs2_dir_foreach_blk(inode, &version, ctx, true);\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_dir_foreach_blk",
          "args": [
            "inode",
            "&version",
            "ctx",
            "true"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_foreach_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1938-1945",
          "snippet": "static int ocfs2_dir_foreach_blk(struct inode *inode, u64 *f_version,\n\t\t\t\t struct dir_context *ctx,\n\t\t\t\t bool persist)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_dir_foreach_blk_id(inode, f_version, ctx);\n\treturn ocfs2_dir_foreach_blk_el(inode, f_version, ctx, persist);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_foreach_blk(struct inode *inode, u64 *f_version,\n\t\t\t\t struct dir_context *ctx,\n\t\t\t\t bool persist)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_dir_foreach_blk_id(inode, f_version, ctx);\n\treturn ocfs2_dir_foreach_blk_el(inode, f_version, ctx, persist);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_dir_foreach(struct inode *inode, struct dir_context *ctx)\n{\n\tu64 version = inode->i_version;\n\tocfs2_dir_foreach_blk(inode, &version, ctx, true);\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dir_foreach_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1938-1945",
    "snippet": "static int ocfs2_dir_foreach_blk(struct inode *inode, u64 *f_version,\n\t\t\t\t struct dir_context *ctx,\n\t\t\t\t bool persist)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_dir_foreach_blk_id(inode, f_version, ctx);\n\treturn ocfs2_dir_foreach_blk_el(inode, f_version, ctx, persist);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_dir_foreach_blk_el",
          "args": [
            "inode",
            "f_version",
            "ctx",
            "persist"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_foreach_blk_el",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1835-1936",
          "snippet": "static int ocfs2_dir_foreach_blk_el(struct inode *inode,\n\t\t\t\t    u64 *f_version,\n\t\t\t\t    struct dir_context *ctx,\n\t\t\t\t    bool persist)\n{\n\tunsigned long offset, blk, last_ra_blk = 0;\n\tint i;\n\tstruct buffer_head * bh, * tmp;\n\tstruct ocfs2_dir_entry * de;\n\tstruct super_block * sb = inode->i_sb;\n\tunsigned int ra_sectors = 16;\n\tint stored = 0;\n\n\tbh = NULL;\n\n\toffset = ctx->pos & (sb->s_blocksize - 1);\n\n\twhile (ctx->pos < i_size_read(inode)) {\n\t\tblk = ctx->pos >> sb->s_blocksize_bits;\n\t\tif (ocfs2_read_dir_block(inode, blk, &bh, 0)) {\n\t\t\t/* Skip the corrupt dirblock and keep trying */\n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* The idea here is to begin with 8k read-ahead and to stay\n\t\t * 4k ahead of our current position.\n\t\t *\n\t\t * TODO: Use the pagecache for this. We just need to\n\t\t * make sure it's cluster-safe... */\n\t\tif (!last_ra_blk\n\t\t    || (((last_ra_blk - blk) << 9) <= (ra_sectors / 2))) {\n\t\t\tfor (i = ra_sectors >> (sb->s_blocksize_bits - 9);\n\t\t\t     i > 0; i--) {\n\t\t\t\ttmp = NULL;\n\t\t\t\tif (!ocfs2_read_dir_block(inode, ++blk, &tmp,\n\t\t\t\t\t\t\t  OCFS2_BH_READAHEAD))\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tlast_ra_blk = blk;\n\t\t\tra_sectors = 8;\n\t\t}\n\n\t\t/* If the dir block has changed since the last call to\n\t\t * readdir(2), then we might be pointing to an invalid\n\t\t * dirent right now.  Scan from the start of the block\n\t\t * to make sure. */\n\t\tif (*f_version != inode->i_version) {\n\t\t\tfor (i = 0; i < sb->s_blocksize && i < offset; ) {\n\t\t\t\tde = (struct ocfs2_dir_entry *) (bh->b_data + i);\n\t\t\t\t/* It's too expensive to do a full\n\t\t\t\t * dirent test each time round this\n\t\t\t\t * loop, but we do have to test at\n\t\t\t\t * least that it is non-zero.  A\n\t\t\t\t * failure will be detected in the\n\t\t\t\t * dirent test below. */\n\t\t\t\tif (le16_to_cpu(de->rec_len) <\n\t\t\t\t    OCFS2_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += le16_to_cpu(de->rec_len);\n\t\t\t}\n\t\t\toffset = i;\n\t\t\tctx->pos = (ctx->pos & ~(sb->s_blocksize - 1))\n\t\t\t\t| offset;\n\t\t\t*f_version = inode->i_version;\n\t\t}\n\n\t\twhile (ctx->pos < i_size_read(inode)\n\t\t       && offset < sb->s_blocksize) {\n\t\t\tde = (struct ocfs2_dir_entry *) (bh->b_data + offset);\n\t\t\tif (!ocfs2_check_dir_entry(inode, de, bh, offset)) {\n\t\t\t\t/* On error, skip the f_pos to the\n\t\t\t\t   next block. */\n\t\t\t\tctx->pos = (ctx->pos | (sb->s_blocksize - 1)) + 1;\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (le64_to_cpu(de->inode)) {\n\t\t\t\tunsigned char d_type = DT_UNKNOWN;\n\n\t\t\t\tif (de->file_type < OCFS2_FT_MAX)\n\t\t\t\t\td_type = ocfs2_filetype_table[de->file_type];\n\t\t\t\tif (!dir_emit(ctx, de->name,\n\t\t\t\t\t\tde->name_len,\n\t\t\t\t\t\tle64_to_cpu(de->inode),\n\t\t\t\t\t\td_type)) {\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tstored++;\n\t\t\t}\n\t\t\toffset += le16_to_cpu(de->rec_len);\n\t\t\tctx->pos += le16_to_cpu(de->rec_len);\n\t\t}\n\t\toffset = 0;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tif (!persist && stored)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char ocfs2_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};",
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic unsigned char ocfs2_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_foreach_blk_el(struct inode *inode,\n\t\t\t\t    u64 *f_version,\n\t\t\t\t    struct dir_context *ctx,\n\t\t\t\t    bool persist)\n{\n\tunsigned long offset, blk, last_ra_blk = 0;\n\tint i;\n\tstruct buffer_head * bh, * tmp;\n\tstruct ocfs2_dir_entry * de;\n\tstruct super_block * sb = inode->i_sb;\n\tunsigned int ra_sectors = 16;\n\tint stored = 0;\n\n\tbh = NULL;\n\n\toffset = ctx->pos & (sb->s_blocksize - 1);\n\n\twhile (ctx->pos < i_size_read(inode)) {\n\t\tblk = ctx->pos >> sb->s_blocksize_bits;\n\t\tif (ocfs2_read_dir_block(inode, blk, &bh, 0)) {\n\t\t\t/* Skip the corrupt dirblock and keep trying */\n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* The idea here is to begin with 8k read-ahead and to stay\n\t\t * 4k ahead of our current position.\n\t\t *\n\t\t * TODO: Use the pagecache for this. We just need to\n\t\t * make sure it's cluster-safe... */\n\t\tif (!last_ra_blk\n\t\t    || (((last_ra_blk - blk) << 9) <= (ra_sectors / 2))) {\n\t\t\tfor (i = ra_sectors >> (sb->s_blocksize_bits - 9);\n\t\t\t     i > 0; i--) {\n\t\t\t\ttmp = NULL;\n\t\t\t\tif (!ocfs2_read_dir_block(inode, ++blk, &tmp,\n\t\t\t\t\t\t\t  OCFS2_BH_READAHEAD))\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tlast_ra_blk = blk;\n\t\t\tra_sectors = 8;\n\t\t}\n\n\t\t/* If the dir block has changed since the last call to\n\t\t * readdir(2), then we might be pointing to an invalid\n\t\t * dirent right now.  Scan from the start of the block\n\t\t * to make sure. */\n\t\tif (*f_version != inode->i_version) {\n\t\t\tfor (i = 0; i < sb->s_blocksize && i < offset; ) {\n\t\t\t\tde = (struct ocfs2_dir_entry *) (bh->b_data + i);\n\t\t\t\t/* It's too expensive to do a full\n\t\t\t\t * dirent test each time round this\n\t\t\t\t * loop, but we do have to test at\n\t\t\t\t * least that it is non-zero.  A\n\t\t\t\t * failure will be detected in the\n\t\t\t\t * dirent test below. */\n\t\t\t\tif (le16_to_cpu(de->rec_len) <\n\t\t\t\t    OCFS2_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += le16_to_cpu(de->rec_len);\n\t\t\t}\n\t\t\toffset = i;\n\t\t\tctx->pos = (ctx->pos & ~(sb->s_blocksize - 1))\n\t\t\t\t| offset;\n\t\t\t*f_version = inode->i_version;\n\t\t}\n\n\t\twhile (ctx->pos < i_size_read(inode)\n\t\t       && offset < sb->s_blocksize) {\n\t\t\tde = (struct ocfs2_dir_entry *) (bh->b_data + offset);\n\t\t\tif (!ocfs2_check_dir_entry(inode, de, bh, offset)) {\n\t\t\t\t/* On error, skip the f_pos to the\n\t\t\t\t   next block. */\n\t\t\t\tctx->pos = (ctx->pos | (sb->s_blocksize - 1)) + 1;\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (le64_to_cpu(de->inode)) {\n\t\t\t\tunsigned char d_type = DT_UNKNOWN;\n\n\t\t\t\tif (de->file_type < OCFS2_FT_MAX)\n\t\t\t\t\td_type = ocfs2_filetype_table[de->file_type];\n\t\t\t\tif (!dir_emit(ctx, de->name,\n\t\t\t\t\t\tde->name_len,\n\t\t\t\t\t\tle64_to_cpu(de->inode),\n\t\t\t\t\t\td_type)) {\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tstored++;\n\t\t\t}\n\t\t\toffset += le16_to_cpu(de->rec_len);\n\t\t\tctx->pos += le16_to_cpu(de->rec_len);\n\t\t}\n\t\toffset = 0;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tif (!persist && stored)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_foreach_blk_id",
          "args": [
            "inode",
            "f_version",
            "ctx"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_foreach_blk_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1762-1829",
          "snippet": "static int ocfs2_dir_foreach_blk_id(struct inode *inode,\n\t\t\t\t    u64 *f_version,\n\t\t\t\t    struct dir_context *ctx)\n{\n\tint ret, i;\n\tunsigned long offset = ctx->pos;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\tstruct ocfs2_dir_entry *de;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"Unable to read inode block for dir %llu\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\twhile (ctx->pos < i_size_read(inode)) {\n\t\t/* If the dir block has changed since the last call to\n\t\t * readdir(2), then we might be pointing to an invalid\n\t\t * dirent right now.  Scan from the start of the block\n\t\t * to make sure. */\n\t\tif (*f_version != inode->i_version) {\n\t\t\tfor (i = 0; i < i_size_read(inode) && i < offset; ) {\n\t\t\t\tde = (struct ocfs2_dir_entry *)\n\t\t\t\t\t(data->id_data + i);\n\t\t\t\t/* It's too expensive to do a full\n\t\t\t\t * dirent test each time round this\n\t\t\t\t * loop, but we do have to test at\n\t\t\t\t * least that it is non-zero.  A\n\t\t\t\t * failure will be detected in the\n\t\t\t\t * dirent test below. */\n\t\t\t\tif (le16_to_cpu(de->rec_len) <\n\t\t\t\t    OCFS2_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += le16_to_cpu(de->rec_len);\n\t\t\t}\n\t\t\tctx->pos = offset = i;\n\t\t\t*f_version = inode->i_version;\n\t\t}\n\n\t\tde = (struct ocfs2_dir_entry *) (data->id_data + ctx->pos);\n\t\tif (!ocfs2_check_dir_entry(inode, de, di_bh, ctx->pos)) {\n\t\t\t/* On error, skip the f_pos to the end. */\n\t\t\tctx->pos = i_size_read(inode);\n\t\t\tbreak;\n\t\t}\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tif (le64_to_cpu(de->inode)) {\n\t\t\tunsigned char d_type = DT_UNKNOWN;\n\n\t\t\tif (de->file_type < OCFS2_FT_MAX)\n\t\t\t\td_type = ocfs2_filetype_table[de->file_type];\n\n\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t      le64_to_cpu(de->inode), d_type))\n\t\t\t\tgoto out;\n\t\t}\n\t\tctx->pos += le16_to_cpu(de->rec_len);\n\t}\nout:\n\tbrelse(di_bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char ocfs2_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};",
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic unsigned char ocfs2_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_foreach_blk_id(struct inode *inode,\n\t\t\t\t    u64 *f_version,\n\t\t\t\t    struct dir_context *ctx)\n{\n\tint ret, i;\n\tunsigned long offset = ctx->pos;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\tstruct ocfs2_dir_entry *de;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"Unable to read inode block for dir %llu\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\twhile (ctx->pos < i_size_read(inode)) {\n\t\t/* If the dir block has changed since the last call to\n\t\t * readdir(2), then we might be pointing to an invalid\n\t\t * dirent right now.  Scan from the start of the block\n\t\t * to make sure. */\n\t\tif (*f_version != inode->i_version) {\n\t\t\tfor (i = 0; i < i_size_read(inode) && i < offset; ) {\n\t\t\t\tde = (struct ocfs2_dir_entry *)\n\t\t\t\t\t(data->id_data + i);\n\t\t\t\t/* It's too expensive to do a full\n\t\t\t\t * dirent test each time round this\n\t\t\t\t * loop, but we do have to test at\n\t\t\t\t * least that it is non-zero.  A\n\t\t\t\t * failure will be detected in the\n\t\t\t\t * dirent test below. */\n\t\t\t\tif (le16_to_cpu(de->rec_len) <\n\t\t\t\t    OCFS2_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += le16_to_cpu(de->rec_len);\n\t\t\t}\n\t\t\tctx->pos = offset = i;\n\t\t\t*f_version = inode->i_version;\n\t\t}\n\n\t\tde = (struct ocfs2_dir_entry *) (data->id_data + ctx->pos);\n\t\tif (!ocfs2_check_dir_entry(inode, de, di_bh, ctx->pos)) {\n\t\t\t/* On error, skip the f_pos to the end. */\n\t\t\tctx->pos = i_size_read(inode);\n\t\t\tbreak;\n\t\t}\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tif (le64_to_cpu(de->inode)) {\n\t\t\tunsigned char d_type = DT_UNKNOWN;\n\n\t\t\tif (de->file_type < OCFS2_FT_MAX)\n\t\t\t\td_type = ocfs2_filetype_table[de->file_type];\n\n\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t      le64_to_cpu(de->inode), d_type))\n\t\t\t\tgoto out;\n\t\t}\n\t\tctx->pos += le16_to_cpu(de->rec_len);\n\t}\nout:\n\tbrelse(di_bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_foreach_blk(struct inode *inode, u64 *f_version,\n\t\t\t\t struct dir_context *ctx,\n\t\t\t\t bool persist)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_dir_foreach_blk_id(inode, f_version, ctx);\n\treturn ocfs2_dir_foreach_blk_el(inode, f_version, ctx, persist);\n}"
  },
  {
    "function_name": "ocfs2_dir_foreach_blk_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1835-1936",
    "snippet": "static int ocfs2_dir_foreach_blk_el(struct inode *inode,\n\t\t\t\t    u64 *f_version,\n\t\t\t\t    struct dir_context *ctx,\n\t\t\t\t    bool persist)\n{\n\tunsigned long offset, blk, last_ra_blk = 0;\n\tint i;\n\tstruct buffer_head * bh, * tmp;\n\tstruct ocfs2_dir_entry * de;\n\tstruct super_block * sb = inode->i_sb;\n\tunsigned int ra_sectors = 16;\n\tint stored = 0;\n\n\tbh = NULL;\n\n\toffset = ctx->pos & (sb->s_blocksize - 1);\n\n\twhile (ctx->pos < i_size_read(inode)) {\n\t\tblk = ctx->pos >> sb->s_blocksize_bits;\n\t\tif (ocfs2_read_dir_block(inode, blk, &bh, 0)) {\n\t\t\t/* Skip the corrupt dirblock and keep trying */\n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* The idea here is to begin with 8k read-ahead and to stay\n\t\t * 4k ahead of our current position.\n\t\t *\n\t\t * TODO: Use the pagecache for this. We just need to\n\t\t * make sure it's cluster-safe... */\n\t\tif (!last_ra_blk\n\t\t    || (((last_ra_blk - blk) << 9) <= (ra_sectors / 2))) {\n\t\t\tfor (i = ra_sectors >> (sb->s_blocksize_bits - 9);\n\t\t\t     i > 0; i--) {\n\t\t\t\ttmp = NULL;\n\t\t\t\tif (!ocfs2_read_dir_block(inode, ++blk, &tmp,\n\t\t\t\t\t\t\t  OCFS2_BH_READAHEAD))\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tlast_ra_blk = blk;\n\t\t\tra_sectors = 8;\n\t\t}\n\n\t\t/* If the dir block has changed since the last call to\n\t\t * readdir(2), then we might be pointing to an invalid\n\t\t * dirent right now.  Scan from the start of the block\n\t\t * to make sure. */\n\t\tif (*f_version != inode->i_version) {\n\t\t\tfor (i = 0; i < sb->s_blocksize && i < offset; ) {\n\t\t\t\tde = (struct ocfs2_dir_entry *) (bh->b_data + i);\n\t\t\t\t/* It's too expensive to do a full\n\t\t\t\t * dirent test each time round this\n\t\t\t\t * loop, but we do have to test at\n\t\t\t\t * least that it is non-zero.  A\n\t\t\t\t * failure will be detected in the\n\t\t\t\t * dirent test below. */\n\t\t\t\tif (le16_to_cpu(de->rec_len) <\n\t\t\t\t    OCFS2_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += le16_to_cpu(de->rec_len);\n\t\t\t}\n\t\t\toffset = i;\n\t\t\tctx->pos = (ctx->pos & ~(sb->s_blocksize - 1))\n\t\t\t\t| offset;\n\t\t\t*f_version = inode->i_version;\n\t\t}\n\n\t\twhile (ctx->pos < i_size_read(inode)\n\t\t       && offset < sb->s_blocksize) {\n\t\t\tde = (struct ocfs2_dir_entry *) (bh->b_data + offset);\n\t\t\tif (!ocfs2_check_dir_entry(inode, de, bh, offset)) {\n\t\t\t\t/* On error, skip the f_pos to the\n\t\t\t\t   next block. */\n\t\t\t\tctx->pos = (ctx->pos | (sb->s_blocksize - 1)) + 1;\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (le64_to_cpu(de->inode)) {\n\t\t\t\tunsigned char d_type = DT_UNKNOWN;\n\n\t\t\t\tif (de->file_type < OCFS2_FT_MAX)\n\t\t\t\t\td_type = ocfs2_filetype_table[de->file_type];\n\t\t\t\tif (!dir_emit(ctx, de->name,\n\t\t\t\t\t\tde->name_len,\n\t\t\t\t\t\tle64_to_cpu(de->inode),\n\t\t\t\t\t\td_type)) {\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tstored++;\n\t\t\t}\n\t\t\toffset += le16_to_cpu(de->rec_len);\n\t\t\tctx->pos += le16_to_cpu(de->rec_len);\n\t\t}\n\t\toffset = 0;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tif (!persist && stored)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned char ocfs2_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};",
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "de->name",
            "de->name_len",
            "le64_to_cpu(de->inode)",
            "d_type"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_entry",
          "args": [
            "inode",
            "de",
            "bh",
            "offset"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "316-342",
          "snippet": "static int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_dir_block",
          "args": [
            "inode",
            "++blk",
            "&tmp",
            "OCFS2_BH_READAHEAD"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dir_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "522-552",
          "snippet": "static int ocfs2_read_dir_block(struct inode *inode, u64 v_block,\n\t\t\t\tstruct buffer_head **bh, int flags)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, flags,\n\t\t\t\t    ocfs2_validate_dir_block);\n\tif (rc) {\n\t\tmlog_errno(rc);\n\t\tgoto out;\n\t}\n\n\tif (!(flags & OCFS2_BH_READAHEAD) &&\n\t    ocfs2_supports_dir_trailer(inode)) {\n\t\trc = ocfs2_check_dir_trailer(inode, tmp);\n\t\tif (rc) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc ? -EIO : 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dir_block(struct inode *inode, u64 v_block,\n\t\t\t\tstruct buffer_head **bh, int flags)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, flags,\n\t\t\t\t    ocfs2_validate_dir_block);\n\tif (rc) {\n\t\tmlog_errno(rc);\n\t\tgoto out;\n\t}\n\n\tif (!(flags & OCFS2_BH_READAHEAD) &&\n\t    ocfs2_supports_dir_trailer(inode)) {\n\t\trc = ocfs2_check_dir_trailer(inode, tmp);\n\t\tif (rc) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc ? -EIO : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic unsigned char ocfs2_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_foreach_blk_el(struct inode *inode,\n\t\t\t\t    u64 *f_version,\n\t\t\t\t    struct dir_context *ctx,\n\t\t\t\t    bool persist)\n{\n\tunsigned long offset, blk, last_ra_blk = 0;\n\tint i;\n\tstruct buffer_head * bh, * tmp;\n\tstruct ocfs2_dir_entry * de;\n\tstruct super_block * sb = inode->i_sb;\n\tunsigned int ra_sectors = 16;\n\tint stored = 0;\n\n\tbh = NULL;\n\n\toffset = ctx->pos & (sb->s_blocksize - 1);\n\n\twhile (ctx->pos < i_size_read(inode)) {\n\t\tblk = ctx->pos >> sb->s_blocksize_bits;\n\t\tif (ocfs2_read_dir_block(inode, blk, &bh, 0)) {\n\t\t\t/* Skip the corrupt dirblock and keep trying */\n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* The idea here is to begin with 8k read-ahead and to stay\n\t\t * 4k ahead of our current position.\n\t\t *\n\t\t * TODO: Use the pagecache for this. We just need to\n\t\t * make sure it's cluster-safe... */\n\t\tif (!last_ra_blk\n\t\t    || (((last_ra_blk - blk) << 9) <= (ra_sectors / 2))) {\n\t\t\tfor (i = ra_sectors >> (sb->s_blocksize_bits - 9);\n\t\t\t     i > 0; i--) {\n\t\t\t\ttmp = NULL;\n\t\t\t\tif (!ocfs2_read_dir_block(inode, ++blk, &tmp,\n\t\t\t\t\t\t\t  OCFS2_BH_READAHEAD))\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tlast_ra_blk = blk;\n\t\t\tra_sectors = 8;\n\t\t}\n\n\t\t/* If the dir block has changed since the last call to\n\t\t * readdir(2), then we might be pointing to an invalid\n\t\t * dirent right now.  Scan from the start of the block\n\t\t * to make sure. */\n\t\tif (*f_version != inode->i_version) {\n\t\t\tfor (i = 0; i < sb->s_blocksize && i < offset; ) {\n\t\t\t\tde = (struct ocfs2_dir_entry *) (bh->b_data + i);\n\t\t\t\t/* It's too expensive to do a full\n\t\t\t\t * dirent test each time round this\n\t\t\t\t * loop, but we do have to test at\n\t\t\t\t * least that it is non-zero.  A\n\t\t\t\t * failure will be detected in the\n\t\t\t\t * dirent test below. */\n\t\t\t\tif (le16_to_cpu(de->rec_len) <\n\t\t\t\t    OCFS2_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += le16_to_cpu(de->rec_len);\n\t\t\t}\n\t\t\toffset = i;\n\t\t\tctx->pos = (ctx->pos & ~(sb->s_blocksize - 1))\n\t\t\t\t| offset;\n\t\t\t*f_version = inode->i_version;\n\t\t}\n\n\t\twhile (ctx->pos < i_size_read(inode)\n\t\t       && offset < sb->s_blocksize) {\n\t\t\tde = (struct ocfs2_dir_entry *) (bh->b_data + offset);\n\t\t\tif (!ocfs2_check_dir_entry(inode, de, bh, offset)) {\n\t\t\t\t/* On error, skip the f_pos to the\n\t\t\t\t   next block. */\n\t\t\t\tctx->pos = (ctx->pos | (sb->s_blocksize - 1)) + 1;\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (le64_to_cpu(de->inode)) {\n\t\t\t\tunsigned char d_type = DT_UNKNOWN;\n\n\t\t\t\tif (de->file_type < OCFS2_FT_MAX)\n\t\t\t\t\td_type = ocfs2_filetype_table[de->file_type];\n\t\t\t\tif (!dir_emit(ctx, de->name,\n\t\t\t\t\t\tde->name_len,\n\t\t\t\t\t\tle64_to_cpu(de->inode),\n\t\t\t\t\t\td_type)) {\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tstored++;\n\t\t\t}\n\t\t\toffset += le16_to_cpu(de->rec_len);\n\t\t\tctx->pos += le16_to_cpu(de->rec_len);\n\t\t}\n\t\toffset = 0;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tif (!persist && stored)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dir_foreach_blk_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1762-1829",
    "snippet": "static int ocfs2_dir_foreach_blk_id(struct inode *inode,\n\t\t\t\t    u64 *f_version,\n\t\t\t\t    struct dir_context *ctx)\n{\n\tint ret, i;\n\tunsigned long offset = ctx->pos;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\tstruct ocfs2_dir_entry *de;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"Unable to read inode block for dir %llu\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\twhile (ctx->pos < i_size_read(inode)) {\n\t\t/* If the dir block has changed since the last call to\n\t\t * readdir(2), then we might be pointing to an invalid\n\t\t * dirent right now.  Scan from the start of the block\n\t\t * to make sure. */\n\t\tif (*f_version != inode->i_version) {\n\t\t\tfor (i = 0; i < i_size_read(inode) && i < offset; ) {\n\t\t\t\tde = (struct ocfs2_dir_entry *)\n\t\t\t\t\t(data->id_data + i);\n\t\t\t\t/* It's too expensive to do a full\n\t\t\t\t * dirent test each time round this\n\t\t\t\t * loop, but we do have to test at\n\t\t\t\t * least that it is non-zero.  A\n\t\t\t\t * failure will be detected in the\n\t\t\t\t * dirent test below. */\n\t\t\t\tif (le16_to_cpu(de->rec_len) <\n\t\t\t\t    OCFS2_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += le16_to_cpu(de->rec_len);\n\t\t\t}\n\t\t\tctx->pos = offset = i;\n\t\t\t*f_version = inode->i_version;\n\t\t}\n\n\t\tde = (struct ocfs2_dir_entry *) (data->id_data + ctx->pos);\n\t\tif (!ocfs2_check_dir_entry(inode, de, di_bh, ctx->pos)) {\n\t\t\t/* On error, skip the f_pos to the end. */\n\t\t\tctx->pos = i_size_read(inode);\n\t\t\tbreak;\n\t\t}\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tif (le64_to_cpu(de->inode)) {\n\t\t\tunsigned char d_type = DT_UNKNOWN;\n\n\t\t\tif (de->file_type < OCFS2_FT_MAX)\n\t\t\t\td_type = ocfs2_filetype_table[de->file_type];\n\n\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t      le64_to_cpu(de->inode), d_type))\n\t\t\t\tgoto out;\n\t\t}\n\t\tctx->pos += le16_to_cpu(de->rec_len);\n\t}\nout:\n\tbrelse(di_bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned char ocfs2_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};",
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "de->name",
            "de->name_len",
            "le64_to_cpu(de->inode)",
            "d_type"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_entry",
          "args": [
            "inode",
            "de",
            "di_bh",
            "ctx->pos"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "316-342",
          "snippet": "static int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Unable to read inode block for dir %llu\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "&di_bh"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic unsigned char ocfs2_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_foreach_blk_id(struct inode *inode,\n\t\t\t\t    u64 *f_version,\n\t\t\t\t    struct dir_context *ctx)\n{\n\tint ret, i;\n\tunsigned long offset = ctx->pos;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\tstruct ocfs2_dir_entry *de;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"Unable to read inode block for dir %llu\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\twhile (ctx->pos < i_size_read(inode)) {\n\t\t/* If the dir block has changed since the last call to\n\t\t * readdir(2), then we might be pointing to an invalid\n\t\t * dirent right now.  Scan from the start of the block\n\t\t * to make sure. */\n\t\tif (*f_version != inode->i_version) {\n\t\t\tfor (i = 0; i < i_size_read(inode) && i < offset; ) {\n\t\t\t\tde = (struct ocfs2_dir_entry *)\n\t\t\t\t\t(data->id_data + i);\n\t\t\t\t/* It's too expensive to do a full\n\t\t\t\t * dirent test each time round this\n\t\t\t\t * loop, but we do have to test at\n\t\t\t\t * least that it is non-zero.  A\n\t\t\t\t * failure will be detected in the\n\t\t\t\t * dirent test below. */\n\t\t\t\tif (le16_to_cpu(de->rec_len) <\n\t\t\t\t    OCFS2_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += le16_to_cpu(de->rec_len);\n\t\t\t}\n\t\t\tctx->pos = offset = i;\n\t\t\t*f_version = inode->i_version;\n\t\t}\n\n\t\tde = (struct ocfs2_dir_entry *) (data->id_data + ctx->pos);\n\t\tif (!ocfs2_check_dir_entry(inode, de, di_bh, ctx->pos)) {\n\t\t\t/* On error, skip the f_pos to the end. */\n\t\t\tctx->pos = i_size_read(inode);\n\t\t\tbreak;\n\t\t}\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tif (le64_to_cpu(de->inode)) {\n\t\t\tunsigned char d_type = DT_UNKNOWN;\n\n\t\t\tif (de->file_type < OCFS2_FT_MAX)\n\t\t\t\td_type = ocfs2_filetype_table[de->file_type];\n\n\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t      le64_to_cpu(de->inode), d_type))\n\t\t\t\tgoto out;\n\t\t}\n\t\tctx->pos += le16_to_cpu(de->rec_len);\n\t}\nout:\n\tbrelse(di_bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "__ocfs2_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1608-1760",
    "snippet": "int __ocfs2_add_entry(handle_t *handle,\n\t\t      struct inode *dir,\n\t\t      const char *name, int namelen,\n\t\t      struct inode *inode, u64 blkno,\n\t\t      struct buffer_head *parent_fe_bh,\n\t\t      struct ocfs2_dir_lookup_result *lookup)\n{\n\tunsigned long offset;\n\tunsigned short rec_len;\n\tstruct ocfs2_dir_entry *de, *de1;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_fe_bh->b_data;\n\tstruct super_block *sb = dir->i_sb;\n\tint retval, status;\n\tunsigned int size = sb->s_blocksize;\n\tstruct buffer_head *insert_bh = lookup->dl_leaf_bh;\n\tchar *data_start = insert_bh->b_data;\n\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tstruct buffer_head *bh;\n\n\t\t/*\n\t\t * An indexed dir may require that we update the free space\n\t\t * list. Reserve a write to the previous node in the list so\n\t\t * that we don't fail later.\n\t\t *\n\t\t * XXX: This can be either a dx_root_block, or an unindexed\n\t\t * directory tree leaf block.\n\t\t */\n\t\tif (ocfs2_free_list_at_root(lookup)) {\n\t\t\tbh = lookup->dl_dx_root_bh;\n\t\t\tretval = ocfs2_journal_access_dr(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t} else {\n\t\t\tbh = lookup->dl_prev_leaf_bh;\n\t\t\tretval = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t}\n\t\tif (retval) {\n\t\t\tmlog_errno(retval);\n\t\t\treturn retval;\n\t\t}\n\t} else if (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tdata_start = di->id2.i_data.id_data;\n\t\tsize = i_size_read(dir);\n\n\t\tBUG_ON(insert_bh != parent_fe_bh);\n\t}\n\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\toffset = 0;\n\tde = (struct ocfs2_dir_entry *) data_start;\n\twhile (1) {\n\t\tBUG_ON((char *)de >= (size + data_start));\n\n\t\t/* These checks should've already been passed by the\n\t\t * prepare function, but I guess we can leave them\n\t\t * here anyway. */\n\t\tif (!ocfs2_check_dir_entry(dir, de, insert_bh, offset)) {\n\t\t\tretval = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tretval = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* We're guaranteed that we should have space, so we\n\t\t * can't possibly have hit the trailer...right? */\n\t\tmlog_bug_on_msg(ocfs2_skip_dir_trailer(dir, de, offset, size),\n\t\t\t\t\"Hit dir trailer trying to insert %.*s \"\n\t\t\t        \"(namelen %d) into directory %llu.  \"\n\t\t\t\t\"offset is %lu, trailer offset is %d\\n\",\n\t\t\t\tnamelen, name, namelen,\n\t\t\t\t(unsigned long long)parent_fe_bh->b_blocknr,\n\t\t\t\toffset, ocfs2_dir_trailer_blk_off(dir->i_sb));\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t\t\tretval = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\t\t\tif (retval < 0) {\n\t\t\t\tmlog_errno(retval);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tif (insert_bh == parent_fe_bh)\n\t\t\t\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\telse {\n\t\t\t\tstatus = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t\t\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\t\t\tstatus = ocfs2_dx_dir_insert(dir,\n\t\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\t\tlookup);\n\t\t\t\t\tif (status) {\n\t\t\t\t\t\tmlog_errno(status);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* By now the buffer is marked for journaling */\n\t\t\toffset += le16_to_cpu(de->rec_len);\n\t\t\tif (le64_to_cpu(de->inode)) {\n\t\t\t\tde1 = (struct ocfs2_dir_entry *)((char *) de +\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde1->rec_len =\n\t\t\t\t\tcpu_to_le16(le16_to_cpu(de->rec_len) -\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde->rec_len = cpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde = de1;\n\t\t\t}\n\t\t\tde->file_type = OCFS2_FT_UNKNOWN;\n\t\t\tif (blkno) {\n\t\t\t\tde->inode = cpu_to_le64(blkno);\n\t\t\t\tocfs2_set_de_type(de, inode->i_mode);\n\t\t\t} else\n\t\t\t\tde->inode = 0;\n\t\t\tde->name_len = namelen;\n\t\t\tmemcpy(de->name, name, namelen);\n\n\t\t\tif (ocfs2_dir_indexed(dir))\n\t\t\t\tocfs2_recalc_free_list(dir, handle, lookup);\n\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, insert_bh);\n\t\t\tretval = 0;\n\t\t\tgoto bail;\n\t\t}\n\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *) ((char *) de + le16_to_cpu(de->rec_len));\n\t}\n\n\t/* when you think about it, the assert above should prevent us\n\t * from ever getting here. */\n\tretval = -ENOSPC;\nbail:\n\tif (retval)\n\t\tmlog_errno(retval);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "retval"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "insert_bh"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_recalc_free_list",
          "args": [
            "dir",
            "handle",
            "lookup"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recalc_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1580-1600",
          "snippet": "static void ocfs2_recalc_free_list(struct inode *dir, handle_t *handle,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint max_rec_len;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\t/* Walk dl_leaf_bh to figure out what the new free rec_len is. */\n\tmax_rec_len = ocfs2_find_max_rec_len(dir->i_sb, lookup->dl_leaf_bh);\n\tif (max_rec_len) {\n\t\t/*\n\t\t * There's still room in this block, so no need to remove it\n\t\t * from the free list. In this case, we just want to update\n\t\t * the rec len accounting.\n\t\t */\n\t\ttrailer = ocfs2_trailer_from_bh(lookup->dl_leaf_bh, dir->i_sb);\n\t\ttrailer->db_free_rec_len = cpu_to_le16(max_rec_len);\n\t\tocfs2_journal_dirty(handle, lookup->dl_leaf_bh);\n\t} else {\n\t\tocfs2_remove_block_from_free_list(dir, handle, lookup);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_recalc_free_list(struct inode *dir, handle_t *handle,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint max_rec_len;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\t/* Walk dl_leaf_bh to figure out what the new free rec_len is. */\n\tmax_rec_len = ocfs2_find_max_rec_len(dir->i_sb, lookup->dl_leaf_bh);\n\tif (max_rec_len) {\n\t\t/*\n\t\t * There's still room in this block, so no need to remove it\n\t\t * from the free list. In this case, we just want to update\n\t\t * the rec len accounting.\n\t\t */\n\t\ttrailer = ocfs2_trailer_from_bh(lookup->dl_leaf_bh, dir->i_sb);\n\t\ttrailer->db_free_rec_len = cpu_to_le16(max_rec_len);\n\t\tocfs2_journal_dirty(handle, lookup->dl_leaf_bh);\n\t} else {\n\t\tocfs2_remove_block_from_free_list(dir, handle, lookup);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_indexed",
          "args": [
            "dir"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_indexed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "209-214",
          "snippet": "static int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de->name",
            "name",
            "namelen"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_de_type",
          "args": [
            "de",
            "inode->i_mode"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1630-1634",
          "snippet": "static inline void ocfs2_set_de_type(struct ocfs2_dir_entry *de,\n\t\t\t\t    umode_t mode)\n{\n\tde->file_type = ocfs2_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}",
          "includes": [],
          "macros_used": [
            "#define S_SHIFT\t\t\t12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define S_SHIFT\t\t\t12\n\nstatic inline void ocfs2_set_de_type(struct ocfs2_dir_entry *de,\n\t\t\t\t    umode_t mode)\n{\n\tde->file_type = ocfs2_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "OCFS2_DIR_REC_LEN(de->name_len)"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "le16_to_cpu(de->rec_len) -\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len)"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_insert",
          "args": [
            "dir",
            "handle",
            "lookup"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1514-1547",
          "snippet": "static int ocfs2_dx_dir_insert(struct inode *dir, handle_t *handle,\n\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret = 0;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)lookup->dl_dx_root_bh->b_data;\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tocfs2_dx_inline_root_insert(dir, handle,\n\t\t\t\t\t    &lookup->dl_hinfo,\n\t\t\t\t\t    lookup->dl_leaf_bh->b_blocknr,\n\t\t\t\t\t    dx_root);\n\t} else {\n\t\tret = __ocfs2_dx_dir_leaf_insert(dir, handle, &lookup->dl_hinfo,\n\t\t\t\t\t\t lookup->dl_leaf_bh->b_blocknr,\n\t\t\t\t\t\t lookup->dl_dx_leaf_bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tle32_add_cpu(&dx_root->dr_num_entries, 1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_insert(struct inode *dir, handle_t *handle,\n\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret = 0;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)lookup->dl_dx_root_bh->b_data;\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tocfs2_dx_inline_root_insert(dir, handle,\n\t\t\t\t\t    &lookup->dl_hinfo,\n\t\t\t\t\t    lookup->dl_leaf_bh->b_blocknr,\n\t\t\t\t\t    dx_root);\n\t} else {\n\t\tret = __ocfs2_dx_dir_leaf_insert(dir, handle, &lookup->dl_hinfo,\n\t\t\t\t\t\t lookup->dl_leaf_bh->b_blocknr,\n\t\t\t\t\t\t lookup->dl_dx_leaf_bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tle32_add_cpu(&dx_root->dr_num_entries, 1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_db",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "insert_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "735-739",
          "snippet": "int ocfs2_journal_access_db(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &db_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers db_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_db_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers db_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_db_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_db(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &db_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "insert_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "retval"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "dir",
            "parent_fe_bh"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1250-1289",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dirent_would_fit",
          "args": [
            "de",
            "rec_len"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dirent_would_fit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1433-1452",
          "snippet": "static inline int ocfs2_dirent_would_fit(struct ocfs2_dir_entry *de,\n\t\t\t\t\t unsigned int new_rec_len)\n{\n\tunsigned int de_really_used;\n\n\t/* Check whether this is an empty record with enough space */\n\tif (le64_to_cpu(de->inode) == 0 &&\n\t    le16_to_cpu(de->rec_len) >= new_rec_len)\n\t\treturn 1;\n\n\t/*\n\t * Record might have free space at the end which we can\n\t * use.\n\t */\n\tde_really_used = OCFS2_DIR_REC_LEN(de->name_len);\n\tif (le16_to_cpu(de->rec_len) >= (de_really_used + new_rec_len))\n\t    return 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_dirent_would_fit(struct ocfs2_dir_entry *de,\n\t\t\t\t\t unsigned int new_rec_len)\n{\n\tunsigned int de_really_used;\n\n\t/* Check whether this is an empty record with enough space */\n\tif (le64_to_cpu(de->inode) == 0 &&\n\t    le16_to_cpu(de->rec_len) >= new_rec_len)\n\t\treturn 1;\n\n\t/*\n\t * Record might have free space at the end which we can\n\t * use.\n\t */\n\tde_really_used = OCFS2_DIR_REC_LEN(de->name_len);\n\tif (le16_to_cpu(de->rec_len) >= (de_really_used + new_rec_len))\n\t    return 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "ocfs2_skip_dir_trailer(dir, de, offset, size)",
            "\"Hit dir trailer trying to insert %.*s \"\n\t\t\t        \"(namelen %d) into directory %llu.  \"\n\t\t\t\t\"offset is %lu, trailer offset is %d\\n\"",
            "namelen",
            "name",
            "namelen",
            "(unsigned long long)parent_fe_bh->b_blocknr",
            "offset",
            "ocfs2_dir_trailer_blk_off(dir->i_sb)"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_trailer_blk_off",
          "args": [
            "dir->i_sb"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_trailer_blk_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "114-117",
          "snippet": "static inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_skip_dir_trailer",
          "args": [
            "dir",
            "de",
            "offset",
            "size"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_skip_dir_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "136-150",
          "snippet": "static int ocfs2_skip_dir_trailer(struct inode *dir,\n\t\t\t\t  struct ocfs2_dir_entry *de,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  unsigned long blklen)\n{\n\tunsigned long toff = blklen - sizeof(struct ocfs2_dir_block_trailer);\n\n\tif (!ocfs2_supports_dir_trailer(dir))\n\t\treturn 0;\n\n\tif (offset != toff)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_skip_dir_trailer(struct inode *dir,\n\t\t\t\t  struct ocfs2_dir_entry *de,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  unsigned long blklen)\n{\n\tunsigned long toff = blklen - sizeof(struct ocfs2_dir_block_trailer);\n\n\tif (!ocfs2_supports_dir_trailer(dir))\n\t\treturn 0;\n\n\tif (offset != toff)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_match",
          "args": [
            "namelen",
            "name",
            "de"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "344-353",
          "snippet": "static inline int ocfs2_match(int len,\n\t\t\t      const char * const name,\n\t\t\t      struct ocfs2_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_match(int len,\n\t\t\t      const char * const name,\n\t\t\t      struct ocfs2_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_entry",
          "args": [
            "dir",
            "de",
            "insert_bh",
            "offset"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "316-342",
          "snippet": "static int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(char *)de >= (size + data_start)"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "namelen"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "insert_bh != parent_fe_bh"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "retval"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dr",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "753-757",
          "snippet": "int ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};\n\nint ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_list_at_root",
          "args": [
            "lookup"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_list_at_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "196-199",
          "snippet": "static int ocfs2_free_list_at_root(struct ocfs2_dir_lookup_result *res)\n{\n\treturn res->dl_prev_leaf_bh == NULL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_free_list_at_root(struct ocfs2_dir_lookup_result *res)\n{\n\treturn res->dl_prev_leaf_bh == NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint __ocfs2_add_entry(handle_t *handle,\n\t\t      struct inode *dir,\n\t\t      const char *name, int namelen,\n\t\t      struct inode *inode, u64 blkno,\n\t\t      struct buffer_head *parent_fe_bh,\n\t\t      struct ocfs2_dir_lookup_result *lookup)\n{\n\tunsigned long offset;\n\tunsigned short rec_len;\n\tstruct ocfs2_dir_entry *de, *de1;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_fe_bh->b_data;\n\tstruct super_block *sb = dir->i_sb;\n\tint retval, status;\n\tunsigned int size = sb->s_blocksize;\n\tstruct buffer_head *insert_bh = lookup->dl_leaf_bh;\n\tchar *data_start = insert_bh->b_data;\n\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tstruct buffer_head *bh;\n\n\t\t/*\n\t\t * An indexed dir may require that we update the free space\n\t\t * list. Reserve a write to the previous node in the list so\n\t\t * that we don't fail later.\n\t\t *\n\t\t * XXX: This can be either a dx_root_block, or an unindexed\n\t\t * directory tree leaf block.\n\t\t */\n\t\tif (ocfs2_free_list_at_root(lookup)) {\n\t\t\tbh = lookup->dl_dx_root_bh;\n\t\t\tretval = ocfs2_journal_access_dr(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t} else {\n\t\t\tbh = lookup->dl_prev_leaf_bh;\n\t\t\tretval = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t}\n\t\tif (retval) {\n\t\t\tmlog_errno(retval);\n\t\t\treturn retval;\n\t\t}\n\t} else if (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tdata_start = di->id2.i_data.id_data;\n\t\tsize = i_size_read(dir);\n\n\t\tBUG_ON(insert_bh != parent_fe_bh);\n\t}\n\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\toffset = 0;\n\tde = (struct ocfs2_dir_entry *) data_start;\n\twhile (1) {\n\t\tBUG_ON((char *)de >= (size + data_start));\n\n\t\t/* These checks should've already been passed by the\n\t\t * prepare function, but I guess we can leave them\n\t\t * here anyway. */\n\t\tif (!ocfs2_check_dir_entry(dir, de, insert_bh, offset)) {\n\t\t\tretval = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tretval = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* We're guaranteed that we should have space, so we\n\t\t * can't possibly have hit the trailer...right? */\n\t\tmlog_bug_on_msg(ocfs2_skip_dir_trailer(dir, de, offset, size),\n\t\t\t\t\"Hit dir trailer trying to insert %.*s \"\n\t\t\t        \"(namelen %d) into directory %llu.  \"\n\t\t\t\t\"offset is %lu, trailer offset is %d\\n\",\n\t\t\t\tnamelen, name, namelen,\n\t\t\t\t(unsigned long long)parent_fe_bh->b_blocknr,\n\t\t\t\toffset, ocfs2_dir_trailer_blk_off(dir->i_sb));\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t\t\tretval = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\t\t\tif (retval < 0) {\n\t\t\t\tmlog_errno(retval);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tif (insert_bh == parent_fe_bh)\n\t\t\t\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\telse {\n\t\t\t\tstatus = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t\t\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\t\t\tstatus = ocfs2_dx_dir_insert(dir,\n\t\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\t\tlookup);\n\t\t\t\t\tif (status) {\n\t\t\t\t\t\tmlog_errno(status);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* By now the buffer is marked for journaling */\n\t\t\toffset += le16_to_cpu(de->rec_len);\n\t\t\tif (le64_to_cpu(de->inode)) {\n\t\t\t\tde1 = (struct ocfs2_dir_entry *)((char *) de +\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde1->rec_len =\n\t\t\t\t\tcpu_to_le16(le16_to_cpu(de->rec_len) -\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde->rec_len = cpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde = de1;\n\t\t\t}\n\t\t\tde->file_type = OCFS2_FT_UNKNOWN;\n\t\t\tif (blkno) {\n\t\t\t\tde->inode = cpu_to_le64(blkno);\n\t\t\t\tocfs2_set_de_type(de, inode->i_mode);\n\t\t\t} else\n\t\t\t\tde->inode = 0;\n\t\t\tde->name_len = namelen;\n\t\t\tmemcpy(de->name, name, namelen);\n\n\t\t\tif (ocfs2_dir_indexed(dir))\n\t\t\t\tocfs2_recalc_free_list(dir, handle, lookup);\n\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, insert_bh);\n\t\t\tretval = 0;\n\t\t\tgoto bail;\n\t\t}\n\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *) ((char *) de + le16_to_cpu(de->rec_len));\n\t}\n\n\t/* when you think about it, the assert above should prevent us\n\t * from ever getting here. */\n\tretval = -ENOSPC;\nbail:\n\tif (retval)\n\t\tmlog_errno(retval);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "ocfs2_recalc_free_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1580-1600",
    "snippet": "static void ocfs2_recalc_free_list(struct inode *dir, handle_t *handle,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint max_rec_len;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\t/* Walk dl_leaf_bh to figure out what the new free rec_len is. */\n\tmax_rec_len = ocfs2_find_max_rec_len(dir->i_sb, lookup->dl_leaf_bh);\n\tif (max_rec_len) {\n\t\t/*\n\t\t * There's still room in this block, so no need to remove it\n\t\t * from the free list. In this case, we just want to update\n\t\t * the rec len accounting.\n\t\t */\n\t\ttrailer = ocfs2_trailer_from_bh(lookup->dl_leaf_bh, dir->i_sb);\n\t\ttrailer->db_free_rec_len = cpu_to_le16(max_rec_len);\n\t\tocfs2_journal_dirty(handle, lookup->dl_leaf_bh);\n\t} else {\n\t\tocfs2_remove_block_from_free_list(dir, handle, lookup);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_remove_block_from_free_list",
          "args": [
            "dir",
            "handle",
            "lookup"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_block_from_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1549-1574",
          "snippet": "static void ocfs2_remove_block_from_free_list(struct inode *dir,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct ocfs2_dir_block_trailer *trailer, *prev;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *bh;\n\n\ttrailer = ocfs2_trailer_from_bh(lookup->dl_leaf_bh, dir->i_sb);\n\n\tif (ocfs2_free_list_at_root(lookup)) {\n\t\tbh = lookup->dl_dx_root_bh;\n\t\tdx_root = (struct ocfs2_dx_root_block *)bh->b_data;\n\t\tdx_root->dr_free_blk = trailer->db_free_next;\n\t} else {\n\t\tbh = lookup->dl_prev_leaf_bh;\n\t\tprev = ocfs2_trailer_from_bh(bh, dir->i_sb);\n\t\tprev->db_free_next = trailer->db_free_next;\n\t}\n\n\ttrailer->db_free_rec_len = cpu_to_le16(0);\n\ttrailer->db_free_next = cpu_to_le64(0);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_journal_dirty(handle, lookup->dl_leaf_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_remove_block_from_free_list(struct inode *dir,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct ocfs2_dir_block_trailer *trailer, *prev;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *bh;\n\n\ttrailer = ocfs2_trailer_from_bh(lookup->dl_leaf_bh, dir->i_sb);\n\n\tif (ocfs2_free_list_at_root(lookup)) {\n\t\tbh = lookup->dl_dx_root_bh;\n\t\tdx_root = (struct ocfs2_dx_root_block *)bh->b_data;\n\t\tdx_root->dr_free_blk = trailer->db_free_next;\n\t} else {\n\t\tbh = lookup->dl_prev_leaf_bh;\n\t\tprev = ocfs2_trailer_from_bh(bh, dir->i_sb);\n\t\tprev->db_free_next = trailer->db_free_next;\n\t}\n\n\ttrailer->db_free_rec_len = cpu_to_le16(0);\n\ttrailer->db_free_next = cpu_to_le64(0);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_journal_dirty(handle, lookup->dl_leaf_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "lookup->dl_leaf_bh"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "max_rec_len"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trailer_from_bh",
          "args": [
            "lookup->dl_leaf_bh",
            "dir->i_sb"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_max_rec_len",
          "args": [
            "dir->i_sb",
            "lookup->dl_leaf_bh"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_max_rec_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1212-1238",
          "snippet": "static int ocfs2_find_max_rec_len(struct super_block *sb,\n\t\t\t\t  struct buffer_head *dirblock_bh)\n{\n\tint size, this_hole, largest_hole = 0;\n\tchar *trailer, *de_buf, *limit, *start = dirblock_bh->b_data;\n\tstruct ocfs2_dir_entry *de;\n\n\ttrailer = (char *)ocfs2_trailer_from_bh(dirblock_bh, sb);\n\tsize = ocfs2_dir_trailer_blk_off(sb);\n\tlimit = start + size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tif (de_buf != trailer) {\n\t\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\t\tif (this_hole > largest_hole)\n\t\t\t\tlargest_hole = this_hole;\n\t\t}\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_find_max_rec_len(struct super_block *sb,\n\t\t\t\t  struct buffer_head *dirblock_bh)\n{\n\tint size, this_hole, largest_hole = 0;\n\tchar *trailer, *de_buf, *limit, *start = dirblock_bh->b_data;\n\tstruct ocfs2_dir_entry *de;\n\n\ttrailer = (char *)ocfs2_trailer_from_bh(dirblock_bh, sb);\n\tsize = ocfs2_dir_trailer_blk_off(sb);\n\tlimit = start + size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tif (de_buf != trailer) {\n\t\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\t\tif (this_hole > largest_hole)\n\t\t\t\tlargest_hole = this_hole;\n\t\t}\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_recalc_free_list(struct inode *dir, handle_t *handle,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint max_rec_len;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\t/* Walk dl_leaf_bh to figure out what the new free rec_len is. */\n\tmax_rec_len = ocfs2_find_max_rec_len(dir->i_sb, lookup->dl_leaf_bh);\n\tif (max_rec_len) {\n\t\t/*\n\t\t * There's still room in this block, so no need to remove it\n\t\t * from the free list. In this case, we just want to update\n\t\t * the rec len accounting.\n\t\t */\n\t\ttrailer = ocfs2_trailer_from_bh(lookup->dl_leaf_bh, dir->i_sb);\n\t\ttrailer->db_free_rec_len = cpu_to_le16(max_rec_len);\n\t\tocfs2_journal_dirty(handle, lookup->dl_leaf_bh);\n\t} else {\n\t\tocfs2_remove_block_from_free_list(dir, handle, lookup);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_remove_block_from_free_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1549-1574",
    "snippet": "static void ocfs2_remove_block_from_free_list(struct inode *dir,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct ocfs2_dir_block_trailer *trailer, *prev;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *bh;\n\n\ttrailer = ocfs2_trailer_from_bh(lookup->dl_leaf_bh, dir->i_sb);\n\n\tif (ocfs2_free_list_at_root(lookup)) {\n\t\tbh = lookup->dl_dx_root_bh;\n\t\tdx_root = (struct ocfs2_dx_root_block *)bh->b_data;\n\t\tdx_root->dr_free_blk = trailer->db_free_next;\n\t} else {\n\t\tbh = lookup->dl_prev_leaf_bh;\n\t\tprev = ocfs2_trailer_from_bh(bh, dir->i_sb);\n\t\tprev->db_free_next = trailer->db_free_next;\n\t}\n\n\ttrailer->db_free_rec_len = cpu_to_le16(0);\n\ttrailer->db_free_next = cpu_to_le64(0);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_journal_dirty(handle, lookup->dl_leaf_bh);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "lookup->dl_leaf_bh"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "0"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trailer_from_bh",
          "args": [
            "bh",
            "dir->i_sb"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_list_at_root",
          "args": [
            "lookup"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_list_at_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "196-199",
          "snippet": "static int ocfs2_free_list_at_root(struct ocfs2_dir_lookup_result *res)\n{\n\treturn res->dl_prev_leaf_bh == NULL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_free_list_at_root(struct ocfs2_dir_lookup_result *res)\n{\n\treturn res->dl_prev_leaf_bh == NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_trailer_from_bh",
          "args": [
            "lookup->dl_leaf_bh",
            "dir->i_sb"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_remove_block_from_free_list(struct inode *dir,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct ocfs2_dir_block_trailer *trailer, *prev;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *bh;\n\n\ttrailer = ocfs2_trailer_from_bh(lookup->dl_leaf_bh, dir->i_sb);\n\n\tif (ocfs2_free_list_at_root(lookup)) {\n\t\tbh = lookup->dl_dx_root_bh;\n\t\tdx_root = (struct ocfs2_dx_root_block *)bh->b_data;\n\t\tdx_root->dr_free_blk = trailer->db_free_next;\n\t} else {\n\t\tbh = lookup->dl_prev_leaf_bh;\n\t\tprev = ocfs2_trailer_from_bh(bh, dir->i_sb);\n\t\tprev->db_free_next = trailer->db_free_next;\n\t}\n\n\ttrailer->db_free_rec_len = cpu_to_le16(0);\n\ttrailer->db_free_next = cpu_to_le64(0);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_journal_dirty(handle, lookup->dl_leaf_bh);\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1514-1547",
    "snippet": "static int ocfs2_dx_dir_insert(struct inode *dir, handle_t *handle,\n\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret = 0;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)lookup->dl_dx_root_bh->b_data;\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tocfs2_dx_inline_root_insert(dir, handle,\n\t\t\t\t\t    &lookup->dl_hinfo,\n\t\t\t\t\t    lookup->dl_leaf_bh->b_blocknr,\n\t\t\t\t\t    dx_root);\n\t} else {\n\t\tret = __ocfs2_dx_dir_leaf_insert(dir, handle, &lookup->dl_hinfo,\n\t\t\t\t\t\t lookup->dl_leaf_bh->b_blocknr,\n\t\t\t\t\t\t lookup->dl_dx_leaf_bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tle32_add_cpu(&dx_root->dr_num_entries, 1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "dx_root_bh"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dx_root->dr_num_entries",
            "1"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_dx_dir_leaf_insert",
          "args": [
            "dir",
            "handle",
            "&lookup->dl_hinfo",
            "lookup->dl_leaf_bh->b_blocknr",
            "lookup->dl_dx_leaf_bh"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_dx_dir_leaf_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1483-1504",
          "snippet": "static int __ocfs2_dx_dir_leaf_insert(struct inode *dir, handle_t *handle,\n\t\t\t\t      struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t      u64 dirent_blk,\n\t\t\t\t      struct buffer_head *dx_leaf_bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\n\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), dx_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\tocfs2_dx_entry_list_insert(&dx_leaf->dl_list, hinfo, dirent_blk);\n\tocfs2_journal_dirty(handle, dx_leaf_bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int __ocfs2_dx_dir_leaf_insert(struct inode *dir, handle_t *handle,\n\t\t\t\t      struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t      u64 dirent_blk,\n\t\t\t\t      struct buffer_head *dx_leaf_bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\n\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), dx_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\tocfs2_dx_entry_list_insert(&dx_leaf->dl_list, hinfo, dirent_blk);\n\tocfs2_journal_dirty(handle, dx_leaf_bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_inline_root_insert",
          "args": [
            "dir",
            "handle",
            "&lookup->dl_hinfo",
            "lookup->dl_leaf_bh->b_blocknr",
            "dx_root"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_inline_root_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1506-1512",
          "snippet": "static void ocfs2_dx_inline_root_insert(struct inode *dir, handle_t *handle,\n\t\t\t\t\tstruct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t\tu64 dirent_blk,\n\t\t\t\t\tstruct ocfs2_dx_root_block *dx_root)\n{\n\tocfs2_dx_entry_list_insert(&dx_root->dr_entries, hinfo, dirent_blk);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_dx_inline_root_insert(struct inode *dir, handle_t *handle,\n\t\t\t\t\tstruct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t\tu64 dirent_blk,\n\t\t\t\t\tstruct ocfs2_dx_root_block *dx_root)\n{\n\tocfs2_dx_entry_list_insert(&dx_root->dr_entries, hinfo, dirent_blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_root_inline",
          "args": [
            "dx_root"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_root_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "216-219",
          "snippet": "static inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dr",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "dx_root_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "753-757",
          "snippet": "int ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};\n\nint ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_insert(struct inode *dir, handle_t *handle,\n\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret = 0;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)lookup->dl_dx_root_bh->b_data;\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tocfs2_dx_inline_root_insert(dir, handle,\n\t\t\t\t\t    &lookup->dl_hinfo,\n\t\t\t\t\t    lookup->dl_leaf_bh->b_blocknr,\n\t\t\t\t\t    dx_root);\n\t} else {\n\t\tret = __ocfs2_dx_dir_leaf_insert(dir, handle, &lookup->dl_hinfo,\n\t\t\t\t\t\t lookup->dl_leaf_bh->b_blocknr,\n\t\t\t\t\t\t lookup->dl_dx_leaf_bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tle32_add_cpu(&dx_root->dr_num_entries, 1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dx_inline_root_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1506-1512",
    "snippet": "static void ocfs2_dx_inline_root_insert(struct inode *dir, handle_t *handle,\n\t\t\t\t\tstruct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t\tu64 dirent_blk,\n\t\t\t\t\tstruct ocfs2_dx_root_block *dx_root)\n{\n\tocfs2_dx_entry_list_insert(&dx_root->dr_entries, hinfo, dirent_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_dx_entry_list_insert",
          "args": [
            "&dx_root->dr_entries",
            "hinfo",
            "dirent_blk"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_entry_list_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1465-1481",
          "snippet": "static void ocfs2_dx_entry_list_insert(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t       u64 dirent_blk)\n{\n\tint i;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ti = le16_to_cpu(entry_list->de_num_used);\n\tdx_entry = &entry_list->de_entries[i];\n\n\tmemset(dx_entry, 0, sizeof(*dx_entry));\n\tdx_entry->dx_major_hash = cpu_to_le32(hinfo->major_hash);\n\tdx_entry->dx_minor_hash = cpu_to_le32(hinfo->minor_hash);\n\tdx_entry->dx_dirent_blk = cpu_to_le64(dirent_blk);\n\n\tle16_add_cpu(&entry_list->de_num_used, 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dx_entry_list_insert(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t       u64 dirent_blk)\n{\n\tint i;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ti = le16_to_cpu(entry_list->de_num_used);\n\tdx_entry = &entry_list->de_entries[i];\n\n\tmemset(dx_entry, 0, sizeof(*dx_entry));\n\tdx_entry->dx_major_hash = cpu_to_le32(hinfo->major_hash);\n\tdx_entry->dx_minor_hash = cpu_to_le32(hinfo->minor_hash);\n\tdx_entry->dx_dirent_blk = cpu_to_le64(dirent_blk);\n\n\tle16_add_cpu(&entry_list->de_num_used, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_dx_inline_root_insert(struct inode *dir, handle_t *handle,\n\t\t\t\t\tstruct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t\tu64 dirent_blk,\n\t\t\t\t\tstruct ocfs2_dx_root_block *dx_root)\n{\n\tocfs2_dx_entry_list_insert(&dx_root->dr_entries, hinfo, dirent_blk);\n}"
  },
  {
    "function_name": "__ocfs2_dx_dir_leaf_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1483-1504",
    "snippet": "static int __ocfs2_dx_dir_leaf_insert(struct inode *dir, handle_t *handle,\n\t\t\t\t      struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t      u64 dirent_blk,\n\t\t\t\t      struct buffer_head *dx_leaf_bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\n\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), dx_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\tocfs2_dx_entry_list_insert(&dx_leaf->dl_list, hinfo, dirent_blk);\n\tocfs2_journal_dirty(handle, dx_leaf_bh);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "dx_leaf_bh"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_entry_list_insert",
          "args": [
            "&dx_leaf->dl_list",
            "hinfo",
            "dirent_blk"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_entry_list_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1465-1481",
          "snippet": "static void ocfs2_dx_entry_list_insert(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t       u64 dirent_blk)\n{\n\tint i;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ti = le16_to_cpu(entry_list->de_num_used);\n\tdx_entry = &entry_list->de_entries[i];\n\n\tmemset(dx_entry, 0, sizeof(*dx_entry));\n\tdx_entry->dx_major_hash = cpu_to_le32(hinfo->major_hash);\n\tdx_entry->dx_minor_hash = cpu_to_le32(hinfo->minor_hash);\n\tdx_entry->dx_dirent_blk = cpu_to_le64(dirent_blk);\n\n\tle16_add_cpu(&entry_list->de_num_used, 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dx_entry_list_insert(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t       u64 dirent_blk)\n{\n\tint i;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ti = le16_to_cpu(entry_list->de_num_used);\n\tdx_entry = &entry_list->de_entries[i];\n\n\tmemset(dx_entry, 0, sizeof(*dx_entry));\n\tdx_entry->dx_major_hash = cpu_to_le32(hinfo->major_hash);\n\tdx_entry->dx_minor_hash = cpu_to_le32(hinfo->minor_hash);\n\tdx_entry->dx_dirent_blk = cpu_to_le64(dirent_blk);\n\n\tle16_add_cpu(&entry_list->de_num_used, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dl",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "dx_leaf_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "759-763",
          "snippet": "int ocfs2_journal_access_dl(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dl_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dl_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_leaf, dl_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dl_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_leaf, dl_check),\n};\n\nint ocfs2_journal_access_dl(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dl_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int __ocfs2_dx_dir_leaf_insert(struct inode *dir, handle_t *handle,\n\t\t\t\t      struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t      u64 dirent_blk,\n\t\t\t\t      struct buffer_head *dx_leaf_bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\n\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), dx_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\tocfs2_dx_entry_list_insert(&dx_leaf->dl_list, hinfo, dirent_blk);\n\tocfs2_journal_dirty(handle, dx_leaf_bh);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dx_entry_list_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1465-1481",
    "snippet": "static void ocfs2_dx_entry_list_insert(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t       u64 dirent_blk)\n{\n\tint i;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ti = le16_to_cpu(entry_list->de_num_used);\n\tdx_entry = &entry_list->de_entries[i];\n\n\tmemset(dx_entry, 0, sizeof(*dx_entry));\n\tdx_entry->dx_major_hash = cpu_to_le32(hinfo->major_hash);\n\tdx_entry->dx_minor_hash = cpu_to_le32(hinfo->minor_hash);\n\tdx_entry->dx_dirent_blk = cpu_to_le64(dirent_blk);\n\n\tle16_add_cpu(&entry_list->de_num_used, 1);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&entry_list->de_num_used",
            "1"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "dirent_blk"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "hinfo->minor_hash"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "hinfo->major_hash"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dx_entry",
            "0",
            "sizeof(*dx_entry)"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry_list->de_num_used"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dx_entry_list_insert(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t       u64 dirent_blk)\n{\n\tint i;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ti = le16_to_cpu(entry_list->de_num_used);\n\tdx_entry = &entry_list->de_entries[i];\n\n\tmemset(dx_entry, 0, sizeof(*dx_entry));\n\tdx_entry->dx_major_hash = cpu_to_le32(hinfo->major_hash);\n\tdx_entry->dx_minor_hash = cpu_to_le32(hinfo->minor_hash);\n\tdx_entry->dx_dirent_blk = cpu_to_le64(dirent_blk);\n\n\tle16_add_cpu(&entry_list->de_num_used, 1);\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_leaf_insert_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1454-1463",
    "snippet": "static void ocfs2_dx_dir_leaf_insert_tail(struct ocfs2_dx_leaf *dx_leaf,\n\t\t\t\t\t  struct ocfs2_dx_entry *dx_new_entry)\n{\n\tint i;\n\n\ti = le16_to_cpu(dx_leaf->dl_list.de_num_used);\n\tdx_leaf->dl_list.de_entries[i] = *dx_new_entry;\n\n\tle16_add_cpu(&dx_leaf->dl_list.de_num_used, 1);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&dx_leaf->dl_list.de_num_used",
            "1"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dx_leaf->dl_list.de_num_used"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dx_dir_leaf_insert_tail(struct ocfs2_dx_leaf *dx_leaf,\n\t\t\t\t\t  struct ocfs2_dx_entry *dx_new_entry)\n{\n\tint i;\n\n\ti = le16_to_cpu(dx_leaf->dl_list.de_num_used);\n\tdx_leaf->dl_list.de_entries[i] = *dx_new_entry;\n\n\tle16_add_cpu(&dx_leaf->dl_list.de_num_used, 1);\n}"
  },
  {
    "function_name": "ocfs2_dirent_would_fit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1433-1452",
    "snippet": "static inline int ocfs2_dirent_would_fit(struct ocfs2_dir_entry *de,\n\t\t\t\t\t unsigned int new_rec_len)\n{\n\tunsigned int de_really_used;\n\n\t/* Check whether this is an empty record with enough space */\n\tif (le64_to_cpu(de->inode) == 0 &&\n\t    le16_to_cpu(de->rec_len) >= new_rec_len)\n\t\treturn 1;\n\n\t/*\n\t * Record might have free space at the end which we can\n\t * use.\n\t */\n\tde_really_used = OCFS2_DIR_REC_LEN(de->name_len);\n\tif (le16_to_cpu(de->rec_len) >= (de_really_used + new_rec_len))\n\t    return 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_dirent_would_fit(struct ocfs2_dir_entry *de,\n\t\t\t\t\t unsigned int new_rec_len)\n{\n\tunsigned int de_really_used;\n\n\t/* Check whether this is an empty record with enough space */\n\tif (le64_to_cpu(de->inode) == 0 &&\n\t    le16_to_cpu(de->rec_len) >= new_rec_len)\n\t\treturn 1;\n\n\t/*\n\t * Record might have free space at the end which we can\n\t * use.\n\t */\n\tde_really_used = OCFS2_DIR_REC_LEN(de->name_len);\n\tif (le16_to_cpu(de->rec_len) >= (de_really_used + new_rec_len))\n\t    return 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1414-1427",
    "snippet": "int ocfs2_delete_entry(handle_t *handle,\n\t\t       struct inode *dir,\n\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_delete_entry_dx(handle, dir, res);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_delete_entry_id(handle, dir, res->dl_entry,\n\t\t\t\t\t     res->dl_leaf_bh);\n\n\treturn ocfs2_delete_entry_el(handle, dir, res->dl_entry,\n\t\t\t\t     res->dl_leaf_bh);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_delete_entry_el",
          "args": [
            "handle",
            "dir",
            "res->dl_entry",
            "res->dl_leaf_bh"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_delete_entry_el",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1401-1408",
          "snippet": "static inline int ocfs2_delete_entry_el(handle_t *handle,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\treturn __ocfs2_delete_entry(handle, dir, de_del, bh, bh->b_data,\n\t\t\t\t    bh->b_size);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_delete_entry_el(handle_t *handle,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\treturn __ocfs2_delete_entry(handle, dir, de_del, bh, bh->b_data,\n\t\t\t\t    bh->b_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_delete_entry_id",
          "args": [
            "handle",
            "dir",
            "res->dl_entry",
            "res->dl_leaf_bh"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_delete_entry_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1374-1399",
          "snippet": "static inline int ocfs2_delete_entry_id(handle_t *handle,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\tret = __ocfs2_delete_entry(handle, dir, de_del, bh, data->id_data,\n\t\t\t\t   i_size_read(dir));\n\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_delete_entry_id(handle_t *handle,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\tret = __ocfs2_delete_entry(handle, dir, de_del, bh, data->id_data,\n\t\t\t\t   i_size_read(dir));\n\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_delete_entry_dx",
          "args": [
            "handle",
            "dir",
            "res"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_delete_entry_dx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1258-1372",
          "snippet": "static int ocfs2_delete_entry_dx(handle_t *handle, struct inode *dir,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, index, max_rec_len, add_to_free_list = 0;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\tstruct buffer_head *leaf_bh = lookup->dl_leaf_bh;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct ocfs2_dx_entry *dx_entry = lookup->dl_dx_entry;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\t/*\n\t * This function gets a bit messy because we might have to\n\t * modify the root block, regardless of whether the indexed\n\t * entries are stored inline.\n\t */\n\n\t/*\n\t * *Only* set 'entry_list' here, based on where we're looking\n\t * for the indexed entries. Later, we might still want to\n\t * journal both blocks, based on free list state.\n\t */\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tentry_list = &dx_root->dr_entries;\n\t} else {\n\t\tdx_leaf = (struct ocfs2_dx_leaf *) lookup->dl_dx_leaf_bh->b_data;\n\t\tentry_list = &dx_leaf->dl_list;\n\t}\n\n\t/* Neither of these are a disk corruption - that should have\n\t * been caught by lookup, before we got here. */\n\tBUG_ON(le16_to_cpu(entry_list->de_count) <= 0);\n\tBUG_ON(le16_to_cpu(entry_list->de_num_used) <= 0);\n\n\tindex = (char *)dx_entry - (char *)entry_list->de_entries;\n\tindex /= sizeof(*dx_entry);\n\n\tif (index >= le16_to_cpu(entry_list->de_num_used)) {\n\t\tmlog(ML_ERROR, \"Dir %llu: Bad dx_entry ptr idx %d, (%p, %p)\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, index,\n\t\t     entry_list, dx_entry);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * We know that removal of this dirent will leave enough room\n\t * for a new one, so add this block to the free list if it\n\t * isn't already there.\n\t */\n\ttrailer = ocfs2_trailer_from_bh(leaf_bh, dir->i_sb);\n\tif (trailer->db_free_rec_len == 0)\n\t\tadd_to_free_list = 1;\n\n\t/*\n\t * Add the block holding our index into the journal before\n\t * removing the unindexed entry. If we get an error return\n\t * from __ocfs2_delete_entry(), then it hasn't removed the\n\t * entry yet. Likewise, successful return means we *must*\n\t * remove the indexed entry.\n\t *\n\t * We're also careful to journal the root tree block here as\n\t * the entry count needs to be updated. Also, we might be\n\t * adding to the start of the free list.\n\t */\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!ocfs2_dx_root_inline(dx_root)) {\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      lookup->dl_dx_leaf_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttrace_ocfs2_delete_entry_dx((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t    index);\n\n\tret = __ocfs2_delete_entry(handle, dir, lookup->dl_entry,\n\t\t\t\t   leaf_bh, leaf_bh->b_data, leaf_bh->b_size);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmax_rec_len = ocfs2_find_max_rec_len(dir->i_sb, leaf_bh);\n\ttrailer->db_free_rec_len = cpu_to_le16(max_rec_len);\n\tif (add_to_free_list) {\n\t\ttrailer->db_free_next = dx_root->dr_free_blk;\n\t\tdx_root->dr_free_blk = cpu_to_le64(leaf_bh->b_blocknr);\n\t\tocfs2_journal_dirty(handle, dx_root_bh);\n\t}\n\n\t/* leaf_bh was journal_accessed for us in __ocfs2_delete_entry */\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tle32_add_cpu(&dx_root->dr_num_entries, -1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\n\tocfs2_dx_list_remove_entry(entry_list, index);\n\n\tif (!ocfs2_dx_root_inline(dx_root))\n\t\tocfs2_journal_dirty(handle, lookup->dl_dx_leaf_bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_delete_entry_dx(handle_t *handle, struct inode *dir,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, index, max_rec_len, add_to_free_list = 0;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\tstruct buffer_head *leaf_bh = lookup->dl_leaf_bh;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct ocfs2_dx_entry *dx_entry = lookup->dl_dx_entry;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\t/*\n\t * This function gets a bit messy because we might have to\n\t * modify the root block, regardless of whether the indexed\n\t * entries are stored inline.\n\t */\n\n\t/*\n\t * *Only* set 'entry_list' here, based on where we're looking\n\t * for the indexed entries. Later, we might still want to\n\t * journal both blocks, based on free list state.\n\t */\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tentry_list = &dx_root->dr_entries;\n\t} else {\n\t\tdx_leaf = (struct ocfs2_dx_leaf *) lookup->dl_dx_leaf_bh->b_data;\n\t\tentry_list = &dx_leaf->dl_list;\n\t}\n\n\t/* Neither of these are a disk corruption - that should have\n\t * been caught by lookup, before we got here. */\n\tBUG_ON(le16_to_cpu(entry_list->de_count) <= 0);\n\tBUG_ON(le16_to_cpu(entry_list->de_num_used) <= 0);\n\n\tindex = (char *)dx_entry - (char *)entry_list->de_entries;\n\tindex /= sizeof(*dx_entry);\n\n\tif (index >= le16_to_cpu(entry_list->de_num_used)) {\n\t\tmlog(ML_ERROR, \"Dir %llu: Bad dx_entry ptr idx %d, (%p, %p)\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, index,\n\t\t     entry_list, dx_entry);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * We know that removal of this dirent will leave enough room\n\t * for a new one, so add this block to the free list if it\n\t * isn't already there.\n\t */\n\ttrailer = ocfs2_trailer_from_bh(leaf_bh, dir->i_sb);\n\tif (trailer->db_free_rec_len == 0)\n\t\tadd_to_free_list = 1;\n\n\t/*\n\t * Add the block holding our index into the journal before\n\t * removing the unindexed entry. If we get an error return\n\t * from __ocfs2_delete_entry(), then it hasn't removed the\n\t * entry yet. Likewise, successful return means we *must*\n\t * remove the indexed entry.\n\t *\n\t * We're also careful to journal the root tree block here as\n\t * the entry count needs to be updated. Also, we might be\n\t * adding to the start of the free list.\n\t */\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!ocfs2_dx_root_inline(dx_root)) {\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      lookup->dl_dx_leaf_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttrace_ocfs2_delete_entry_dx((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t    index);\n\n\tret = __ocfs2_delete_entry(handle, dir, lookup->dl_entry,\n\t\t\t\t   leaf_bh, leaf_bh->b_data, leaf_bh->b_size);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmax_rec_len = ocfs2_find_max_rec_len(dir->i_sb, leaf_bh);\n\ttrailer->db_free_rec_len = cpu_to_le16(max_rec_len);\n\tif (add_to_free_list) {\n\t\ttrailer->db_free_next = dx_root->dr_free_blk;\n\t\tdx_root->dr_free_blk = cpu_to_le64(leaf_bh->b_blocknr);\n\t\tocfs2_journal_dirty(handle, dx_root_bh);\n\t}\n\n\t/* leaf_bh was journal_accessed for us in __ocfs2_delete_entry */\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tle32_add_cpu(&dx_root->dr_num_entries, -1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\n\tocfs2_dx_list_remove_entry(entry_list, index);\n\n\tif (!ocfs2_dx_root_inline(dx_root))\n\t\tocfs2_journal_dirty(handle, lookup->dl_dx_leaf_bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_indexed",
          "args": [
            "dir"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_indexed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "209-214",
          "snippet": "static int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_delete_entry(handle_t *handle,\n\t\t       struct inode *dir,\n\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_delete_entry_dx(handle, dir, res);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_delete_entry_id(handle, dir, res->dl_entry,\n\t\t\t\t\t     res->dl_leaf_bh);\n\n\treturn ocfs2_delete_entry_el(handle, dir, res->dl_entry,\n\t\t\t\t     res->dl_leaf_bh);\n}"
  },
  {
    "function_name": "ocfs2_delete_entry_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1401-1408",
    "snippet": "static inline int ocfs2_delete_entry_el(handle_t *handle,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\treturn __ocfs2_delete_entry(handle, dir, de_del, bh, bh->b_data,\n\t\t\t\t    bh->b_size);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_delete_entry",
          "args": [
            "handle",
            "dir",
            "de_del",
            "bh",
            "bh->b_data",
            "bh->b_size"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1154-1197",
          "snippet": "static int __ocfs2_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\tstruct buffer_head *bh, char *first_de,\n\t\t\t\tunsigned int bytes)\n{\n\tstruct ocfs2_dir_entry *de, *pde;\n\tint i, status = -ENOENT;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ocfs2_dir_entry *) first_de;\n\twhile (i < bytes) {\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, i)) {\n\t\t\tstatus = -EIO;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tif (de == de_del)  {\n\t\t\tstatus = access(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (pde)\n\t\t\t\tle16_add_cpu(&pde->rec_len,\n\t\t\t\t\t\tle16_to_cpu(de->rec_len));\n\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tgoto bail;\n\t\t}\n\t\ti += le16_to_cpu(de->rec_len);\n\t\tpde = de;\n\t\tde = (struct ocfs2_dir_entry *)((char *)de + le16_to_cpu(de->rec_len));\n\t}\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int __ocfs2_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\tstruct buffer_head *bh, char *first_de,\n\t\t\t\tunsigned int bytes)\n{\n\tstruct ocfs2_dir_entry *de, *pde;\n\tint i, status = -ENOENT;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ocfs2_dir_entry *) first_de;\n\twhile (i < bytes) {\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, i)) {\n\t\t\tstatus = -EIO;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tif (de == de_del)  {\n\t\t\tstatus = access(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (pde)\n\t\t\t\tle16_add_cpu(&pde->rec_len,\n\t\t\t\t\t\tle16_to_cpu(de->rec_len));\n\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tgoto bail;\n\t\t}\n\t\ti += le16_to_cpu(de->rec_len);\n\t\tpde = de;\n\t\tde = (struct ocfs2_dir_entry *)((char *)de + le16_to_cpu(de->rec_len));\n\t}\nbail:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_delete_entry_el(handle_t *handle,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\treturn __ocfs2_delete_entry(handle, dir, de_del, bh, bh->b_data,\n\t\t\t\t    bh->b_size);\n}"
  },
  {
    "function_name": "ocfs2_delete_entry_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1374-1399",
    "snippet": "static inline int ocfs2_delete_entry_id(handle_t *handle,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\tret = __ocfs2_delete_entry(handle, dir, de_del, bh, data->id_data,\n\t\t\t\t   i_size_read(dir));\n\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_delete_entry",
          "args": [
            "handle",
            "dir",
            "de_del",
            "bh",
            "data->id_data",
            "i_size_read(dir)"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1154-1197",
          "snippet": "static int __ocfs2_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\tstruct buffer_head *bh, char *first_de,\n\t\t\t\tunsigned int bytes)\n{\n\tstruct ocfs2_dir_entry *de, *pde;\n\tint i, status = -ENOENT;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ocfs2_dir_entry *) first_de;\n\twhile (i < bytes) {\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, i)) {\n\t\t\tstatus = -EIO;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tif (de == de_del)  {\n\t\t\tstatus = access(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (pde)\n\t\t\t\tle16_add_cpu(&pde->rec_len,\n\t\t\t\t\t\tle16_to_cpu(de->rec_len));\n\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tgoto bail;\n\t\t}\n\t\ti += le16_to_cpu(de->rec_len);\n\t\tpde = de;\n\t\tde = (struct ocfs2_dir_entry *)((char *)de + le16_to_cpu(de->rec_len));\n\t}\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int __ocfs2_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\tstruct buffer_head *bh, char *first_de,\n\t\t\t\tunsigned int bytes)\n{\n\tstruct ocfs2_dir_entry *de, *pde;\n\tint i, status = -ENOENT;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ocfs2_dir_entry *) first_de;\n\twhile (i < bytes) {\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, i)) {\n\t\t\tstatus = -EIO;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tif (de == de_del)  {\n\t\t\tstatus = access(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (pde)\n\t\t\t\tle16_add_cpu(&pde->rec_len,\n\t\t\t\t\t\tle16_to_cpu(de->rec_len));\n\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tgoto bail;\n\t\t}\n\t\ti += le16_to_cpu(de->rec_len);\n\t\tpde = de;\n\t\tde = (struct ocfs2_dir_entry *)((char *)de + le16_to_cpu(de->rec_len));\n\t}\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "dir",
            "&di_bh"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_delete_entry_id(handle_t *handle,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\tret = __ocfs2_delete_entry(handle, dir, de_del, bh, data->id_data,\n\t\t\t\t   i_size_read(dir));\n\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_delete_entry_dx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1258-1372",
    "snippet": "static int ocfs2_delete_entry_dx(handle_t *handle, struct inode *dir,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, index, max_rec_len, add_to_free_list = 0;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\tstruct buffer_head *leaf_bh = lookup->dl_leaf_bh;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct ocfs2_dx_entry *dx_entry = lookup->dl_dx_entry;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\t/*\n\t * This function gets a bit messy because we might have to\n\t * modify the root block, regardless of whether the indexed\n\t * entries are stored inline.\n\t */\n\n\t/*\n\t * *Only* set 'entry_list' here, based on where we're looking\n\t * for the indexed entries. Later, we might still want to\n\t * journal both blocks, based on free list state.\n\t */\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tentry_list = &dx_root->dr_entries;\n\t} else {\n\t\tdx_leaf = (struct ocfs2_dx_leaf *) lookup->dl_dx_leaf_bh->b_data;\n\t\tentry_list = &dx_leaf->dl_list;\n\t}\n\n\t/* Neither of these are a disk corruption - that should have\n\t * been caught by lookup, before we got here. */\n\tBUG_ON(le16_to_cpu(entry_list->de_count) <= 0);\n\tBUG_ON(le16_to_cpu(entry_list->de_num_used) <= 0);\n\n\tindex = (char *)dx_entry - (char *)entry_list->de_entries;\n\tindex /= sizeof(*dx_entry);\n\n\tif (index >= le16_to_cpu(entry_list->de_num_used)) {\n\t\tmlog(ML_ERROR, \"Dir %llu: Bad dx_entry ptr idx %d, (%p, %p)\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, index,\n\t\t     entry_list, dx_entry);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * We know that removal of this dirent will leave enough room\n\t * for a new one, so add this block to the free list if it\n\t * isn't already there.\n\t */\n\ttrailer = ocfs2_trailer_from_bh(leaf_bh, dir->i_sb);\n\tif (trailer->db_free_rec_len == 0)\n\t\tadd_to_free_list = 1;\n\n\t/*\n\t * Add the block holding our index into the journal before\n\t * removing the unindexed entry. If we get an error return\n\t * from __ocfs2_delete_entry(), then it hasn't removed the\n\t * entry yet. Likewise, successful return means we *must*\n\t * remove the indexed entry.\n\t *\n\t * We're also careful to journal the root tree block here as\n\t * the entry count needs to be updated. Also, we might be\n\t * adding to the start of the free list.\n\t */\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!ocfs2_dx_root_inline(dx_root)) {\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      lookup->dl_dx_leaf_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttrace_ocfs2_delete_entry_dx((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t    index);\n\n\tret = __ocfs2_delete_entry(handle, dir, lookup->dl_entry,\n\t\t\t\t   leaf_bh, leaf_bh->b_data, leaf_bh->b_size);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmax_rec_len = ocfs2_find_max_rec_len(dir->i_sb, leaf_bh);\n\ttrailer->db_free_rec_len = cpu_to_le16(max_rec_len);\n\tif (add_to_free_list) {\n\t\ttrailer->db_free_next = dx_root->dr_free_blk;\n\t\tdx_root->dr_free_blk = cpu_to_le64(leaf_bh->b_blocknr);\n\t\tocfs2_journal_dirty(handle, dx_root_bh);\n\t}\n\n\t/* leaf_bh was journal_accessed for us in __ocfs2_delete_entry */\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tle32_add_cpu(&dx_root->dr_num_entries, -1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\n\tocfs2_dx_list_remove_entry(entry_list, index);\n\n\tif (!ocfs2_dx_root_inline(dx_root))\n\t\tocfs2_journal_dirty(handle, lookup->dl_dx_leaf_bh);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "lookup->dl_dx_leaf_bh"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_root_inline",
          "args": [
            "dx_root"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_root_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "216-219",
          "snippet": "static inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_list_remove_entry",
          "args": [
            "entry_list",
            "index"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_list_remove_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1240-1256",
          "snippet": "static void ocfs2_dx_list_remove_entry(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       int index)\n{\n\tint num_used = le16_to_cpu(entry_list->de_num_used);\n\n\tif (num_used == 1 || index == (num_used - 1))\n\t\tgoto clear;\n\n\tmemmove(&entry_list->de_entries[index],\n\t\t&entry_list->de_entries[index + 1],\n\t\t(num_used - index - 1)*sizeof(struct ocfs2_dx_entry));\nclear:\n\tnum_used--;\n\tmemset(&entry_list->de_entries[num_used], 0,\n\t       sizeof(struct ocfs2_dx_entry));\n\tentry_list->de_num_used = cpu_to_le16(num_used);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dx_list_remove_entry(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       int index)\n{\n\tint num_used = le16_to_cpu(entry_list->de_num_used);\n\n\tif (num_used == 1 || index == (num_used - 1))\n\t\tgoto clear;\n\n\tmemmove(&entry_list->de_entries[index],\n\t\t&entry_list->de_entries[index + 1],\n\t\t(num_used - index - 1)*sizeof(struct ocfs2_dx_entry));\nclear:\n\tnum_used--;\n\tmemset(&entry_list->de_entries[num_used], 0,\n\t       sizeof(struct ocfs2_dx_entry));\n\tentry_list->de_num_used = cpu_to_le16(num_used);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dx_root->dr_num_entries",
            "-1"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "leaf_bh->b_blocknr"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "max_rec_len"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_max_rec_len",
          "args": [
            "dir->i_sb",
            "leaf_bh"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_max_rec_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1212-1238",
          "snippet": "static int ocfs2_find_max_rec_len(struct super_block *sb,\n\t\t\t\t  struct buffer_head *dirblock_bh)\n{\n\tint size, this_hole, largest_hole = 0;\n\tchar *trailer, *de_buf, *limit, *start = dirblock_bh->b_data;\n\tstruct ocfs2_dir_entry *de;\n\n\ttrailer = (char *)ocfs2_trailer_from_bh(dirblock_bh, sb);\n\tsize = ocfs2_dir_trailer_blk_off(sb);\n\tlimit = start + size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tif (de_buf != trailer) {\n\t\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\t\tif (this_hole > largest_hole)\n\t\t\t\tlargest_hole = this_hole;\n\t\t}\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_find_max_rec_len(struct super_block *sb,\n\t\t\t\t  struct buffer_head *dirblock_bh)\n{\n\tint size, this_hole, largest_hole = 0;\n\tchar *trailer, *de_buf, *limit, *start = dirblock_bh->b_data;\n\tstruct ocfs2_dir_entry *de;\n\n\ttrailer = (char *)ocfs2_trailer_from_bh(dirblock_bh, sb);\n\tsize = ocfs2_dir_trailer_blk_off(sb);\n\tlimit = start + size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tif (de_buf != trailer) {\n\t\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\t\tif (this_hole > largest_hole)\n\t\t\t\tlargest_hole = this_hole;\n\t\t}\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_delete_entry",
          "args": [
            "handle",
            "dir",
            "lookup->dl_entry",
            "leaf_bh",
            "leaf_bh->b_data",
            "leaf_bh->b_size"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1154-1197",
          "snippet": "static int __ocfs2_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\tstruct buffer_head *bh, char *first_de,\n\t\t\t\tunsigned int bytes)\n{\n\tstruct ocfs2_dir_entry *de, *pde;\n\tint i, status = -ENOENT;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ocfs2_dir_entry *) first_de;\n\twhile (i < bytes) {\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, i)) {\n\t\t\tstatus = -EIO;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tif (de == de_del)  {\n\t\t\tstatus = access(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (pde)\n\t\t\t\tle16_add_cpu(&pde->rec_len,\n\t\t\t\t\t\tle16_to_cpu(de->rec_len));\n\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tgoto bail;\n\t\t}\n\t\ti += le16_to_cpu(de->rec_len);\n\t\tpde = de;\n\t\tde = (struct ocfs2_dir_entry *)((char *)de + le16_to_cpu(de->rec_len));\n\t}\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int __ocfs2_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\tstruct buffer_head *bh, char *first_de,\n\t\t\t\tunsigned int bytes)\n{\n\tstruct ocfs2_dir_entry *de, *pde;\n\tint i, status = -ENOENT;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ocfs2_dir_entry *) first_de;\n\twhile (i < bytes) {\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, i)) {\n\t\t\tstatus = -EIO;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tif (de == de_del)  {\n\t\t\tstatus = access(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (pde)\n\t\t\t\tle16_add_cpu(&pde->rec_len,\n\t\t\t\t\t\tle16_to_cpu(de->rec_len));\n\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tgoto bail;\n\t\t}\n\t\ti += le16_to_cpu(de->rec_len);\n\t\tpde = de;\n\t\tde = (struct ocfs2_dir_entry *)((char *)de + le16_to_cpu(de->rec_len));\n\t}\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_delete_entry_dx",
          "args": [
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "index"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dl",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "lookup->dl_dx_leaf_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "759-763",
          "snippet": "int ocfs2_journal_access_dl(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dl_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dl_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_leaf, dl_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dl_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_leaf, dl_check),\n};\n\nint ocfs2_journal_access_dl(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dl_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dr",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "dx_root_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "753-757",
          "snippet": "int ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};\n\nint ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_trailer_from_bh",
          "args": [
            "leaf_bh",
            "dir->i_sb"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Dir %llu: Bad dx_entry ptr idx %d, (%p, %p)\\n\"",
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "index",
            "entry_list",
            "dx_entry"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry_list->de_num_used"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(entry_list->de_num_used) <= 0"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(entry_list->de_count) <= 0"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_delete_entry_dx(handle_t *handle, struct inode *dir,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, index, max_rec_len, add_to_free_list = 0;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\tstruct buffer_head *leaf_bh = lookup->dl_leaf_bh;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct ocfs2_dx_entry *dx_entry = lookup->dl_dx_entry;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\t/*\n\t * This function gets a bit messy because we might have to\n\t * modify the root block, regardless of whether the indexed\n\t * entries are stored inline.\n\t */\n\n\t/*\n\t * *Only* set 'entry_list' here, based on where we're looking\n\t * for the indexed entries. Later, we might still want to\n\t * journal both blocks, based on free list state.\n\t */\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tentry_list = &dx_root->dr_entries;\n\t} else {\n\t\tdx_leaf = (struct ocfs2_dx_leaf *) lookup->dl_dx_leaf_bh->b_data;\n\t\tentry_list = &dx_leaf->dl_list;\n\t}\n\n\t/* Neither of these are a disk corruption - that should have\n\t * been caught by lookup, before we got here. */\n\tBUG_ON(le16_to_cpu(entry_list->de_count) <= 0);\n\tBUG_ON(le16_to_cpu(entry_list->de_num_used) <= 0);\n\n\tindex = (char *)dx_entry - (char *)entry_list->de_entries;\n\tindex /= sizeof(*dx_entry);\n\n\tif (index >= le16_to_cpu(entry_list->de_num_used)) {\n\t\tmlog(ML_ERROR, \"Dir %llu: Bad dx_entry ptr idx %d, (%p, %p)\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, index,\n\t\t     entry_list, dx_entry);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * We know that removal of this dirent will leave enough room\n\t * for a new one, so add this block to the free list if it\n\t * isn't already there.\n\t */\n\ttrailer = ocfs2_trailer_from_bh(leaf_bh, dir->i_sb);\n\tif (trailer->db_free_rec_len == 0)\n\t\tadd_to_free_list = 1;\n\n\t/*\n\t * Add the block holding our index into the journal before\n\t * removing the unindexed entry. If we get an error return\n\t * from __ocfs2_delete_entry(), then it hasn't removed the\n\t * entry yet. Likewise, successful return means we *must*\n\t * remove the indexed entry.\n\t *\n\t * We're also careful to journal the root tree block here as\n\t * the entry count needs to be updated. Also, we might be\n\t * adding to the start of the free list.\n\t */\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!ocfs2_dx_root_inline(dx_root)) {\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      lookup->dl_dx_leaf_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttrace_ocfs2_delete_entry_dx((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t    index);\n\n\tret = __ocfs2_delete_entry(handle, dir, lookup->dl_entry,\n\t\t\t\t   leaf_bh, leaf_bh->b_data, leaf_bh->b_size);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmax_rec_len = ocfs2_find_max_rec_len(dir->i_sb, leaf_bh);\n\ttrailer->db_free_rec_len = cpu_to_le16(max_rec_len);\n\tif (add_to_free_list) {\n\t\ttrailer->db_free_next = dx_root->dr_free_blk;\n\t\tdx_root->dr_free_blk = cpu_to_le64(leaf_bh->b_blocknr);\n\t\tocfs2_journal_dirty(handle, dx_root_bh);\n\t}\n\n\t/* leaf_bh was journal_accessed for us in __ocfs2_delete_entry */\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tle32_add_cpu(&dx_root->dr_num_entries, -1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\n\tocfs2_dx_list_remove_entry(entry_list, index);\n\n\tif (!ocfs2_dx_root_inline(dx_root))\n\t\tocfs2_journal_dirty(handle, lookup->dl_dx_leaf_bh);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dx_list_remove_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1240-1256",
    "snippet": "static void ocfs2_dx_list_remove_entry(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       int index)\n{\n\tint num_used = le16_to_cpu(entry_list->de_num_used);\n\n\tif (num_used == 1 || index == (num_used - 1))\n\t\tgoto clear;\n\n\tmemmove(&entry_list->de_entries[index],\n\t\t&entry_list->de_entries[index + 1],\n\t\t(num_used - index - 1)*sizeof(struct ocfs2_dx_entry));\nclear:\n\tnum_used--;\n\tmemset(&entry_list->de_entries[num_used], 0,\n\t       sizeof(struct ocfs2_dx_entry));\n\tentry_list->de_num_used = cpu_to_le16(num_used);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "num_used"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&entry_list->de_entries[num_used]",
            "0",
            "sizeof(struct ocfs2_dx_entry)"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&entry_list->de_entries[index]",
            "&entry_list->de_entries[index + 1]",
            "(num_used - index - 1)*sizeof(struct ocfs2_dx_entry)"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry_list->de_num_used"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dx_list_remove_entry(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       int index)\n{\n\tint num_used = le16_to_cpu(entry_list->de_num_used);\n\n\tif (num_used == 1 || index == (num_used - 1))\n\t\tgoto clear;\n\n\tmemmove(&entry_list->de_entries[index],\n\t\t&entry_list->de_entries[index + 1],\n\t\t(num_used - index - 1)*sizeof(struct ocfs2_dx_entry));\nclear:\n\tnum_used--;\n\tmemset(&entry_list->de_entries[num_used], 0,\n\t       sizeof(struct ocfs2_dx_entry));\n\tentry_list->de_num_used = cpu_to_le16(num_used);\n}"
  },
  {
    "function_name": "ocfs2_find_max_rec_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1212-1238",
    "snippet": "static int ocfs2_find_max_rec_len(struct super_block *sb,\n\t\t\t\t  struct buffer_head *dirblock_bh)\n{\n\tint size, this_hole, largest_hole = 0;\n\tchar *trailer, *de_buf, *limit, *start = dirblock_bh->b_data;\n\tstruct ocfs2_dir_entry *de;\n\n\ttrailer = (char *)ocfs2_trailer_from_bh(dirblock_bh, sb);\n\tsize = ocfs2_dir_trailer_blk_off(sb);\n\tlimit = start + size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tif (de_buf != trailer) {\n\t\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\t\tif (this_hole > largest_hole)\n\t\t\t\tlargest_hole = this_hole;\n\t\t}\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_figure_dirent_hole",
          "args": [
            "de"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_figure_dirent_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1199-1210",
          "snippet": "static unsigned int ocfs2_figure_dirent_hole(struct ocfs2_dir_entry *de)\n{\n\tunsigned int hole;\n\n\tif (le64_to_cpu(de->inode) == 0)\n\t\thole = le16_to_cpu(de->rec_len);\n\telse\n\t\thole = le16_to_cpu(de->rec_len) -\n\t\t\tOCFS2_DIR_REC_LEN(de->name_len);\n\n\treturn hole;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic unsigned int ocfs2_figure_dirent_hole(struct ocfs2_dir_entry *de)\n{\n\tunsigned int hole;\n\n\tif (le64_to_cpu(de->inode) == 0)\n\t\thole = le16_to_cpu(de->rec_len);\n\telse\n\t\thole = le16_to_cpu(de->rec_len) -\n\t\t\tOCFS2_DIR_REC_LEN(de->name_len);\n\n\treturn hole;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_trailer_blk_off",
          "args": [
            "sb"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_trailer_blk_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "114-117",
          "snippet": "static inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_trailer_from_bh",
          "args": [
            "dirblock_bh",
            "sb"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_find_max_rec_len(struct super_block *sb,\n\t\t\t\t  struct buffer_head *dirblock_bh)\n{\n\tint size, this_hole, largest_hole = 0;\n\tchar *trailer, *de_buf, *limit, *start = dirblock_bh->b_data;\n\tstruct ocfs2_dir_entry *de;\n\n\ttrailer = (char *)ocfs2_trailer_from_bh(dirblock_bh, sb);\n\tsize = ocfs2_dir_trailer_blk_off(sb);\n\tlimit = start + size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tif (de_buf != trailer) {\n\t\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\t\tif (this_hole > largest_hole)\n\t\t\t\tlargest_hole = this_hole;\n\t\t}\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_figure_dirent_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1199-1210",
    "snippet": "static unsigned int ocfs2_figure_dirent_hole(struct ocfs2_dir_entry *de)\n{\n\tunsigned int hole;\n\n\tif (le64_to_cpu(de->inode) == 0)\n\t\thole = le16_to_cpu(de->rec_len);\n\telse\n\t\thole = le16_to_cpu(de->rec_len) -\n\t\t\tOCFS2_DIR_REC_LEN(de->name_len);\n\n\treturn hole;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic unsigned int ocfs2_figure_dirent_hole(struct ocfs2_dir_entry *de)\n{\n\tunsigned int hole;\n\n\tif (le64_to_cpu(de->inode) == 0)\n\t\thole = le16_to_cpu(de->rec_len);\n\telse\n\t\thole = le16_to_cpu(de->rec_len) -\n\t\t\tOCFS2_DIR_REC_LEN(de->name_len);\n\n\treturn hole;\n}"
  },
  {
    "function_name": "__ocfs2_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1154-1197",
    "snippet": "static int __ocfs2_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\tstruct buffer_head *bh, char *first_de,\n\t\t\t\tunsigned int bytes)\n{\n\tstruct ocfs2_dir_entry *de, *pde;\n\tint i, status = -ENOENT;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ocfs2_dir_entry *) first_de;\n\twhile (i < bytes) {\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, i)) {\n\t\t\tstatus = -EIO;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tif (de == de_del)  {\n\t\t\tstatus = access(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (pde)\n\t\t\t\tle16_add_cpu(&pde->rec_len,\n\t\t\t\t\t\tle16_to_cpu(de->rec_len));\n\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tgoto bail;\n\t\t}\n\t\ti += le16_to_cpu(de->rec_len);\n\t\tpde = de;\n\t\tde = (struct ocfs2_dir_entry *)((char *)de + le16_to_cpu(de->rec_len));\n\t}\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&pde->rec_len",
            "le16_to_cpu(de->rec_len)"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "726-741",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_entry",
          "args": [
            "dir",
            "de",
            "bh",
            "i"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "316-342",
          "snippet": "static int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int __ocfs2_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\tstruct buffer_head *bh, char *first_de,\n\t\t\t\tunsigned int bytes)\n{\n\tstruct ocfs2_dir_entry *de, *pde;\n\tint i, status = -ENOENT;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ocfs2_dir_entry *) first_de;\n\twhile (i < bytes) {\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, i)) {\n\t\t\tstatus = -EIO;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tif (de == de_del)  {\n\t\t\tstatus = access(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (pde)\n\t\t\t\tle16_add_cpu(&pde->rec_len,\n\t\t\t\t\t\tle16_to_cpu(de->rec_len));\n\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tgoto bail;\n\t\t}\n\t\ti += le16_to_cpu(de->rec_len);\n\t\tpde = de;\n\t\tde = (struct ocfs2_dir_entry *)((char *)de + le16_to_cpu(de->rec_len));\n\t}\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_update_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1116-1148",
    "snippet": "int ocfs2_update_entry(struct inode *dir, handle_t *handle,\n\t\t       struct ocfs2_dir_lookup_result *res,\n\t\t       struct inode *new_entry_inode)\n{\n\tint ret;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\tstruct ocfs2_dir_entry *de = res->dl_entry;\n\tstruct buffer_head *de_bh = res->dl_leaf_bh;\n\n\t/*\n\t * The same code works fine for both inline-data and extent\n\t * based directories, so no need to split this up.  The only\n\t * difference is the journal_access function.\n\t */\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\tret = access(handle, INODE_CACHE(dir), de_bh,\n\t\t     OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tde->inode = cpu_to_le64(OCFS2_I(new_entry_inode)->ip_blkno);\n\tocfs2_set_de_type(de, new_entry_inode->i_mode);\n\n\tocfs2_journal_dirty(handle, de_bh);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "de_bh"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_de_type",
          "args": [
            "de",
            "new_entry_inode->i_mode"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1630-1634",
          "snippet": "static inline void ocfs2_set_de_type(struct ocfs2_dir_entry *de,\n\t\t\t\t    umode_t mode)\n{\n\tde->file_type = ocfs2_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}",
          "includes": [],
          "macros_used": [
            "#define S_SHIFT\t\t\t12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define S_SHIFT\t\t\t12\n\nstatic inline void ocfs2_set_de_type(struct ocfs2_dir_entry *de,\n\t\t\t\t    umode_t mode)\n{\n\tde->file_type = ocfs2_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "OCFS2_I(new_entry_inode)->ip_blkno"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "new_entry_inode"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "de_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "726-741",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_update_entry(struct inode *dir, handle_t *handle,\n\t\t       struct ocfs2_dir_lookup_result *res,\n\t\t       struct inode *new_entry_inode)\n{\n\tint ret;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\tstruct ocfs2_dir_entry *de = res->dl_entry;\n\tstruct buffer_head *de_bh = res->dl_leaf_bh;\n\n\t/*\n\t * The same code works fine for both inline-data and extent\n\t * based directories, so no need to split this up.  The only\n\t * difference is the journal_access function.\n\t */\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\tret = access(handle, INODE_CACHE(dir), de_bh,\n\t\t     OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tde->inode = cpu_to_le64(OCFS2_I(new_entry_inode)->ip_blkno);\n\tocfs2_set_de_type(de, new_entry_inode->i_mode);\n\n\tocfs2_journal_dirty(handle, de_bh);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1086-1111",
    "snippet": "int ocfs2_find_entry(const char *name, int namelen,\n\t\t     struct inode *dir, struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct buffer_head *bh;\n\tstruct ocfs2_dir_entry *res_dir = NULL;\n\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_find_entry_dx(name, namelen, dir, lookup);\n\n\t/*\n\t * The unindexed dir code only uses part of the lookup\n\t * structure, so there's no reason to push it down further\n\t * than this.\n\t */\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tbh = ocfs2_find_entry_id(name, namelen, dir, &res_dir);\n\telse\n\t\tbh = ocfs2_find_entry_el(name, namelen, dir, &res_dir);\n\n\tif (bh == NULL)\n\t\treturn -ENOENT;\n\n\tlookup->dl_leaf_bh = bh;\n\tlookup->dl_entry = res_dir;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_find_entry_el",
          "args": [
            "name",
            "namelen",
            "dir",
            "&res_dir"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_entry_el",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "692-789",
          "snippet": "static struct buffer_head *ocfs2_find_entry_el(const char *name, int namelen,\n\t\t\t\t\t       struct inode *dir,\n\t\t\t\t\t       struct ocfs2_dir_entry **res_dir)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\n\tsb = dir->i_sb;\n\n\tnblocks = i_size_read(dir) >> sb->s_blocksize_bits;\n\tstart = OCFS2_I(dir)->ip_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\n\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\n\t\t\t\tbh = NULL;\n\t\t\t\terr = ocfs2_read_dir_block(dir, b++, &bh,\n\t\t\t\t\t\t\t   OCFS2_BH_READAHEAD);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\tif (ocfs2_read_dir_block(dir, block, &bh, 0)) {\n\t\t\t/* read error, skip block & hope for the best.\n\t\t\t * ocfs2_read_dir_block() has released the bh. */\n\t\t\tmlog(ML_ERROR, \"reading directory %llu, \"\n\t\t\t\t    \"offset %lu\\n\",\n\t\t\t\t    (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t    block);\n\t\t\tgoto next;\n\t\t}\n\t\ti = ocfs2_search_dirblock(bh, dir, name, namelen,\n\t\t\t\t\t  block << sb->s_blocksize_bits,\n\t\t\t\t\t  bh->b_data, sb->s_blocksize,\n\t\t\t\t\t  res_dir);\n\t\tif (i == 1) {\n\t\t\tOCFS2_I(dir)->ip_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = i_size_read(dir) >> sb->s_blocksize_bits;\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\n\ttrace_ocfs2_find_entry_el(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
          ],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic struct buffer_head *ocfs2_find_entry_el(const char *name, int namelen,\n\t\t\t\t\t       struct inode *dir,\n\t\t\t\t\t       struct ocfs2_dir_entry **res_dir)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\n\tsb = dir->i_sb;\n\n\tnblocks = i_size_read(dir) >> sb->s_blocksize_bits;\n\tstart = OCFS2_I(dir)->ip_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\n\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\n\t\t\t\tbh = NULL;\n\t\t\t\terr = ocfs2_read_dir_block(dir, b++, &bh,\n\t\t\t\t\t\t\t   OCFS2_BH_READAHEAD);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\tif (ocfs2_read_dir_block(dir, block, &bh, 0)) {\n\t\t\t/* read error, skip block & hope for the best.\n\t\t\t * ocfs2_read_dir_block() has released the bh. */\n\t\t\tmlog(ML_ERROR, \"reading directory %llu, \"\n\t\t\t\t    \"offset %lu\\n\",\n\t\t\t\t    (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t    block);\n\t\t\tgoto next;\n\t\t}\n\t\ti = ocfs2_search_dirblock(bh, dir, name, namelen,\n\t\t\t\t\t  block << sb->s_blocksize_bits,\n\t\t\t\t\t  bh->b_data, sb->s_blocksize,\n\t\t\t\t\t  res_dir);\n\t\tif (i == 1) {\n\t\t\tOCFS2_I(dir)->ip_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = i_size_read(dir) >> sb->s_blocksize_bits;\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\n\ttrace_ocfs2_find_entry_el(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_entry_id",
          "args": [
            "name",
            "namelen",
            "dir",
            "&res_dir"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_entry_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "408-435",
          "snippet": "static struct buffer_head *ocfs2_find_entry_id(const char *name,\n\t\t\t\t\t       int namelen,\n\t\t\t\t\t       struct inode *dir,\n\t\t\t\t\t       struct ocfs2_dir_entry **res_dir)\n{\n\tint ret, found;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\tfound = ocfs2_search_dirblock(di_bh, dir, name, namelen, 0,\n\t\t\t\t      data->id_data, i_size_read(dir), res_dir);\n\tif (found == 1)\n\t\treturn di_bh;\n\n\tbrelse(di_bh);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic struct buffer_head *ocfs2_find_entry_id(const char *name,\n\t\t\t\t\t       int namelen,\n\t\t\t\t\t       struct inode *dir,\n\t\t\t\t\t       struct ocfs2_dir_entry **res_dir)\n{\n\tint ret, found;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\tfound = ocfs2_search_dirblock(di_bh, dir, name, namelen, 0,\n\t\t\t\t      data->id_data, i_size_read(dir), res_dir);\n\tif (found == 1)\n\t\treturn di_bh;\n\n\tbrelse(di_bh);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_entry_dx",
          "args": [
            "name",
            "namelen",
            "dir",
            "lookup"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_entry_dx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1032-1070",
          "snippet": "static int ocfs2_find_entry_dx(const char *name, int namelen,\n\t\t\t       struct inode *dir,\n\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\n\tret = ocfs2_dx_dir_search(name, namelen, dir, dx_root, lookup);\n\tif (ret) {\n\t\tif (ret != -ENOENT)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tlookup->dl_dx_root_bh = dx_root_bh;\n\tdx_root_bh = NULL;\nout:\n\tbrelse(di_bh);\n\tbrelse(dx_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_find_entry_dx(const char *name, int namelen,\n\t\t\t       struct inode *dir,\n\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\n\tret = ocfs2_dx_dir_search(name, namelen, dir, dx_root, lookup);\n\tif (ret) {\n\t\tif (ret != -ENOENT)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tlookup->dl_dx_root_bh = dx_root_bh;\n\tdx_root_bh = NULL;\nout:\n\tbrelse(di_bh);\n\tbrelse(dx_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_indexed",
          "args": [
            "dir"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_indexed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "209-214",
          "snippet": "static int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_find_entry(const char *name, int namelen,\n\t\t     struct inode *dir, struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct buffer_head *bh;\n\tstruct ocfs2_dir_entry *res_dir = NULL;\n\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_find_entry_dx(name, namelen, dir, lookup);\n\n\t/*\n\t * The unindexed dir code only uses part of the lookup\n\t * structure, so there's no reason to push it down further\n\t * than this.\n\t */\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tbh = ocfs2_find_entry_id(name, namelen, dir, &res_dir);\n\telse\n\t\tbh = ocfs2_find_entry_el(name, namelen, dir, &res_dir);\n\n\tif (bh == NULL)\n\t\treturn -ENOENT;\n\n\tlookup->dl_leaf_bh = bh;\n\tlookup->dl_entry = res_dir;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_find_entry_dx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "1032-1070",
    "snippet": "static int ocfs2_find_entry_dx(const char *name, int namelen,\n\t\t\t       struct inode *dir,\n\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\n\tret = ocfs2_dx_dir_search(name, namelen, dir, dx_root, lookup);\n\tif (ret) {\n\t\tif (ret != -ENOENT)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tlookup->dl_dx_root_bh = dx_root_bh;\n\tdx_root_bh = NULL;\nout:\n\tbrelse(di_bh);\n\tbrelse(dx_root_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dx_root_bh"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_search",
          "args": [
            "name",
            "namelen",
            "dir",
            "dx_root",
            "lookup"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "918-1030",
          "snippet": "static int ocfs2_dx_dir_search(const char *name, int namelen,\n\t\t\t       struct inode *dir,\n\t\t\t       struct ocfs2_dx_root_block *dx_root,\n\t\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tint ret, i, found;\n\tu64 uninitialized_var(phys);\n\tstruct buffer_head *dx_leaf_bh = NULL;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct ocfs2_dx_entry *dx_entry = NULL;\n\tstruct buffer_head *dir_ent_bh = NULL;\n\tstruct ocfs2_dir_entry *dir_ent = NULL;\n\tstruct ocfs2_dx_hinfo *hinfo = &res->dl_hinfo;\n\tstruct ocfs2_extent_list *dr_el;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\tocfs2_dx_dir_name_hash(dir, name, namelen, &res->dl_hinfo);\n\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tentry_list = &dx_root->dr_entries;\n\t\tgoto search;\n\t}\n\n\tdr_el = &dx_root->dr_list;\n\n\tret = ocfs2_dx_dir_lookup(dir, dr_el, hinfo, NULL, &phys);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_dx_dir_search((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t  namelen, name, hinfo->major_hash,\n\t\t\t\t  hinfo->minor_hash, (unsigned long long)phys);\n\n\tret = ocfs2_read_dx_leaf(dir, phys, &dx_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *) dx_leaf_bh->b_data;\n\n\ttrace_ocfs2_dx_dir_search_leaf_info(\n\t\t\tle16_to_cpu(dx_leaf->dl_list.de_num_used),\n\t\t\tle16_to_cpu(dx_leaf->dl_list.de_count));\n\n\tentry_list = &dx_leaf->dl_list;\n\nsearch:\n\t/*\n\t * Empty leaf is legal, so no need to check for that.\n\t */\n\tfound = 0;\n\tfor (i = 0; i < le16_to_cpu(entry_list->de_num_used); i++) {\n\t\tdx_entry = &entry_list->de_entries[i];\n\n\t\tif (hinfo->major_hash != le32_to_cpu(dx_entry->dx_major_hash)\n\t\t    || hinfo->minor_hash != le32_to_cpu(dx_entry->dx_minor_hash))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Search unindexed leaf block now. We're not\n\t\t * guaranteed to find anything.\n\t\t */\n\t\tret = ocfs2_read_dir_block_direct(dir,\n\t\t\t\t\t  le64_to_cpu(dx_entry->dx_dirent_blk),\n\t\t\t\t\t  &dir_ent_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: We should check the unindexed block here,\n\t\t * before using it.\n\t\t */\n\n\t\tfound = ocfs2_search_dirblock(dir_ent_bh, dir, name, namelen,\n\t\t\t\t\t      0, dir_ent_bh->b_data,\n\t\t\t\t\t      dir->i_sb->s_blocksize, &dir_ent);\n\t\tif (found == 1)\n\t\t\tbreak;\n\n\t\tif (found == -1) {\n\t\t\t/* This means we found a bad directory entry. */\n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(dir_ent_bh);\n\t\tdir_ent_bh = NULL;\n\t}\n\n\tif (found <= 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tres->dl_leaf_bh = dir_ent_bh;\n\tres->dl_entry = dir_ent;\n\tres->dl_dx_leaf_bh = dx_leaf_bh;\n\tres->dl_dx_entry = dx_entry;\n\n\tret = 0;\nout:\n\tif (ret) {\n\t\tbrelse(dx_leaf_bh);\n\t\tbrelse(dir_ent_bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_search(const char *name, int namelen,\n\t\t\t       struct inode *dir,\n\t\t\t       struct ocfs2_dx_root_block *dx_root,\n\t\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tint ret, i, found;\n\tu64 uninitialized_var(phys);\n\tstruct buffer_head *dx_leaf_bh = NULL;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct ocfs2_dx_entry *dx_entry = NULL;\n\tstruct buffer_head *dir_ent_bh = NULL;\n\tstruct ocfs2_dir_entry *dir_ent = NULL;\n\tstruct ocfs2_dx_hinfo *hinfo = &res->dl_hinfo;\n\tstruct ocfs2_extent_list *dr_el;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\tocfs2_dx_dir_name_hash(dir, name, namelen, &res->dl_hinfo);\n\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tentry_list = &dx_root->dr_entries;\n\t\tgoto search;\n\t}\n\n\tdr_el = &dx_root->dr_list;\n\n\tret = ocfs2_dx_dir_lookup(dir, dr_el, hinfo, NULL, &phys);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_dx_dir_search((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t  namelen, name, hinfo->major_hash,\n\t\t\t\t  hinfo->minor_hash, (unsigned long long)phys);\n\n\tret = ocfs2_read_dx_leaf(dir, phys, &dx_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *) dx_leaf_bh->b_data;\n\n\ttrace_ocfs2_dx_dir_search_leaf_info(\n\t\t\tle16_to_cpu(dx_leaf->dl_list.de_num_used),\n\t\t\tle16_to_cpu(dx_leaf->dl_list.de_count));\n\n\tentry_list = &dx_leaf->dl_list;\n\nsearch:\n\t/*\n\t * Empty leaf is legal, so no need to check for that.\n\t */\n\tfound = 0;\n\tfor (i = 0; i < le16_to_cpu(entry_list->de_num_used); i++) {\n\t\tdx_entry = &entry_list->de_entries[i];\n\n\t\tif (hinfo->major_hash != le32_to_cpu(dx_entry->dx_major_hash)\n\t\t    || hinfo->minor_hash != le32_to_cpu(dx_entry->dx_minor_hash))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Search unindexed leaf block now. We're not\n\t\t * guaranteed to find anything.\n\t\t */\n\t\tret = ocfs2_read_dir_block_direct(dir,\n\t\t\t\t\t  le64_to_cpu(dx_entry->dx_dirent_blk),\n\t\t\t\t\t  &dir_ent_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: We should check the unindexed block here,\n\t\t * before using it.\n\t\t */\n\n\t\tfound = ocfs2_search_dirblock(dir_ent_bh, dir, name, namelen,\n\t\t\t\t\t      0, dir_ent_bh->b_data,\n\t\t\t\t\t      dir->i_sb->s_blocksize, &dir_ent);\n\t\tif (found == 1)\n\t\t\tbreak;\n\n\t\tif (found == -1) {\n\t\t\t/* This means we found a bad directory entry. */\n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(dir_ent_bh);\n\t\tdir_ent_bh = NULL;\n\t}\n\n\tif (found <= 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tres->dl_leaf_bh = dir_ent_bh;\n\tres->dl_entry = dir_ent;\n\tres->dl_dx_leaf_bh = dx_leaf_bh;\n\tres->dl_dx_entry = dx_entry;\n\n\tret = 0;\nout:\n\tif (ret) {\n\t\tbrelse(dx_leaf_bh);\n\t\tbrelse(dir_ent_bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_dx_root",
          "args": [
            "dir",
            "di",
            "&dx_root_bh"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dx_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "617-632",
          "snippet": "static int ocfs2_read_dx_root(struct inode *dir, struct ocfs2_dinode *di,\n\t\t\t      struct buffer_head **dx_root_bh)\n{\n\tint ret;\n\tu64 blkno = le64_to_cpu(di->i_dx_root);\n\tstruct buffer_head *tmp = *dx_root_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_root);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_root_bh)\n\t\t*dx_root_bh = tmp;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dx_root(struct inode *dir, struct ocfs2_dinode *di,\n\t\t\t      struct buffer_head **dx_root_bh)\n{\n\tint ret;\n\tu64 blkno = le64_to_cpu(di->i_dx_root);\n\tstruct buffer_head *tmp = *dx_root_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_root);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_root_bh)\n\t\t*dx_root_bh = tmp;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "dir",
            "&di_bh"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_find_entry_dx(const char *name, int namelen,\n\t\t\t       struct inode *dir,\n\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\n\tret = ocfs2_dx_dir_search(name, namelen, dir, dx_root, lookup);\n\tif (ret) {\n\t\tif (ret != -ENOENT)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tlookup->dl_dx_root_bh = dx_root_bh;\n\tdx_root_bh = NULL;\nout:\n\tbrelse(di_bh);\n\tbrelse(dx_root_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "918-1030",
    "snippet": "static int ocfs2_dx_dir_search(const char *name, int namelen,\n\t\t\t       struct inode *dir,\n\t\t\t       struct ocfs2_dx_root_block *dx_root,\n\t\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tint ret, i, found;\n\tu64 uninitialized_var(phys);\n\tstruct buffer_head *dx_leaf_bh = NULL;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct ocfs2_dx_entry *dx_entry = NULL;\n\tstruct buffer_head *dir_ent_bh = NULL;\n\tstruct ocfs2_dir_entry *dir_ent = NULL;\n\tstruct ocfs2_dx_hinfo *hinfo = &res->dl_hinfo;\n\tstruct ocfs2_extent_list *dr_el;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\tocfs2_dx_dir_name_hash(dir, name, namelen, &res->dl_hinfo);\n\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tentry_list = &dx_root->dr_entries;\n\t\tgoto search;\n\t}\n\n\tdr_el = &dx_root->dr_list;\n\n\tret = ocfs2_dx_dir_lookup(dir, dr_el, hinfo, NULL, &phys);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_dx_dir_search((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t  namelen, name, hinfo->major_hash,\n\t\t\t\t  hinfo->minor_hash, (unsigned long long)phys);\n\n\tret = ocfs2_read_dx_leaf(dir, phys, &dx_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *) dx_leaf_bh->b_data;\n\n\ttrace_ocfs2_dx_dir_search_leaf_info(\n\t\t\tle16_to_cpu(dx_leaf->dl_list.de_num_used),\n\t\t\tle16_to_cpu(dx_leaf->dl_list.de_count));\n\n\tentry_list = &dx_leaf->dl_list;\n\nsearch:\n\t/*\n\t * Empty leaf is legal, so no need to check for that.\n\t */\n\tfound = 0;\n\tfor (i = 0; i < le16_to_cpu(entry_list->de_num_used); i++) {\n\t\tdx_entry = &entry_list->de_entries[i];\n\n\t\tif (hinfo->major_hash != le32_to_cpu(dx_entry->dx_major_hash)\n\t\t    || hinfo->minor_hash != le32_to_cpu(dx_entry->dx_minor_hash))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Search unindexed leaf block now. We're not\n\t\t * guaranteed to find anything.\n\t\t */\n\t\tret = ocfs2_read_dir_block_direct(dir,\n\t\t\t\t\t  le64_to_cpu(dx_entry->dx_dirent_blk),\n\t\t\t\t\t  &dir_ent_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: We should check the unindexed block here,\n\t\t * before using it.\n\t\t */\n\n\t\tfound = ocfs2_search_dirblock(dir_ent_bh, dir, name, namelen,\n\t\t\t\t\t      0, dir_ent_bh->b_data,\n\t\t\t\t\t      dir->i_sb->s_blocksize, &dir_ent);\n\t\tif (found == 1)\n\t\t\tbreak;\n\n\t\tif (found == -1) {\n\t\t\t/* This means we found a bad directory entry. */\n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(dir_ent_bh);\n\t\tdir_ent_bh = NULL;\n\t}\n\n\tif (found <= 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tres->dl_leaf_bh = dir_ent_bh;\n\tres->dl_entry = dir_ent;\n\tres->dl_dx_leaf_bh = dx_leaf_bh;\n\tres->dl_dx_entry = dx_entry;\n\n\tret = 0;\nout:\n\tif (ret) {\n\t\tbrelse(dx_leaf_bh);\n\t\tbrelse(dir_ent_bh);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dir_ent_bh"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_search_dirblock",
          "args": [
            "dir_ent_bh",
            "dir",
            "name",
            "namelen",
            "0",
            "dir_ent_bh->b_data",
            "dir->i_sb->s_blocksize",
            "&dir_ent"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_dirblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "358-406",
          "snippet": "static inline int ocfs2_search_dirblock(struct buffer_head *bh,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tconst char *name, int namelen,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tchar *first_de,\n\t\t\t\t\tunsigned int bytes,\n\t\t\t\t\tstruct ocfs2_dir_entry **res_dir)\n{\n\tstruct ocfs2_dir_entry *de;\n\tchar *dlimit, *de_buf;\n\tint de_len;\n\tint ret = 0;\n\n\tde_buf = first_de;\n\tdlimit = de_buf + bytes;\n\n\twhile (de_buf < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tde = (struct ocfs2_dir_entry *) de_buf;\n\n\t\tif (de_buf + namelen <= dlimit &&\n\t\t    ocfs2_match(namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t*res_dir = de;\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* prevent looping on a bad block */\n\t\tde_len = le16_to_cpu(de->rec_len);\n\t\tif (de_len <= 0) {\n\t\t\tret = -1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tde_buf += de_len;\n\t\toffset += de_len;\n\t}\n\nbail:\n\ttrace_ocfs2_search_dirblock(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_search_dirblock(struct buffer_head *bh,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tconst char *name, int namelen,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tchar *first_de,\n\t\t\t\t\tunsigned int bytes,\n\t\t\t\t\tstruct ocfs2_dir_entry **res_dir)\n{\n\tstruct ocfs2_dir_entry *de;\n\tchar *dlimit, *de_buf;\n\tint de_len;\n\tint ret = 0;\n\n\tde_buf = first_de;\n\tdlimit = de_buf + bytes;\n\n\twhile (de_buf < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tde = (struct ocfs2_dir_entry *) de_buf;\n\n\t\tif (de_buf + namelen <= dlimit &&\n\t\t    ocfs2_match(namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t*res_dir = de;\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* prevent looping on a bad block */\n\t\tde_len = le16_to_cpu(de->rec_len);\n\t\tif (de_len <= 0) {\n\t\t\tret = -1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tde_buf += de_len;\n\t\toffset += de_len;\n\t}\n\nbail:\n\ttrace_ocfs2_search_dirblock(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_dir_block_direct",
          "args": [
            "dir",
            "le64_to_cpu(dx_entry->dx_dirent_blk)",
            "&dir_ent_bh"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dir_block_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "559-586",
          "snippet": "static int ocfs2_read_dir_block_direct(struct inode *dir, u64 phys,\n\t\t\t\t       struct buffer_head **bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), phys, &tmp,\n\t\t\t       ocfs2_validate_dir_block);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tret = ocfs2_check_dir_trailer(dir, tmp);\n\t\tif (ret) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!ret && !*bh)\n\t\t*bh = tmp;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dir_block_direct(struct inode *dir, u64 phys,\n\t\t\t\t       struct buffer_head **bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), phys, &tmp,\n\t\t\t       ocfs2_validate_dir_block);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tret = ocfs2_check_dir_trailer(dir, tmp);\n\t\tif (ret) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!ret && !*bh)\n\t\t*bh = tmp;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dx_entry->dx_dirent_blk"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dx_entry->dx_minor_hash"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry_list->de_num_used"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dx_dir_search_leaf_info",
          "args": [
            "le16_to_cpu(dx_leaf->dl_list.de_num_used)",
            "le16_to_cpu(dx_leaf->dl_list.de_count)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_dx_leaf",
          "args": [
            "dir",
            "phys",
            "&dx_leaf_bh"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dx_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "659-673",
          "snippet": "static int ocfs2_read_dx_leaf(struct inode *dir, u64 blkno,\n\t\t\t      struct buffer_head **dx_leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *dx_leaf_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_leaf);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_leaf_bh)\n\t\t*dx_leaf_bh = tmp;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dx_leaf(struct inode *dir, u64 blkno,\n\t\t\t      struct buffer_head **dx_leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *dx_leaf_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_leaf);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_leaf_bh)\n\t\t*dx_leaf_bh = tmp;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dx_dir_search",
          "args": [
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "namelen",
            "name",
            "hinfo->major_hash",
            "hinfo->minor_hash",
            "(unsigned long long)phys"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_lookup",
          "args": [
            "dir",
            "dr_el",
            "hinfo",
            "NULL",
            "&phys"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "871-916",
          "snippet": "static int ocfs2_dx_dir_lookup(struct inode *inode,\n\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t       u32 *ret_cpos,\n\t\t\t       u64 *ret_phys_blkno)\n{\n\tint ret = 0;\n\tunsigned int cend, uninitialized_var(clen);\n\tu32 uninitialized_var(cpos);\n\tu64 uninitialized_var(blkno);\n\tu32 name_hash = hinfo->major_hash;\n\n\tret = ocfs2_dx_dir_lookup_rec(inode, el, name_hash, &cpos, &blkno,\n\t\t\t\t      &clen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcend = cpos + clen;\n\tif (name_hash >= cend) {\n\t\t/* We want the last cluster */\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, clen - 1);\n\t\tcpos += clen - 1;\n\t} else {\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t  name_hash - cpos);\n\t\tcpos = name_hash;\n\t}\n\n\t/*\n\t * We now have the cluster which should hold our entry. To\n\t * find the exact block from the start of the cluster to\n\t * search, we take the lower bits of the hash.\n\t */\n\tblkno += ocfs2_dx_dir_hash_idx(OCFS2_SB(inode->i_sb), hinfo);\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = blkno;\n\tif (ret_cpos)\n\t\t*ret_cpos = cpos;\n\nout:\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_lookup(struct inode *inode,\n\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t       u32 *ret_cpos,\n\t\t\t       u64 *ret_phys_blkno)\n{\n\tint ret = 0;\n\tunsigned int cend, uninitialized_var(clen);\n\tu32 uninitialized_var(cpos);\n\tu64 uninitialized_var(blkno);\n\tu32 name_hash = hinfo->major_hash;\n\n\tret = ocfs2_dx_dir_lookup_rec(inode, el, name_hash, &cpos, &blkno,\n\t\t\t\t      &clen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcend = cpos + clen;\n\tif (name_hash >= cend) {\n\t\t/* We want the last cluster */\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, clen - 1);\n\t\tcpos += clen - 1;\n\t} else {\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t  name_hash - cpos);\n\t\tcpos = name_hash;\n\t}\n\n\t/*\n\t * We now have the cluster which should hold our entry. To\n\t * find the exact block from the start of the cluster to\n\t * search, we take the lower bits of the hash.\n\t */\n\tblkno += ocfs2_dx_dir_hash_idx(OCFS2_SB(inode->i_sb), hinfo);\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = blkno;\n\tif (ret_cpos)\n\t\t*ret_cpos = cpos;\n\nout:\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_root_inline",
          "args": [
            "dx_root"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_root_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "216-219",
          "snippet": "static inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_name_hash",
          "args": [
            "dir",
            "name",
            "namelen",
            "&res->dl_hinfo"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "270-310",
          "snippet": "static void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t/*\n\t * XXX: Is this really necessary, if the index is never looked\n\t * at by readdir? Is a hash value of '0' a bad idea?\n\t */\n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t/*\n\t * This makes it very easy to debug indexing problems. We\n\t * should never allow this to be selected without hand editing\n\t * this file though.\n\t */\n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t/*\n\t * XXX: Is this really necessary, if the index is never looked\n\t * at by readdir? Is a hash value of '0' a bad idea?\n\t */\n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t/*\n\t * This makes it very easy to debug indexing problems. We\n\t * should never allow this to be selected without hand editing\n\t * this file though.\n\t */\n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_search(const char *name, int namelen,\n\t\t\t       struct inode *dir,\n\t\t\t       struct ocfs2_dx_root_block *dx_root,\n\t\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tint ret, i, found;\n\tu64 uninitialized_var(phys);\n\tstruct buffer_head *dx_leaf_bh = NULL;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct ocfs2_dx_entry *dx_entry = NULL;\n\tstruct buffer_head *dir_ent_bh = NULL;\n\tstruct ocfs2_dir_entry *dir_ent = NULL;\n\tstruct ocfs2_dx_hinfo *hinfo = &res->dl_hinfo;\n\tstruct ocfs2_extent_list *dr_el;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\tocfs2_dx_dir_name_hash(dir, name, namelen, &res->dl_hinfo);\n\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tentry_list = &dx_root->dr_entries;\n\t\tgoto search;\n\t}\n\n\tdr_el = &dx_root->dr_list;\n\n\tret = ocfs2_dx_dir_lookup(dir, dr_el, hinfo, NULL, &phys);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_dx_dir_search((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t  namelen, name, hinfo->major_hash,\n\t\t\t\t  hinfo->minor_hash, (unsigned long long)phys);\n\n\tret = ocfs2_read_dx_leaf(dir, phys, &dx_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *) dx_leaf_bh->b_data;\n\n\ttrace_ocfs2_dx_dir_search_leaf_info(\n\t\t\tle16_to_cpu(dx_leaf->dl_list.de_num_used),\n\t\t\tle16_to_cpu(dx_leaf->dl_list.de_count));\n\n\tentry_list = &dx_leaf->dl_list;\n\nsearch:\n\t/*\n\t * Empty leaf is legal, so no need to check for that.\n\t */\n\tfound = 0;\n\tfor (i = 0; i < le16_to_cpu(entry_list->de_num_used); i++) {\n\t\tdx_entry = &entry_list->de_entries[i];\n\n\t\tif (hinfo->major_hash != le32_to_cpu(dx_entry->dx_major_hash)\n\t\t    || hinfo->minor_hash != le32_to_cpu(dx_entry->dx_minor_hash))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Search unindexed leaf block now. We're not\n\t\t * guaranteed to find anything.\n\t\t */\n\t\tret = ocfs2_read_dir_block_direct(dir,\n\t\t\t\t\t  le64_to_cpu(dx_entry->dx_dirent_blk),\n\t\t\t\t\t  &dir_ent_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: We should check the unindexed block here,\n\t\t * before using it.\n\t\t */\n\n\t\tfound = ocfs2_search_dirblock(dir_ent_bh, dir, name, namelen,\n\t\t\t\t\t      0, dir_ent_bh->b_data,\n\t\t\t\t\t      dir->i_sb->s_blocksize, &dir_ent);\n\t\tif (found == 1)\n\t\t\tbreak;\n\n\t\tif (found == -1) {\n\t\t\t/* This means we found a bad directory entry. */\n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(dir_ent_bh);\n\t\tdir_ent_bh = NULL;\n\t}\n\n\tif (found <= 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tres->dl_leaf_bh = dir_ent_bh;\n\tres->dl_entry = dir_ent;\n\tres->dl_dx_leaf_bh = dx_leaf_bh;\n\tres->dl_dx_entry = dx_entry;\n\n\tret = 0;\nout:\n\tif (ret) {\n\t\tbrelse(dx_leaf_bh);\n\t\tbrelse(dir_ent_bh);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "871-916",
    "snippet": "static int ocfs2_dx_dir_lookup(struct inode *inode,\n\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t       u32 *ret_cpos,\n\t\t\t       u64 *ret_phys_blkno)\n{\n\tint ret = 0;\n\tunsigned int cend, uninitialized_var(clen);\n\tu32 uninitialized_var(cpos);\n\tu64 uninitialized_var(blkno);\n\tu32 name_hash = hinfo->major_hash;\n\n\tret = ocfs2_dx_dir_lookup_rec(inode, el, name_hash, &cpos, &blkno,\n\t\t\t\t      &clen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcend = cpos + clen;\n\tif (name_hash >= cend) {\n\t\t/* We want the last cluster */\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, clen - 1);\n\t\tcpos += clen - 1;\n\t} else {\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t  name_hash - cpos);\n\t\tcpos = name_hash;\n\t}\n\n\t/*\n\t * We now have the cluster which should hold our entry. To\n\t * find the exact block from the start of the cluster to\n\t * search, we take the lower bits of the hash.\n\t */\n\tblkno += ocfs2_dx_dir_hash_idx(OCFS2_SB(inode->i_sb), hinfo);\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = blkno;\n\tif (ret_cpos)\n\t\t*ret_cpos = cpos;\n\nout:\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_hash_idx",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "hinfo"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_hash_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "865-869",
          "snippet": "static inline unsigned int ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_hinfo *hinfo)\n{\n\treturn __ocfs2_dx_dir_hash_idx(osb, hinfo->minor_hash);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_hinfo *hinfo)\n{\n\treturn __ocfs2_dx_dir_hash_idx(osb, hinfo->minor_hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "name_hash - cpos"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dx_dir_lookup_rec",
          "args": [
            "inode",
            "el",
            "name_hash",
            "&cpos",
            "&blkno",
            "&clen"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_lookup_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "791-853",
          "snippet": "static int ocfs2_dx_dir_lookup_rec(struct inode *inode,\n\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t   u32 major_hash,\n\t\t\t\t   u32 *ret_cpos,\n\t\t\t\t   u64 *ret_phys_blkno,\n\t\t\t\t   unsigned int *ret_clen)\n{\n\tint ret = 0, i, found;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, major_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"btree tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= major_hash) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in btree\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = le64_to_cpu(rec->e_blkno);\n\tif (ret_cpos)\n\t\t*ret_cpos = le32_to_cpu(rec->e_cpos);\n\tif (ret_clen)\n\t\t*ret_clen = le16_to_cpu(rec->e_leaf_clusters);\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_lookup_rec(struct inode *inode,\n\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t   u32 major_hash,\n\t\t\t\t   u32 *ret_cpos,\n\t\t\t\t   u64 *ret_phys_blkno,\n\t\t\t\t   unsigned int *ret_clen)\n{\n\tint ret = 0, i, found;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, major_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"btree tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= major_hash) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in btree\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = le64_to_cpu(rec->e_blkno);\n\tif (ret_cpos)\n\t\t*ret_cpos = le32_to_cpu(rec->e_cpos);\n\tif (ret_clen)\n\t\t*ret_clen = le16_to_cpu(rec->e_leaf_clusters);\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_lookup(struct inode *inode,\n\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t       u32 *ret_cpos,\n\t\t\t       u64 *ret_phys_blkno)\n{\n\tint ret = 0;\n\tunsigned int cend, uninitialized_var(clen);\n\tu32 uninitialized_var(cpos);\n\tu64 uninitialized_var(blkno);\n\tu32 name_hash = hinfo->major_hash;\n\n\tret = ocfs2_dx_dir_lookup_rec(inode, el, name_hash, &cpos, &blkno,\n\t\t\t\t      &clen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcend = cpos + clen;\n\tif (name_hash >= cend) {\n\t\t/* We want the last cluster */\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, clen - 1);\n\t\tcpos += clen - 1;\n\t} else {\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t  name_hash - cpos);\n\t\tcpos = name_hash;\n\t}\n\n\t/*\n\t * We now have the cluster which should hold our entry. To\n\t * find the exact block from the start of the cluster to\n\t * search, we take the lower bits of the hash.\n\t */\n\tblkno += ocfs2_dx_dir_hash_idx(OCFS2_SB(inode->i_sb), hinfo);\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = blkno;\n\tif (ret_cpos)\n\t\t*ret_cpos = cpos;\n\nout:\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_hash_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "865-869",
    "snippet": "static inline unsigned int ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_hinfo *hinfo)\n{\n\treturn __ocfs2_dx_dir_hash_idx(osb, hinfo->minor_hash);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_dx_dir_hash_idx",
          "args": [
            "osb",
            "hinfo->minor_hash"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_dx_dir_hash_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "859-863",
          "snippet": "static inline unsigned int __ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t\t   u32 minor_hash)\n{\n\treturn minor_hash & osb->osb_dx_mask;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int __ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t\t   u32 minor_hash)\n{\n\treturn minor_hash & osb->osb_dx_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_hinfo *hinfo)\n{\n\treturn __ocfs2_dx_dir_hash_idx(osb, hinfo->minor_hash);\n}"
  },
  {
    "function_name": "__ocfs2_dx_dir_hash_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "859-863",
    "snippet": "static inline unsigned int __ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t\t   u32 minor_hash)\n{\n\treturn minor_hash & osb->osb_dx_mask;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int __ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t\t   u32 minor_hash)\n{\n\treturn minor_hash & osb->osb_dx_mask;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_lookup_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "791-853",
    "snippet": "static int ocfs2_dx_dir_lookup_rec(struct inode *inode,\n\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t   u32 major_hash,\n\t\t\t\t   u32 *ret_cpos,\n\t\t\t\t   u64 *ret_phys_blkno,\n\t\t\t\t   unsigned int *ret_clen)\n{\n\tint ret = 0, i, found;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, major_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"btree tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= major_hash) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in btree\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = le64_to_cpu(rec->e_blkno);\n\tif (ret_cpos)\n\t\t*ret_cpos = le32_to_cpu(rec->e_cpos);\n\tif (ret_clen)\n\t\t*ret_clen = le16_to_cpu(rec->e_leaf_clusters);\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "eb_bh"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->e_blkno"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in btree\"",
            "inode->i_ino",
            "le32_to_cpu(rec->e_cpos)",
            "ocfs2_rec_clusters(el, rec)"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_leaf",
          "args": [
            "INODE_CACHE(inode)",
            "el",
            "major_hash",
            "&eb_bh"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1917-1933",
          "snippet": "int ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_lookup_rec(struct inode *inode,\n\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t   u32 major_hash,\n\t\t\t\t   u32 *ret_cpos,\n\t\t\t\t   u64 *ret_phys_blkno,\n\t\t\t\t   unsigned int *ret_clen)\n{\n\tint ret = 0, i, found;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, major_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"btree tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= major_hash) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in btree\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = le64_to_cpu(rec->e_blkno);\n\tif (ret_cpos)\n\t\t*ret_cpos = le32_to_cpu(rec->e_cpos);\n\tif (ret_clen)\n\t\t*ret_clen = le16_to_cpu(rec->e_leaf_clusters);\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_entry_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "692-789",
    "snippet": "static struct buffer_head *ocfs2_find_entry_el(const char *name, int namelen,\n\t\t\t\t\t       struct inode *dir,\n\t\t\t\t\t       struct ocfs2_dir_entry **res_dir)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\n\tsb = dir->i_sb;\n\n\tnblocks = i_size_read(dir) >> sb->s_blocksize_bits;\n\tstart = OCFS2_I(dir)->ip_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\n\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\n\t\t\t\tbh = NULL;\n\t\t\t\terr = ocfs2_read_dir_block(dir, b++, &bh,\n\t\t\t\t\t\t\t   OCFS2_BH_READAHEAD);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\tif (ocfs2_read_dir_block(dir, block, &bh, 0)) {\n\t\t\t/* read error, skip block & hope for the best.\n\t\t\t * ocfs2_read_dir_block() has released the bh. */\n\t\t\tmlog(ML_ERROR, \"reading directory %llu, \"\n\t\t\t\t    \"offset %lu\\n\",\n\t\t\t\t    (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t    block);\n\t\t\tgoto next;\n\t\t}\n\t\ti = ocfs2_search_dirblock(bh, dir, name, namelen,\n\t\t\t\t\t  block << sb->s_blocksize_bits,\n\t\t\t\t\t  bh->b_data, sb->s_blocksize,\n\t\t\t\t\t  res_dir);\n\t\tif (i == 1) {\n\t\t\tOCFS2_I(dir)->ip_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = i_size_read(dir) >> sb->s_blocksize_bits;\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\n\ttrace_ocfs2_find_entry_el(ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)"
    ],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_find_entry_el",
          "args": [
            "ret"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh_use[ra_ptr]"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_dirblock",
          "args": [
            "bh",
            "dir",
            "name",
            "namelen",
            "block << sb->s_blocksize_bits",
            "bh->b_data",
            "sb->s_blocksize",
            "res_dir"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_dirblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "358-406",
          "snippet": "static inline int ocfs2_search_dirblock(struct buffer_head *bh,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tconst char *name, int namelen,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tchar *first_de,\n\t\t\t\t\tunsigned int bytes,\n\t\t\t\t\tstruct ocfs2_dir_entry **res_dir)\n{\n\tstruct ocfs2_dir_entry *de;\n\tchar *dlimit, *de_buf;\n\tint de_len;\n\tint ret = 0;\n\n\tde_buf = first_de;\n\tdlimit = de_buf + bytes;\n\n\twhile (de_buf < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tde = (struct ocfs2_dir_entry *) de_buf;\n\n\t\tif (de_buf + namelen <= dlimit &&\n\t\t    ocfs2_match(namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t*res_dir = de;\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* prevent looping on a bad block */\n\t\tde_len = le16_to_cpu(de->rec_len);\n\t\tif (de_len <= 0) {\n\t\t\tret = -1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tde_buf += de_len;\n\t\toffset += de_len;\n\t}\n\nbail:\n\ttrace_ocfs2_search_dirblock(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_search_dirblock(struct buffer_head *bh,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tconst char *name, int namelen,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tchar *first_de,\n\t\t\t\t\tunsigned int bytes,\n\t\t\t\t\tstruct ocfs2_dir_entry **res_dir)\n{\n\tstruct ocfs2_dir_entry *de;\n\tchar *dlimit, *de_buf;\n\tint de_len;\n\tint ret = 0;\n\n\tde_buf = first_de;\n\tdlimit = de_buf + bytes;\n\n\twhile (de_buf < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tde = (struct ocfs2_dir_entry *) de_buf;\n\n\t\tif (de_buf + namelen <= dlimit &&\n\t\t    ocfs2_match(namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t*res_dir = de;\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* prevent looping on a bad block */\n\t\tde_len = le16_to_cpu(de->rec_len);\n\t\tif (de_len <= 0) {\n\t\t\tret = -1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tde_buf += de_len;\n\t\toffset += de_len;\n\t}\n\nbail:\n\ttrace_ocfs2_search_dirblock(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"reading directory %llu, \"\n\t\t\t\t    \"offset %lu\\n\"",
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "block"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_dir_block",
          "args": [
            "dir",
            "block",
            "&bh",
            "0"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dir_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "522-552",
          "snippet": "static int ocfs2_read_dir_block(struct inode *inode, u64 v_block,\n\t\t\t\tstruct buffer_head **bh, int flags)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, flags,\n\t\t\t\t    ocfs2_validate_dir_block);\n\tif (rc) {\n\t\tmlog_errno(rc);\n\t\tgoto out;\n\t}\n\n\tif (!(flags & OCFS2_BH_READAHEAD) &&\n\t    ocfs2_supports_dir_trailer(inode)) {\n\t\trc = ocfs2_check_dir_trailer(inode, tmp);\n\t\tif (rc) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc ? -EIO : 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dir_block(struct inode *inode, u64 v_block,\n\t\t\t\tstruct buffer_head **bh, int flags)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, flags,\n\t\t\t\t    ocfs2_validate_dir_block);\n\tif (rc) {\n\t\tmlog_errno(rc);\n\t\tgoto out;\n\t}\n\n\tif (!(flags & OCFS2_BH_READAHEAD) &&\n\t    ocfs2_supports_dir_trailer(inode)) {\n\t\trc = ocfs2_check_dir_trailer(inode, tmp);\n\t\tif (rc) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc ? -EIO : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic struct buffer_head *ocfs2_find_entry_el(const char *name, int namelen,\n\t\t\t\t\t       struct inode *dir,\n\t\t\t\t\t       struct ocfs2_dir_entry **res_dir)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\tint nblocks, i, err;\n\n\tsb = dir->i_sb;\n\n\tnblocks = i_size_read(dir) >> sb->s_blocksize_bits;\n\tstart = OCFS2_I(dir)->ip_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\n\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\n\t\t\t\tbh = NULL;\n\t\t\t\terr = ocfs2_read_dir_block(dir, b++, &bh,\n\t\t\t\t\t\t\t   OCFS2_BH_READAHEAD);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\tif (ocfs2_read_dir_block(dir, block, &bh, 0)) {\n\t\t\t/* read error, skip block & hope for the best.\n\t\t\t * ocfs2_read_dir_block() has released the bh. */\n\t\t\tmlog(ML_ERROR, \"reading directory %llu, \"\n\t\t\t\t    \"offset %lu\\n\",\n\t\t\t\t    (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t    block);\n\t\t\tgoto next;\n\t\t}\n\t\ti = ocfs2_search_dirblock(bh, dir, name, namelen,\n\t\t\t\t\t  block << sb->s_blocksize_bits,\n\t\t\t\t\t  bh->b_data, sb->s_blocksize,\n\t\t\t\t\t  res_dir);\n\t\tif (i == 1) {\n\t\t\tOCFS2_I(dir)->ip_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = i_size_read(dir) >> sb->s_blocksize_bits;\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\n\ttrace_ocfs2_find_entry_el(ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_read_dx_leaves",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "679-690",
    "snippet": "static int ocfs2_read_dx_leaves(struct inode *dir, u64 start, int num,\n\t\t\t\tstruct buffer_head **dx_leaf_bhs)\n{\n\tint ret;\n\n\tret = ocfs2_read_blocks(INODE_CACHE(dir), start, num, dx_leaf_bhs, 0,\n\t\t\t\tocfs2_validate_dx_leaf);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks",
          "args": [
            "INODE_CACHE(dir)",
            "start",
            "num",
            "dx_leaf_bhs",
            "0",
            "ocfs2_validate_dx_leaf"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "176-366",
          "snippet": "int ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dx_leaves(struct inode *dir, u64 start, int num,\n\t\t\t\tstruct buffer_head **dx_leaf_bhs)\n{\n\tint ret;\n\n\tret = ocfs2_read_blocks(INODE_CACHE(dir), start, num, dx_leaf_bhs, 0,\n\t\t\t\tocfs2_validate_dx_leaf);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_read_dx_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "659-673",
    "snippet": "static int ocfs2_read_dx_leaf(struct inode *dir, u64 blkno,\n\t\t\t      struct buffer_head **dx_leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *dx_leaf_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_leaf);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_leaf_bh)\n\t\t*dx_leaf_bh = tmp;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_read_block",
          "args": [
            "INODE_CACHE(dir)",
            "blkno",
            "&tmp",
            "ocfs2_validate_dx_leaf"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dx_leaf(struct inode *dir, u64 blkno,\n\t\t\t      struct buffer_head **dx_leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *dx_leaf_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_leaf);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_leaf_bh)\n\t\t*dx_leaf_bh = tmp;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_validate_dx_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "634-657",
    "snippet": "static int ocfs2_validate_dx_leaf(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_leaf *dx_leaf = (struct ocfs2_dx_leaf *)bh->b_data;\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\tret = ocfs2_validate_meta_ecc(sb, bh->b_data, &dx_leaf->dl_check);\n\tif (ret) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Checksum failed for dir index leaf block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn ret;\n\t}\n\n\tif (!OCFS2_IS_VALID_DX_LEAF(dx_leaf)) {\n\t\tocfs2_error(sb, \"Dir Index Leaf has bad signature %.*s\",\n\t\t\t    7, dx_leaf->dl_signature);\n\t\treturn -EROFS;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Dir Index Leaf has bad signature %.*s\"",
            "7",
            "dx_leaf->dl_signature"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DX_LEAF",
          "args": [
            "dx_leaf"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Checksum failed for dir index leaf block %llu\\n\"",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_meta_ecc",
          "args": [
            "sb",
            "bh->b_data",
            "&dx_leaf->dl_check"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "613-624",
          "snippet": "int ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_validate_dx_leaf(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_leaf *dx_leaf = (struct ocfs2_dx_leaf *)bh->b_data;\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\tret = ocfs2_validate_meta_ecc(sb, bh->b_data, &dx_leaf->dl_check);\n\tif (ret) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Checksum failed for dir index leaf block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn ret;\n\t}\n\n\tif (!OCFS2_IS_VALID_DX_LEAF(dx_leaf)) {\n\t\tocfs2_error(sb, \"Dir Index Leaf has bad signature %.*s\",\n\t\t\t    7, dx_leaf->dl_signature);\n\t\treturn -EROFS;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_read_dx_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "617-632",
    "snippet": "static int ocfs2_read_dx_root(struct inode *dir, struct ocfs2_dinode *di,\n\t\t\t      struct buffer_head **dx_root_bh)\n{\n\tint ret;\n\tu64 blkno = le64_to_cpu(di->i_dx_root);\n\tstruct buffer_head *tmp = *dx_root_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_root);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_root_bh)\n\t\t*dx_root_bh = tmp;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_read_block",
          "args": [
            "INODE_CACHE(dir)",
            "blkno",
            "&tmp",
            "ocfs2_validate_dx_root"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_dx_root"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dx_root(struct inode *dir, struct ocfs2_dinode *di,\n\t\t\t      struct buffer_head **dx_root_bh)\n{\n\tint ret;\n\tu64 blkno = le64_to_cpu(di->i_dx_root);\n\tstruct buffer_head *tmp = *dx_root_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_root);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!ret && !*dx_root_bh)\n\t\t*dx_root_bh = tmp;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_validate_dx_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "588-615",
    "snippet": "static int ocfs2_validate_dx_root(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\tdx_root = (struct ocfs2_dx_root_block *) bh->b_data;\n\n\tret = ocfs2_validate_meta_ecc(sb, bh->b_data, &dx_root->dr_check);\n\tif (ret) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Checksum failed for dir index root block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn ret;\n\t}\n\n\tif (!OCFS2_IS_VALID_DX_ROOT(dx_root)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Dir Index Root # %llu has bad signature %.*s\",\n\t\t\t    (unsigned long long)le64_to_cpu(dx_root->dr_blkno),\n\t\t\t    7, dx_root->dr_signature);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Dir Index Root # %llu has bad signature %.*s\"",
            "(unsigned long long)le64_to_cpu(dx_root->dr_blkno)",
            "7",
            "dx_root->dr_signature"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dx_root->dr_blkno"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DX_ROOT",
          "args": [
            "dx_root"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Checksum failed for dir index root block %llu\\n\"",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_meta_ecc",
          "args": [
            "sb",
            "bh->b_data",
            "&dx_root->dr_check"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "613-624",
          "snippet": "int ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_validate_dx_root(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\tdx_root = (struct ocfs2_dx_root_block *) bh->b_data;\n\n\tret = ocfs2_validate_meta_ecc(sb, bh->b_data, &dx_root->dr_check);\n\tif (ret) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Checksum failed for dir index root block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn ret;\n\t}\n\n\tif (!OCFS2_IS_VALID_DX_ROOT(dx_root)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Dir Index Root # %llu has bad signature %.*s\",\n\t\t\t    (unsigned long long)le64_to_cpu(dx_root->dr_blkno),\n\t\t\t    7, dx_root->dr_signature);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_read_dir_block_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "559-586",
    "snippet": "static int ocfs2_read_dir_block_direct(struct inode *dir, u64 phys,\n\t\t\t\t       struct buffer_head **bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), phys, &tmp,\n\t\t\t       ocfs2_validate_dir_block);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tret = ocfs2_check_dir_trailer(dir, tmp);\n\t\tif (ret) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!ret && !*bh)\n\t\t*bh = tmp;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "tmp"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_trailer",
          "args": [
            "dir",
            "tmp"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "476-514",
          "snippet": "static int ocfs2_check_dir_trailer(struct inode *dir, struct buffer_head *bh)\n{\n\tint rc = 0;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, dir->i_sb);\n\tif (!OCFS2_IS_VALID_DIR_TRAILER(trailer)) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Invalid dirblock #%llu: \"\n\t\t\t    \"signature = %.*s\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    trailer->db_signature);\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_blkno) != bh->b_blocknr) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Directory block #%llu has an invalid \"\n\t\t\t    \"db_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_parent_dinode) !=\n\t    OCFS2_I(dir)->ip_blkno) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Directory block #%llu on dinode \"\n\t\t\t    \"#%llu has an invalid parent_dinode \"\n\t\t\t    \"of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t    (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_check_dir_trailer(struct inode *dir, struct buffer_head *bh)\n{\n\tint rc = 0;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, dir->i_sb);\n\tif (!OCFS2_IS_VALID_DIR_TRAILER(trailer)) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Invalid dirblock #%llu: \"\n\t\t\t    \"signature = %.*s\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    trailer->db_signature);\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_blkno) != bh->b_blocknr) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Directory block #%llu has an invalid \"\n\t\t\t    \"db_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_parent_dinode) !=\n\t    OCFS2_I(dir)->ip_blkno) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Directory block #%llu on dinode \"\n\t\t\t    \"#%llu has an invalid parent_dinode \"\n\t\t\t    \"of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t    (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_dir_trailer",
          "args": [
            "dir"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_dir_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "88-96",
          "snippet": "static int ocfs2_supports_dir_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\treturn ocfs2_meta_ecc(osb) || ocfs2_dir_indexed(dir);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_supports_dir_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\treturn ocfs2_meta_ecc(osb) || ocfs2_dir_indexed(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_block",
          "args": [
            "INODE_CACHE(dir)",
            "phys",
            "&tmp",
            "ocfs2_validate_dir_block"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dir_block_direct(struct inode *dir, u64 phys,\n\t\t\t\t       struct buffer_head **bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), phys, &tmp,\n\t\t\t       ocfs2_validate_dir_block);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tret = ocfs2_check_dir_trailer(dir, tmp);\n\t\tif (ret) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!ret && !*bh)\n\t\t*bh = tmp;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_read_dir_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "522-552",
    "snippet": "static int ocfs2_read_dir_block(struct inode *inode, u64 v_block,\n\t\t\t\tstruct buffer_head **bh, int flags)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, flags,\n\t\t\t\t    ocfs2_validate_dir_block);\n\tif (rc) {\n\t\tmlog_errno(rc);\n\t\tgoto out;\n\t}\n\n\tif (!(flags & OCFS2_BH_READAHEAD) &&\n\t    ocfs2_supports_dir_trailer(inode)) {\n\t\trc = ocfs2_check_dir_trailer(inode, tmp);\n\t\tif (rc) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc ? -EIO : 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "tmp"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_trailer",
          "args": [
            "inode",
            "tmp"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "476-514",
          "snippet": "static int ocfs2_check_dir_trailer(struct inode *dir, struct buffer_head *bh)\n{\n\tint rc = 0;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, dir->i_sb);\n\tif (!OCFS2_IS_VALID_DIR_TRAILER(trailer)) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Invalid dirblock #%llu: \"\n\t\t\t    \"signature = %.*s\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    trailer->db_signature);\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_blkno) != bh->b_blocknr) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Directory block #%llu has an invalid \"\n\t\t\t    \"db_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_parent_dinode) !=\n\t    OCFS2_I(dir)->ip_blkno) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Directory block #%llu on dinode \"\n\t\t\t    \"#%llu has an invalid parent_dinode \"\n\t\t\t    \"of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t    (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_check_dir_trailer(struct inode *dir, struct buffer_head *bh)\n{\n\tint rc = 0;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, dir->i_sb);\n\tif (!OCFS2_IS_VALID_DIR_TRAILER(trailer)) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Invalid dirblock #%llu: \"\n\t\t\t    \"signature = %.*s\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    trailer->db_signature);\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_blkno) != bh->b_blocknr) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Directory block #%llu has an invalid \"\n\t\t\t    \"db_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_parent_dinode) !=\n\t    OCFS2_I(dir)->ip_blkno) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Directory block #%llu on dinode \"\n\t\t\t    \"#%llu has an invalid parent_dinode \"\n\t\t\t    \"of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t    (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_dir_trailer",
          "args": [
            "inode"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_dir_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "88-96",
          "snippet": "static int ocfs2_supports_dir_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\treturn ocfs2_meta_ecc(osb) || ocfs2_dir_indexed(dir);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_supports_dir_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\treturn ocfs2_meta_ecc(osb) || ocfs2_dir_indexed(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_virt_blocks",
          "args": [
            "inode",
            "v_block",
            "1",
            "&tmp",
            "flags",
            "ocfs2_validate_dir_block"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_virt_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "927-992",
          "snippet": "int ocfs2_read_virt_blocks(struct inode *inode, u64 v_block, int nr,\n\t\t\t   struct buffer_head *bhs[], int flags,\n\t\t\t   int (*validate)(struct super_block *sb,\n\t\t\t\t\t   struct buffer_head *bh))\n{\n\tint rc = 0;\n\tu64 p_block, p_count;\n\tint i, count, done = 0;\n\n\ttrace_ocfs2_read_virt_blocks(\n\t     inode, (unsigned long long)v_block, nr, bhs, flags,\n\t     validate);\n\n\tif (((v_block + nr - 1) << inode->i_sb->s_blocksize_bits) >=\n\t    i_size_read(inode)) {\n\t\tBUG_ON(!(flags & OCFS2_BH_READAHEAD));\n\t\tgoto out;\n\t}\n\n\twhile (done < nr) {\n\t\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\trc = ocfs2_extent_map_get_blocks(inode, v_block + done,\n\t\t\t\t\t\t &p_block, &p_count, NULL);\n\t\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!p_block) {\n\t\t\trc = -EIO;\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode #%llu contains a hole at offset %llu\\n\",\n\t\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t     (unsigned long long)(v_block + done) <<\n\t\t\t     inode->i_sb->s_blocksize_bits);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = nr - done;\n\t\tif (p_count < count)\n\t\t\tcount = p_count;\n\n\t\t/*\n\t\t * If the caller passed us bhs, they should have come\n\t\t * from a previous readahead call to this function.  Thus,\n\t\t * they should have the right b_blocknr.\n\t\t */\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (!bhs[done + i])\n\t\t\t\tcontinue;\n\t\t\tBUG_ON(bhs[done + i]->b_blocknr != (p_block + i));\n\t\t}\n\n\t\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, count,\n\t\t\t\t       bhs + done, flags, validate);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t\tdone += count;\n\t}\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_read_virt_blocks(struct inode *inode, u64 v_block, int nr,\n\t\t\t   struct buffer_head *bhs[], int flags,\n\t\t\t   int (*validate)(struct super_block *sb,\n\t\t\t\t\t   struct buffer_head *bh))\n{\n\tint rc = 0;\n\tu64 p_block, p_count;\n\tint i, count, done = 0;\n\n\ttrace_ocfs2_read_virt_blocks(\n\t     inode, (unsigned long long)v_block, nr, bhs, flags,\n\t     validate);\n\n\tif (((v_block + nr - 1) << inode->i_sb->s_blocksize_bits) >=\n\t    i_size_read(inode)) {\n\t\tBUG_ON(!(flags & OCFS2_BH_READAHEAD));\n\t\tgoto out;\n\t}\n\n\twhile (done < nr) {\n\t\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\trc = ocfs2_extent_map_get_blocks(inode, v_block + done,\n\t\t\t\t\t\t &p_block, &p_count, NULL);\n\t\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!p_block) {\n\t\t\trc = -EIO;\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode #%llu contains a hole at offset %llu\\n\",\n\t\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t     (unsigned long long)(v_block + done) <<\n\t\t\t     inode->i_sb->s_blocksize_bits);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = nr - done;\n\t\tif (p_count < count)\n\t\t\tcount = p_count;\n\n\t\t/*\n\t\t * If the caller passed us bhs, they should have come\n\t\t * from a previous readahead call to this function.  Thus,\n\t\t * they should have the right b_blocknr.\n\t\t */\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (!bhs[done + i])\n\t\t\t\tcontinue;\n\t\t\tBUG_ON(bhs[done + i]->b_blocknr != (p_block + i));\n\t\t}\n\n\t\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, count,\n\t\t\t\t       bhs + done, flags, validate);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t\tdone += count;\n\t}\n\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dir_block(struct inode *inode, u64 v_block,\n\t\t\t\tstruct buffer_head **bh, int flags)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, flags,\n\t\t\t\t    ocfs2_validate_dir_block);\n\tif (rc) {\n\t\tmlog_errno(rc);\n\t\tgoto out;\n\t}\n\n\tif (!(flags & OCFS2_BH_READAHEAD) &&\n\t    ocfs2_supports_dir_trailer(inode)) {\n\t\trc = ocfs2_check_dir_trailer(inode, tmp);\n\t\tif (rc) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc ? -EIO : 0;\n}"
  },
  {
    "function_name": "ocfs2_check_dir_trailer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "476-514",
    "snippet": "static int ocfs2_check_dir_trailer(struct inode *dir, struct buffer_head *bh)\n{\n\tint rc = 0;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, dir->i_sb);\n\tif (!OCFS2_IS_VALID_DIR_TRAILER(trailer)) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Invalid dirblock #%llu: \"\n\t\t\t    \"signature = %.*s\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    trailer->db_signature);\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_blkno) != bh->b_blocknr) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Directory block #%llu has an invalid \"\n\t\t\t    \"db_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_parent_dinode) !=\n\t    OCFS2_I(dir)->ip_blkno) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Directory block #%llu on dinode \"\n\t\t\t    \"#%llu has an invalid parent_dinode \"\n\t\t\t    \"of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t    (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "dir->i_sb",
            "\"Directory block #%llu on dinode \"\n\t\t\t    \"#%llu has an invalid parent_dinode \"\n\t\t\t    \"of %llu\"",
            "(unsigned long long)bh->b_blocknr",
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "(unsigned long long)le64_to_cpu(trailer->db_blkno)"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "trailer->db_blkno"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DIR_TRAILER",
          "args": [
            "trailer"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trailer_from_bh",
          "args": [
            "bh",
            "dir->i_sb"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_check_dir_trailer(struct inode *dir, struct buffer_head *bh)\n{\n\tint rc = 0;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, dir->i_sb);\n\tif (!OCFS2_IS_VALID_DIR_TRAILER(trailer)) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Invalid dirblock #%llu: \"\n\t\t\t    \"signature = %.*s\\n\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    trailer->db_signature);\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_blkno) != bh->b_blocknr) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Directory block #%llu has an invalid \"\n\t\t\t    \"db_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_parent_dinode) !=\n\t    OCFS2_I(dir)->ip_blkno) {\n\t\trc = -EINVAL;\n\t\tocfs2_error(dir->i_sb,\n\t\t\t    \"Directory block #%llu on dinode \"\n\t\t\t    \"#%llu has an invalid parent_dinode \"\n\t\t\t    \"of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t    (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_validate_dir_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "437-468",
    "snippet": "static int ocfs2_validate_dir_block(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_trailer_from_bh(bh, sb);\n\n\n\t/*\n\t * We don't validate dirents here, that's handled\n\t * in-place when the code walks them.\n\t */\n\ttrace_ocfs2_validate_dir_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t *\n\t * Note that we are safe to call this even if the directory\n\t * doesn't have a trailer.  Filesystems without metaecc will do\n\t * nothing, and filesystems with it will have one.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &trailer->db_check);\n\tif (rc)\n\t\tmlog(ML_ERROR, \"Checksum failed for dinode %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Checksum failed for dinode %llu\\n\"",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_meta_ecc",
          "args": [
            "sb",
            "bh->b_data",
            "&trailer->db_check"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "613-624",
          "snippet": "int ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_validate_dir_block",
          "args": [
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trailer_from_bh",
          "args": [
            "bh",
            "sb"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_validate_dir_block(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_trailer_from_bh(bh, sb);\n\n\n\t/*\n\t * We don't validate dirents here, that's handled\n\t * in-place when the code walks them.\n\t */\n\ttrace_ocfs2_validate_dir_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t *\n\t * Note that we are safe to call this even if the directory\n\t * doesn't have a trailer.  Filesystems without metaecc will do\n\t * nothing, and filesystems with it will have one.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &trailer->db_check);\n\tif (rc)\n\t\tmlog(ML_ERROR, \"Checksum failed for dinode %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_find_entry_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "408-435",
    "snippet": "static struct buffer_head *ocfs2_find_entry_id(const char *name,\n\t\t\t\t\t       int namelen,\n\t\t\t\t\t       struct inode *dir,\n\t\t\t\t\t       struct ocfs2_dir_entry **res_dir)\n{\n\tint ret, found;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\tfound = ocfs2_search_dirblock(di_bh, dir, name, namelen, 0,\n\t\t\t\t      data->id_data, i_size_read(dir), res_dir);\n\tif (found == 1)\n\t\treturn di_bh;\n\n\tbrelse(di_bh);\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_dirblock",
          "args": [
            "di_bh",
            "dir",
            "name",
            "namelen",
            "0",
            "data->id_data",
            "i_size_read(dir)",
            "res_dir"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_dirblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "358-406",
          "snippet": "static inline int ocfs2_search_dirblock(struct buffer_head *bh,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tconst char *name, int namelen,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tchar *first_de,\n\t\t\t\t\tunsigned int bytes,\n\t\t\t\t\tstruct ocfs2_dir_entry **res_dir)\n{\n\tstruct ocfs2_dir_entry *de;\n\tchar *dlimit, *de_buf;\n\tint de_len;\n\tint ret = 0;\n\n\tde_buf = first_de;\n\tdlimit = de_buf + bytes;\n\n\twhile (de_buf < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tde = (struct ocfs2_dir_entry *) de_buf;\n\n\t\tif (de_buf + namelen <= dlimit &&\n\t\t    ocfs2_match(namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t*res_dir = de;\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* prevent looping on a bad block */\n\t\tde_len = le16_to_cpu(de->rec_len);\n\t\tif (de_len <= 0) {\n\t\t\tret = -1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tde_buf += de_len;\n\t\toffset += de_len;\n\t}\n\nbail:\n\ttrace_ocfs2_search_dirblock(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_search_dirblock(struct buffer_head *bh,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tconst char *name, int namelen,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tchar *first_de,\n\t\t\t\t\tunsigned int bytes,\n\t\t\t\t\tstruct ocfs2_dir_entry **res_dir)\n{\n\tstruct ocfs2_dir_entry *de;\n\tchar *dlimit, *de_buf;\n\tint de_len;\n\tint ret = 0;\n\n\tde_buf = first_de;\n\tdlimit = de_buf + bytes;\n\n\twhile (de_buf < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tde = (struct ocfs2_dir_entry *) de_buf;\n\n\t\tif (de_buf + namelen <= dlimit &&\n\t\t    ocfs2_match(namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t*res_dir = de;\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* prevent looping on a bad block */\n\t\tde_len = le16_to_cpu(de->rec_len);\n\t\tif (de_len <= 0) {\n\t\t\tret = -1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tde_buf += de_len;\n\t\toffset += de_len;\n\t}\n\nbail:\n\ttrace_ocfs2_search_dirblock(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "dir",
            "&di_bh"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic struct buffer_head *ocfs2_find_entry_id(const char *name,\n\t\t\t\t\t       int namelen,\n\t\t\t\t\t       struct inode *dir,\n\t\t\t\t\t       struct ocfs2_dir_entry **res_dir)\n{\n\tint ret, found;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\tfound = ocfs2_search_dirblock(di_bh, dir, name, namelen, 0,\n\t\t\t\t      data->id_data, i_size_read(dir), res_dir);\n\tif (found == 1)\n\t\treturn di_bh;\n\n\tbrelse(di_bh);\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "ocfs2_search_dirblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "358-406",
    "snippet": "static inline int ocfs2_search_dirblock(struct buffer_head *bh,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tconst char *name, int namelen,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tchar *first_de,\n\t\t\t\t\tunsigned int bytes,\n\t\t\t\t\tstruct ocfs2_dir_entry **res_dir)\n{\n\tstruct ocfs2_dir_entry *de;\n\tchar *dlimit, *de_buf;\n\tint de_len;\n\tint ret = 0;\n\n\tde_buf = first_de;\n\tdlimit = de_buf + bytes;\n\n\twhile (de_buf < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tde = (struct ocfs2_dir_entry *) de_buf;\n\n\t\tif (de_buf + namelen <= dlimit &&\n\t\t    ocfs2_match(namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t*res_dir = de;\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* prevent looping on a bad block */\n\t\tde_len = le16_to_cpu(de->rec_len);\n\t\tif (de_len <= 0) {\n\t\t\tret = -1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tde_buf += de_len;\n\t\toffset += de_len;\n\t}\n\nbail:\n\ttrace_ocfs2_search_dirblock(ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_search_dirblock",
          "args": [
            "ret"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_dir_entry",
          "args": [
            "dir",
            "de",
            "bh",
            "offset"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "316-342",
          "snippet": "static int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_match",
          "args": [
            "namelen",
            "name",
            "de"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "344-353",
          "snippet": "static inline int ocfs2_match(int len,\n\t\t\t      const char * const name,\n\t\t\t      struct ocfs2_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_match(int len,\n\t\t\t      const char * const name,\n\t\t\t      struct ocfs2_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_search_dirblock(struct buffer_head *bh,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tconst char *name, int namelen,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tchar *first_de,\n\t\t\t\t\tunsigned int bytes,\n\t\t\t\t\tstruct ocfs2_dir_entry **res_dir)\n{\n\tstruct ocfs2_dir_entry *de;\n\tchar *dlimit, *de_buf;\n\tint de_len;\n\tint ret = 0;\n\n\tde_buf = first_de;\n\tdlimit = de_buf + bytes;\n\n\twhile (de_buf < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tde = (struct ocfs2_dir_entry *) de_buf;\n\n\t\tif (de_buf + namelen <= dlimit &&\n\t\t    ocfs2_match(namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t*res_dir = de;\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* prevent looping on a bad block */\n\t\tde_len = le16_to_cpu(de->rec_len);\n\t\tif (de_len <= 0) {\n\t\t\tret = -1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tde_buf += de_len;\n\t\toffset += de_len;\n\t}\n\nbail:\n\ttrace_ocfs2_search_dirblock(ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "344-353",
    "snippet": "static inline int ocfs2_match(int len,\n\t\t\t      const char * const name,\n\t\t\t      struct ocfs2_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "de->name",
            "len"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic inline int ocfs2_match(int len,\n\t\t\t      const char * const name,\n\t\t\t      struct ocfs2_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
  },
  {
    "function_name": "ocfs2_check_dir_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "316-342",
    "snippet": "static int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\"",
            "(unsigned long long)OCFS2_I(dir)->ip_blkno",
            "error_msg",
            "offset",
            "(unsigned long long)le64_to_cpu(de->inode)",
            "rlen",
            "de->name_len"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error_msg != NULL"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rlen < OCFS2_DIR_REC_LEN(de->name_len)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rlen % 4 != 0"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rlen < OCFS2_DIR_REC_LEN(1)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_name_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "270-310",
    "snippet": "static void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t/*\n\t * XXX: Is this really necessary, if the index is never looked\n\t * at by readdir? Is a hash value of '0' a bad idea?\n\t */\n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t/*\n\t * This makes it very easy to debug indexing problems. We\n\t * should never allow this to be selected without hand editing\n\t * this file though.\n\t */\n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEA_transform",
          "args": [
            "buf",
            "in"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "TEA_transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "226-241",
          "snippet": "static void TEA_transform(__u32 buf[4], __u32 const in[])\n{\n\t__u32\tsum = 0;\n\t__u32\tb0 = buf[0], b1 = buf[1];\n\t__u32\ta = in[0], b = in[1], c = in[2], d = in[3];\n\tint\tn = 16;\n\n\tdo {\n\t\tsum += DELTA;\n\t\tb0 += ((b1 << 4)+a) ^ (b1+sum) ^ ((b1 >> 5)+b);\n\t\tb1 += ((b0 << 4)+c) ^ (b0+sum) ^ ((b0 >> 5)+d);\n\t} while (--n);\n\n\tbuf[0] += b0;\n\tbuf[1] += b1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define DELTA 0x9E3779B9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define DELTA 0x9E3779B9\n\nstatic void TEA_transform(__u32 buf[4], __u32 const in[])\n{\n\t__u32\tsum = 0;\n\t__u32\tb0 = buf[0], b1 = buf[1];\n\t__u32\ta = in[0], b = in[1], c = in[2], d = in[3];\n\tint\tn = 16;\n\n\tdo {\n\t\tsum += DELTA;\n\t\tb0 += ((b1 << 4)+a) ^ (b1+sum) ^ ((b1 >> 5)+b);\n\t\tb1 += ((b0 << 4)+c) ^ (b0+sum) ^ ((b0 >> 5)+d);\n\t} while (--n);\n\n\tbuf[0] += b0;\n\tbuf[1] += b1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str2hashbuf",
          "args": [
            "p",
            "len",
            "in",
            "4"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "str2hashbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "243-268",
          "snippet": "static void str2hashbuf(const char *msg, int len, __u32 *buf, int num)\n{\n\t__u32\tpad, val;\n\tint\ti;\n\n\tpad = (__u32)len | ((__u32)len << 8);\n\tpad |= pad << 16;\n\n\tval = pad;\n\tif (len > num*4)\n\t\tlen = num * 4;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((i % 4) == 0)\n\t\t\tval = pad;\n\t\tval = msg[i] + (val << 8);\n\t\tif ((i % 4) == 3) {\n\t\t\t*buf++ = val;\n\t\t\tval = pad;\n\t\t\tnum--;\n\t\t}\n\t}\n\tif (--num >= 0)\n\t\t*buf++ = val;\n\twhile (--num >= 0)\n\t\t*buf++ = pad;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void str2hashbuf(const char *msg, int len, __u32 *buf, int num)\n{\n\t__u32\tpad, val;\n\tint\ti;\n\n\tpad = (__u32)len | ((__u32)len << 8);\n\tpad |= pad << 16;\n\n\tval = pad;\n\tif (len > num*4)\n\t\tlen = num * 4;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((i % 4) == 0)\n\t\t\tval = pad;\n\t\tval = msg[i] + (val << 8);\n\t\tif ((i % 4) == 3) {\n\t\t\t*buf++ = val;\n\t\t\tval = pad;\n\t\t\tnum--;\n\t\t}\n\t}\n\tif (--num >= 0)\n\t\t*buf++ = val;\n\twhile (--num >= 0)\n\t\t*buf++ = pad;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "osb->osb_dx_seed",
            "sizeof(buf)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"..\"",
            "name",
            "2"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\".\"",
            "name",
            "1"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t/*\n\t * XXX: Is this really necessary, if the index is never looked\n\t * at by readdir? Is a hash value of '0' a bad idea?\n\t */\n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t/*\n\t * This makes it very easy to debug indexing problems. We\n\t * should never allow this to be selected without hand editing\n\t * this file though.\n\t */\n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}"
  },
  {
    "function_name": "str2hashbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "243-268",
    "snippet": "static void str2hashbuf(const char *msg, int len, __u32 *buf, int num)\n{\n\t__u32\tpad, val;\n\tint\ti;\n\n\tpad = (__u32)len | ((__u32)len << 8);\n\tpad |= pad << 16;\n\n\tval = pad;\n\tif (len > num*4)\n\t\tlen = num * 4;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((i % 4) == 0)\n\t\t\tval = pad;\n\t\tval = msg[i] + (val << 8);\n\t\tif ((i % 4) == 3) {\n\t\t\t*buf++ = val;\n\t\t\tval = pad;\n\t\t\tnum--;\n\t\t}\n\t}\n\tif (--num >= 0)\n\t\t*buf++ = val;\n\twhile (--num >= 0)\n\t\t*buf++ = pad;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void str2hashbuf(const char *msg, int len, __u32 *buf, int num)\n{\n\t__u32\tpad, val;\n\tint\ti;\n\n\tpad = (__u32)len | ((__u32)len << 8);\n\tpad |= pad << 16;\n\n\tval = pad;\n\tif (len > num*4)\n\t\tlen = num * 4;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((i % 4) == 0)\n\t\t\tval = pad;\n\t\tval = msg[i] + (val << 8);\n\t\tif ((i % 4) == 3) {\n\t\t\t*buf++ = val;\n\t\t\tval = pad;\n\t\t\tnum--;\n\t\t}\n\t}\n\tif (--num >= 0)\n\t\t*buf++ = val;\n\twhile (--num >= 0)\n\t\t*buf++ = pad;\n}"
  },
  {
    "function_name": "TEA_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "226-241",
    "snippet": "static void TEA_transform(__u32 buf[4], __u32 const in[])\n{\n\t__u32\tsum = 0;\n\t__u32\tb0 = buf[0], b1 = buf[1];\n\t__u32\ta = in[0], b = in[1], c = in[2], d = in[3];\n\tint\tn = 16;\n\n\tdo {\n\t\tsum += DELTA;\n\t\tb0 += ((b1 << 4)+a) ^ (b1+sum) ^ ((b1 >> 5)+b);\n\t\tb1 += ((b0 << 4)+c) ^ (b0+sum) ^ ((b0 >> 5)+d);\n\t} while (--n);\n\n\tbuf[0] += b0;\n\tbuf[1] += b1;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define DELTA 0x9E3779B9"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define DELTA 0x9E3779B9\n\nstatic void TEA_transform(__u32 buf[4], __u32 const in[])\n{\n\t__u32\tsum = 0;\n\t__u32\tb0 = buf[0], b1 = buf[1];\n\t__u32\ta = in[0], b = in[1], c = in[2], d = in[3];\n\tint\tn = 16;\n\n\tdo {\n\t\tsum += DELTA;\n\t\tb0 += ((b1 << 4)+a) ^ (b1+sum) ^ ((b1 >> 5)+b);\n\t\tb1 += ((b0 << 4)+c) ^ (b0+sum) ^ ((b0 >> 5)+d);\n\t} while (--n);\n\n\tbuf[0] += b0;\n\tbuf[1] += b1;\n}"
  },
  {
    "function_name": "ocfs2_dx_root_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "216-219",
    "snippet": "static inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}"
  },
  {
    "function_name": "ocfs2_dir_indexed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "209-214",
    "snippet": "static int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_free_dir_lookup_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "201-207",
    "snippet": "void ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "res->dl_prev_leaf_bh"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}"
  },
  {
    "function_name": "ocfs2_free_list_at_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "196-199",
    "snippet": "static int ocfs2_free_list_at_root(struct ocfs2_dir_lookup_result *res)\n{\n\treturn res->dl_prev_leaf_bh == NULL;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_free_list_at_root(struct ocfs2_dir_lookup_result *res)\n{\n\treturn res->dl_prev_leaf_bh == NULL;\n}"
  },
  {
    "function_name": "ocfs2_dx_dir_link_trailer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "170-194",
    "snippet": "static int ocfs2_dx_dir_link_trailer(struct inode *dir, handle_t *handle,\n\t\t\t\t     struct buffer_head *dx_root_bh,\n\t\t\t\t     struct buffer_head *dirdata_bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\ttrailer = ocfs2_trailer_from_bh(dirdata_bh, dir->i_sb);\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\ttrailer->db_free_next = dx_root->dr_free_blk;\n\tdx_root->dr_free_blk = cpu_to_le64(dirdata_bh->b_blocknr);\n\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "dx_root_bh"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "dirdata_bh->b_blocknr"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trailer_from_bh",
          "args": [
            "dirdata_bh",
            "dir->i_sb"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dr",
          "args": [
            "handle",
            "INODE_CACHE(dir)",
            "dx_root_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "753-757",
          "snippet": "int ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};\n\nint ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "dir"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dx_dir_link_trailer(struct inode *dir, handle_t *handle,\n\t\t\t\t     struct buffer_head *dx_root_bh,\n\t\t\t\t     struct buffer_head *dirdata_bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\ttrailer = ocfs2_trailer_from_bh(dirdata_bh, dir->i_sb);\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\ttrailer->db_free_next = dx_root->dr_free_blk;\n\tdx_root->dr_free_blk = cpu_to_le64(dirdata_bh->b_blocknr);\n\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_init_dir_trailer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "152-164",
    "snippet": "static void ocfs2_init_dir_trailer(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh, u16 rec_len)\n{\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, inode->i_sb);\n\tstrcpy(trailer->db_signature, OCFS2_DIR_TRAILER_SIGNATURE);\n\ttrailer->db_compat_rec_len =\n\t\t\tcpu_to_le16(sizeof(struct ocfs2_dir_block_trailer));\n\ttrailer->db_parent_dinode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\ttrailer->db_blkno = cpu_to_le64(bh->b_blocknr);\n\ttrailer->db_free_rec_len = cpu_to_le16(rec_len);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "rec_len"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bh->b_blocknr"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "OCFS2_I(inode)->ip_blkno"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sizeof(struct ocfs2_dir_block_trailer)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "trailer->db_signature",
            "OCFS2_DIR_TRAILER_SIGNATURE"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trailer_from_bh",
          "args": [
            "bh",
            "inode->i_sb"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic void ocfs2_init_dir_trailer(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh, u16 rec_len)\n{\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, inode->i_sb);\n\tstrcpy(trailer->db_signature, OCFS2_DIR_TRAILER_SIGNATURE);\n\ttrailer->db_compat_rec_len =\n\t\t\tcpu_to_le16(sizeof(struct ocfs2_dir_block_trailer));\n\ttrailer->db_parent_dinode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\ttrailer->db_blkno = cpu_to_le64(bh->b_blocknr);\n\ttrailer->db_free_rec_len = cpu_to_le16(rec_len);\n}"
  },
  {
    "function_name": "ocfs2_skip_dir_trailer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "136-150",
    "snippet": "static int ocfs2_skip_dir_trailer(struct inode *dir,\n\t\t\t\t  struct ocfs2_dir_entry *de,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  unsigned long blklen)\n{\n\tunsigned long toff = blklen - sizeof(struct ocfs2_dir_block_trailer);\n\n\tif (!ocfs2_supports_dir_trailer(dir))\n\t\treturn 0;\n\n\tif (offset != toff)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_supports_dir_trailer",
          "args": [
            "dir"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_dir_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "88-96",
          "snippet": "static int ocfs2_supports_dir_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\treturn ocfs2_meta_ecc(osb) || ocfs2_dir_indexed(dir);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_supports_dir_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\treturn ocfs2_meta_ecc(osb) || ocfs2_dir_indexed(dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_skip_dir_trailer(struct inode *dir,\n\t\t\t\t  struct ocfs2_dir_entry *de,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  unsigned long blklen)\n{\n\tunsigned long toff = blklen - sizeof(struct ocfs2_dir_block_trailer);\n\n\tif (!ocfs2_supports_dir_trailer(dir))\n\t\treturn 0;\n\n\tif (offset != toff)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ocfs2_dir_trailer_from_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "123-130",
    "snippet": "struct ocfs2_dir_block_trailer *ocfs2_dir_trailer_from_size(int blocksize,\n\t\t\t\t\t\t\t    void *data)\n{\n\tchar *p = data;\n\n\tp += blocksize - sizeof(struct ocfs2_dir_block_trailer);\n\treturn (struct ocfs2_dir_block_trailer *)p;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_dir_block_trailer *ocfs2_dir_trailer_from_size(int blocksize,\n\t\t\t\t\t\t\t    void *data)\n{\n\tchar *p = data;\n\n\tp += blocksize - sizeof(struct ocfs2_dir_block_trailer);\n\treturn (struct ocfs2_dir_block_trailer *)p;\n}"
  },
  {
    "function_name": "ocfs2_dir_trailer_blk_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "114-117",
    "snippet": "static inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}"
  },
  {
    "function_name": "ocfs2_new_dir_wants_trailer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "106-112",
    "snippet": "static int ocfs2_new_dir_wants_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\treturn ocfs2_meta_ecc(osb) ||\n\t\tocfs2_supports_indexed_dirs(osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_supports_indexed_dirs",
          "args": [
            "osb"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_indexed_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "532-537",
          "snippet": "static inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_meta_ecc",
          "args": [
            "osb"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "525-530",
          "snippet": "static inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_new_dir_wants_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\treturn ocfs2_meta_ecc(osb) ||\n\t\tocfs2_supports_indexed_dirs(osb);\n}"
  },
  {
    "function_name": "ocfs2_supports_dir_trailer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
    "lines": "88-96",
    "snippet": "static int ocfs2_supports_dir_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\treturn ocfs2_meta_ecc(osb) || ocfs2_dir_indexed(dir);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"namei.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_dir_indexed(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_dir_indexed",
          "args": [
            "dir"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_indexed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "209-214",
          "snippet": "static int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_meta_ecc",
          "args": [
            "osb"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "525-530",
          "snippet": "static inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_supports_dir_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\treturn ocfs2_meta_ecc(osb) || ocfs2_dir_indexed(dir);\n}"
  }
]