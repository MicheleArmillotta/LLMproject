[
  {
    "function_name": "dlm_copy_master_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
    "lines": "236-307",
    "snippet": "void dlm_copy_master_names(struct dlm_ls *ls, char *inbuf, int inlen,\n \t\t\t   char *outbuf, int outlen, int nodeid)\n{\n\tstruct list_head *list;\n\tstruct dlm_rsb *r;\n\tint offset = 0, dir_nodeid;\n\t__be16 be_namelen;\n\n\tdown_read(&ls->ls_root_sem);\n\n\tif (inlen > 1) {\n\t\tr = find_rsb_root(ls, inbuf, inlen);\n\t\tif (!r) {\n\t\t\tinbuf[inlen - 1] = '\\0';\n\t\t\tlog_error(ls, \"copy_master_names from %d start %d %s\",\n\t\t\t\t  nodeid, inlen, inbuf);\n\t\t\tgoto out;\n\t\t}\n\t\tlist = r->res_root_list.next;\n\t} else {\n\t\tlist = ls->ls_root_list.next;\n\t}\n\n\tfor (offset = 0; list != &ls->ls_root_list; list = list->next) {\n\t\tr = list_entry(list, struct dlm_rsb, res_root_list);\n\t\tif (r->res_nodeid)\n\t\t\tcontinue;\n\n\t\tdir_nodeid = dlm_dir_nodeid(r);\n\t\tif (dir_nodeid != nodeid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The block ends when we can't fit the following in the\n\t\t * remaining buffer space:\n\t\t * namelen (uint16_t) +\n\t\t * name (r->res_length) +\n\t\t * end-of-block record 0x0000 (uint16_t)\n\t\t */\n\n\t\tif (offset + sizeof(uint16_t)*2 + r->res_length > outlen) {\n\t\t\t/* Write end-of-block record */\n\t\t\tbe_namelen = cpu_to_be16(0);\n\t\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\t\toffset += sizeof(__be16);\n\t\t\tls->ls_recover_dir_sent_msg++;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbe_namelen = cpu_to_be16(r->res_length);\n\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\toffset += sizeof(__be16);\n\t\tmemcpy(outbuf + offset, r->res_name, r->res_length);\n\t\toffset += r->res_length;\n\t\tls->ls_recover_dir_sent_res++;\n\t}\n\n\t/*\n\t * If we've reached the end of the list (and there's room) write a\n\t * terminating record.\n\t */\n\n\tif ((list == &ls->ls_root_list) &&\n\t    (offset + sizeof(uint16_t) <= outlen)) {\n\t\tbe_namelen = cpu_to_be16(0xFFFF);\n\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\toffset += sizeof(__be16);\n\t\tls->ls_recover_dir_sent_msg++;\n\t}\n out:\n\tup_read(&ls->ls_root_sem);\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"lock.h\"",
      "#include \"util.h\"",
      "#include \"recover.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outbuf + offset",
            "&be_namelen",
            "sizeof(__be16)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "0xFFFF"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outbuf + offset",
            "r->res_name",
            "r->res_length"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outbuf + offset",
            "&be_namelen",
            "sizeof(__be16)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "r->res_length"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outbuf + offset",
            "&be_namelen",
            "sizeof(__be16)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "0"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dir_nodeid",
          "args": [
            "r"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dir_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "47-50",
          "snippet": "int dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "list",
            "structdlm_rsb",
            "res_root_list"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"copy_master_names from %d start %d %s\"",
            "nodeid",
            "inlen",
            "inbuf"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_rsb_root",
          "args": [
            "ls",
            "inbuf",
            "inlen"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "find_rsb_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "200-230",
          "snippet": "static struct dlm_rsb *find_rsb_root(struct dlm_ls *ls, char *name, int len)\n{\n\tstruct dlm_rsb *r;\n\tuint32_t hash, bucket;\n\tint rv;\n\n\thash = jhash(name, len, 0);\n\tbucket = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[bucket].keep, name, len, &r);\n\tif (rv)\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[bucket].toss,\n\t\t\t\t\t name, len, &r);\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\n\tif (!rv)\n\t\treturn r;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (len == r->res_length && !memcmp(name, r->res_name, len)) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tlog_debug(ls, \"find_rsb_root revert to root_list %s\",\n\t\t\t\t  r->res_name);\n\t\t\treturn r;\n\t\t}\n\t}\n\tup_read(&ls->ls_root_sem);\n\treturn NULL;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct dlm_rsb *find_rsb_root(struct dlm_ls *ls, char *name, int len)\n{\n\tstruct dlm_rsb *r;\n\tuint32_t hash, bucket;\n\tint rv;\n\n\thash = jhash(name, len, 0);\n\tbucket = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[bucket].keep, name, len, &r);\n\tif (rv)\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[bucket].toss,\n\t\t\t\t\t name, len, &r);\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\n\tif (!rv)\n\t\treturn r;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (len == r->res_length && !memcmp(name, r->res_name, len)) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tlog_debug(ls, \"find_rsb_root revert to root_list %s\",\n\t\t\t\t  r->res_name);\n\t\t\treturn r;\n\t\t}\n\t}\n\tup_read(&ls->ls_root_sem);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_copy_master_names(struct dlm_ls *ls, char *inbuf, int inlen,\n \t\t\t   char *outbuf, int outlen, int nodeid)\n{\n\tstruct list_head *list;\n\tstruct dlm_rsb *r;\n\tint offset = 0, dir_nodeid;\n\t__be16 be_namelen;\n\n\tdown_read(&ls->ls_root_sem);\n\n\tif (inlen > 1) {\n\t\tr = find_rsb_root(ls, inbuf, inlen);\n\t\tif (!r) {\n\t\t\tinbuf[inlen - 1] = '\\0';\n\t\t\tlog_error(ls, \"copy_master_names from %d start %d %s\",\n\t\t\t\t  nodeid, inlen, inbuf);\n\t\t\tgoto out;\n\t\t}\n\t\tlist = r->res_root_list.next;\n\t} else {\n\t\tlist = ls->ls_root_list.next;\n\t}\n\n\tfor (offset = 0; list != &ls->ls_root_list; list = list->next) {\n\t\tr = list_entry(list, struct dlm_rsb, res_root_list);\n\t\tif (r->res_nodeid)\n\t\t\tcontinue;\n\n\t\tdir_nodeid = dlm_dir_nodeid(r);\n\t\tif (dir_nodeid != nodeid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The block ends when we can't fit the following in the\n\t\t * remaining buffer space:\n\t\t * namelen (uint16_t) +\n\t\t * name (r->res_length) +\n\t\t * end-of-block record 0x0000 (uint16_t)\n\t\t */\n\n\t\tif (offset + sizeof(uint16_t)*2 + r->res_length > outlen) {\n\t\t\t/* Write end-of-block record */\n\t\t\tbe_namelen = cpu_to_be16(0);\n\t\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\t\toffset += sizeof(__be16);\n\t\t\tls->ls_recover_dir_sent_msg++;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbe_namelen = cpu_to_be16(r->res_length);\n\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\toffset += sizeof(__be16);\n\t\tmemcpy(outbuf + offset, r->res_name, r->res_length);\n\t\toffset += r->res_length;\n\t\tls->ls_recover_dir_sent_res++;\n\t}\n\n\t/*\n\t * If we've reached the end of the list (and there's room) write a\n\t * terminating record.\n\t */\n\n\tif ((list == &ls->ls_root_list) &&\n\t    (offset + sizeof(uint16_t) <= outlen)) {\n\t\tbe_namelen = cpu_to_be16(0xFFFF);\n\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\toffset += sizeof(__be16);\n\t\tls->ls_recover_dir_sent_msg++;\n\t}\n out:\n\tup_read(&ls->ls_root_sem);\n}"
  },
  {
    "function_name": "find_rsb_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
    "lines": "200-230",
    "snippet": "static struct dlm_rsb *find_rsb_root(struct dlm_ls *ls, char *name, int len)\n{\n\tstruct dlm_rsb *r;\n\tuint32_t hash, bucket;\n\tint rv;\n\n\thash = jhash(name, len, 0);\n\tbucket = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[bucket].keep, name, len, &r);\n\tif (rv)\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[bucket].toss,\n\t\t\t\t\t name, len, &r);\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\n\tif (!rv)\n\t\treturn r;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (len == r->res_length && !memcmp(name, r->res_name, len)) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tlog_debug(ls, \"find_rsb_root revert to root_list %s\",\n\t\t\t\t  r->res_name);\n\t\t\treturn r;\n\t\t}\n\t}\n\tup_read(&ls->ls_root_sem);\n\treturn NULL;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"lock.h\"",
      "#include \"util.h\"",
      "#include \"recover.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"find_rsb_root revert to root_list %s\"",
            "r->res_name"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "r->res_name",
            "len"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "r",
            "&ls->ls_root_list",
            "res_root_list"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[bucket].lock"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_search_rsb_tree",
          "args": [
            "&ls->ls_rsbtbl[bucket].toss",
            "name",
            "len",
            "&r"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_search_rsb_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "447-470",
          "snippet": "int dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[bucket].lock"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "name",
            "len",
            "0"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct dlm_rsb *find_rsb_root(struct dlm_ls *ls, char *name, int len)\n{\n\tstruct dlm_rsb *r;\n\tuint32_t hash, bucket;\n\tint rv;\n\n\thash = jhash(name, len, 0);\n\tbucket = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[bucket].keep, name, len, &r);\n\tif (rv)\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[bucket].toss,\n\t\t\t\t\t name, len, &r);\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\n\tif (!rv)\n\t\treturn r;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (len == r->res_length && !memcmp(name, r->res_name, len)) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tlog_debug(ls, \"find_rsb_root revert to root_list %s\",\n\t\t\t\t  r->res_name);\n\t\t\treturn r;\n\t\t}\n\t}\n\tup_read(&ls->ls_root_sem);\n\treturn NULL;\n}"
  },
  {
    "function_name": "dlm_recover_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
    "lines": "63-198",
    "snippet": "int dlm_recover_directory(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tchar *b, *last_name = NULL;\n\tint error = -ENOMEM, last_len, nodeid, result;\n\tuint16_t namelen;\n\tunsigned int count = 0, count_match = 0, count_bad = 0, count_add = 0;\n\n\tlog_rinfo(ls, \"dlm_recover_directory\");\n\n\tif (dlm_no_directory(ls))\n\t\tgoto out_status;\n\n\tlast_name = kmalloc(DLM_RESNAME_MAXLEN, GFP_NOFS);\n\tif (!last_name)\n\t\tgoto out;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->nodeid == dlm_our_nodeid())\n\t\t\tcontinue;\n\n\t\tmemset(last_name, 0, DLM_RESNAME_MAXLEN);\n\t\tlast_len = 0;\n\n\t\tfor (;;) {\n\t\t\tint left;\n\t\t\terror = dlm_recovery_stopped(ls);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\n\t\t\terror = dlm_rcom_names(ls, memb->nodeid,\n\t\t\t\t\t       last_name, last_len);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\n\t\t\tcond_resched();\n\n\t\t\t/*\n\t\t\t * pick namelen/name pairs out of received buffer\n\t\t\t */\n\n\t\t\tb = ls->ls_recover_buf->rc_buf;\n\t\t\tleft = ls->ls_recover_buf->rc_header.h_length;\n\t\t\tleft -= sizeof(struct dlm_rcom);\n\n\t\t\tfor (;;) {\n\t\t\t\t__be16 v;\n\n\t\t\t\terror = -EINVAL;\n\t\t\t\tif (left < sizeof(__be16))\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\tmemcpy(&v, b, sizeof(__be16));\n\t\t\t\tnamelen = be16_to_cpu(v);\n\t\t\t\tb += sizeof(__be16);\n\t\t\t\tleft -= sizeof(__be16);\n\n\t\t\t\t/* namelen of 0xFFFFF marks end of names for\n\t\t\t\t   this node; namelen of 0 marks end of the\n\t\t\t\t   buffer */\n\n\t\t\t\tif (namelen == 0xFFFF)\n\t\t\t\t\tgoto done;\n\t\t\t\tif (!namelen)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (namelen > left)\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\tif (namelen > DLM_RESNAME_MAXLEN)\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\terror = dlm_master_lookup(ls, memb->nodeid,\n\t\t\t\t\t\t\t  b, namelen,\n\t\t\t\t\t\t\t  DLM_LU_RECOVER_DIR,\n\t\t\t\t\t\t\t  &nodeid, &result);\n\t\t\t\tif (error) {\n\t\t\t\t\tlog_error(ls, \"recover_dir lookup %d\",\n\t\t\t\t\t\t  error);\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\n\t\t\t\t/* The name was found in rsbtbl, but the\n\t\t\t\t * master nodeid is different from\n\t\t\t\t * memb->nodeid which says it is the master.\n\t\t\t\t * This should not happen. */\n\n\t\t\t\tif (result == DLM_LU_MATCH &&\n\t\t\t\t    nodeid != memb->nodeid) {\n\t\t\t\t\tcount_bad++;\n\t\t\t\t\tlog_error(ls, \"recover_dir lookup %d \"\n\t\t\t\t\t\t  \"nodeid %d memb %d bad %u\",\n\t\t\t\t\t\t  result, nodeid, memb->nodeid,\n\t\t\t\t\t\t  count_bad);\n\t\t\t\t\tprint_hex_dump_bytes(\"dlm_recover_dir \",\n\t\t\t\t\t\t\t     DUMP_PREFIX_NONE,\n\t\t\t\t\t\t\t     b, namelen);\n\t\t\t\t}\n\n\t\t\t\t/* The name was found in rsbtbl, and the\n\t\t\t\t * master nodeid matches memb->nodeid. */\n\n\t\t\t\tif (result == DLM_LU_MATCH &&\n\t\t\t\t    nodeid == memb->nodeid) {\n\t\t\t\t\tcount_match++;\n\t\t\t\t}\n\n\t\t\t\t/* The name was not found in rsbtbl and was\n\t\t\t\t * added with memb->nodeid as the master. */\n\n\t\t\t\tif (result == DLM_LU_ADD) {\n\t\t\t\t\tcount_add++;\n\t\t\t\t}\n\n\t\t\t\tlast_len = namelen;\n\t\t\t\tmemcpy(last_name, b, namelen);\n\t\t\t\tb += namelen;\n\t\t\t\tleft -= namelen;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t done:\n\t\t;\n\t}\n\n out_status:\n\terror = 0;\n\tdlm_set_recover_status(ls, DLM_RS_DIR);\n\n\tlog_rinfo(ls, \"dlm_recover_directory %u in %u new\",\n\t\t  count, count_add);\n out_free:\n\tkfree(last_name);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"lock.h\"",
      "#include \"util.h\"",
      "#include \"recover.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "last_name"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_directory %u in %u new\"",
            "count",
            "count_add"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_set_recover_status",
          "args": [
            "ls",
            "DLM_RS_DIR"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_recover_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "86-91",
          "snippet": "void dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tspin_lock(&ls->ls_recover_lock);\n\t_set_recover_status(ls, status);\n\tspin_unlock(&ls->ls_recover_lock);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tspin_lock(&ls->ls_recover_lock);\n\t_set_recover_status(ls, status);\n\tspin_unlock(&ls->ls_recover_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "last_name",
            "b",
            "namelen"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump_bytes",
          "args": [
            "\"dlm_recover_dir \"",
            "DUMP_PREFIX_NONE",
            "b",
            "namelen"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"recover_dir lookup %d \"\n\t\t\t\t\t\t  \"nodeid %d memb %d bad %u\"",
            "result",
            "nodeid",
            "memb->nodeid",
            "count_bad"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"recover_dir lookup %d\"",
            "error"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_master_lookup",
          "args": [
            "ls",
            "memb->nodeid",
            "b",
            "namelen",
            "DLM_LU_RECOVER_DIR",
            "&nodeid",
            "&result"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_master_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "912-1084",
          "snippet": "int dlm_master_lookup(struct dlm_ls *ls, int from_nodeid, char *name, int len,\n\t\t      unsigned int flags, int *r_nodeid, int *result)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint from_master = (flags & DLM_LU_RECOVER_DIR);\n\tint fix_master = (flags & DLM_LU_RECOVER_MASTER);\n\tint our_nodeid = dlm_our_nodeid();\n\tint dir_nodeid, error, toss_list = 0;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tif (from_nodeid == our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from our_nodeid %d flags %x\",\n\t\t\t  our_nodeid, flags);\n\t\treturn -EINVAL;\n\t}\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\tif (dir_nodeid != our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from %d dir %d our %d h %x %d\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, hash,\n\t\t\t  ls->ls_num_nodes);\n\t\t*r_nodeid = -1;\n\t\treturn -EINVAL;\n\t}\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\treturn error;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error) {\n\t\t/* because the rsb is active, we need to lock_rsb before\n\t\t   checking/changing re_master_nodeid */\n\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlock_rsb(r);\n\t\tgoto found;\n\t}\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto not_found;\n\n\t/* because the rsb is inactive (on toss list), it's not refcounted\n\t   and lock_rsb is not used, but is protected by the rsbtbl lock */\n\n\ttoss_list = 1;\n found:\n\tif (r->res_dir_nodeid != our_nodeid) {\n\t\t/* should not happen, but may as well fix it and carry on */\n\t\tlog_error(ls, \"dlm_master_lookup res_dir %d our %d %s\",\n\t\t\t  r->res_dir_nodeid, our_nodeid, r->res_name);\n\t\tr->res_dir_nodeid = our_nodeid;\n\t}\n\n\tif (fix_master && dlm_is_removed(ls, r->res_master_nodeid)) {\n\t\t/* Recovery uses this function to set a new master when\n\t\t   the previous master failed.  Setting NEW_MASTER will\n\t\t   force dlm_recover_masters to call recover_master on this\n\t\t   rsb even though the res_nodeid is no longer removed. */\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\n\t\tif (toss_list) {\n\t\t\t/* I don't think we should ever find it on toss list. */\n\t\t\tlog_error(ls, \"dlm_master_lookup fix_master on toss\");\n\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t}\n\n\tif (from_master && (r->res_master_nodeid != from_nodeid)) {\n\t\t/* this will happen if from_nodeid became master during\n\t\t   a previous recovery cycle, and we aborted the previous\n\t\t   cycle before recovering this master value */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from_master %d \"\n\t\t\t  \"master_nodeid %d res_nodeid %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_nodeid,\n\t\t\t  r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_master_nodeid == our_nodeid) {\n\t\t\tlog_error(ls, \"from_master %d our_master\", from_nodeid);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tdlm_send_rcom_lookup_dump(r, from_nodeid);\n\t\t\tgoto out_found;\n\t\t}\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\t}\n\n\tif (!r->res_master_nodeid) {\n\t\t/* this will happen if recovery happens while we're looking\n\t\t   up the master for this rsb */\n\n\t\tlog_debug(ls, \"dlm_master_lookup master 0 to %d first %x %s\",\n\t\t\t  from_nodeid, r->res_first_lkid, r->res_name);\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t}\n\n\tif (!from_master && !fix_master &&\n\t    (r->res_master_nodeid == from_nodeid)) {\n\t\t/* this can happen when the master sends remove, the dir node\n\t\t   finds the rsb on the keep list and ignores the remove,\n\t\t   and the former master sends a lookup */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from master %d flags %x \"\n\t\t\t  \"first %x %s\", from_nodeid, flags,\n\t\t\t  r->res_first_lkid, r->res_name);\n\t}\n\n out_found:\n\t*r_nodeid = r->res_master_nodeid;\n\tif (result)\n\t\t*result = DLM_LU_MATCH;\n\n\tif (toss_list) {\n\t\tr->res_toss_time = jiffies;\n\t\t/* the rsb was inactive (on toss list) */\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t} else {\n\t\t/* the rsb was active */\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t}\n\treturn 0;\n\n not_found:\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = our_nodeid;\n\tr->res_master_nodeid = from_nodeid;\n\tr->res_nodeid = from_nodeid;\n\tkref_init(&r->res_ref);\n\tr->res_toss_time = jiffies;\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].toss);\n\tif (error) {\n\t\t/* should never happen */\n\t\tdlm_free_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\n\tif (result)\n\t\t*result = DLM_LU_ADD;\n\t*r_nodeid = from_nodeid;\n\terror = 0;\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_master_lookup(struct dlm_ls *ls, int from_nodeid, char *name, int len,\n\t\t      unsigned int flags, int *r_nodeid, int *result)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint from_master = (flags & DLM_LU_RECOVER_DIR);\n\tint fix_master = (flags & DLM_LU_RECOVER_MASTER);\n\tint our_nodeid = dlm_our_nodeid();\n\tint dir_nodeid, error, toss_list = 0;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tif (from_nodeid == our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from our_nodeid %d flags %x\",\n\t\t\t  our_nodeid, flags);\n\t\treturn -EINVAL;\n\t}\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\tif (dir_nodeid != our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from %d dir %d our %d h %x %d\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, hash,\n\t\t\t  ls->ls_num_nodes);\n\t\t*r_nodeid = -1;\n\t\treturn -EINVAL;\n\t}\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\treturn error;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error) {\n\t\t/* because the rsb is active, we need to lock_rsb before\n\t\t   checking/changing re_master_nodeid */\n\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlock_rsb(r);\n\t\tgoto found;\n\t}\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto not_found;\n\n\t/* because the rsb is inactive (on toss list), it's not refcounted\n\t   and lock_rsb is not used, but is protected by the rsbtbl lock */\n\n\ttoss_list = 1;\n found:\n\tif (r->res_dir_nodeid != our_nodeid) {\n\t\t/* should not happen, but may as well fix it and carry on */\n\t\tlog_error(ls, \"dlm_master_lookup res_dir %d our %d %s\",\n\t\t\t  r->res_dir_nodeid, our_nodeid, r->res_name);\n\t\tr->res_dir_nodeid = our_nodeid;\n\t}\n\n\tif (fix_master && dlm_is_removed(ls, r->res_master_nodeid)) {\n\t\t/* Recovery uses this function to set a new master when\n\t\t   the previous master failed.  Setting NEW_MASTER will\n\t\t   force dlm_recover_masters to call recover_master on this\n\t\t   rsb even though the res_nodeid is no longer removed. */\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\n\t\tif (toss_list) {\n\t\t\t/* I don't think we should ever find it on toss list. */\n\t\t\tlog_error(ls, \"dlm_master_lookup fix_master on toss\");\n\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t}\n\n\tif (from_master && (r->res_master_nodeid != from_nodeid)) {\n\t\t/* this will happen if from_nodeid became master during\n\t\t   a previous recovery cycle, and we aborted the previous\n\t\t   cycle before recovering this master value */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from_master %d \"\n\t\t\t  \"master_nodeid %d res_nodeid %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_nodeid,\n\t\t\t  r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_master_nodeid == our_nodeid) {\n\t\t\tlog_error(ls, \"from_master %d our_master\", from_nodeid);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tdlm_send_rcom_lookup_dump(r, from_nodeid);\n\t\t\tgoto out_found;\n\t\t}\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\t}\n\n\tif (!r->res_master_nodeid) {\n\t\t/* this will happen if recovery happens while we're looking\n\t\t   up the master for this rsb */\n\n\t\tlog_debug(ls, \"dlm_master_lookup master 0 to %d first %x %s\",\n\t\t\t  from_nodeid, r->res_first_lkid, r->res_name);\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t}\n\n\tif (!from_master && !fix_master &&\n\t    (r->res_master_nodeid == from_nodeid)) {\n\t\t/* this can happen when the master sends remove, the dir node\n\t\t   finds the rsb on the keep list and ignores the remove,\n\t\t   and the former master sends a lookup */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from master %d flags %x \"\n\t\t\t  \"first %x %s\", from_nodeid, flags,\n\t\t\t  r->res_first_lkid, r->res_name);\n\t}\n\n out_found:\n\t*r_nodeid = r->res_master_nodeid;\n\tif (result)\n\t\t*result = DLM_LU_MATCH;\n\n\tif (toss_list) {\n\t\tr->res_toss_time = jiffies;\n\t\t/* the rsb was inactive (on toss list) */\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t} else {\n\t\t/* the rsb was active */\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t}\n\treturn 0;\n\n not_found:\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = our_nodeid;\n\tr->res_master_nodeid = from_nodeid;\n\tr->res_nodeid = from_nodeid;\n\tkref_init(&r->res_ref);\n\tr->res_toss_time = jiffies;\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].toss);\n\tif (error) {\n\t\t/* should never happen */\n\t\tdlm_free_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\n\tif (result)\n\t\t*result = DLM_LU_ADD;\n\t*r_nodeid = from_nodeid;\n\terror = 0;\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "v"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&v",
            "b",
            "sizeof(__be16)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_rcom_names",
          "args": [
            "ls",
            "memb->nodeid",
            "last_name",
            "last_len"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_rcom_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "271-293",
          "snippet": "int dlm_rcom_names(struct dlm_ls *ls, int nodeid, char *last_name, int last_len)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_NAMES, last_len, &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, last_name, last_len);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_rcom_names(struct dlm_ls *ls, int nodeid, char *last_name, int last_len)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_NAMES, last_len, &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, last_name, last_len);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recovery_stopped",
          "args": [
            "ls"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recovery_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "700-703",
          "snippet": "static inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RECOVER_STOP\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RECOVER_STOP\t0\n\nstatic inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "last_name",
            "0",
            "DLM_RESNAME_MAXLEN"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "DLM_RESNAME_MAXLEN",
            "GFP_NOFS"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_no_directory",
          "args": [
            "ls"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_no_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "705-708",
          "snippet": "static inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_NODIR\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_NODIR\t\t10\n\nstatic inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_directory\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_directory(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tchar *b, *last_name = NULL;\n\tint error = -ENOMEM, last_len, nodeid, result;\n\tuint16_t namelen;\n\tunsigned int count = 0, count_match = 0, count_bad = 0, count_add = 0;\n\n\tlog_rinfo(ls, \"dlm_recover_directory\");\n\n\tif (dlm_no_directory(ls))\n\t\tgoto out_status;\n\n\tlast_name = kmalloc(DLM_RESNAME_MAXLEN, GFP_NOFS);\n\tif (!last_name)\n\t\tgoto out;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->nodeid == dlm_our_nodeid())\n\t\t\tcontinue;\n\n\t\tmemset(last_name, 0, DLM_RESNAME_MAXLEN);\n\t\tlast_len = 0;\n\n\t\tfor (;;) {\n\t\t\tint left;\n\t\t\terror = dlm_recovery_stopped(ls);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\n\t\t\terror = dlm_rcom_names(ls, memb->nodeid,\n\t\t\t\t\t       last_name, last_len);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\n\t\t\tcond_resched();\n\n\t\t\t/*\n\t\t\t * pick namelen/name pairs out of received buffer\n\t\t\t */\n\n\t\t\tb = ls->ls_recover_buf->rc_buf;\n\t\t\tleft = ls->ls_recover_buf->rc_header.h_length;\n\t\t\tleft -= sizeof(struct dlm_rcom);\n\n\t\t\tfor (;;) {\n\t\t\t\t__be16 v;\n\n\t\t\t\terror = -EINVAL;\n\t\t\t\tif (left < sizeof(__be16))\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\tmemcpy(&v, b, sizeof(__be16));\n\t\t\t\tnamelen = be16_to_cpu(v);\n\t\t\t\tb += sizeof(__be16);\n\t\t\t\tleft -= sizeof(__be16);\n\n\t\t\t\t/* namelen of 0xFFFFF marks end of names for\n\t\t\t\t   this node; namelen of 0 marks end of the\n\t\t\t\t   buffer */\n\n\t\t\t\tif (namelen == 0xFFFF)\n\t\t\t\t\tgoto done;\n\t\t\t\tif (!namelen)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (namelen > left)\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\tif (namelen > DLM_RESNAME_MAXLEN)\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\terror = dlm_master_lookup(ls, memb->nodeid,\n\t\t\t\t\t\t\t  b, namelen,\n\t\t\t\t\t\t\t  DLM_LU_RECOVER_DIR,\n\t\t\t\t\t\t\t  &nodeid, &result);\n\t\t\t\tif (error) {\n\t\t\t\t\tlog_error(ls, \"recover_dir lookup %d\",\n\t\t\t\t\t\t  error);\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\n\t\t\t\t/* The name was found in rsbtbl, but the\n\t\t\t\t * master nodeid is different from\n\t\t\t\t * memb->nodeid which says it is the master.\n\t\t\t\t * This should not happen. */\n\n\t\t\t\tif (result == DLM_LU_MATCH &&\n\t\t\t\t    nodeid != memb->nodeid) {\n\t\t\t\t\tcount_bad++;\n\t\t\t\t\tlog_error(ls, \"recover_dir lookup %d \"\n\t\t\t\t\t\t  \"nodeid %d memb %d bad %u\",\n\t\t\t\t\t\t  result, nodeid, memb->nodeid,\n\t\t\t\t\t\t  count_bad);\n\t\t\t\t\tprint_hex_dump_bytes(\"dlm_recover_dir \",\n\t\t\t\t\t\t\t     DUMP_PREFIX_NONE,\n\t\t\t\t\t\t\t     b, namelen);\n\t\t\t\t}\n\n\t\t\t\t/* The name was found in rsbtbl, and the\n\t\t\t\t * master nodeid matches memb->nodeid. */\n\n\t\t\t\tif (result == DLM_LU_MATCH &&\n\t\t\t\t    nodeid == memb->nodeid) {\n\t\t\t\t\tcount_match++;\n\t\t\t\t}\n\n\t\t\t\t/* The name was not found in rsbtbl and was\n\t\t\t\t * added with memb->nodeid as the master. */\n\n\t\t\t\tif (result == DLM_LU_ADD) {\n\t\t\t\t\tcount_add++;\n\t\t\t\t}\n\n\t\t\t\tlast_len = namelen;\n\t\t\t\tmemcpy(last_name, b, namelen);\n\t\t\t\tb += namelen;\n\t\t\t\tleft -= namelen;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t done:\n\t\t;\n\t}\n\n out_status:\n\terror = 0;\n\tdlm_set_recover_status(ls, DLM_RS_DIR);\n\n\tlog_rinfo(ls, \"dlm_recover_directory %u in %u new\",\n\t\t  count, count_add);\n out_free:\n\tkfree(last_name);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_recover_dir_nodeid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
    "lines": "52-61",
    "snippet": "void dlm_recover_dir_nodeid(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tr->res_dir_nodeid = dlm_hash2nodeid(ls, r->res_hash);\n\t}\n\tup_read(&ls->ls_root_sem);\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"lock.h\"",
      "#include \"util.h\"",
      "#include \"recover.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_hash2nodeid",
          "args": [
            "ls",
            "r->res_hash"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hash2nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "35-45",
          "snippet": "int dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "r",
            "&ls->ls_root_list",
            "res_root_list"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recover_dir_nodeid(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tr->res_dir_nodeid = dlm_hash2nodeid(ls, r->res_hash);\n\t}\n\tup_read(&ls->ls_root_sem);\n}"
  },
  {
    "function_name": "dlm_dir_nodeid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
    "lines": "47-50",
    "snippet": "int dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"lock.h\"",
      "#include \"util.h\"",
      "#include \"recover.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}"
  },
  {
    "function_name": "dlm_hash2nodeid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
    "lines": "35-45",
    "snippet": "int dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"lock.h\"",
      "#include \"util.h\"",
      "#include \"recover.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}"
  }
]