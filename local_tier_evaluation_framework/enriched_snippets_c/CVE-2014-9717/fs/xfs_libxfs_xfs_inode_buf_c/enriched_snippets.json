[
  {
    "function_name": "xfs_iread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
    "lines": "342-476",
    "snippet": "int\nxfs_iread(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tiget_flags)\n{\n\txfs_buf_t\t*bp;\n\txfs_dinode_t\t*dip;\n\tint\t\terror;\n\n\t/*\n\t * Fill in the location information in the in-core inode.\n\t */\n\terror = xfs_imap(mp, tp, ip->i_ino, &ip->i_imap, iget_flags);\n\tif (error)\n\t\treturn error;\n\n\t/* shortcut IO on inode allocation if possible */\n\tif ((iget_flags & XFS_IGET_CREATE) &&\n\t    xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !(mp->m_flags & XFS_MOUNT_IKEEP)) {\n\t\t/* initialise the on-disk inode core */\n\t\tmemset(&ip->i_d, 0, sizeof(ip->i_d));\n\t\tip->i_d.di_magic = XFS_DINODE_MAGIC;\n\t\tip->i_d.di_gen = prandom_u32();\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tip->i_d.di_version = 3;\n\t\t\tip->i_d.di_ino = ip->i_ino;\n\t\t\tuuid_copy(&ip->i_d.di_uuid, &mp->m_sb.sb_uuid);\n\t\t} else\n\t\t\tip->i_d.di_version = 2;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Get pointers to the on-disk inode and the buffer containing it.\n\t */\n\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &bp, 0, iget_flags);\n\tif (error)\n\t\treturn error;\n\n\t/* even unallocated inodes are verified */\n\tif (!xfs_dinode_verify(mp, ip, dip)) {\n\t\txfs_alert(mp, \"%s: validation failed for inode %lld failed\",\n\t\t\t\t__func__, ip->i_ino);\n\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, dip);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_brelse;\n\t}\n\n\t/*\n\t * If the on-disk inode is already linked to a directory\n\t * entry, copy all of the inode into the in-core inode.\n\t * xfs_iformat_fork() handles copying in the inode format\n\t * specific information.\n\t * Otherwise, just get the truly permanent information.\n\t */\n\tif (dip->di_mode) {\n\t\txfs_dinode_from_disk(&ip->i_d, dip);\n\t\terror = xfs_iformat_fork(ip, dip);\n\t\tif (error)  {\n#ifdef DEBUG\n\t\t\txfs_alert(mp, \"%s: xfs_iformat() returned error %d\",\n\t\t\t\t__func__, error);\n#endif /* DEBUG */\n\t\t\tgoto out_brelse;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Partial initialisation of the in-core inode. Just the bits\n\t\t * that xfs_ialloc won't overwrite or relies on being correct.\n\t\t */\n\t\tip->i_d.di_magic = be16_to_cpu(dip->di_magic);\n\t\tip->i_d.di_version = dip->di_version;\n\t\tip->i_d.di_gen = be32_to_cpu(dip->di_gen);\n\t\tip->i_d.di_flushiter = be16_to_cpu(dip->di_flushiter);\n\n\t\tif (dip->di_version == 3) {\n\t\t\tip->i_d.di_ino = be64_to_cpu(dip->di_ino);\n\t\t\tuuid_copy(&ip->i_d.di_uuid, &dip->di_uuid);\n\t\t}\n\n\t\t/*\n\t\t * Make sure to pull in the mode here as well in\n\t\t * case the inode is released without being used.\n\t\t * This ensures that xfs_inactive() will see that\n\t\t * the inode is already free and not try to mess\n\t\t * with the uninitialized part of it.\n\t\t */\n\t\tip->i_d.di_mode = 0;\n\t}\n\n\t/*\n\t * Automatically convert version 1 inode formats in memory to version 2\n\t * inode format. If the inode is modified, it will get logged and\n\t * rewritten as a version 2 inode. We can do this because we set the\n\t * superblock feature bit for v2 inodes unconditionally during mount\n\t * and it means the reast of the code can assume the inode version is 2\n\t * or higher.\n\t */\n\tif (ip->i_d.di_version == 1) {\n\t\tip->i_d.di_version = 2;\n\t\tmemset(&(ip->i_d.di_pad[0]), 0, sizeof(ip->i_d.di_pad));\n\t\tip->i_d.di_nlink = ip->i_d.di_onlink;\n\t\tip->i_d.di_onlink = 0;\n\t\txfs_set_projid(ip, 0);\n\t}\n\n\tip->i_delayed_blks = 0;\n\n\t/*\n\t * Mark the buffer containing the inode as something to keep\n\t * around for a while.  This helps to keep recently accessed\n\t * meta-data in-core longer.\n\t */\n\txfs_buf_set_ref(bp, XFS_INO_REF);\n\n\t/*\n\t * Use xfs_trans_brelse() to release the buffer containing the on-disk\n\t * inode, because it was acquired with xfs_trans_read_buf() in\n\t * xfs_imap_to_bp() above.  If tp is NULL, this is just a normal\n\t * brelse().  If we're within a transaction, then xfs_trans_brelse()\n\t * will only release the buffer if it is not dirty within the\n\t * transaction.  It will be OK to release the buffer in this case,\n\t * because inodes on disk are never destroyed and we will be locking the\n\t * new in-core inode before putting it in the cache where other\n\t * processes can find it.  Thus we don't have to worry about the inode\n\t * being changed just because we released the buffer.\n\t */\n out_brelse:\n\txfs_trans_brelse(tp, bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "bp"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_set_ref",
          "args": [
            "bp",
            "XFS_INO_REF"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "351-354",
          "snippet": "static inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_projid",
          "args": [
            "ip",
            "0"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "187-193",
          "snippet": "static inline void\nxfs_set_projid(struct xfs_inode *ip,\n\t\tprid_t projid)\n{\n\tip->i_d.di_projid_hi = (__uint16_t) (projid >> 16);\n\tip->i_d.di_projid_lo = (__uint16_t) (projid & 0xffff);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_set_projid(struct xfs_inode *ip,\n\t\tprid_t projid)\n{\n\tip->i_d.di_projid_hi = (__uint16_t) (projid >> 16);\n\tip->i_d.di_projid_lo = (__uint16_t) (projid & 0xffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&(ip->i_d.di_pad[0])",
            "0",
            "sizeof(ip->i_d.di_pad)"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&ip->i_d.di_uuid",
            "&dip->di_uuid"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dip->di_ino"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dip->di_flushiter"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dip->di_gen"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dip->di_magic"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"%s: xfs_iformat() returned error %d\"",
            "__func__",
            "error"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iformat_fork",
          "args": [
            "ip",
            "dip"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iformat_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "79-231",
          "snippet": "int\nxfs_iformat_fork(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip)\n{\n\txfs_attr_shortform_t\t*atp;\n\tint\t\t\tsize;\n\tint\t\t\terror = 0;\n\txfs_fsize_t             di_size;\n\n\tif (unlikely(be32_to_cpu(dip->di_nextents) +\n\t\t     be16_to_cpu(dip->di_anextents) >\n\t\t     be64_to_cpu(dip->di_nblocks))) {\n\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, extent total = %d, nblocks = %Lu.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(int)(be32_to_cpu(dip->di_nextents) +\n\t\t\t      be16_to_cpu(dip->di_anextents)),\n\t\t\t(unsigned long long)\n\t\t\t\tbe64_to_cpu(dip->di_nblocks));\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely(dip->di_forkoff > ip->i_mount->m_sb.sb_inodesize)) {\n\t\txfs_warn(ip->i_mount, \"corrupt dinode %Lu, forkoff = 0x%x.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\tdip->di_forkoff);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely((ip->i_d.di_flags & XFS_DIFLAG_REALTIME) &&\n\t\t     !ip->i_mount->m_rtdev_targp)) {\n\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, has realtime flag set.\",\n\t\t\tip->i_ino);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(realtime)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tswitch (ip->i_d.di_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tif (unlikely(dip->di_format != XFS_DINODE_FMT_DEV)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(3)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t      ip->i_mount, dip);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tip->i_d.di_size = 0;\n\t\tip->i_df.if_u2.if_rdev = xfs_dinode_get_rdev(dip);\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\tcase S_IFDIR:\n\t\tswitch (dip->di_format) {\n\t\tcase XFS_DINODE_FMT_LOCAL:\n\t\t\t/*\n\t\t\t * no local regular files yet\n\t\t\t */\n\t\t\tif (unlikely(S_ISREG(be16_to_cpu(dip->di_mode)))) {\n\t\t\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt inode %Lu (local format for regular file).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(4)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tdi_size = be64_to_cpu(dip->di_size);\n\t\t\tif (unlikely(di_size < 0 ||\n\t\t\t\t     di_size > XFS_DFORK_DSIZE(dip, ip->i_mount))) {\n\t\t\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt inode %Lu (bad size %Ld for local inode).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t\t(long long) di_size);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(5)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tsize = (int)di_size;\n\t\t\terror = xfs_iformat_local(ip, dip, XFS_DATA_FORK, size);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\terror = xfs_iformat_extents(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_BTREE:\n\t\t\terror = xfs_iformat_btree(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tXFS_ERROR_REPORT(\"xfs_iformat(6)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"xfs_iformat(7)\", XFS_ERRLEVEL_LOW, ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (!XFS_DFORK_Q(dip))\n\t\treturn 0;\n\n\tASSERT(ip->i_afp == NULL);\n\tip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP | KM_NOFS);\n\n\tswitch (dip->di_aformat) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tatp = (xfs_attr_shortform_t *)XFS_DFORK_APTR(dip);\n\t\tsize = be16_to_cpu(atp->hdr.totsize);\n\n\t\tif (unlikely(size < sizeof(struct xfs_attr_sf_hdr))) {\n\t\t\txfs_warn(ip->i_mount,\n\t\t\t\t\"corrupt inode %Lu (bad attr fork size %Ld).\",\n\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t(long long) size);\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(8)\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     ip->i_mount, dip);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\terror = xfs_iformat_local(ip, dip, XFS_ATTR_FORK, size);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_iformat_extents(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_iformat_btree(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tdefault:\n\t\terror = -EFSCORRUPTED;\n\t\tbreak;\n\t}\n\tif (error) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_ifork_zone;",
            "STATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);",
            "STATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);",
            "STATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nkmem_zone_t *xfs_ifork_zone;\nSTATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);\nSTATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);\nSTATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);\n\nint\nxfs_iformat_fork(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip)\n{\n\txfs_attr_shortform_t\t*atp;\n\tint\t\t\tsize;\n\tint\t\t\terror = 0;\n\txfs_fsize_t             di_size;\n\n\tif (unlikely(be32_to_cpu(dip->di_nextents) +\n\t\t     be16_to_cpu(dip->di_anextents) >\n\t\t     be64_to_cpu(dip->di_nblocks))) {\n\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, extent total = %d, nblocks = %Lu.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(int)(be32_to_cpu(dip->di_nextents) +\n\t\t\t      be16_to_cpu(dip->di_anextents)),\n\t\t\t(unsigned long long)\n\t\t\t\tbe64_to_cpu(dip->di_nblocks));\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely(dip->di_forkoff > ip->i_mount->m_sb.sb_inodesize)) {\n\t\txfs_warn(ip->i_mount, \"corrupt dinode %Lu, forkoff = 0x%x.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\tdip->di_forkoff);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely((ip->i_d.di_flags & XFS_DIFLAG_REALTIME) &&\n\t\t     !ip->i_mount->m_rtdev_targp)) {\n\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, has realtime flag set.\",\n\t\t\tip->i_ino);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(realtime)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tswitch (ip->i_d.di_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tif (unlikely(dip->di_format != XFS_DINODE_FMT_DEV)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(3)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t      ip->i_mount, dip);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tip->i_d.di_size = 0;\n\t\tip->i_df.if_u2.if_rdev = xfs_dinode_get_rdev(dip);\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\tcase S_IFDIR:\n\t\tswitch (dip->di_format) {\n\t\tcase XFS_DINODE_FMT_LOCAL:\n\t\t\t/*\n\t\t\t * no local regular files yet\n\t\t\t */\n\t\t\tif (unlikely(S_ISREG(be16_to_cpu(dip->di_mode)))) {\n\t\t\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt inode %Lu (local format for regular file).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(4)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tdi_size = be64_to_cpu(dip->di_size);\n\t\t\tif (unlikely(di_size < 0 ||\n\t\t\t\t     di_size > XFS_DFORK_DSIZE(dip, ip->i_mount))) {\n\t\t\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt inode %Lu (bad size %Ld for local inode).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t\t(long long) di_size);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(5)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tsize = (int)di_size;\n\t\t\terror = xfs_iformat_local(ip, dip, XFS_DATA_FORK, size);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\terror = xfs_iformat_extents(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_BTREE:\n\t\t\terror = xfs_iformat_btree(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tXFS_ERROR_REPORT(\"xfs_iformat(6)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"xfs_iformat(7)\", XFS_ERRLEVEL_LOW, ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (!XFS_DFORK_Q(dip))\n\t\treturn 0;\n\n\tASSERT(ip->i_afp == NULL);\n\tip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP | KM_NOFS);\n\n\tswitch (dip->di_aformat) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tatp = (xfs_attr_shortform_t *)XFS_DFORK_APTR(dip);\n\t\tsize = be16_to_cpu(atp->hdr.totsize);\n\n\t\tif (unlikely(size < sizeof(struct xfs_attr_sf_hdr))) {\n\t\t\txfs_warn(ip->i_mount,\n\t\t\t\t\"corrupt inode %Lu (bad attr fork size %Ld).\",\n\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t(long long) size);\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(8)\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     ip->i_mount, dip);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\terror = xfs_iformat_local(ip, dip, XFS_ATTR_FORK, size);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_iformat_extents(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_iformat_btree(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tdefault:\n\t\terror = -EFSCORRUPTED;\n\t\tbreak;\n\t}\n\tif (error) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dinode_from_disk",
          "args": [
            "&ip->i_d",
            "dip"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "193-238",
          "snippet": "void\nxfs_dinode_from_disk(\n\txfs_icdinode_t\t\t*to,\n\txfs_dinode_t\t\t*from)\n{\n\tto->di_magic = be16_to_cpu(from->di_magic);\n\tto->di_mode = be16_to_cpu(from->di_mode);\n\tto->di_version = from ->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = be16_to_cpu(from->di_onlink);\n\tto->di_uid = be32_to_cpu(from->di_uid);\n\tto->di_gid = be32_to_cpu(from->di_gid);\n\tto->di_nlink = be32_to_cpu(from->di_nlink);\n\tto->di_projid_lo = be16_to_cpu(from->di_projid_lo);\n\tto->di_projid_hi = be16_to_cpu(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\tto->di_flushiter = be16_to_cpu(from->di_flushiter);\n\tto->di_atime.t_sec = be32_to_cpu(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = be32_to_cpu(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = be32_to_cpu(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = be32_to_cpu(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = be32_to_cpu(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = be32_to_cpu(from->di_ctime.t_nsec);\n\tto->di_size = be64_to_cpu(from->di_size);\n\tto->di_nblocks = be64_to_cpu(from->di_nblocks);\n\tto->di_extsize = be32_to_cpu(from->di_extsize);\n\tto->di_nextents = be32_to_cpu(from->di_nextents);\n\tto->di_anextents = be16_to_cpu(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat\t= from->di_aformat;\n\tto->di_dmevmask\t= be32_to_cpu(from->di_dmevmask);\n\tto->di_dmstate\t= be16_to_cpu(from->di_dmstate);\n\tto->di_flags\t= be16_to_cpu(from->di_flags);\n\tto->di_gen\t= be32_to_cpu(from->di_gen);\n\n\tif (to->di_version == 3) {\n\t\tto->di_changecount = be64_to_cpu(from->di_changecount);\n\t\tto->di_crtime.t_sec = be32_to_cpu(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = be32_to_cpu(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = be64_to_cpu(from->di_flags2);\n\t\tto->di_ino = be64_to_cpu(from->di_ino);\n\t\tto->di_lsn = be64_to_cpu(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t}\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_from_disk(\n\txfs_icdinode_t\t\t*to,\n\txfs_dinode_t\t\t*from)\n{\n\tto->di_magic = be16_to_cpu(from->di_magic);\n\tto->di_mode = be16_to_cpu(from->di_mode);\n\tto->di_version = from ->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = be16_to_cpu(from->di_onlink);\n\tto->di_uid = be32_to_cpu(from->di_uid);\n\tto->di_gid = be32_to_cpu(from->di_gid);\n\tto->di_nlink = be32_to_cpu(from->di_nlink);\n\tto->di_projid_lo = be16_to_cpu(from->di_projid_lo);\n\tto->di_projid_hi = be16_to_cpu(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\tto->di_flushiter = be16_to_cpu(from->di_flushiter);\n\tto->di_atime.t_sec = be32_to_cpu(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = be32_to_cpu(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = be32_to_cpu(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = be32_to_cpu(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = be32_to_cpu(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = be32_to_cpu(from->di_ctime.t_nsec);\n\tto->di_size = be64_to_cpu(from->di_size);\n\tto->di_nblocks = be64_to_cpu(from->di_nblocks);\n\tto->di_extsize = be32_to_cpu(from->di_extsize);\n\tto->di_nextents = be32_to_cpu(from->di_nextents);\n\tto->di_anextents = be16_to_cpu(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat\t= from->di_aformat;\n\tto->di_dmevmask\t= be32_to_cpu(from->di_dmevmask);\n\tto->di_dmstate\t= be16_to_cpu(from->di_dmstate);\n\tto->di_flags\t= be16_to_cpu(from->di_flags);\n\tto->di_gen\t= be32_to_cpu(from->di_gen);\n\n\tif (to->di_version == 3) {\n\t\tto->di_changecount = be64_to_cpu(from->di_changecount);\n\t\tto->di_crtime.t_sec = be32_to_cpu(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = be32_to_cpu(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = be64_to_cpu(from->di_flags2);\n\t\tto->di_ino = be64_to_cpu(from->di_ino);\n\t\tto->di_lsn = be64_to_cpu(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "__func__",
            "XFS_ERRLEVEL_LOW",
            "mp",
            "dip"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dinode_verify",
          "args": [
            "mp",
            "ip",
            "dip"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "289-312",
          "snippet": "static bool\nxfs_dinode_verify(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*dip)\n{\n\tif (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))\n\t\treturn false;\n\n\t/* only version 3 or greater inodes are extensively verified here */\n\tif (dip->di_version < 3)\n\t\treturn true;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn false;\n\tif (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF))\n\t\treturn false;\n\tif (be64_to_cpu(dip->di_ino) != ip->i_ino)\n\t\treturn false;\n\tif (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_dinode_verify(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*dip)\n{\n\tif (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))\n\t\treturn false;\n\n\t/* only version 3 or greater inodes are extensively verified here */\n\tif (dip->di_version < 3)\n\t\treturn true;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn false;\n\tif (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF))\n\t\treturn false;\n\tif (be64_to_cpu(dip->di_ino) != ip->i_ino)\n\t\treturn false;\n\tif (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_imap_to_bp",
          "args": [
            "mp",
            "tp",
            "&ip->i_imap",
            "&dip",
            "&bp",
            "0",
            "iget_flags"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_imap_to_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "156-191",
          "snippet": "int\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED &&\n\t\t    (iget_flags & XFS_IGET_UNTRUSTED))\n\t\t\treturn -EINVAL;\n\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = (struct xfs_dinode *)xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};\n\nint\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED &&\n\t\t    (iget_flags & XFS_IGET_UNTRUSTED))\n\t\t\treturn -EINVAL;\n\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = (struct xfs_dinode *)xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ip->i_d",
            "0",
            "sizeof(ip->i_d)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_imap",
          "args": [
            "mp",
            "tp",
            "ip->i_ino",
            "&ip->i_imap",
            "iget_flags"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_imap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1804-1934",
          "snippet": "int\nxfs_imap(\n\txfs_mount_t\t *mp,\t/* file system mount structure */\n\txfs_trans_t\t *tp,\t/* transaction pointer */\n\txfs_ino_t\tino,\t/* inode to locate */\n\tstruct xfs_imap\t*imap,\t/* location map structure */\n\tuint\t\tflags)\t/* flags for inode btree lookup */\n{\n\txfs_agblock_t\tagbno;\t/* block number of inode in the alloc group */\n\txfs_agino_t\tagino;\t/* inode number within alloc group */\n\txfs_agnumber_t\tagno;\t/* allocation group number */\n\tint\t\tblks_per_cluster; /* num blocks per inode cluster */\n\txfs_agblock_t\tchunk_agbno;\t/* first block in inode chunk */\n\txfs_agblock_t\tcluster_agbno;\t/* first block in inode cluster */\n\tint\t\terror;\t/* error code */\n\tint\t\toffset;\t/* index of inode in its buffer */\n\txfs_agblock_t\toffset_agbno;\t/* blks from chunk start to inode */\n\n\tASSERT(ino != NULLFSINO);\n\n\t/*\n\t * Split up the inode number into its parts.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tagbno = XFS_AGINO_TO_AGBNO(mp, agino);\n\tif (agno >= mp->m_sb.sb_agcount || agbno >= mp->m_sb.sb_agblocks ||\n\t    ino != XFS_AGINO_TO_INO(mp, agno, agino)) {\n#ifdef DEBUG\n\t\t/*\n\t\t * Don't output diagnostic information for untrusted inodes\n\t\t * as they can be invalid without implying corruption.\n\t\t */\n\t\tif (flags & XFS_IGET_UNTRUSTED)\n\t\t\treturn -EINVAL;\n\t\tif (agno >= mp->m_sb.sb_agcount) {\n\t\t\txfs_alert(mp,\n\t\t\t\t\"%s: agno (%d) >= mp->m_sb.sb_agcount (%d)\",\n\t\t\t\t__func__, agno, mp->m_sb.sb_agcount);\n\t\t}\n\t\tif (agbno >= mp->m_sb.sb_agblocks) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: agbno (0x%llx) >= mp->m_sb.sb_agblocks (0x%lx)\",\n\t\t\t\t__func__, (unsigned long long)agbno,\n\t\t\t\t(unsigned long)mp->m_sb.sb_agblocks);\n\t\t}\n\t\tif (ino != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: ino (0x%llx) != XFS_AGINO_TO_INO() (0x%llx)\",\n\t\t\t\t__func__, ino,\n\t\t\t\tXFS_AGINO_TO_INO(mp, agno, agino));\n\t\t}\n\t\txfs_stack_trace();\n#endif /* DEBUG */\n\t\treturn -EINVAL;\n\t}\n\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\n\t/*\n\t * For bulkstat and handle lookups, we have an untrusted inode number\n\t * that we have to verify is valid. We cannot do this just by reading\n\t * the inode buffer as it may have been unlinked and removed leaving\n\t * inodes in stale state on disk. Hence we have to do a btree lookup\n\t * in all cases where an untrusted inode number is passed.\n\t */\n\tif (flags & XFS_IGET_UNTRUSTED) {\n\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgoto out_map;\n\t}\n\n\t/*\n\t * If the inode cluster size is the same as the blocksize or\n\t * smaller we get to the buffer by simple arithmetics.\n\t */\n\tif (blks_per_cluster == 1) {\n\t\toffset = XFS_INO_TO_OFFSET(mp, ino);\n\t\tASSERT(offset < mp->m_sb.sb_inopblock);\n\n\t\timap->im_blkno = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\t\timap->im_len = XFS_FSB_TO_BB(mp, 1);\n\t\timap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the inode chunks are aligned then use simple maths to\n\t * find the location. Otherwise we have to do a btree\n\t * lookup to find the location.\n\t */\n\tif (mp->m_inoalign_mask) {\n\t\toffset_agbno = agbno & mp->m_inoalign_mask;\n\t\tchunk_agbno = agbno - offset_agbno;\n\t} else {\n\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\nout_map:\n\tASSERT(agbno >= chunk_agbno);\n\tcluster_agbno = chunk_agbno +\n\t\t((offset_agbno / blks_per_cluster) * blks_per_cluster);\n\toffset = ((agbno - cluster_agbno) * mp->m_sb.sb_inopblock) +\n\t\tXFS_INO_TO_OFFSET(mp, ino);\n\n\timap->im_blkno = XFS_AGB_TO_DADDR(mp, agno, cluster_agbno);\n\timap->im_len = XFS_FSB_TO_BB(mp, blks_per_cluster);\n\timap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);\n\n\t/*\n\t * If the inode number maps to a block outside the bounds\n\t * of the file system then return NULL rather than calling\n\t * read_buf and panicing when we get an error from the\n\t * driver.\n\t */\n\tif ((imap->im_blkno + imap->im_len) >\n\t    XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)) {\n\t\txfs_alert(mp,\n\t\"%s: (im_blkno (0x%llx) + im_len (0x%llx)) > sb_dblocks (0x%llx)\",\n\t\t\t__func__, (unsigned long long) imap->im_blkno,\n\t\t\t(unsigned long long) imap->im_len,\n\t\t\tXFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_imap(\n\txfs_mount_t\t *mp,\t/* file system mount structure */\n\txfs_trans_t\t *tp,\t/* transaction pointer */\n\txfs_ino_t\tino,\t/* inode to locate */\n\tstruct xfs_imap\t*imap,\t/* location map structure */\n\tuint\t\tflags)\t/* flags for inode btree lookup */\n{\n\txfs_agblock_t\tagbno;\t/* block number of inode in the alloc group */\n\txfs_agino_t\tagino;\t/* inode number within alloc group */\n\txfs_agnumber_t\tagno;\t/* allocation group number */\n\tint\t\tblks_per_cluster; /* num blocks per inode cluster */\n\txfs_agblock_t\tchunk_agbno;\t/* first block in inode chunk */\n\txfs_agblock_t\tcluster_agbno;\t/* first block in inode cluster */\n\tint\t\terror;\t/* error code */\n\tint\t\toffset;\t/* index of inode in its buffer */\n\txfs_agblock_t\toffset_agbno;\t/* blks from chunk start to inode */\n\n\tASSERT(ino != NULLFSINO);\n\n\t/*\n\t * Split up the inode number into its parts.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tagbno = XFS_AGINO_TO_AGBNO(mp, agino);\n\tif (agno >= mp->m_sb.sb_agcount || agbno >= mp->m_sb.sb_agblocks ||\n\t    ino != XFS_AGINO_TO_INO(mp, agno, agino)) {\n#ifdef DEBUG\n\t\t/*\n\t\t * Don't output diagnostic information for untrusted inodes\n\t\t * as they can be invalid without implying corruption.\n\t\t */\n\t\tif (flags & XFS_IGET_UNTRUSTED)\n\t\t\treturn -EINVAL;\n\t\tif (agno >= mp->m_sb.sb_agcount) {\n\t\t\txfs_alert(mp,\n\t\t\t\t\"%s: agno (%d) >= mp->m_sb.sb_agcount (%d)\",\n\t\t\t\t__func__, agno, mp->m_sb.sb_agcount);\n\t\t}\n\t\tif (agbno >= mp->m_sb.sb_agblocks) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: agbno (0x%llx) >= mp->m_sb.sb_agblocks (0x%lx)\",\n\t\t\t\t__func__, (unsigned long long)agbno,\n\t\t\t\t(unsigned long)mp->m_sb.sb_agblocks);\n\t\t}\n\t\tif (ino != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: ino (0x%llx) != XFS_AGINO_TO_INO() (0x%llx)\",\n\t\t\t\t__func__, ino,\n\t\t\t\tXFS_AGINO_TO_INO(mp, agno, agino));\n\t\t}\n\t\txfs_stack_trace();\n#endif /* DEBUG */\n\t\treturn -EINVAL;\n\t}\n\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\n\t/*\n\t * For bulkstat and handle lookups, we have an untrusted inode number\n\t * that we have to verify is valid. We cannot do this just by reading\n\t * the inode buffer as it may have been unlinked and removed leaving\n\t * inodes in stale state on disk. Hence we have to do a btree lookup\n\t * in all cases where an untrusted inode number is passed.\n\t */\n\tif (flags & XFS_IGET_UNTRUSTED) {\n\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgoto out_map;\n\t}\n\n\t/*\n\t * If the inode cluster size is the same as the blocksize or\n\t * smaller we get to the buffer by simple arithmetics.\n\t */\n\tif (blks_per_cluster == 1) {\n\t\toffset = XFS_INO_TO_OFFSET(mp, ino);\n\t\tASSERT(offset < mp->m_sb.sb_inopblock);\n\n\t\timap->im_blkno = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\t\timap->im_len = XFS_FSB_TO_BB(mp, 1);\n\t\timap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the inode chunks are aligned then use simple maths to\n\t * find the location. Otherwise we have to do a btree\n\t * lookup to find the location.\n\t */\n\tif (mp->m_inoalign_mask) {\n\t\toffset_agbno = agbno & mp->m_inoalign_mask;\n\t\tchunk_agbno = agbno - offset_agbno;\n\t} else {\n\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\nout_map:\n\tASSERT(agbno >= chunk_agbno);\n\tcluster_agbno = chunk_agbno +\n\t\t((offset_agbno / blks_per_cluster) * blks_per_cluster);\n\toffset = ((agbno - cluster_agbno) * mp->m_sb.sb_inopblock) +\n\t\tXFS_INO_TO_OFFSET(mp, ino);\n\n\timap->im_blkno = XFS_AGB_TO_DADDR(mp, agno, cluster_agbno);\n\timap->im_len = XFS_FSB_TO_BB(mp, blks_per_cluster);\n\timap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);\n\n\t/*\n\t * If the inode number maps to a block outside the bounds\n\t * of the file system then return NULL rather than calling\n\t * read_buf and panicing when we get an error from the\n\t * driver.\n\t */\n\tif ((imap->im_blkno + imap->im_len) >\n\t    XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)) {\n\t\txfs_alert(mp,\n\t\"%s: (im_blkno (0x%llx) + im_len (0x%llx)) > sb_dblocks (0x%llx)\",\n\t\t\t__func__, (unsigned long long) imap->im_blkno,\n\t\t\t(unsigned long long) imap->im_len,\n\t\t\tXFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_iread(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tiget_flags)\n{\n\txfs_buf_t\t*bp;\n\txfs_dinode_t\t*dip;\n\tint\t\terror;\n\n\t/*\n\t * Fill in the location information in the in-core inode.\n\t */\n\terror = xfs_imap(mp, tp, ip->i_ino, &ip->i_imap, iget_flags);\n\tif (error)\n\t\treturn error;\n\n\t/* shortcut IO on inode allocation if possible */\n\tif ((iget_flags & XFS_IGET_CREATE) &&\n\t    xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !(mp->m_flags & XFS_MOUNT_IKEEP)) {\n\t\t/* initialise the on-disk inode core */\n\t\tmemset(&ip->i_d, 0, sizeof(ip->i_d));\n\t\tip->i_d.di_magic = XFS_DINODE_MAGIC;\n\t\tip->i_d.di_gen = prandom_u32();\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tip->i_d.di_version = 3;\n\t\t\tip->i_d.di_ino = ip->i_ino;\n\t\t\tuuid_copy(&ip->i_d.di_uuid, &mp->m_sb.sb_uuid);\n\t\t} else\n\t\t\tip->i_d.di_version = 2;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Get pointers to the on-disk inode and the buffer containing it.\n\t */\n\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &bp, 0, iget_flags);\n\tif (error)\n\t\treturn error;\n\n\t/* even unallocated inodes are verified */\n\tif (!xfs_dinode_verify(mp, ip, dip)) {\n\t\txfs_alert(mp, \"%s: validation failed for inode %lld failed\",\n\t\t\t\t__func__, ip->i_ino);\n\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, dip);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_brelse;\n\t}\n\n\t/*\n\t * If the on-disk inode is already linked to a directory\n\t * entry, copy all of the inode into the in-core inode.\n\t * xfs_iformat_fork() handles copying in the inode format\n\t * specific information.\n\t * Otherwise, just get the truly permanent information.\n\t */\n\tif (dip->di_mode) {\n\t\txfs_dinode_from_disk(&ip->i_d, dip);\n\t\terror = xfs_iformat_fork(ip, dip);\n\t\tif (error)  {\n#ifdef DEBUG\n\t\t\txfs_alert(mp, \"%s: xfs_iformat() returned error %d\",\n\t\t\t\t__func__, error);\n#endif /* DEBUG */\n\t\t\tgoto out_brelse;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Partial initialisation of the in-core inode. Just the bits\n\t\t * that xfs_ialloc won't overwrite or relies on being correct.\n\t\t */\n\t\tip->i_d.di_magic = be16_to_cpu(dip->di_magic);\n\t\tip->i_d.di_version = dip->di_version;\n\t\tip->i_d.di_gen = be32_to_cpu(dip->di_gen);\n\t\tip->i_d.di_flushiter = be16_to_cpu(dip->di_flushiter);\n\n\t\tif (dip->di_version == 3) {\n\t\t\tip->i_d.di_ino = be64_to_cpu(dip->di_ino);\n\t\t\tuuid_copy(&ip->i_d.di_uuid, &dip->di_uuid);\n\t\t}\n\n\t\t/*\n\t\t * Make sure to pull in the mode here as well in\n\t\t * case the inode is released without being used.\n\t\t * This ensures that xfs_inactive() will see that\n\t\t * the inode is already free and not try to mess\n\t\t * with the uninitialized part of it.\n\t\t */\n\t\tip->i_d.di_mode = 0;\n\t}\n\n\t/*\n\t * Automatically convert version 1 inode formats in memory to version 2\n\t * inode format. If the inode is modified, it will get logged and\n\t * rewritten as a version 2 inode. We can do this because we set the\n\t * superblock feature bit for v2 inodes unconditionally during mount\n\t * and it means the reast of the code can assume the inode version is 2\n\t * or higher.\n\t */\n\tif (ip->i_d.di_version == 1) {\n\t\tip->i_d.di_version = 2;\n\t\tmemset(&(ip->i_d.di_pad[0]), 0, sizeof(ip->i_d.di_pad));\n\t\tip->i_d.di_nlink = ip->i_d.di_onlink;\n\t\tip->i_d.di_onlink = 0;\n\t\txfs_set_projid(ip, 0);\n\t}\n\n\tip->i_delayed_blks = 0;\n\n\t/*\n\t * Mark the buffer containing the inode as something to keep\n\t * around for a while.  This helps to keep recently accessed\n\t * meta-data in-core longer.\n\t */\n\txfs_buf_set_ref(bp, XFS_INO_REF);\n\n\t/*\n\t * Use xfs_trans_brelse() to release the buffer containing the on-disk\n\t * inode, because it was acquired with xfs_trans_read_buf() in\n\t * xfs_imap_to_bp() above.  If tp is NULL, this is just a normal\n\t * brelse().  If we're within a transaction, then xfs_trans_brelse()\n\t * will only release the buffer if it is not dirty within the\n\t * transaction.  It will be OK to release the buffer in this case,\n\t * because inodes on disk are never destroyed and we will be locking the\n\t * new in-core inode before putting it in the cache where other\n\t * processes can find it.  Thus we don't have to worry about the inode\n\t * being changed just because we released the buffer.\n\t */\n out_brelse:\n\txfs_trans_brelse(tp, bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dinode_calc_crc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
    "lines": "314-328",
    "snippet": "void\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}",
    "includes": [
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_end_cksum",
          "args": [
            "crc"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_end_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "35-39",
          "snippet": "static inline __le32\nxfs_end_cksum(__uint32_t crc)\n{\n\treturn ~cpu_to_le32(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __le32\nxfs_end_cksum(__uint32_t crc)\n{\n\treturn ~cpu_to_le32(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_start_cksum",
          "args": [
            "(char *)dip",
            "mp->m_sb.sb_inodesize",
            "XFS_DINODE_CRC_OFF"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_start_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "11-26",
          "snippet": "static inline __uint32_t\nxfs_start_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t zero = 0;\n\t__uint32_t crc;\n\n\t/* Calculate CRC up to the checksum. */\n\tcrc = crc32c(XFS_CRC_SEED, buffer, cksum_offset);\n\n\t/* Skip checksum field */\n\tcrc = crc32c(crc, &zero, sizeof(__u32));\n\n\t/* Calculate the rest of the CRC. */\n\treturn crc32c(crc, &buffer[cksum_offset + sizeof(__be32)],\n\t\t      length - (cksum_offset + sizeof(__be32)));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_CRC_SEED\t(~(__uint32_t)0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_CRC_SEED\t(~(__uint32_t)0)\n\nstatic inline __uint32_t\nxfs_start_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t zero = 0;\n\t__uint32_t crc;\n\n\t/* Calculate CRC up to the checksum. */\n\tcrc = crc32c(XFS_CRC_SEED, buffer, cksum_offset);\n\n\t/* Skip checksum field */\n\tcrc = crc32c(crc, &zero, sizeof(__u32));\n\n\t/* Calculate the rest of the CRC. */\n\treturn crc32c(crc, &buffer[cksum_offset + sizeof(__be32)],\n\t\t      length - (cksum_offset + sizeof(__be32)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_sb_version_hascrc(&mp->m_sb)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\t__uint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}"
  },
  {
    "function_name": "xfs_dinode_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
    "lines": "289-312",
    "snippet": "static bool\nxfs_dinode_verify(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*dip)\n{\n\tif (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))\n\t\treturn false;\n\n\t/* only version 3 or greater inodes are extensively verified here */\n\tif (dip->di_version < 3)\n\t\treturn true;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn false;\n\tif (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF))\n\t\treturn false;\n\tif (be64_to_cpu(dip->di_ino) != ip->i_ino)\n\t\treturn false;\n\tif (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&dip->di_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dip->di_ino"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_verify_cksum",
          "args": [
            "(char *)dip",
            "mp->m_sb.sb_inodesize",
            "XFS_DINODE_CRC_OFF"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "55-61",
          "snippet": "static inline int\nxfs_verify_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\treturn *(__le32 *)(buffer + cksum_offset) == xfs_end_cksum(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_verify_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\treturn *(__le32 *)(buffer + cksum_offset) == xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DINODE_MAGIC"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_dinode_verify(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*dip)\n{\n\tif (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))\n\t\treturn false;\n\n\t/* only version 3 or greater inodes are extensively verified here */\n\tif (dip->di_version < 3)\n\t\treturn true;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn false;\n\tif (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF))\n\t\treturn false;\n\tif (be64_to_cpu(dip->di_ino) != ip->i_ino)\n\t\treturn false;\n\tif (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_dinode_to_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
    "lines": "240-287",
    "snippet": "void\nxfs_dinode_to_disk(\n\txfs_dinode_t\t\t*to,\n\txfs_icdinode_t\t\t*from)\n{\n\tto->di_magic = cpu_to_be16(from->di_magic);\n\tto->di_mode = cpu_to_be16(from->di_mode);\n\tto->di_version = from ->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = cpu_to_be16(from->di_onlink);\n\tto->di_uid = cpu_to_be32(from->di_uid);\n\tto->di_gid = cpu_to_be32(from->di_gid);\n\tto->di_nlink = cpu_to_be32(from->di_nlink);\n\tto->di_projid_lo = cpu_to_be16(from->di_projid_lo);\n\tto->di_projid_hi = cpu_to_be16(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\tto->di_atime.t_sec = cpu_to_be32(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = cpu_to_be32(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = cpu_to_be32(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = cpu_to_be32(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = cpu_to_be32(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = cpu_to_be32(from->di_ctime.t_nsec);\n\tto->di_size = cpu_to_be64(from->di_size);\n\tto->di_nblocks = cpu_to_be64(from->di_nblocks);\n\tto->di_extsize = cpu_to_be32(from->di_extsize);\n\tto->di_nextents = cpu_to_be32(from->di_nextents);\n\tto->di_anextents = cpu_to_be16(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat = from->di_aformat;\n\tto->di_dmevmask = cpu_to_be32(from->di_dmevmask);\n\tto->di_dmstate = cpu_to_be16(from->di_dmstate);\n\tto->di_flags = cpu_to_be16(from->di_flags);\n\tto->di_gen = cpu_to_be32(from->di_gen);\n\n\tif (from->di_version == 3) {\n\t\tto->di_changecount = cpu_to_be64(from->di_changecount);\n\t\tto->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = cpu_to_be64(from->di_flags2);\n\t\tto->di_ino = cpu_to_be64(from->di_ino);\n\t\tto->di_lsn = cpu_to_be64(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t\tto->di_flushiter = 0;\n\t} else {\n\t\tto->di_flushiter = cpu_to_be16(from->di_flushiter);\n\t}\n}",
    "includes": [
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->di_flushiter"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&to->di_uuid",
            "&from->di_uuid"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to->di_pad2",
            "from->di_pad2",
            "sizeof(to->di_pad2)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->di_lsn"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->di_ino"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->di_flags2"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_crtime.t_nsec"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_crtime.t_sec"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->di_changecount"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_gen"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->di_flags"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->di_dmstate"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_dmevmask"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->di_anextents"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_nextents"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_extsize"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->di_nblocks"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->di_size"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_ctime.t_nsec"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_ctime.t_sec"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_mtime.t_nsec"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_mtime.t_sec"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_atime.t_nsec"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_atime.t_sec"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to->di_pad",
            "from->di_pad",
            "sizeof(to->di_pad)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->di_projid_hi"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->di_projid_lo"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_nlink"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_gid"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->di_uid"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->di_onlink"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->di_mode"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->di_magic"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_to_disk(\n\txfs_dinode_t\t\t*to,\n\txfs_icdinode_t\t\t*from)\n{\n\tto->di_magic = cpu_to_be16(from->di_magic);\n\tto->di_mode = cpu_to_be16(from->di_mode);\n\tto->di_version = from ->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = cpu_to_be16(from->di_onlink);\n\tto->di_uid = cpu_to_be32(from->di_uid);\n\tto->di_gid = cpu_to_be32(from->di_gid);\n\tto->di_nlink = cpu_to_be32(from->di_nlink);\n\tto->di_projid_lo = cpu_to_be16(from->di_projid_lo);\n\tto->di_projid_hi = cpu_to_be16(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\tto->di_atime.t_sec = cpu_to_be32(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = cpu_to_be32(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = cpu_to_be32(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = cpu_to_be32(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = cpu_to_be32(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = cpu_to_be32(from->di_ctime.t_nsec);\n\tto->di_size = cpu_to_be64(from->di_size);\n\tto->di_nblocks = cpu_to_be64(from->di_nblocks);\n\tto->di_extsize = cpu_to_be32(from->di_extsize);\n\tto->di_nextents = cpu_to_be32(from->di_nextents);\n\tto->di_anextents = cpu_to_be16(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat = from->di_aformat;\n\tto->di_dmevmask = cpu_to_be32(from->di_dmevmask);\n\tto->di_dmstate = cpu_to_be16(from->di_dmstate);\n\tto->di_flags = cpu_to_be16(from->di_flags);\n\tto->di_gen = cpu_to_be32(from->di_gen);\n\n\tif (from->di_version == 3) {\n\t\tto->di_changecount = cpu_to_be64(from->di_changecount);\n\t\tto->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = cpu_to_be64(from->di_flags2);\n\t\tto->di_ino = cpu_to_be64(from->di_ino);\n\t\tto->di_lsn = cpu_to_be64(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t\tto->di_flushiter = 0;\n\t} else {\n\t\tto->di_flushiter = cpu_to_be16(from->di_flushiter);\n\t}\n}"
  },
  {
    "function_name": "xfs_dinode_from_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
    "lines": "193-238",
    "snippet": "void\nxfs_dinode_from_disk(\n\txfs_icdinode_t\t\t*to,\n\txfs_dinode_t\t\t*from)\n{\n\tto->di_magic = be16_to_cpu(from->di_magic);\n\tto->di_mode = be16_to_cpu(from->di_mode);\n\tto->di_version = from ->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = be16_to_cpu(from->di_onlink);\n\tto->di_uid = be32_to_cpu(from->di_uid);\n\tto->di_gid = be32_to_cpu(from->di_gid);\n\tto->di_nlink = be32_to_cpu(from->di_nlink);\n\tto->di_projid_lo = be16_to_cpu(from->di_projid_lo);\n\tto->di_projid_hi = be16_to_cpu(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\tto->di_flushiter = be16_to_cpu(from->di_flushiter);\n\tto->di_atime.t_sec = be32_to_cpu(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = be32_to_cpu(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = be32_to_cpu(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = be32_to_cpu(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = be32_to_cpu(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = be32_to_cpu(from->di_ctime.t_nsec);\n\tto->di_size = be64_to_cpu(from->di_size);\n\tto->di_nblocks = be64_to_cpu(from->di_nblocks);\n\tto->di_extsize = be32_to_cpu(from->di_extsize);\n\tto->di_nextents = be32_to_cpu(from->di_nextents);\n\tto->di_anextents = be16_to_cpu(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat\t= from->di_aformat;\n\tto->di_dmevmask\t= be32_to_cpu(from->di_dmevmask);\n\tto->di_dmstate\t= be16_to_cpu(from->di_dmstate);\n\tto->di_flags\t= be16_to_cpu(from->di_flags);\n\tto->di_gen\t= be32_to_cpu(from->di_gen);\n\n\tif (to->di_version == 3) {\n\t\tto->di_changecount = be64_to_cpu(from->di_changecount);\n\t\tto->di_crtime.t_sec = be32_to_cpu(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = be32_to_cpu(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = be64_to_cpu(from->di_flags2);\n\t\tto->di_ino = be64_to_cpu(from->di_ino);\n\t\tto->di_lsn = be64_to_cpu(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t}\n}",
    "includes": [
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&to->di_uuid",
            "&from->di_uuid"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to->di_pad2",
            "from->di_pad2",
            "sizeof(to->di_pad2)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->di_lsn"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->di_ino"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->di_flags2"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_crtime.t_nsec"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_crtime.t_sec"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->di_changecount"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_gen"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->di_flags"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->di_dmstate"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_dmevmask"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->di_anextents"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_nextents"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_extsize"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->di_nblocks"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->di_size"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_ctime.t_nsec"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_ctime.t_sec"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_mtime.t_nsec"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_mtime.t_sec"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_atime.t_nsec"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_atime.t_sec"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->di_flushiter"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to->di_pad",
            "from->di_pad",
            "sizeof(to->di_pad)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->di_projid_hi"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->di_projid_lo"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_nlink"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_gid"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->di_uid"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->di_onlink"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->di_mode"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->di_magic"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dinode_from_disk(\n\txfs_icdinode_t\t\t*to,\n\txfs_dinode_t\t\t*from)\n{\n\tto->di_magic = be16_to_cpu(from->di_magic);\n\tto->di_mode = be16_to_cpu(from->di_mode);\n\tto->di_version = from ->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = be16_to_cpu(from->di_onlink);\n\tto->di_uid = be32_to_cpu(from->di_uid);\n\tto->di_gid = be32_to_cpu(from->di_gid);\n\tto->di_nlink = be32_to_cpu(from->di_nlink);\n\tto->di_projid_lo = be16_to_cpu(from->di_projid_lo);\n\tto->di_projid_hi = be16_to_cpu(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\tto->di_flushiter = be16_to_cpu(from->di_flushiter);\n\tto->di_atime.t_sec = be32_to_cpu(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = be32_to_cpu(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = be32_to_cpu(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = be32_to_cpu(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = be32_to_cpu(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = be32_to_cpu(from->di_ctime.t_nsec);\n\tto->di_size = be64_to_cpu(from->di_size);\n\tto->di_nblocks = be64_to_cpu(from->di_nblocks);\n\tto->di_extsize = be32_to_cpu(from->di_extsize);\n\tto->di_nextents = be32_to_cpu(from->di_nextents);\n\tto->di_anextents = be16_to_cpu(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat\t= from->di_aformat;\n\tto->di_dmevmask\t= be32_to_cpu(from->di_dmevmask);\n\tto->di_dmstate\t= be16_to_cpu(from->di_dmstate);\n\tto->di_flags\t= be16_to_cpu(from->di_flags);\n\tto->di_gen\t= be32_to_cpu(from->di_gen);\n\n\tif (to->di_version == 3) {\n\t\tto->di_changecount = be64_to_cpu(from->di_changecount);\n\t\tto->di_crtime.t_sec = be32_to_cpu(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = be32_to_cpu(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = be64_to_cpu(from->di_flags2);\n\t\tto->di_ino = be64_to_cpu(from->di_ino);\n\t\tto->di_lsn = be64_to_cpu(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t}\n}"
  },
  {
    "function_name": "xfs_imap_to_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
    "lines": "156-191",
    "snippet": "int\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED &&\n\t\t    (iget_flags & XFS_IGET_UNTRUSTED))\n\t\t\treturn -EINVAL;\n\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = (struct xfs_dinode *)xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_offset",
          "args": [
            "bp",
            "imap->im_boffset"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1422-1435",
          "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: xfs_trans_read_buf() returned error %d.\"",
            "__func__",
            "error"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "buf_flags & XBF_TRYLOCK"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "tp",
            "mp->m_ddev_targp",
            "imap->im_blkno",
            "(int)imap->im_len",
            "buf_flags",
            "&bp",
            "&xfs_inode_buf_ops"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};\n\nint\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED &&\n\t\t    (iget_flags & XFS_IGET_UNTRUSTED))\n\t\t\treturn -EINVAL;\n\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = (struct xfs_dinode *)xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_inode_buf_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
    "lines": "129-134",
    "snippet": "static void\nxfs_inode_buf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_inode_buf_verify(bp, false);\n}",
    "includes": [
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inode_buf_verify",
          "args": [
            "bp",
            "false"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_buf_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "72-112",
          "snippet": "static void\nxfs_inode_buf_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\treadahead)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tint\t\ti;\n\tint\t\tni;\n\n\t/*\n\t * Validate the magic number and version of every inode in the buffer\n\t */\n\tni = XFS_BB_TO_FSB(mp, bp->b_length) * mp->m_sb.sb_inopblock;\n\tfor (i = 0; i < ni; i++) {\n\t\tint\t\tdi_ok;\n\t\txfs_dinode_t\t*dip;\n\n\t\tdip = (struct xfs_dinode *)xfs_buf_offset(bp,\n\t\t\t\t\t(i << mp->m_sb.sb_inodelog));\n\t\tdi_ok = dip->di_magic == cpu_to_be16(XFS_DINODE_MAGIC) &&\n\t\t\t    XFS_DINODE_GOOD_VERSION(dip->di_version);\n\t\tif (unlikely(XFS_TEST_ERROR(!di_ok, mp,\n\t\t\t\t\t\tXFS_ERRTAG_ITOBP_INOTOBP,\n\t\t\t\t\t\tXFS_RANDOM_ITOBP_INOTOBP))) {\n\t\t\tif (readahead) {\n\t\t\t\tbp->b_flags &= ~XBF_DONE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\txfs_verifier_error(bp);\n#ifdef DEBUG\n\t\t\txfs_alert(mp,\n\t\t\t\t\"bad inode magic/vsn daddr %lld #%d (magic=%x)\",\n\t\t\t\t(unsigned long long)bp->b_bn, i,\n\t\t\t\tbe16_to_cpu(dip->di_magic));\n#endif\n\t\t}\n\t}\n\txfs_inobp_check(mp, bp);\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_inode_buf_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\treadahead)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tint\t\ti;\n\tint\t\tni;\n\n\t/*\n\t * Validate the magic number and version of every inode in the buffer\n\t */\n\tni = XFS_BB_TO_FSB(mp, bp->b_length) * mp->m_sb.sb_inopblock;\n\tfor (i = 0; i < ni; i++) {\n\t\tint\t\tdi_ok;\n\t\txfs_dinode_t\t*dip;\n\n\t\tdip = (struct xfs_dinode *)xfs_buf_offset(bp,\n\t\t\t\t\t(i << mp->m_sb.sb_inodelog));\n\t\tdi_ok = dip->di_magic == cpu_to_be16(XFS_DINODE_MAGIC) &&\n\t\t\t    XFS_DINODE_GOOD_VERSION(dip->di_version);\n\t\tif (unlikely(XFS_TEST_ERROR(!di_ok, mp,\n\t\t\t\t\t\tXFS_ERRTAG_ITOBP_INOTOBP,\n\t\t\t\t\t\tXFS_RANDOM_ITOBP_INOTOBP))) {\n\t\t\tif (readahead) {\n\t\t\t\tbp->b_flags &= ~XBF_DONE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\txfs_verifier_error(bp);\n#ifdef DEBUG\n\t\t\txfs_alert(mp,\n\t\t\t\t\"bad inode magic/vsn daddr %lld #%d (magic=%x)\",\n\t\t\t\t(unsigned long long)bp->b_bn, i,\n\t\t\t\tbe16_to_cpu(dip->di_magic));\n#endif\n\t\t}\n\t}\n\txfs_inobp_check(mp, bp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_inode_buf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_inode_buf_verify(bp, false);\n}"
  },
  {
    "function_name": "xfs_inode_buf_readahead_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
    "lines": "122-127",
    "snippet": "static void\nxfs_inode_buf_readahead_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_inode_buf_verify(bp, true);\n}",
    "includes": [
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inode_buf_verify",
          "args": [
            "bp",
            "true"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_buf_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "72-112",
          "snippet": "static void\nxfs_inode_buf_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\treadahead)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tint\t\ti;\n\tint\t\tni;\n\n\t/*\n\t * Validate the magic number and version of every inode in the buffer\n\t */\n\tni = XFS_BB_TO_FSB(mp, bp->b_length) * mp->m_sb.sb_inopblock;\n\tfor (i = 0; i < ni; i++) {\n\t\tint\t\tdi_ok;\n\t\txfs_dinode_t\t*dip;\n\n\t\tdip = (struct xfs_dinode *)xfs_buf_offset(bp,\n\t\t\t\t\t(i << mp->m_sb.sb_inodelog));\n\t\tdi_ok = dip->di_magic == cpu_to_be16(XFS_DINODE_MAGIC) &&\n\t\t\t    XFS_DINODE_GOOD_VERSION(dip->di_version);\n\t\tif (unlikely(XFS_TEST_ERROR(!di_ok, mp,\n\t\t\t\t\t\tXFS_ERRTAG_ITOBP_INOTOBP,\n\t\t\t\t\t\tXFS_RANDOM_ITOBP_INOTOBP))) {\n\t\t\tif (readahead) {\n\t\t\t\tbp->b_flags &= ~XBF_DONE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\txfs_verifier_error(bp);\n#ifdef DEBUG\n\t\t\txfs_alert(mp,\n\t\t\t\t\"bad inode magic/vsn daddr %lld #%d (magic=%x)\",\n\t\t\t\t(unsigned long long)bp->b_bn, i,\n\t\t\t\tbe16_to_cpu(dip->di_magic));\n#endif\n\t\t}\n\t}\n\txfs_inobp_check(mp, bp);\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_inode_buf_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\treadahead)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tint\t\ti;\n\tint\t\tni;\n\n\t/*\n\t * Validate the magic number and version of every inode in the buffer\n\t */\n\tni = XFS_BB_TO_FSB(mp, bp->b_length) * mp->m_sb.sb_inopblock;\n\tfor (i = 0; i < ni; i++) {\n\t\tint\t\tdi_ok;\n\t\txfs_dinode_t\t*dip;\n\n\t\tdip = (struct xfs_dinode *)xfs_buf_offset(bp,\n\t\t\t\t\t(i << mp->m_sb.sb_inodelog));\n\t\tdi_ok = dip->di_magic == cpu_to_be16(XFS_DINODE_MAGIC) &&\n\t\t\t    XFS_DINODE_GOOD_VERSION(dip->di_version);\n\t\tif (unlikely(XFS_TEST_ERROR(!di_ok, mp,\n\t\t\t\t\t\tXFS_ERRTAG_ITOBP_INOTOBP,\n\t\t\t\t\t\tXFS_RANDOM_ITOBP_INOTOBP))) {\n\t\t\tif (readahead) {\n\t\t\t\tbp->b_flags &= ~XBF_DONE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\txfs_verifier_error(bp);\n#ifdef DEBUG\n\t\t\txfs_alert(mp,\n\t\t\t\t\"bad inode magic/vsn daddr %lld #%d (magic=%x)\",\n\t\t\t\t(unsigned long long)bp->b_bn, i,\n\t\t\t\tbe16_to_cpu(dip->di_magic));\n#endif\n\t\t}\n\t}\n\txfs_inobp_check(mp, bp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_inode_buf_readahead_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_inode_buf_verify(bp, true);\n}"
  },
  {
    "function_name": "xfs_inode_buf_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
    "lines": "115-120",
    "snippet": "static void\nxfs_inode_buf_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_inode_buf_verify(bp, false);\n}",
    "includes": [
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inode_buf_verify",
          "args": [
            "bp",
            "false"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_buf_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "72-112",
          "snippet": "static void\nxfs_inode_buf_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\treadahead)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tint\t\ti;\n\tint\t\tni;\n\n\t/*\n\t * Validate the magic number and version of every inode in the buffer\n\t */\n\tni = XFS_BB_TO_FSB(mp, bp->b_length) * mp->m_sb.sb_inopblock;\n\tfor (i = 0; i < ni; i++) {\n\t\tint\t\tdi_ok;\n\t\txfs_dinode_t\t*dip;\n\n\t\tdip = (struct xfs_dinode *)xfs_buf_offset(bp,\n\t\t\t\t\t(i << mp->m_sb.sb_inodelog));\n\t\tdi_ok = dip->di_magic == cpu_to_be16(XFS_DINODE_MAGIC) &&\n\t\t\t    XFS_DINODE_GOOD_VERSION(dip->di_version);\n\t\tif (unlikely(XFS_TEST_ERROR(!di_ok, mp,\n\t\t\t\t\t\tXFS_ERRTAG_ITOBP_INOTOBP,\n\t\t\t\t\t\tXFS_RANDOM_ITOBP_INOTOBP))) {\n\t\t\tif (readahead) {\n\t\t\t\tbp->b_flags &= ~XBF_DONE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\txfs_verifier_error(bp);\n#ifdef DEBUG\n\t\t\txfs_alert(mp,\n\t\t\t\t\"bad inode magic/vsn daddr %lld #%d (magic=%x)\",\n\t\t\t\t(unsigned long long)bp->b_bn, i,\n\t\t\t\tbe16_to_cpu(dip->di_magic));\n#endif\n\t\t}\n\t}\n\txfs_inobp_check(mp, bp);\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_inode_buf_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\treadahead)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tint\t\ti;\n\tint\t\tni;\n\n\t/*\n\t * Validate the magic number and version of every inode in the buffer\n\t */\n\tni = XFS_BB_TO_FSB(mp, bp->b_length) * mp->m_sb.sb_inopblock;\n\tfor (i = 0; i < ni; i++) {\n\t\tint\t\tdi_ok;\n\t\txfs_dinode_t\t*dip;\n\n\t\tdip = (struct xfs_dinode *)xfs_buf_offset(bp,\n\t\t\t\t\t(i << mp->m_sb.sb_inodelog));\n\t\tdi_ok = dip->di_magic == cpu_to_be16(XFS_DINODE_MAGIC) &&\n\t\t\t    XFS_DINODE_GOOD_VERSION(dip->di_version);\n\t\tif (unlikely(XFS_TEST_ERROR(!di_ok, mp,\n\t\t\t\t\t\tXFS_ERRTAG_ITOBP_INOTOBP,\n\t\t\t\t\t\tXFS_RANDOM_ITOBP_INOTOBP))) {\n\t\t\tif (readahead) {\n\t\t\t\tbp->b_flags &= ~XBF_DONE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\txfs_verifier_error(bp);\n#ifdef DEBUG\n\t\t\txfs_alert(mp,\n\t\t\t\t\"bad inode magic/vsn daddr %lld #%d (magic=%x)\",\n\t\t\t\t(unsigned long long)bp->b_bn, i,\n\t\t\t\tbe16_to_cpu(dip->di_magic));\n#endif\n\t\t}\n\t}\n\txfs_inobp_check(mp, bp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_inode_buf_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_inode_buf_verify(bp, false);\n}"
  },
  {
    "function_name": "xfs_inode_buf_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
    "lines": "72-112",
    "snippet": "static void\nxfs_inode_buf_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\treadahead)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tint\t\ti;\n\tint\t\tni;\n\n\t/*\n\t * Validate the magic number and version of every inode in the buffer\n\t */\n\tni = XFS_BB_TO_FSB(mp, bp->b_length) * mp->m_sb.sb_inopblock;\n\tfor (i = 0; i < ni; i++) {\n\t\tint\t\tdi_ok;\n\t\txfs_dinode_t\t*dip;\n\n\t\tdip = (struct xfs_dinode *)xfs_buf_offset(bp,\n\t\t\t\t\t(i << mp->m_sb.sb_inodelog));\n\t\tdi_ok = dip->di_magic == cpu_to_be16(XFS_DINODE_MAGIC) &&\n\t\t\t    XFS_DINODE_GOOD_VERSION(dip->di_version);\n\t\tif (unlikely(XFS_TEST_ERROR(!di_ok, mp,\n\t\t\t\t\t\tXFS_ERRTAG_ITOBP_INOTOBP,\n\t\t\t\t\t\tXFS_RANDOM_ITOBP_INOTOBP))) {\n\t\t\tif (readahead) {\n\t\t\t\tbp->b_flags &= ~XBF_DONE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\txfs_verifier_error(bp);\n#ifdef DEBUG\n\t\t\txfs_alert(mp,\n\t\t\t\t\"bad inode magic/vsn daddr %lld #%d (magic=%x)\",\n\t\t\t\t(unsigned long long)bp->b_bn, i,\n\t\t\t\tbe16_to_cpu(dip->di_magic));\n#endif\n\t\t}\n\t}\n\txfs_inobp_check(mp, bp);\n}",
    "includes": [
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inobp_check",
          "args": [
            "mp",
            "bp"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "37-57",
          "snippet": "void\nxfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = (xfs_dinode_t *)xfs_buf_offset(bp,\n\t\t\t\t\ti * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = (xfs_dinode_t *)xfs_buf_offset(bp,\n\t\t\t\t\ti * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"bad inode magic/vsn daddr %lld #%d (magic=%x)\"",
            "(unsigned long long)bp->b_bn",
            "i",
            "be16_to_cpu(dip->di_magic)"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dip->di_magic"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "XFS_TEST_ERROR(!di_ok, mp,\n\t\t\t\t\t\tXFS_ERRTAG_ITOBP_INOTOBP,\n\t\t\t\t\t\tXFS_RANDOM_ITOBP_INOTOBP)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "!di_ok",
            "mp",
            "XFS_ERRTAG_ITOBP_INOTOBP",
            "XFS_RANDOM_ITOBP_INOTOBP"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DINODE_GOOD_VERSION",
          "args": [
            "dip->di_version"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DINODE_MAGIC"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_offset",
          "args": [
            "bp",
            "(i << mp->m_sb.sb_inodelog)"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1422-1435",
          "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSB",
          "args": [
            "mp",
            "bp->b_length"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_inode_buf_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\treadahead)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tint\t\ti;\n\tint\t\tni;\n\n\t/*\n\t * Validate the magic number and version of every inode in the buffer\n\t */\n\tni = XFS_BB_TO_FSB(mp, bp->b_length) * mp->m_sb.sb_inopblock;\n\tfor (i = 0; i < ni; i++) {\n\t\tint\t\tdi_ok;\n\t\txfs_dinode_t\t*dip;\n\n\t\tdip = (struct xfs_dinode *)xfs_buf_offset(bp,\n\t\t\t\t\t(i << mp->m_sb.sb_inodelog));\n\t\tdi_ok = dip->di_magic == cpu_to_be16(XFS_DINODE_MAGIC) &&\n\t\t\t    XFS_DINODE_GOOD_VERSION(dip->di_version);\n\t\tif (unlikely(XFS_TEST_ERROR(!di_ok, mp,\n\t\t\t\t\t\tXFS_ERRTAG_ITOBP_INOTOBP,\n\t\t\t\t\t\tXFS_RANDOM_ITOBP_INOTOBP))) {\n\t\t\tif (readahead) {\n\t\t\t\tbp->b_flags &= ~XBF_DONE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\txfs_verifier_error(bp);\n#ifdef DEBUG\n\t\t\txfs_alert(mp,\n\t\t\t\t\"bad inode magic/vsn daddr %lld #%d (magic=%x)\",\n\t\t\t\t(unsigned long long)bp->b_bn, i,\n\t\t\t\tbe16_to_cpu(dip->di_magic));\n#endif\n\t\t}\n\t}\n\txfs_inobp_check(mp, bp);\n}"
  },
  {
    "function_name": "xfs_inobp_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
    "lines": "37-57",
    "snippet": "void\nxfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = (xfs_dinode_t *)xfs_buf_offset(bp,\n\t\t\t\t\ti * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\"",
            "i",
            "(long long)bp->b_bn"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_offset",
          "args": [
            "bp",
            "i * mp->m_sb.sb_inodesize"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1422-1435",
          "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = (xfs_dinode_t *)xfs_buf_offset(bp,\n\t\t\t\t\ti * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}"
  }
]