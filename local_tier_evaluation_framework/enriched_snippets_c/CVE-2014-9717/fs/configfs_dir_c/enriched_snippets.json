[
  {
    "function_name": "configfs_unregister_subsystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1687-1721",
    "snippet": "void configfs_unregister_subsystem(struct configfs_subsystem *subsys)\n{\n\tstruct config_group *group = &subsys->su_group;\n\tstruct dentry *dentry = group->cg_item.ci_dentry;\n\tstruct dentry *root = dentry->d_sb->s_root;\n\n\tif (dentry->d_parent != root) {\n\t\tpr_err(\"Tried to unregister non-subsystem!\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock_nested(&root->d_inode->i_mutex,\n\t\t\t  I_MUTEX_PARENT);\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\tmutex_lock(&configfs_symlink_mutex);\n\tspin_lock(&configfs_dirent_lock);\n\tif (configfs_detach_prep(dentry, NULL)) {\n\t\tpr_err(\"Tried to unregister non-empty subsystem!\\n\");\n\t}\n\tspin_unlock(&configfs_dirent_lock);\n\tmutex_unlock(&configfs_symlink_mutex);\n\tconfigfs_detach_group(&group->cg_item);\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\td_delete(dentry);\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\tdput(dentry);\n\n\tunlink_group(group);\n\tconfigfs_release_fs();\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_release_fs",
          "args": [],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_release_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
          "lines": "126-129",
          "snippet": "void configfs_release_fs(void)\n{\n\tsimple_release_fs(&configfs_mount, &configfs_mnt_count);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *configfs_mount = NULL;",
            "static int configfs_mnt_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *configfs_mount = NULL;\nstatic int configfs_mnt_count = 0;\n\nvoid configfs_release_fs(void)\n{\n\tsimple_release_fs(&configfs_mount, &configfs_mnt_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_group",
          "args": [
            "group"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "751-765",
          "snippet": "static void unlink_group(struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tunlink_group(new_group);\n\t\t}\n\t}\n\n\tgroup->cg_subsys = NULL;\n\tunlink_obj(&group->cg_item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void unlink_group(struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tunlink_group(new_group);\n\t\t}\n\t}\n\n\tgroup->cg_subsys = NULL;\n\tunlink_obj(&group->cg_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dentry"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "afs_d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "699-717",
          "snippet": "static int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
            "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
            "static int afs_d_delete(const struct dentry *dentry);",
            "static void afs_d_release(struct dentry *dentry);",
            "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
            "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
            "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dont_mount",
          "args": [
            "dentry"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_detach_group",
          "args": [
            "&group->cg_item"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_detach_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "879-883",
          "snippet": "static void configfs_detach_group(struct config_item *item)\n{\n\tdetach_groups(to_config_group(item));\n\tconfigfs_detach_item(item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void configfs_detach_group(struct config_item *item)\n{\n\tdetach_groups(to_config_group(item));\n\tconfigfs_detach_item(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&configfs_symlink_mutex"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Tried to unregister non-empty subsystem!\\n\""
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_detach_prep",
          "args": [
            "dentry",
            "NULL"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_detach_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "494-535",
          "snippet": "static int configfs_detach_prep(struct dentry *dentry, struct mutex **wait_mutex)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\tint ret;\n\n\t/* Mark that we're trying to drop the group */\n\tparent_sd->s_type |= CONFIGFS_USET_DROPPING;\n\n\tret = -EBUSY;\n\tif (!list_empty(&parent_sd->s_links))\n\t\tgoto out;\n\n\tret = 0;\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    (sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT) {\n\t\t\t/* Abort if racing with mkdir() */\n\t\t\tif (sd->s_type & CONFIGFS_USET_IN_MKDIR) {\n\t\t\t\tif (wait_mutex)\n\t\t\t\t\t*wait_mutex = &sd->s_dentry->d_inode->i_mutex;\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Yup, recursive.  If there's a problem, blame\n\t\t\t * deep nesting of default_groups\n\t\t\t */\n\t\t\tret = configfs_detach_prep(sd->s_dentry, wait_mutex);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\tret = -ENOTEMPTY;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic int configfs_detach_prep(struct dentry *dentry, struct mutex **wait_mutex)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\tint ret;\n\n\t/* Mark that we're trying to drop the group */\n\tparent_sd->s_type |= CONFIGFS_USET_DROPPING;\n\n\tret = -EBUSY;\n\tif (!list_empty(&parent_sd->s_links))\n\t\tgoto out;\n\n\tret = 0;\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    (sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT) {\n\t\t\t/* Abort if racing with mkdir() */\n\t\t\tif (sd->s_type & CONFIGFS_USET_IN_MKDIR) {\n\t\t\t\tif (wait_mutex)\n\t\t\t\t\t*wait_mutex = &sd->s_dentry->d_inode->i_mutex;\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Yup, recursive.  If there's a problem, blame\n\t\t\t * deep nesting of default_groups\n\t\t\t */\n\t\t\tret = configfs_detach_prep(sd->s_dentry, wait_mutex);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\tret = -ENOTEMPTY;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&configfs_symlink_mutex"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dentry->d_inode->i_mutex",
            "I_MUTEX_CHILD"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&root->d_inode->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Tried to unregister non-subsystem!\\n\""
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nvoid configfs_unregister_subsystem(struct configfs_subsystem *subsys)\n{\n\tstruct config_group *group = &subsys->su_group;\n\tstruct dentry *dentry = group->cg_item.ci_dentry;\n\tstruct dentry *root = dentry->d_sb->s_root;\n\n\tif (dentry->d_parent != root) {\n\t\tpr_err(\"Tried to unregister non-subsystem!\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock_nested(&root->d_inode->i_mutex,\n\t\t\t  I_MUTEX_PARENT);\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\tmutex_lock(&configfs_symlink_mutex);\n\tspin_lock(&configfs_dirent_lock);\n\tif (configfs_detach_prep(dentry, NULL)) {\n\t\tpr_err(\"Tried to unregister non-empty subsystem!\\n\");\n\t}\n\tspin_unlock(&configfs_dirent_lock);\n\tmutex_unlock(&configfs_symlink_mutex);\n\tconfigfs_detach_group(&group->cg_item);\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\td_delete(dentry);\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\tdput(dentry);\n\n\tunlink_group(group);\n\tconfigfs_release_fs();\n}"
  },
  {
    "function_name": "configfs_register_subsystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1639-1685",
    "snippet": "int configfs_register_subsystem(struct configfs_subsystem *subsys)\n{\n\tint err;\n\tstruct config_group *group = &subsys->su_group;\n\tstruct dentry *dentry;\n\tstruct dentry *root;\n\tstruct configfs_dirent *sd;\n\n\troot = configfs_pin_fs();\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tif (!group->cg_item.ci_name)\n\t\tgroup->cg_item.ci_name = group->cg_item.ci_namebuf;\n\n\tsd = root->d_fsdata;\n\tlink_group(to_config_group(sd->s_element), group);\n\n\tmutex_lock_nested(&root->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\terr = -ENOMEM;\n\tdentry = d_alloc_name(root, group->cg_item.ci_name);\n\tif (dentry) {\n\t\td_add(dentry, NULL);\n\n\t\terr = configfs_attach_group(sd->s_element, &group->cg_item,\n\t\t\t\t\t    dentry);\n\t\tif (err) {\n\t\t\tBUG_ON(dentry->d_inode);\n\t\t\td_drop(dentry);\n\t\t\tdput(dentry);\n\t\t} else {\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tconfigfs_dir_set_ready(dentry->d_fsdata);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t}\n\t}\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\tif (err) {\n\t\tunlink_group(group);\n\t\tconfigfs_release_fs();\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_release_fs",
          "args": [],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_release_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
          "lines": "126-129",
          "snippet": "void configfs_release_fs(void)\n{\n\tsimple_release_fs(&configfs_mount, &configfs_mnt_count);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *configfs_mount = NULL;",
            "static int configfs_mnt_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *configfs_mount = NULL;\nstatic int configfs_mnt_count = 0;\n\nvoid configfs_release_fs(void)\n{\n\tsimple_release_fs(&configfs_mount, &configfs_mnt_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_group",
          "args": [
            "group"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "751-765",
          "snippet": "static void unlink_group(struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tunlink_group(new_group);\n\t\t}\n\t}\n\n\tgroup->cg_subsys = NULL;\n\tunlink_obj(&group->cg_item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void unlink_group(struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tunlink_group(new_group);\n\t\t}\n\t}\n\n\tgroup->cg_subsys = NULL;\n\tunlink_obj(&group->cg_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_dir_set_ready",
          "args": [
            "dentry->d_fsdata"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_dir_set_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "313-321",
          "snippet": "static void configfs_dir_set_ready(struct configfs_dirent *sd)\n{\n\tstruct configfs_dirent *child_sd;\n\n\tsd->s_type &= ~CONFIGFS_USET_CREATING;\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling)\n\t\tif (child_sd->s_type & CONFIGFS_USET_CREATING)\n\t\t\tconfigfs_dir_set_ready(child_sd);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_dir_set_ready(struct configfs_dirent *sd)\n{\n\tstruct configfs_dirent *child_sd;\n\n\tsd->s_type &= ~CONFIGFS_USET_CREATING;\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling)\n\t\tif (child_sd->s_type & CONFIGFS_USET_CREATING)\n\t\t\tconfigfs_dir_set_ready(child_sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_attach_group",
          "args": [
            "sd->s_element",
            "&group->cg_item",
            "dentry"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_attach_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "840-876",
          "snippet": "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\n\tret = configfs_attach_item(parent_item, item, dentry);\n\tif (!ret) {\n\t\tsd = dentry->d_fsdata;\n\t\tsd->s_type |= CONFIGFS_USET_DIR;\n\n\t\t/*\n\t\t * FYI, we're faking mkdir in populate_groups()\n\t\t * We must lock the group's inode to avoid races with the VFS\n\t\t * which can already hit the inode and try to add/remove entries\n\t\t * under it.\n\t\t *\n\t\t * We must also lock the inode to remove it safely in case of\n\t\t * error, as rmdir() would.\n\t\t */\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\tconfigfs_adjust_dir_dirent_depth_before_populate(sd);\n\t\tret = populate_groups(to_config_group(item));\n\t\tif (ret) {\n\t\t\tconfigfs_detach_item(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t}\n\t\tconfigfs_adjust_dir_dirent_depth_after_populate(sd);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\tif (ret)\n\t\t\td_delete(dentry);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\n\tret = configfs_attach_item(parent_item, item, dentry);\n\tif (!ret) {\n\t\tsd = dentry->d_fsdata;\n\t\tsd->s_type |= CONFIGFS_USET_DIR;\n\n\t\t/*\n\t\t * FYI, we're faking mkdir in populate_groups()\n\t\t * We must lock the group's inode to avoid races with the VFS\n\t\t * which can already hit the inode and try to add/remove entries\n\t\t * under it.\n\t\t *\n\t\t * We must also lock the inode to remove it safely in case of\n\t\t * error, as rmdir() would.\n\t\t */\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\tconfigfs_adjust_dir_dirent_depth_before_populate(sd);\n\t\tret = populate_groups(to_config_group(item));\n\t\tif (ret) {\n\t\t\tconfigfs_detach_item(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t}\n\t\tconfigfs_adjust_dir_dirent_depth_after_populate(sd);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\tif (ret)\n\t\t\td_delete(dentry);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "NULL"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "root",
            "group->cg_item.ci_name"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&root->d_inode->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_group",
          "args": [
            "to_config_group(sd->s_element)",
            "group"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "link_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "767-789",
          "snippet": "static void link_group(struct config_group *parent_group, struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\tstruct configfs_subsystem *subsys = NULL; /* gcc is a turd */\n\n\tlink_obj(&parent_group->cg_item, &group->cg_item);\n\n\tif (parent_group->cg_subsys)\n\t\tsubsys = parent_group->cg_subsys;\n\telse if (configfs_is_root(&parent_group->cg_item))\n\t\tsubsys = to_configfs_subsystem(group);\n\telse\n\t\tBUG();\n\tgroup->cg_subsys = subsys;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tlink_group(group, new_group);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void link_group(struct config_group *parent_group, struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\tstruct configfs_subsystem *subsys = NULL; /* gcc is a turd */\n\n\tlink_obj(&parent_group->cg_item, &group->cg_item);\n\n\tif (parent_group->cg_subsys)\n\t\tsubsys = parent_group->cg_subsys;\n\telse if (configfs_is_root(&parent_group->cg_item))\n\t\tsubsys = to_configfs_subsystem(group);\n\telse\n\t\tBUG();\n\tgroup->cg_subsys = subsys;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tlink_group(group, new_group);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "sd->s_element"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_pin_fs",
          "args": [],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_pin_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
          "lines": "119-124",
          "snippet": "struct dentry *configfs_pin_fs(void)\n{\n\tint err = simple_pin_fs(&configfs_fs_type, &configfs_mount,\n\t\t\t     &configfs_mnt_count);\n\treturn err ? ERR_PTR(err) : configfs_mount->mnt_root;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *configfs_mount = NULL;",
            "static int configfs_mnt_count = 0;",
            "static struct file_system_type configfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"configfs\",\n\t.mount\t\t= configfs_do_mount,\n\t.kill_sb\t= kill_litter_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *configfs_mount = NULL;\nstatic int configfs_mnt_count = 0;\nstatic struct file_system_type configfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"configfs\",\n\t.mount\t\t= configfs_do_mount,\n\t.kill_sb\t= kill_litter_super,\n};\n\nstruct dentry *configfs_pin_fs(void)\n{\n\tint err = simple_pin_fs(&configfs_fs_type, &configfs_mount,\n\t\t\t     &configfs_mnt_count);\n\treturn err ? ERR_PTR(err) : configfs_mount->mnt_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nint configfs_register_subsystem(struct configfs_subsystem *subsys)\n{\n\tint err;\n\tstruct config_group *group = &subsys->su_group;\n\tstruct dentry *dentry;\n\tstruct dentry *root;\n\tstruct configfs_dirent *sd;\n\n\troot = configfs_pin_fs();\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tif (!group->cg_item.ci_name)\n\t\tgroup->cg_item.ci_name = group->cg_item.ci_namebuf;\n\n\tsd = root->d_fsdata;\n\tlink_group(to_config_group(sd->s_element), group);\n\n\tmutex_lock_nested(&root->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\terr = -ENOMEM;\n\tdentry = d_alloc_name(root, group->cg_item.ci_name);\n\tif (dentry) {\n\t\td_add(dentry, NULL);\n\n\t\terr = configfs_attach_group(sd->s_element, &group->cg_item,\n\t\t\t\t\t    dentry);\n\t\tif (err) {\n\t\t\tBUG_ON(dentry->d_inode);\n\t\t\td_drop(dentry);\n\t\t\tdput(dentry);\n\t\t} else {\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tconfigfs_dir_set_ready(dentry->d_fsdata);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t}\n\t}\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\tif (err) {\n\t\tunlink_group(group);\n\t\tconfigfs_release_fs();\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "configfs_dir_lseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1589-1629",
    "snippet": "static loff_t configfs_dir_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct dentry * dentry = file->f_path.dentry;\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tswitch (whence) {\n\t\tcase 1:\n\t\t\toffset += file->f_pos;\n\t\tcase 0:\n\t\t\tif (offset >= 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tmutex_unlock(&file_inode(file)->i_mutex);\n\t\t\treturn -EINVAL;\n\t}\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tif (file->f_pos >= 2) {\n\t\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\t\tstruct configfs_dirent *cursor = file->private_data;\n\t\t\tstruct list_head *p;\n\t\t\tloff_t n = file->f_pos - 2;\n\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tlist_del(&cursor->s_sibling);\n\t\t\tp = sd->s_children.next;\n\t\t\twhile (n && p != &sd->s_children) {\n\t\t\t\tstruct configfs_dirent *next;\n\t\t\t\tnext = list_entry(p, struct configfs_dirent,\n\t\t\t\t\t\t   s_sibling);\n\t\t\t\tif (next->s_element)\n\t\t\t\t\tn--;\n\t\t\t\tp = p->next;\n\t\t\t}\n\t\t\tlist_add_tail(&cursor->s_sibling, p);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t}\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn offset;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cursor->s_sibling",
            "p"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structconfigfs_dirent",
            "s_sibling"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cursor->s_sibling"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&file_inode(file)->i_mutex"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic loff_t configfs_dir_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct dentry * dentry = file->f_path.dentry;\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tswitch (whence) {\n\t\tcase 1:\n\t\t\toffset += file->f_pos;\n\t\tcase 0:\n\t\t\tif (offset >= 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tmutex_unlock(&file_inode(file)->i_mutex);\n\t\t\treturn -EINVAL;\n\t}\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tif (file->f_pos >= 2) {\n\t\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\t\tstruct configfs_dirent *cursor = file->private_data;\n\t\t\tstruct list_head *p;\n\t\t\tloff_t n = file->f_pos - 2;\n\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tlist_del(&cursor->s_sibling);\n\t\t\tp = sd->s_children.next;\n\t\t\twhile (n && p != &sd->s_children) {\n\t\t\t\tstruct configfs_dirent *next;\n\t\t\t\tnext = list_entry(p, struct configfs_dirent,\n\t\t\t\t\t\t   s_sibling);\n\t\t\t\tif (next->s_element)\n\t\t\t\t\tn--;\n\t\t\t\tp = p->next;\n\t\t\t}\n\t\t\tlist_add_tail(&cursor->s_sibling, p);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t}\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn offset;\n}"
  },
  {
    "function_name": "configfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1525-1587",
    "snippet": "static int configfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct configfs_dirent * parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *cursor = file->private_data;\n\tstruct list_head *p, *q = &cursor->s_sibling;\n\tino_t ino = 0;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\tif (ctx->pos == 2) {\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tlist_move(q, &parent_sd->s_children);\n\t\tspin_unlock(&configfs_dirent_lock);\n\t}\n\tfor (p = q->next; p != &parent_sd->s_children; p = p->next) {\n\t\tstruct configfs_dirent *next;\n\t\tconst char *name;\n\t\tint len;\n\t\tstruct inode *inode = NULL;\n\n\t\tnext = list_entry(p, struct configfs_dirent, s_sibling);\n\t\tif (!next->s_element)\n\t\t\tcontinue;\n\n\t\tname = configfs_get_name(next);\n\t\tlen = strlen(name);\n\n\t\t/*\n\t\t * We'll have a dentry and an inode for\n\t\t * PINNED items and for open attribute\n\t\t * files.  We lock here to prevent a race\n\t\t * with configfs_d_iput() clearing\n\t\t * s_dentry before calling iput().\n\t\t *\n\t\t * Why do we go to the trouble?  If\n\t\t * someone has an attribute file open,\n\t\t * the inode number should match until\n\t\t * they close it.  Beyond that, we don't\n\t\t * care.\n\t\t */\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tdentry = next->s_dentry;\n\t\tif (dentry)\n\t\t\tinode = dentry->d_inode;\n\t\tif (inode)\n\t\t\tino = inode->i_ino;\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tif (!inode)\n\t\t\tino = iunique(sb, 2);\n\n\t\tif (!dir_emit(ctx, name, len, ino, dt_type(next)))\n\t\t\treturn 0;\n\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tlist_move(q, p);\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tp = q;\n\t\tctx->pos++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "q",
            "p"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "name",
            "len",
            "ino",
            "dt_type(next)"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt_type",
          "args": [
            "next"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "dt_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "1520-1523",
          "snippet": "static inline unsigned char dt_type(struct configfs_dirent *sd)\n{\n\treturn (sd->s_mode >> 12) & 15;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline unsigned char dt_type(struct configfs_dirent *sd)\n{\n\treturn (sd->s_mode >> 12) & 15;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iunique",
          "args": [
            "sb",
            "2"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1150-1170",
          "snippet": "ino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_get_name",
          "args": [
            "next"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "211-226",
          "snippet": "const unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nconst unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structconfigfs_dirent",
            "s_sibling"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "q",
            "&parent_sd->s_children"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic int configfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct configfs_dirent * parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *cursor = file->private_data;\n\tstruct list_head *p, *q = &cursor->s_sibling;\n\tino_t ino = 0;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\tif (ctx->pos == 2) {\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tlist_move(q, &parent_sd->s_children);\n\t\tspin_unlock(&configfs_dirent_lock);\n\t}\n\tfor (p = q->next; p != &parent_sd->s_children; p = p->next) {\n\t\tstruct configfs_dirent *next;\n\t\tconst char *name;\n\t\tint len;\n\t\tstruct inode *inode = NULL;\n\n\t\tnext = list_entry(p, struct configfs_dirent, s_sibling);\n\t\tif (!next->s_element)\n\t\t\tcontinue;\n\n\t\tname = configfs_get_name(next);\n\t\tlen = strlen(name);\n\n\t\t/*\n\t\t * We'll have a dentry and an inode for\n\t\t * PINNED items and for open attribute\n\t\t * files.  We lock here to prevent a race\n\t\t * with configfs_d_iput() clearing\n\t\t * s_dentry before calling iput().\n\t\t *\n\t\t * Why do we go to the trouble?  If\n\t\t * someone has an attribute file open,\n\t\t * the inode number should match until\n\t\t * they close it.  Beyond that, we don't\n\t\t * care.\n\t\t */\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tdentry = next->s_dentry;\n\t\tif (dentry)\n\t\t\tinode = dentry->d_inode;\n\t\tif (inode)\n\t\t\tino = inode->i_ino;\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tif (!inode)\n\t\t\tino = iunique(sb, 2);\n\n\t\tif (!dir_emit(ctx, name, len, ino, dt_type(next)))\n\t\t\treturn 0;\n\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tlist_move(q, p);\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tp = q;\n\t\tctx->pos++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dt_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1520-1523",
    "snippet": "static inline unsigned char dt_type(struct configfs_dirent *sd)\n{\n\treturn (sd->s_mode >> 12) & 15;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline unsigned char dt_type(struct configfs_dirent *sd)\n{\n\treturn (sd->s_mode >> 12) & 15;\n}"
  },
  {
    "function_name": "configfs_dir_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1503-1517",
    "snippet": "static int configfs_dir_close(struct inode *inode, struct file *file)\n{\n\tstruct dentry * dentry = file->f_path.dentry;\n\tstruct configfs_dirent * cursor = file->private_data;\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tspin_lock(&configfs_dirent_lock);\n\tlist_del_init(&cursor->s_sibling);\n\tspin_unlock(&configfs_dirent_lock);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\trelease_configfs_dirent(cursor);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_configfs_dirent",
          "args": [
            "cursor"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "release_configfs_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "140-146",
          "snippet": "static inline void release_configfs_dirent(struct configfs_dirent * sd)\n{\n\tif (!(sd->s_type & CONFIGFS_ROOT)) {\n\t\tkfree(sd->s_iattr);\n\t\tkmem_cache_free(configfs_dir_cachep, sd);\n\t}\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define CONFIGFS_ROOT\t\t0x0001"
          ],
          "globals_used": [
            "extern struct kmem_cache *configfs_dir_cachep;",
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#define CONFIGFS_ROOT\t\t0x0001\n\nextern struct kmem_cache *configfs_dir_cachep;\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\n\nstatic inline void release_configfs_dirent(struct configfs_dirent * sd)\n{\n\tif (!(sd->s_type & CONFIGFS_ROOT)) {\n\t\tkfree(sd->s_iattr);\n\t\tkmem_cache_free(configfs_dir_cachep, sd);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cursor->s_sibling"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic int configfs_dir_close(struct inode *inode, struct file *file)\n{\n\tstruct dentry * dentry = file->f_path.dentry;\n\tstruct configfs_dirent * cursor = file->private_data;\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tspin_lock(&configfs_dirent_lock);\n\tlist_del_init(&cursor->s_sibling);\n\tspin_unlock(&configfs_dirent_lock);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\trelease_configfs_dirent(cursor);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "configfs_dir_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1479-1501",
    "snippet": "static int configfs_dir_open(struct inode *inode, struct file *file)\n{\n\tstruct dentry * dentry = file->f_path.dentry;\n\tstruct configfs_dirent * parent_sd = dentry->d_fsdata;\n\tint err;\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\t/*\n\t * Fake invisibility if dir belongs to a group/default groups hierarchy\n\t * being attached\n\t */\n\terr = -ENOENT;\n\tif (configfs_dirent_is_ready(parent_sd)) {\n\t\tfile->private_data = configfs_new_dirent(parent_sd, NULL, 0);\n\t\tif (IS_ERR(file->private_data))\n\t\t\terr = PTR_ERR(file->private_data);\n\t\telse\n\t\t\terr = 0;\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file->private_data"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file->private_data"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_new_dirent",
          "args": [
            "parent_sd",
            "NULL",
            "0"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_new_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "172-197",
          "snippet": "static struct configfs_dirent *configfs_new_dirent(struct configfs_dirent *parent_sd,\n\t\t\t\t\t\t   void *element, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = kmem_cache_zalloc(configfs_dir_cachep, GFP_KERNEL);\n\tif (!sd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&sd->s_count, 1);\n\tINIT_LIST_HEAD(&sd->s_links);\n\tINIT_LIST_HEAD(&sd->s_children);\n\tsd->s_element = element;\n\tsd->s_type = type;\n\tconfigfs_init_dirent_depth(sd);\n\tspin_lock(&configfs_dirent_lock);\n\tif (parent_sd->s_type & CONFIGFS_USET_DROPPING) {\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tkmem_cache_free(configfs_dir_cachep, sd);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tlist_add(&sd->s_sibling, &parent_sd->s_children);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn sd;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct configfs_dirent *configfs_new_dirent(struct configfs_dirent *parent_sd,\n\t\t\t\t\t\t   void *element, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = kmem_cache_zalloc(configfs_dir_cachep, GFP_KERNEL);\n\tif (!sd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&sd->s_count, 1);\n\tINIT_LIST_HEAD(&sd->s_links);\n\tINIT_LIST_HEAD(&sd->s_children);\n\tsd->s_element = element;\n\tsd->s_type = type;\n\tconfigfs_init_dirent_depth(sd);\n\tspin_lock(&configfs_dirent_lock);\n\tif (parent_sd->s_type & CONFIGFS_USET_DROPPING) {\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tkmem_cache_free(configfs_dir_cachep, sd);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tlist_add(&sd->s_sibling, &parent_sd->s_children);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn sd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_dirent_is_ready",
          "args": [
            "parent_sd"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_dirent_is_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "333-342",
          "snippet": "int configfs_dirent_is_ready(struct configfs_dirent *sd)\n{\n\tint ret;\n\n\tspin_lock(&configfs_dirent_lock);\n\tret = !(sd->s_type & CONFIGFS_USET_CREATING);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint configfs_dirent_is_ready(struct configfs_dirent *sd)\n{\n\tint ret;\n\n\tspin_lock(&configfs_dirent_lock);\n\tret = !(sd->s_type & CONFIGFS_USET_CREATING);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic int configfs_dir_open(struct inode *inode, struct file *file)\n{\n\tstruct dentry * dentry = file->f_path.dentry;\n\tstruct configfs_dirent * parent_sd = dentry->d_fsdata;\n\tint err;\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\t/*\n\t * Fake invisibility if dir belongs to a group/default groups hierarchy\n\t * being attached\n\t */\n\terr = -ENOENT;\n\tif (configfs_dirent_is_ready(parent_sd)) {\n\t\tfile->private_data = configfs_new_dirent(parent_sd, NULL, 0);\n\t\tif (IS_ERR(file->private_data))\n\t\t\terr = PTR_ERR(file->private_data);\n\t\telse\n\t\t\terr = 0;\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "configfs_rename_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1442-1476",
    "snippet": "int configfs_rename_dir(struct config_item * item, const char *new_name)\n{\n\tint error = 0;\n\tstruct dentry * new_dentry, * parent;\n\n\tif (!strcmp(config_item_name(item), new_name))\n\t\treturn -EINVAL;\n\n\tif (!item->parent)\n\t\treturn -EINVAL;\n\n\tdown_write(&configfs_rename_sem);\n\tparent = item->parent->dentry;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\n\tnew_dentry = lookup_one_len(new_name, parent, strlen(new_name));\n\tif (!IS_ERR(new_dentry)) {\n\t\tif (!new_dentry->d_inode) {\n\t\t\terror = config_item_set_name(item, \"%s\", new_name);\n\t\t\tif (!error) {\n\t\t\t\td_add(new_dentry, NULL);\n\t\t\t\td_move(item->dentry, new_dentry);\n\t\t\t}\n\t\t\telse\n\t\t\t\td_delete(new_dentry);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tdput(new_dentry);\n\t}\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tup_write(&configfs_rename_sem);\n\n\treturn error;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&configfs_rename_sem"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "new_dentry"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "new_dentry"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "afs_d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "699-717",
          "snippet": "static int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
            "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
            "static int afs_d_delete(const struct dentry *dentry);",
            "static void afs_d_release(struct dentry *dentry);",
            "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
            "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
            "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_move",
          "args": [
            "item->dentry",
            "new_dentry"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "d_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2634-2639",
          "snippet": "void d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nvoid d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "new_dentry",
            "NULL"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_item_set_name",
          "args": [
            "item",
            "\"%s\"",
            "new_name"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_set_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "66-112",
          "snippet": "int config_item_set_name(struct config_item *item, const char *fmt, ...)\n{\n\tint error = 0;\n\tint limit = CONFIGFS_ITEM_NAME_LEN;\n\tint need;\n\tva_list args;\n\tchar *name;\n\n\t/*\n\t * First, try the static array\n\t */\n\tva_start(args, fmt);\n\tneed = vsnprintf(item->ci_namebuf, limit, fmt, args);\n\tva_end(args);\n\tif (need < limit)\n\t\tname = item->ci_namebuf;\n\telse {\n\t\t/*\n\t\t * Need more space? Allocate it and try again\n\t\t */\n\t\tlimit = need + 1;\n\t\tname = kmalloc(limit, GFP_KERNEL);\n\t\tif (!name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto Done;\n\t\t}\n\t\tva_start(args, fmt);\n\t\tneed = vsnprintf(name, limit, fmt, args);\n\t\tva_end(args);\n\n\t\t/* Still? Give up. */\n\t\tif (need >= limit) {\n\t\t\tkfree(name);\n\t\t\terror = -EFAULT;\n\t\t\tgoto Done;\n\t\t}\n\t}\n\n\t/* Free the old name, if necessary. */\n\tif (item->ci_name && item->ci_name != item->ci_namebuf)\n\t\tkfree(item->ci_name);\n\n\t/* Now, set the new name */\n\titem->ci_name = name;\n Done:\n\treturn error;\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nint config_item_set_name(struct config_item *item, const char *fmt, ...)\n{\n\tint error = 0;\n\tint limit = CONFIGFS_ITEM_NAME_LEN;\n\tint need;\n\tva_list args;\n\tchar *name;\n\n\t/*\n\t * First, try the static array\n\t */\n\tva_start(args, fmt);\n\tneed = vsnprintf(item->ci_namebuf, limit, fmt, args);\n\tva_end(args);\n\tif (need < limit)\n\t\tname = item->ci_namebuf;\n\telse {\n\t\t/*\n\t\t * Need more space? Allocate it and try again\n\t\t */\n\t\tlimit = need + 1;\n\t\tname = kmalloc(limit, GFP_KERNEL);\n\t\tif (!name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto Done;\n\t\t}\n\t\tva_start(args, fmt);\n\t\tneed = vsnprintf(name, limit, fmt, args);\n\t\tva_end(args);\n\n\t\t/* Still? Give up. */\n\t\tif (need >= limit) {\n\t\t\tkfree(name);\n\t\t\terror = -EFAULT;\n\t\t\tgoto Done;\n\t\t}\n\t}\n\n\t/* Free the old name, if necessary. */\n\tif (item->ci_name && item->ci_name != item->ci_namebuf)\n\t\tkfree(item->ci_name);\n\n\t/* Now, set the new name */\n\titem->ci_name = name;\n Done:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_dentry"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "new_name",
            "parent",
            "strlen(new_name)"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "new_name"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&configfs_rename_sem"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "config_item_name(item)",
            "new_name"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_item_name",
          "args": [
            "item"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nint configfs_rename_dir(struct config_item * item, const char *new_name)\n{\n\tint error = 0;\n\tstruct dentry * new_dentry, * parent;\n\n\tif (!strcmp(config_item_name(item), new_name))\n\t\treturn -EINVAL;\n\n\tif (!item->parent)\n\t\treturn -EINVAL;\n\n\tdown_write(&configfs_rename_sem);\n\tparent = item->parent->dentry;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\n\tnew_dentry = lookup_one_len(new_name, parent, strlen(new_name));\n\tif (!IS_ERR(new_dentry)) {\n\t\tif (!new_dentry->d_inode) {\n\t\t\terror = config_item_set_name(item, \"%s\", new_name);\n\t\t\tif (!error) {\n\t\t\t\td_add(new_dentry, NULL);\n\t\t\t\td_move(item->dentry, new_dentry);\n\t\t\t}\n\t\t\telse\n\t\t\t\td_delete(new_dentry);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tdput(new_dentry);\n\t}\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tup_write(&configfs_rename_sem);\n\n\treturn error;\n}"
  },
  {
    "function_name": "configfs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1330-1425",
    "snippet": "static int configfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct config_item *parent_item;\n\tstruct config_item *item;\n\tstruct configfs_subsystem *subsys;\n\tstruct configfs_dirent *sd;\n\tstruct module *subsys_owner = NULL, *dead_item_owner = NULL;\n\tint ret;\n\n\tsd = dentry->d_fsdata;\n\tif (sd->s_type & CONFIGFS_USET_DEFAULT)\n\t\treturn -EPERM;\n\n\t/* Get a working ref until we have the child */\n\tparent_item = configfs_get_config_item(dentry->d_parent);\n\tsubsys = to_config_group(parent_item)->cg_subsys;\n\tBUG_ON(!subsys);\n\n\tif (!parent_item->ci_type) {\n\t\tconfig_item_put(parent_item);\n\t\treturn -EINVAL;\n\t}\n\n\t/* configfs_mkdir() shouldn't have allowed this */\n\tBUG_ON(!subsys->su_group.cg_item.ci_type);\n\tsubsys_owner = subsys->su_group.cg_item.ci_type->ct_owner;\n\n\t/*\n\t * Ensure that no racing symlink() will make detach_prep() fail while\n\t * the new link is temporarily attached\n\t */\n\tdo {\n\t\tstruct mutex *wait_mutex;\n\n\t\tmutex_lock(&configfs_symlink_mutex);\n\t\tspin_lock(&configfs_dirent_lock);\n\t\t/*\n\t\t * Here's where we check for dependents.  We're protected by\n\t\t * configfs_dirent_lock.\n\t\t * If no dependent, atomically tag the item as dropping.\n\t\t */\n\t\tret = sd->s_dependent_count ? -EBUSY : 0;\n\t\tif (!ret) {\n\t\t\tret = configfs_detach_prep(dentry, &wait_mutex);\n\t\t\tif (ret)\n\t\t\t\tconfigfs_detach_rollback(dentry);\n\t\t}\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tmutex_unlock(&configfs_symlink_mutex);\n\n\t\tif (ret) {\n\t\t\tif (ret != -EAGAIN) {\n\t\t\t\tconfig_item_put(parent_item);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t/* Wait until the racing operation terminates */\n\t\t\tmutex_lock(wait_mutex);\n\t\t\tmutex_unlock(wait_mutex);\n\t\t}\n\t} while (ret == -EAGAIN);\n\n\t/* Get a working ref for the duration of this function */\n\titem = configfs_get_config_item(dentry);\n\n\t/* Drop reference from above, item already holds one. */\n\tconfig_item_put(parent_item);\n\n\tif (item->ci_type)\n\t\tdead_item_owner = item->ci_type->ct_owner;\n\n\tif (sd->s_type & CONFIGFS_USET_DIR) {\n\t\tconfigfs_detach_group(item);\n\n\t\tmutex_lock(&subsys->su_mutex);\n\t\tclient_disconnect_notify(parent_item, item);\n\t\tunlink_group(to_config_group(item));\n\t} else {\n\t\tconfigfs_detach_item(item);\n\n\t\tmutex_lock(&subsys->su_mutex);\n\t\tclient_disconnect_notify(parent_item, item);\n\t\tunlink_obj(item);\n\t}\n\n\tclient_drop_item(parent_item, item);\n\tmutex_unlock(&subsys->su_mutex);\n\n\t/* Drop our reference from above */\n\tconfig_item_put(item);\n\n\tmodule_put(dead_item_owner);\n\tmodule_put(subsys_owner);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "subsys_owner"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "dead_item_owner"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_item_put",
          "args": [
            "item"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "171-175",
          "snippet": "void config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&subsys->su_mutex"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client_drop_item",
          "args": [
            "parent_item",
            "item"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "client_drop_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "913-930",
          "snippet": "static void client_drop_item(struct config_item *parent_item,\n\t\t\t     struct config_item *item)\n{\n\tstruct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\t/*\n\t * If ->drop_item() exists, it is responsible for the\n\t * config_item_put().\n\t */\n\tif (type->ct_group_ops && type->ct_group_ops->drop_item)\n\t\ttype->ct_group_ops->drop_item(to_config_group(parent_item),\n\t\t\t\t\t      item);\n\telse\n\t\tconfig_item_put(item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void client_drop_item(struct config_item *parent_item,\n\t\t\t     struct config_item *item)\n{\n\tstruct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\t/*\n\t * If ->drop_item() exists, it is responsible for the\n\t * config_item_put().\n\t */\n\tif (type->ct_group_ops && type->ct_group_ops->drop_item)\n\t\ttype->ct_group_ops->drop_item(to_config_group(parent_item),\n\t\t\t\t\t      item);\n\telse\n\t\tconfig_item_put(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_obj",
          "args": [
            "item"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "710-727",
          "snippet": "static void unlink_obj(struct config_item *item)\n{\n\tstruct config_group *group;\n\n\tgroup = item->ci_group;\n\tif (group) {\n\t\tlist_del_init(&item->ci_entry);\n\n\t\titem->ci_group = NULL;\n\t\titem->ci_parent = NULL;\n\n\t\t/* Drop the reference for ci_entry */\n\t\tconfig_item_put(item);\n\n\t\t/* Drop the reference for ci_parent */\n\t\tconfig_group_put(group);\n\t}\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void unlink_obj(struct config_item *item)\n{\n\tstruct config_group *group;\n\n\tgroup = item->ci_group;\n\tif (group) {\n\t\tlist_del_init(&item->ci_entry);\n\n\t\titem->ci_group = NULL;\n\t\titem->ci_parent = NULL;\n\n\t\t/* Drop the reference for ci_entry */\n\t\tconfig_item_put(item);\n\n\t\t/* Drop the reference for ci_parent */\n\t\tconfig_group_put(group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_disconnect_notify",
          "args": [
            "parent_item",
            "item"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "client_disconnect_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "894-905",
          "snippet": "static void client_disconnect_notify(struct config_item *parent_item,\n\t\t\t\t     struct config_item *item)\n{\n\tstruct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\tif (type->ct_group_ops && type->ct_group_ops->disconnect_notify)\n\t\ttype->ct_group_ops->disconnect_notify(to_config_group(parent_item),\n\t\t\t\t\t\t      item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void client_disconnect_notify(struct config_item *parent_item,\n\t\t\t\t     struct config_item *item)\n{\n\tstruct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\tif (type->ct_group_ops && type->ct_group_ops->disconnect_notify)\n\t\ttype->ct_group_ops->disconnect_notify(to_config_group(parent_item),\n\t\t\t\t\t\t      item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&subsys->su_mutex"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_detach_item",
          "args": [
            "item"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_detach_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "834-838",
          "snippet": "static void configfs_detach_item(struct config_item *item)\n{\n\tdetach_attrs(item);\n\tconfigfs_remove_dir(item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void configfs_detach_item(struct config_item *item)\n{\n\tdetach_attrs(item);\n\tconfigfs_remove_dir(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_group",
          "args": [
            "to_config_group(item)"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "751-765",
          "snippet": "static void unlink_group(struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tunlink_group(new_group);\n\t\t}\n\t}\n\n\tgroup->cg_subsys = NULL;\n\tunlink_obj(&group->cg_item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void unlink_group(struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tunlink_group(new_group);\n\t\t}\n\t}\n\n\tgroup->cg_subsys = NULL;\n\tunlink_obj(&group->cg_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "item"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&subsys->su_mutex"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_detach_group",
          "args": [
            "item"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_detach_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "879-883",
          "snippet": "static void configfs_detach_group(struct config_item *item)\n{\n\tdetach_groups(to_config_group(item));\n\tconfigfs_detach_item(item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void configfs_detach_group(struct config_item *item)\n{\n\tdetach_groups(to_config_group(item));\n\tconfigfs_detach_item(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_get_config_item",
          "args": [
            "dentry"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_get_config_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "122-138",
          "snippet": "static inline struct config_item *configfs_get_config_item(struct dentry *dentry)\n{\n\tstruct config_item * item = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unhashed(dentry)) {\n\t\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\t\tif (sd->s_type & CONFIGFS_ITEM_LINK) {\n\t\t\tstruct configfs_symlink * sl = sd->s_element;\n\t\t\titem = config_item_get(sl->sl_target);\n\t\t} else\n\t\t\titem = config_item_get(sd->s_element);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\treturn item;\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define CONFIGFS_ITEM_LINK\t0x0020"
          ],
          "globals_used": [
            "extern int configfs_is_root(struct config_item *item);",
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);",
            "extern int configfs_unlink(struct inode *dir, struct dentry *dentry);",
            "extern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#define CONFIGFS_ITEM_LINK\t0x0020\n\nextern int configfs_is_root(struct config_item *item);\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\nextern int configfs_unlink(struct inode *dir, struct dentry *dentry);\nextern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);\n\nstatic inline struct config_item *configfs_get_config_item(struct dentry *dentry)\n{\n\tstruct config_item * item = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unhashed(dentry)) {\n\t\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\t\tif (sd->s_type & CONFIGFS_ITEM_LINK) {\n\t\t\tstruct configfs_symlink * sl = sd->s_element;\n\t\t\titem = config_item_get(sl->sl_target);\n\t\t} else\n\t\t\titem = config_item_get(sd->s_element);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "wait_mutex"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "wait_mutex"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&configfs_symlink_mutex"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_detach_rollback",
          "args": [
            "dentry"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_detach_rollback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "541-551",
          "snippet": "static void configfs_detach_rollback(struct dentry *dentry)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\n\tparent_sd->s_type &= ~CONFIGFS_USET_DROPPING;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling)\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT)\n\t\t\tconfigfs_detach_rollback(sd->s_dentry);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic void configfs_detach_rollback(struct dentry *dentry)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\n\tparent_sd->s_type &= ~CONFIGFS_USET_DROPPING;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling)\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT)\n\t\t\tconfigfs_detach_rollback(sd->s_dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_detach_prep",
          "args": [
            "dentry",
            "&wait_mutex"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_detach_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "494-535",
          "snippet": "static int configfs_detach_prep(struct dentry *dentry, struct mutex **wait_mutex)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\tint ret;\n\n\t/* Mark that we're trying to drop the group */\n\tparent_sd->s_type |= CONFIGFS_USET_DROPPING;\n\n\tret = -EBUSY;\n\tif (!list_empty(&parent_sd->s_links))\n\t\tgoto out;\n\n\tret = 0;\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    (sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT) {\n\t\t\t/* Abort if racing with mkdir() */\n\t\t\tif (sd->s_type & CONFIGFS_USET_IN_MKDIR) {\n\t\t\t\tif (wait_mutex)\n\t\t\t\t\t*wait_mutex = &sd->s_dentry->d_inode->i_mutex;\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Yup, recursive.  If there's a problem, blame\n\t\t\t * deep nesting of default_groups\n\t\t\t */\n\t\t\tret = configfs_detach_prep(sd->s_dentry, wait_mutex);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\tret = -ENOTEMPTY;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic int configfs_detach_prep(struct dentry *dentry, struct mutex **wait_mutex)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\tint ret;\n\n\t/* Mark that we're trying to drop the group */\n\tparent_sd->s_type |= CONFIGFS_USET_DROPPING;\n\n\tret = -EBUSY;\n\tif (!list_empty(&parent_sd->s_links))\n\t\tgoto out;\n\n\tret = 0;\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    (sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT) {\n\t\t\t/* Abort if racing with mkdir() */\n\t\t\tif (sd->s_type & CONFIGFS_USET_IN_MKDIR) {\n\t\t\t\tif (wait_mutex)\n\t\t\t\t\t*wait_mutex = &sd->s_dentry->d_inode->i_mutex;\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Yup, recursive.  If there's a problem, blame\n\t\t\t * deep nesting of default_groups\n\t\t\t */\n\t\t\tret = configfs_detach_prep(sd->s_dentry, wait_mutex);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\tret = -ENOTEMPTY;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&configfs_symlink_mutex"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!subsys->su_group.cg_item.ci_type"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!subsys"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "parent_item"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int configfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct config_item *parent_item;\n\tstruct config_item *item;\n\tstruct configfs_subsystem *subsys;\n\tstruct configfs_dirent *sd;\n\tstruct module *subsys_owner = NULL, *dead_item_owner = NULL;\n\tint ret;\n\n\tsd = dentry->d_fsdata;\n\tif (sd->s_type & CONFIGFS_USET_DEFAULT)\n\t\treturn -EPERM;\n\n\t/* Get a working ref until we have the child */\n\tparent_item = configfs_get_config_item(dentry->d_parent);\n\tsubsys = to_config_group(parent_item)->cg_subsys;\n\tBUG_ON(!subsys);\n\n\tif (!parent_item->ci_type) {\n\t\tconfig_item_put(parent_item);\n\t\treturn -EINVAL;\n\t}\n\n\t/* configfs_mkdir() shouldn't have allowed this */\n\tBUG_ON(!subsys->su_group.cg_item.ci_type);\n\tsubsys_owner = subsys->su_group.cg_item.ci_type->ct_owner;\n\n\t/*\n\t * Ensure that no racing symlink() will make detach_prep() fail while\n\t * the new link is temporarily attached\n\t */\n\tdo {\n\t\tstruct mutex *wait_mutex;\n\n\t\tmutex_lock(&configfs_symlink_mutex);\n\t\tspin_lock(&configfs_dirent_lock);\n\t\t/*\n\t\t * Here's where we check for dependents.  We're protected by\n\t\t * configfs_dirent_lock.\n\t\t * If no dependent, atomically tag the item as dropping.\n\t\t */\n\t\tret = sd->s_dependent_count ? -EBUSY : 0;\n\t\tif (!ret) {\n\t\t\tret = configfs_detach_prep(dentry, &wait_mutex);\n\t\t\tif (ret)\n\t\t\t\tconfigfs_detach_rollback(dentry);\n\t\t}\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tmutex_unlock(&configfs_symlink_mutex);\n\n\t\tif (ret) {\n\t\t\tif (ret != -EAGAIN) {\n\t\t\t\tconfig_item_put(parent_item);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t/* Wait until the racing operation terminates */\n\t\t\tmutex_lock(wait_mutex);\n\t\t\tmutex_unlock(wait_mutex);\n\t\t}\n\t} while (ret == -EAGAIN);\n\n\t/* Get a working ref for the duration of this function */\n\titem = configfs_get_config_item(dentry);\n\n\t/* Drop reference from above, item already holds one. */\n\tconfig_item_put(parent_item);\n\n\tif (item->ci_type)\n\t\tdead_item_owner = item->ci_type->ct_owner;\n\n\tif (sd->s_type & CONFIGFS_USET_DIR) {\n\t\tconfigfs_detach_group(item);\n\n\t\tmutex_lock(&subsys->su_mutex);\n\t\tclient_disconnect_notify(parent_item, item);\n\t\tunlink_group(to_config_group(item));\n\t} else {\n\t\tconfigfs_detach_item(item);\n\n\t\tmutex_lock(&subsys->su_mutex);\n\t\tclient_disconnect_notify(parent_item, item);\n\t\tunlink_obj(item);\n\t}\n\n\tclient_drop_item(parent_item, item);\n\tmutex_unlock(&subsys->su_mutex);\n\n\t/* Drop our reference from above */\n\tconfig_item_put(item);\n\n\tmodule_put(dead_item_owner);\n\tmodule_put(subsys_owner);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "configfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1155-1328",
    "snippet": "static int configfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint ret = 0;\n\tint module_got = 0;\n\tstruct config_group *group = NULL;\n\tstruct config_item *item = NULL;\n\tstruct config_item *parent_item;\n\tstruct configfs_subsystem *subsys;\n\tstruct configfs_dirent *sd;\n\tstruct config_item_type *type;\n\tstruct module *subsys_owner = NULL, *new_item_owner = NULL;\n\tchar *name;\n\n\tsd = dentry->d_parent->d_fsdata;\n\n\t/*\n\t * Fake invisibility if dir belongs to a group/default groups hierarchy\n\t * being attached\n\t */\n\tif (!configfs_dirent_is_ready(sd)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(sd->s_type & CONFIGFS_USET_DIR)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\t/* Get a working ref for the duration of this function */\n\tparent_item = configfs_get_config_item(dentry->d_parent);\n\ttype = parent_item->ci_type;\n\tsubsys = to_config_group(parent_item)->cg_subsys;\n\tBUG_ON(!subsys);\n\n\tif (!type || !type->ct_group_ops ||\n\t    (!type->ct_group_ops->make_group &&\n\t     !type->ct_group_ops->make_item)) {\n\t\tret = -EPERM;  /* Lack-of-mkdir returns -EPERM */\n\t\tgoto out_put;\n\t}\n\n\t/*\n\t * The subsystem may belong to a different module than the item\n\t * being created.  We don't want to safely pin the new item but\n\t * fail to pin the subsystem it sits under.\n\t */\n\tif (!subsys->su_group.cg_item.ci_type) {\n\t\tret = -EINVAL;\n\t\tgoto out_put;\n\t}\n\tsubsys_owner = subsys->su_group.cg_item.ci_type->ct_owner;\n\tif (!try_module_get(subsys_owner)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put;\n\t}\n\n\tname = kmalloc(dentry->d_name.len + 1, GFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_subsys_put;\n\t}\n\n\tsnprintf(name, dentry->d_name.len + 1, \"%s\", dentry->d_name.name);\n\n\tmutex_lock(&subsys->su_mutex);\n\tif (type->ct_group_ops->make_group) {\n\t\tgroup = type->ct_group_ops->make_group(to_config_group(parent_item), name);\n\t\tif (!group)\n\t\t\tgroup = ERR_PTR(-ENOMEM);\n\t\tif (!IS_ERR(group)) {\n\t\t\tlink_group(to_config_group(parent_item), group);\n\t\t\titem = &group->cg_item;\n\t\t} else\n\t\t\tret = PTR_ERR(group);\n\t} else {\n\t\titem = type->ct_group_ops->make_item(to_config_group(parent_item), name);\n\t\tif (!item)\n\t\t\titem = ERR_PTR(-ENOMEM);\n\t\tif (!IS_ERR(item))\n\t\t\tlink_obj(parent_item, item);\n\t\telse\n\t\t\tret = PTR_ERR(item);\n\t}\n\tmutex_unlock(&subsys->su_mutex);\n\n\tkfree(name);\n\tif (ret) {\n\t\t/*\n\t\t * If ret != 0, then link_obj() was never called.\n\t\t * There are no extra references to clean up.\n\t\t */\n\t\tgoto out_subsys_put;\n\t}\n\n\t/*\n\t * link_obj() has been called (via link_group() for groups).\n\t * From here on out, errors must clean that up.\n\t */\n\n\ttype = item->ci_type;\n\tif (!type) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlink;\n\t}\n\n\tnew_item_owner = type->ct_owner;\n\tif (!try_module_get(new_item_owner)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlink;\n\t}\n\n\t/*\n\t * I hate doing it this way, but if there is\n\t * an error,  module_put() probably should\n\t * happen after any cleanup.\n\t */\n\tmodule_got = 1;\n\n\t/*\n\t * Make racing rmdir() fail if it did not tag parent with\n\t * CONFIGFS_USET_DROPPING\n\t * Note: if CONFIGFS_USET_DROPPING is already set, attach_group() will\n\t * fail and let rmdir() terminate correctly\n\t */\n\tspin_lock(&configfs_dirent_lock);\n\t/* This will make configfs_detach_prep() fail */\n\tsd->s_type |= CONFIGFS_USET_IN_MKDIR;\n\tspin_unlock(&configfs_dirent_lock);\n\n\tif (group)\n\t\tret = configfs_attach_group(parent_item, item, dentry);\n\telse\n\t\tret = configfs_attach_item(parent_item, item, dentry);\n\n\tspin_lock(&configfs_dirent_lock);\n\tsd->s_type &= ~CONFIGFS_USET_IN_MKDIR;\n\tif (!ret)\n\t\tconfigfs_dir_set_ready(dentry->d_fsdata);\n\tspin_unlock(&configfs_dirent_lock);\n\nout_unlink:\n\tif (ret) {\n\t\t/* Tear down everything we built up */\n\t\tmutex_lock(&subsys->su_mutex);\n\n\t\tclient_disconnect_notify(parent_item, item);\n\t\tif (group)\n\t\t\tunlink_group(group);\n\t\telse\n\t\t\tunlink_obj(item);\n\t\tclient_drop_item(parent_item, item);\n\n\t\tmutex_unlock(&subsys->su_mutex);\n\n\t\tif (module_got)\n\t\t\tmodule_put(new_item_owner);\n\t}\n\nout_subsys_put:\n\tif (ret)\n\t\tmodule_put(subsys_owner);\n\nout_put:\n\t/*\n\t * link_obj()/link_group() took a reference from child->parent,\n\t * so the parent is safely pinned.  We can drop our working\n\t * reference.\n\t */\n\tconfig_item_put(parent_item);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_item_put",
          "args": [
            "parent_item"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "171-175",
          "snippet": "void config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "subsys_owner"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "new_item_owner"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&subsys->su_mutex"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client_drop_item",
          "args": [
            "parent_item",
            "item"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "client_drop_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "913-930",
          "snippet": "static void client_drop_item(struct config_item *parent_item,\n\t\t\t     struct config_item *item)\n{\n\tstruct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\t/*\n\t * If ->drop_item() exists, it is responsible for the\n\t * config_item_put().\n\t */\n\tif (type->ct_group_ops && type->ct_group_ops->drop_item)\n\t\ttype->ct_group_ops->drop_item(to_config_group(parent_item),\n\t\t\t\t\t      item);\n\telse\n\t\tconfig_item_put(item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void client_drop_item(struct config_item *parent_item,\n\t\t\t     struct config_item *item)\n{\n\tstruct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\t/*\n\t * If ->drop_item() exists, it is responsible for the\n\t * config_item_put().\n\t */\n\tif (type->ct_group_ops && type->ct_group_ops->drop_item)\n\t\ttype->ct_group_ops->drop_item(to_config_group(parent_item),\n\t\t\t\t\t      item);\n\telse\n\t\tconfig_item_put(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_obj",
          "args": [
            "item"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "710-727",
          "snippet": "static void unlink_obj(struct config_item *item)\n{\n\tstruct config_group *group;\n\n\tgroup = item->ci_group;\n\tif (group) {\n\t\tlist_del_init(&item->ci_entry);\n\n\t\titem->ci_group = NULL;\n\t\titem->ci_parent = NULL;\n\n\t\t/* Drop the reference for ci_entry */\n\t\tconfig_item_put(item);\n\n\t\t/* Drop the reference for ci_parent */\n\t\tconfig_group_put(group);\n\t}\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void unlink_obj(struct config_item *item)\n{\n\tstruct config_group *group;\n\n\tgroup = item->ci_group;\n\tif (group) {\n\t\tlist_del_init(&item->ci_entry);\n\n\t\titem->ci_group = NULL;\n\t\titem->ci_parent = NULL;\n\n\t\t/* Drop the reference for ci_entry */\n\t\tconfig_item_put(item);\n\n\t\t/* Drop the reference for ci_parent */\n\t\tconfig_group_put(group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_group",
          "args": [
            "group"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "751-765",
          "snippet": "static void unlink_group(struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tunlink_group(new_group);\n\t\t}\n\t}\n\n\tgroup->cg_subsys = NULL;\n\tunlink_obj(&group->cg_item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void unlink_group(struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tunlink_group(new_group);\n\t\t}\n\t}\n\n\tgroup->cg_subsys = NULL;\n\tunlink_obj(&group->cg_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_disconnect_notify",
          "args": [
            "parent_item",
            "item"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "client_disconnect_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "894-905",
          "snippet": "static void client_disconnect_notify(struct config_item *parent_item,\n\t\t\t\t     struct config_item *item)\n{\n\tstruct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\tif (type->ct_group_ops && type->ct_group_ops->disconnect_notify)\n\t\ttype->ct_group_ops->disconnect_notify(to_config_group(parent_item),\n\t\t\t\t\t\t      item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void client_disconnect_notify(struct config_item *parent_item,\n\t\t\t\t     struct config_item *item)\n{\n\tstruct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\tif (type->ct_group_ops && type->ct_group_ops->disconnect_notify)\n\t\ttype->ct_group_ops->disconnect_notify(to_config_group(parent_item),\n\t\t\t\t\t\t      item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&subsys->su_mutex"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_dir_set_ready",
          "args": [
            "dentry->d_fsdata"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_dir_set_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "313-321",
          "snippet": "static void configfs_dir_set_ready(struct configfs_dirent *sd)\n{\n\tstruct configfs_dirent *child_sd;\n\n\tsd->s_type &= ~CONFIGFS_USET_CREATING;\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling)\n\t\tif (child_sd->s_type & CONFIGFS_USET_CREATING)\n\t\t\tconfigfs_dir_set_ready(child_sd);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_dir_set_ready(struct configfs_dirent *sd)\n{\n\tstruct configfs_dirent *child_sd;\n\n\tsd->s_type &= ~CONFIGFS_USET_CREATING;\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling)\n\t\tif (child_sd->s_type & CONFIGFS_USET_CREATING)\n\t\t\tconfigfs_dir_set_ready(child_sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_attach_item",
          "args": [
            "parent_item",
            "item",
            "dentry"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_attach_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "806-831",
          "snippet": "static int configfs_attach_item(struct config_item *parent_item,\n\t\t\t\tstruct config_item *item,\n\t\t\t\tstruct dentry *dentry)\n{\n\tint ret;\n\n\tret = configfs_create_dir(item, dentry);\n\tif (!ret) {\n\t\tret = populate_attrs(item);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * We are going to remove an inode and its dentry but\n\t\t\t * the VFS may already have hit and used them. Thus,\n\t\t\t * we must lock them as rmdir() would.\n\t\t\t */\n\t\t\tmutex_lock(&dentry->d_inode->i_mutex);\n\t\t\tconfigfs_remove_dir(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\t\td_delete(dentry);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int configfs_attach_item(struct config_item *parent_item,\n\t\t\t\tstruct config_item *item,\n\t\t\t\tstruct dentry *dentry)\n{\n\tint ret;\n\n\tret = configfs_create_dir(item, dentry);\n\tif (!ret) {\n\t\tret = populate_attrs(item);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * We are going to remove an inode and its dentry but\n\t\t\t * the VFS may already have hit and used them. Thus,\n\t\t\t * we must lock them as rmdir() would.\n\t\t\t */\n\t\t\tmutex_lock(&dentry->d_inode->i_mutex);\n\t\t\tconfigfs_remove_dir(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\t\td_delete(dentry);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_attach_group",
          "args": [
            "parent_item",
            "item",
            "dentry"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_attach_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "840-876",
          "snippet": "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\n\tret = configfs_attach_item(parent_item, item, dentry);\n\tif (!ret) {\n\t\tsd = dentry->d_fsdata;\n\t\tsd->s_type |= CONFIGFS_USET_DIR;\n\n\t\t/*\n\t\t * FYI, we're faking mkdir in populate_groups()\n\t\t * We must lock the group's inode to avoid races with the VFS\n\t\t * which can already hit the inode and try to add/remove entries\n\t\t * under it.\n\t\t *\n\t\t * We must also lock the inode to remove it safely in case of\n\t\t * error, as rmdir() would.\n\t\t */\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\tconfigfs_adjust_dir_dirent_depth_before_populate(sd);\n\t\tret = populate_groups(to_config_group(item));\n\t\tif (ret) {\n\t\t\tconfigfs_detach_item(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t}\n\t\tconfigfs_adjust_dir_dirent_depth_after_populate(sd);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\tif (ret)\n\t\t\td_delete(dentry);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\n\tret = configfs_attach_item(parent_item, item, dentry);\n\tif (!ret) {\n\t\tsd = dentry->d_fsdata;\n\t\tsd->s_type |= CONFIGFS_USET_DIR;\n\n\t\t/*\n\t\t * FYI, we're faking mkdir in populate_groups()\n\t\t * We must lock the group's inode to avoid races with the VFS\n\t\t * which can already hit the inode and try to add/remove entries\n\t\t * under it.\n\t\t *\n\t\t * We must also lock the inode to remove it safely in case of\n\t\t * error, as rmdir() would.\n\t\t */\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\tconfigfs_adjust_dir_dirent_depth_before_populate(sd);\n\t\tret = populate_groups(to_config_group(item));\n\t\tif (ret) {\n\t\t\tconfigfs_detach_item(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t}\n\t\tconfigfs_adjust_dir_dirent_depth_after_populate(sd);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\tif (ret)\n\t\t\td_delete(dentry);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "new_item_owner"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&subsys->su_mutex"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "item"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_obj",
          "args": [
            "parent_item",
            "item"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "link_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "729-749",
          "snippet": "static void link_obj(struct config_item *parent_item, struct config_item *item)\n{\n\t/*\n\t * Parent seems redundant with group, but it makes certain\n\t * traversals much nicer.\n\t */\n\titem->ci_parent = parent_item;\n\n\t/*\n\t * We hold a reference on the parent for the child's ci_parent\n\t * link.\n\t */\n\titem->ci_group = config_group_get(to_config_group(parent_item));\n\tlist_add_tail(&item->ci_entry, &item->ci_group->cg_children);\n\n\t/*\n\t * We hold a reference on the child for ci_entry on the parent's\n\t * cg_children\n\t */\n\tconfig_item_get(item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void link_obj(struct config_item *parent_item, struct config_item *item)\n{\n\t/*\n\t * Parent seems redundant with group, but it makes certain\n\t * traversals much nicer.\n\t */\n\titem->ci_parent = parent_item;\n\n\t/*\n\t * We hold a reference on the parent for the child's ci_parent\n\t * link.\n\t */\n\titem->ci_group = config_group_get(to_config_group(parent_item));\n\tlist_add_tail(&item->ci_entry, &item->ci_group->cg_children);\n\n\t/*\n\t * We hold a reference on the child for ci_entry on the parent's\n\t * cg_children\n\t */\n\tconfig_item_get(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "item"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->ct_group_ops->make_item",
          "args": [
            "to_config_group(parent_item)",
            "name"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "parent_item"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "group"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_group",
          "args": [
            "to_config_group(parent_item)",
            "group"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "link_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "767-789",
          "snippet": "static void link_group(struct config_group *parent_group, struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\tstruct configfs_subsystem *subsys = NULL; /* gcc is a turd */\n\n\tlink_obj(&parent_group->cg_item, &group->cg_item);\n\n\tif (parent_group->cg_subsys)\n\t\tsubsys = parent_group->cg_subsys;\n\telse if (configfs_is_root(&parent_group->cg_item))\n\t\tsubsys = to_configfs_subsystem(group);\n\telse\n\t\tBUG();\n\tgroup->cg_subsys = subsys;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tlink_group(group, new_group);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void link_group(struct config_group *parent_group, struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\tstruct configfs_subsystem *subsys = NULL; /* gcc is a turd */\n\n\tlink_obj(&parent_group->cg_item, &group->cg_item);\n\n\tif (parent_group->cg_subsys)\n\t\tsubsys = parent_group->cg_subsys;\n\telse if (configfs_is_root(&parent_group->cg_item))\n\t\tsubsys = to_configfs_subsystem(group);\n\telse\n\t\tBUG();\n\tgroup->cg_subsys = subsys;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tlink_group(group, new_group);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "parent_item"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "group"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->ct_group_ops->make_group",
          "args": [
            "to_config_group(parent_item)",
            "name"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "parent_item"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&subsys->su_mutex"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "dentry->d_name.len + 1",
            "\"%s\"",
            "dentry->d_name.name"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "dentry->d_name.len + 1",
            "GFP_KERNEL"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "subsys_owner"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!subsys"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "parent_item"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_get_config_item",
          "args": [
            "dentry->d_parent"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_get_config_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "122-138",
          "snippet": "static inline struct config_item *configfs_get_config_item(struct dentry *dentry)\n{\n\tstruct config_item * item = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unhashed(dentry)) {\n\t\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\t\tif (sd->s_type & CONFIGFS_ITEM_LINK) {\n\t\t\tstruct configfs_symlink * sl = sd->s_element;\n\t\t\titem = config_item_get(sl->sl_target);\n\t\t} else\n\t\t\titem = config_item_get(sd->s_element);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\treturn item;\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define CONFIGFS_ITEM_LINK\t0x0020"
          ],
          "globals_used": [
            "extern int configfs_is_root(struct config_item *item);",
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);",
            "extern int configfs_unlink(struct inode *dir, struct dentry *dentry);",
            "extern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#define CONFIGFS_ITEM_LINK\t0x0020\n\nextern int configfs_is_root(struct config_item *item);\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\nextern int configfs_unlink(struct inode *dir, struct dentry *dentry);\nextern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);\n\nstatic inline struct config_item *configfs_get_config_item(struct dentry *dentry)\n{\n\tstruct config_item * item = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unhashed(dentry)) {\n\t\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\t\tif (sd->s_type & CONFIGFS_ITEM_LINK) {\n\t\t\tstruct configfs_symlink * sl = sd->s_element;\n\t\t\titem = config_item_get(sl->sl_target);\n\t\t} else\n\t\t\titem = config_item_get(sd->s_element);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_dirent_is_ready",
          "args": [
            "sd"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_dirent_is_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "333-342",
          "snippet": "int configfs_dirent_is_ready(struct configfs_dirent *sd)\n{\n\tint ret;\n\n\tspin_lock(&configfs_dirent_lock);\n\tret = !(sd->s_type & CONFIGFS_USET_CREATING);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint configfs_dirent_is_ready(struct configfs_dirent *sd)\n{\n\tint ret;\n\n\tspin_lock(&configfs_dirent_lock);\n\tret = !(sd->s_type & CONFIGFS_USET_CREATING);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int configfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint ret = 0;\n\tint module_got = 0;\n\tstruct config_group *group = NULL;\n\tstruct config_item *item = NULL;\n\tstruct config_item *parent_item;\n\tstruct configfs_subsystem *subsys;\n\tstruct configfs_dirent *sd;\n\tstruct config_item_type *type;\n\tstruct module *subsys_owner = NULL, *new_item_owner = NULL;\n\tchar *name;\n\n\tsd = dentry->d_parent->d_fsdata;\n\n\t/*\n\t * Fake invisibility if dir belongs to a group/default groups hierarchy\n\t * being attached\n\t */\n\tif (!configfs_dirent_is_ready(sd)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(sd->s_type & CONFIGFS_USET_DIR)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\t/* Get a working ref for the duration of this function */\n\tparent_item = configfs_get_config_item(dentry->d_parent);\n\ttype = parent_item->ci_type;\n\tsubsys = to_config_group(parent_item)->cg_subsys;\n\tBUG_ON(!subsys);\n\n\tif (!type || !type->ct_group_ops ||\n\t    (!type->ct_group_ops->make_group &&\n\t     !type->ct_group_ops->make_item)) {\n\t\tret = -EPERM;  /* Lack-of-mkdir returns -EPERM */\n\t\tgoto out_put;\n\t}\n\n\t/*\n\t * The subsystem may belong to a different module than the item\n\t * being created.  We don't want to safely pin the new item but\n\t * fail to pin the subsystem it sits under.\n\t */\n\tif (!subsys->su_group.cg_item.ci_type) {\n\t\tret = -EINVAL;\n\t\tgoto out_put;\n\t}\n\tsubsys_owner = subsys->su_group.cg_item.ci_type->ct_owner;\n\tif (!try_module_get(subsys_owner)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put;\n\t}\n\n\tname = kmalloc(dentry->d_name.len + 1, GFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_subsys_put;\n\t}\n\n\tsnprintf(name, dentry->d_name.len + 1, \"%s\", dentry->d_name.name);\n\n\tmutex_lock(&subsys->su_mutex);\n\tif (type->ct_group_ops->make_group) {\n\t\tgroup = type->ct_group_ops->make_group(to_config_group(parent_item), name);\n\t\tif (!group)\n\t\t\tgroup = ERR_PTR(-ENOMEM);\n\t\tif (!IS_ERR(group)) {\n\t\t\tlink_group(to_config_group(parent_item), group);\n\t\t\titem = &group->cg_item;\n\t\t} else\n\t\t\tret = PTR_ERR(group);\n\t} else {\n\t\titem = type->ct_group_ops->make_item(to_config_group(parent_item), name);\n\t\tif (!item)\n\t\t\titem = ERR_PTR(-ENOMEM);\n\t\tif (!IS_ERR(item))\n\t\t\tlink_obj(parent_item, item);\n\t\telse\n\t\t\tret = PTR_ERR(item);\n\t}\n\tmutex_unlock(&subsys->su_mutex);\n\n\tkfree(name);\n\tif (ret) {\n\t\t/*\n\t\t * If ret != 0, then link_obj() was never called.\n\t\t * There are no extra references to clean up.\n\t\t */\n\t\tgoto out_subsys_put;\n\t}\n\n\t/*\n\t * link_obj() has been called (via link_group() for groups).\n\t * From here on out, errors must clean that up.\n\t */\n\n\ttype = item->ci_type;\n\tif (!type) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlink;\n\t}\n\n\tnew_item_owner = type->ct_owner;\n\tif (!try_module_get(new_item_owner)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlink;\n\t}\n\n\t/*\n\t * I hate doing it this way, but if there is\n\t * an error,  module_put() probably should\n\t * happen after any cleanup.\n\t */\n\tmodule_got = 1;\n\n\t/*\n\t * Make racing rmdir() fail if it did not tag parent with\n\t * CONFIGFS_USET_DROPPING\n\t * Note: if CONFIGFS_USET_DROPPING is already set, attach_group() will\n\t * fail and let rmdir() terminate correctly\n\t */\n\tspin_lock(&configfs_dirent_lock);\n\t/* This will make configfs_detach_prep() fail */\n\tsd->s_type |= CONFIGFS_USET_IN_MKDIR;\n\tspin_unlock(&configfs_dirent_lock);\n\n\tif (group)\n\t\tret = configfs_attach_group(parent_item, item, dentry);\n\telse\n\t\tret = configfs_attach_item(parent_item, item, dentry);\n\n\tspin_lock(&configfs_dirent_lock);\n\tsd->s_type &= ~CONFIGFS_USET_IN_MKDIR;\n\tif (!ret)\n\t\tconfigfs_dir_set_ready(dentry->d_fsdata);\n\tspin_unlock(&configfs_dirent_lock);\n\nout_unlink:\n\tif (ret) {\n\t\t/* Tear down everything we built up */\n\t\tmutex_lock(&subsys->su_mutex);\n\n\t\tclient_disconnect_notify(parent_item, item);\n\t\tif (group)\n\t\t\tunlink_group(group);\n\t\telse\n\t\t\tunlink_obj(item);\n\t\tclient_drop_item(parent_item, item);\n\n\t\tmutex_unlock(&subsys->su_mutex);\n\n\t\tif (module_got)\n\t\t\tmodule_put(new_item_owner);\n\t}\n\nout_subsys_put:\n\tif (ret)\n\t\tmodule_put(subsys_owner);\n\nout_put:\n\t/*\n\t * link_obj()/link_group() took a reference from child->parent,\n\t * so the parent is safely pinned.  We can drop our working\n\t * reference.\n\t */\n\tconfig_item_put(parent_item);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "configfs_undepend_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1131-1152",
    "snippet": "void configfs_undepend_item(struct configfs_subsystem *subsys,\n\t\t\t    struct config_item *target)\n{\n\tstruct configfs_dirent *sd;\n\n\t/*\n\t * Since we can trust everything is pinned, we just need\n\t * configfs_dirent_lock.\n\t */\n\tspin_lock(&configfs_dirent_lock);\n\n\tsd = target->ci_dentry->d_fsdata;\n\tBUG_ON(sd->s_dependent_count < 1);\n\n\tsd->s_dependent_count -= 1;\n\n\t/*\n\t * After this unlock, we cannot trust the item to stay alive!\n\t * DO NOT REFERENCE item after this unlock.\n\t */\n\tspin_unlock(&configfs_dirent_lock);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sd->s_dependent_count < 1"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nvoid configfs_undepend_item(struct configfs_subsystem *subsys,\n\t\t\t    struct config_item *target)\n{\n\tstruct configfs_dirent *sd;\n\n\t/*\n\t * Since we can trust everything is pinned, we just need\n\t * configfs_dirent_lock.\n\t */\n\tspin_lock(&configfs_dirent_lock);\n\n\tsd = target->ci_dentry->d_fsdata;\n\tBUG_ON(sd->s_dependent_count < 1);\n\n\tsd->s_dependent_count -= 1;\n\n\t/*\n\t * After this unlock, we cannot trust the item to stay alive!\n\t * DO NOT REFERENCE item after this unlock.\n\t */\n\tspin_unlock(&configfs_dirent_lock);\n}"
  },
  {
    "function_name": "configfs_depend_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1057-1123",
    "snippet": "int configfs_depend_item(struct configfs_subsystem *subsys,\n\t\t\t struct config_item *target)\n{\n\tint ret;\n\tstruct configfs_dirent *p, *root_sd, *subsys_sd = NULL;\n\tstruct config_item *s_item = &subsys->su_group.cg_item;\n\tstruct dentry *root;\n\n\t/*\n\t * Pin the configfs filesystem.  This means we can safely access\n\t * the root of the configfs filesystem.\n\t */\n\troot = configfs_pin_fs();\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\t/*\n\t * Next, lock the root directory.  We're going to check that the\n\t * subsystem is really registered, and so we need to lock out\n\t * configfs_[un]register_subsystem().\n\t */\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\troot_sd = root->d_fsdata;\n\n\tlist_for_each_entry(p, &root_sd->s_children, s_sibling) {\n\t\tif (p->s_type & CONFIGFS_DIR) {\n\t\t\tif (p->s_element == s_item) {\n\t\t\t\tsubsys_sd = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!subsys_sd) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock_fs;\n\t}\n\n\t/* Ok, now we can trust subsys/s_item */\n\n\tspin_lock(&configfs_dirent_lock);\n\t/* Scan the tree, return 0 if found */\n\tret = configfs_depend_prep(subsys_sd->s_dentry, target);\n\tif (ret)\n\t\tgoto out_unlock_dirent_lock;\n\n\t/*\n\t * We are sure that the item is not about to be removed by rmdir(), and\n\t * not in the middle of attachment by mkdir().\n\t */\n\tp = target->ci_dentry->d_fsdata;\n\tp->s_dependent_count += 1;\n\nout_unlock_dirent_lock:\n\tspin_unlock(&configfs_dirent_lock);\nout_unlock_fs:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\t/*\n\t * If we succeeded, the fs is pinned via other methods.  If not,\n\t * we're done with it anyway.  So release_fs() is always right.\n\t */\n\tconfigfs_release_fs();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_release_fs",
          "args": [],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_release_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
          "lines": "126-129",
          "snippet": "void configfs_release_fs(void)\n{\n\tsimple_release_fs(&configfs_mount, &configfs_mnt_count);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *configfs_mount = NULL;",
            "static int configfs_mnt_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *configfs_mount = NULL;\nstatic int configfs_mnt_count = 0;\n\nvoid configfs_release_fs(void)\n{\n\tsimple_release_fs(&configfs_mount, &configfs_mnt_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_depend_prep",
          "args": [
            "subsys_sd->s_dentry",
            "target"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_depend_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "1027-1055",
          "snippet": "static int configfs_depend_prep(struct dentry *origin,\n\t\t\t\tstruct config_item *target)\n{\n\tstruct configfs_dirent *child_sd, *sd;\n\tint ret = 0;\n\n\tBUG_ON(!origin || !origin->d_fsdata);\n\tsd = origin->d_fsdata;\n\n\tif (sd->s_element == target)  /* Boo-yah */\n\t\tgoto out;\n\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling) {\n\t\tif ((child_sd->s_type & CONFIGFS_DIR) &&\n\t\t    !(child_sd->s_type & CONFIGFS_USET_DROPPING) &&\n\t\t    !(child_sd->s_type & CONFIGFS_USET_CREATING)) {\n\t\t\tret = configfs_depend_prep(child_sd->s_dentry,\n\t\t\t\t\t\t   target);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;  /* Child path boo-yah */\n\t\t}\n\t}\n\n\t/* We looped all our children and didn't find target */\n\tret = -ENOENT;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic int configfs_depend_prep(struct dentry *origin,\n\t\t\t\tstruct config_item *target)\n{\n\tstruct configfs_dirent *child_sd, *sd;\n\tint ret = 0;\n\n\tBUG_ON(!origin || !origin->d_fsdata);\n\tsd = origin->d_fsdata;\n\n\tif (sd->s_element == target)  /* Boo-yah */\n\t\tgoto out;\n\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling) {\n\t\tif ((child_sd->s_type & CONFIGFS_DIR) &&\n\t\t    !(child_sd->s_type & CONFIGFS_USET_DROPPING) &&\n\t\t    !(child_sd->s_type & CONFIGFS_USET_CREATING)) {\n\t\t\tret = configfs_depend_prep(child_sd->s_dentry,\n\t\t\t\t\t\t   target);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;  /* Child path boo-yah */\n\t\t}\n\t}\n\n\t/* We looped all our children and didn't find target */\n\tret = -ENOENT;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&root_sd->s_children",
            "s_sibling"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_pin_fs",
          "args": [],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_pin_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
          "lines": "119-124",
          "snippet": "struct dentry *configfs_pin_fs(void)\n{\n\tint err = simple_pin_fs(&configfs_fs_type, &configfs_mount,\n\t\t\t     &configfs_mnt_count);\n\treturn err ? ERR_PTR(err) : configfs_mount->mnt_root;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *configfs_mount = NULL;",
            "static int configfs_mnt_count = 0;",
            "static struct file_system_type configfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"configfs\",\n\t.mount\t\t= configfs_do_mount,\n\t.kill_sb\t= kill_litter_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *configfs_mount = NULL;\nstatic int configfs_mnt_count = 0;\nstatic struct file_system_type configfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"configfs\",\n\t.mount\t\t= configfs_do_mount,\n\t.kill_sb\t= kill_litter_super,\n};\n\nstruct dentry *configfs_pin_fs(void)\n{\n\tint err = simple_pin_fs(&configfs_fs_type, &configfs_mount,\n\t\t\t     &configfs_mnt_count);\n\treturn err ? ERR_PTR(err) : configfs_mount->mnt_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nint configfs_depend_item(struct configfs_subsystem *subsys,\n\t\t\t struct config_item *target)\n{\n\tint ret;\n\tstruct configfs_dirent *p, *root_sd, *subsys_sd = NULL;\n\tstruct config_item *s_item = &subsys->su_group.cg_item;\n\tstruct dentry *root;\n\n\t/*\n\t * Pin the configfs filesystem.  This means we can safely access\n\t * the root of the configfs filesystem.\n\t */\n\troot = configfs_pin_fs();\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\t/*\n\t * Next, lock the root directory.  We're going to check that the\n\t * subsystem is really registered, and so we need to lock out\n\t * configfs_[un]register_subsystem().\n\t */\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\troot_sd = root->d_fsdata;\n\n\tlist_for_each_entry(p, &root_sd->s_children, s_sibling) {\n\t\tif (p->s_type & CONFIGFS_DIR) {\n\t\t\tif (p->s_element == s_item) {\n\t\t\t\tsubsys_sd = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!subsys_sd) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock_fs;\n\t}\n\n\t/* Ok, now we can trust subsys/s_item */\n\n\tspin_lock(&configfs_dirent_lock);\n\t/* Scan the tree, return 0 if found */\n\tret = configfs_depend_prep(subsys_sd->s_dentry, target);\n\tif (ret)\n\t\tgoto out_unlock_dirent_lock;\n\n\t/*\n\t * We are sure that the item is not about to be removed by rmdir(), and\n\t * not in the middle of attachment by mkdir().\n\t */\n\tp = target->ci_dentry->d_fsdata;\n\tp->s_dependent_count += 1;\n\nout_unlock_dirent_lock:\n\tspin_unlock(&configfs_dirent_lock);\nout_unlock_fs:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\t/*\n\t * If we succeeded, the fs is pinned via other methods.  If not,\n\t * we're done with it anyway.  So release_fs() is always right.\n\t */\n\tconfigfs_release_fs();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "configfs_depend_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "1027-1055",
    "snippet": "static int configfs_depend_prep(struct dentry *origin,\n\t\t\t\tstruct config_item *target)\n{\n\tstruct configfs_dirent *child_sd, *sd;\n\tint ret = 0;\n\n\tBUG_ON(!origin || !origin->d_fsdata);\n\tsd = origin->d_fsdata;\n\n\tif (sd->s_element == target)  /* Boo-yah */\n\t\tgoto out;\n\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling) {\n\t\tif ((child_sd->s_type & CONFIGFS_DIR) &&\n\t\t    !(child_sd->s_type & CONFIGFS_USET_DROPPING) &&\n\t\t    !(child_sd->s_type & CONFIGFS_USET_CREATING)) {\n\t\t\tret = configfs_depend_prep(child_sd->s_dentry,\n\t\t\t\t\t\t   target);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;  /* Child path boo-yah */\n\t\t}\n\t}\n\n\t/* We looped all our children and didn't find target */\n\tret = -ENOENT;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_depend_prep",
          "args": [
            "child_sd->s_dentry",
            "target"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_depend_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "1027-1055",
          "snippet": "static int configfs_depend_prep(struct dentry *origin,\n\t\t\t\tstruct config_item *target)\n{\n\tstruct configfs_dirent *child_sd, *sd;\n\tint ret = 0;\n\n\tBUG_ON(!origin || !origin->d_fsdata);\n\tsd = origin->d_fsdata;\n\n\tif (sd->s_element == target)  /* Boo-yah */\n\t\tgoto out;\n\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling) {\n\t\tif ((child_sd->s_type & CONFIGFS_DIR) &&\n\t\t    !(child_sd->s_type & CONFIGFS_USET_DROPPING) &&\n\t\t    !(child_sd->s_type & CONFIGFS_USET_CREATING)) {\n\t\t\tret = configfs_depend_prep(child_sd->s_dentry,\n\t\t\t\t\t\t   target);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;  /* Child path boo-yah */\n\t\t}\n\t}\n\n\t/* We looped all our children and didn't find target */\n\tret = -ENOENT;\n\nout:\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child_sd",
            "&sd->s_children",
            "s_sibling"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!origin || !origin->d_fsdata"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic int configfs_depend_prep(struct dentry *origin,\n\t\t\t\tstruct config_item *target)\n{\n\tstruct configfs_dirent *child_sd, *sd;\n\tint ret = 0;\n\n\tBUG_ON(!origin || !origin->d_fsdata);\n\tsd = origin->d_fsdata;\n\n\tif (sd->s_element == target)  /* Boo-yah */\n\t\tgoto out;\n\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling) {\n\t\tif ((child_sd->s_type & CONFIGFS_DIR) &&\n\t\t    !(child_sd->s_type & CONFIGFS_USET_DROPPING) &&\n\t\t    !(child_sd->s_type & CONFIGFS_USET_CREATING)) {\n\t\t\tret = configfs_depend_prep(child_sd->s_dentry,\n\t\t\t\t\t\t   target);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;  /* Child path boo-yah */\n\t\t}\n\t}\n\n\t/* We looped all our children and didn't find target */\n\tret = -ENOENT;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "configfs_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "948-965",
    "snippet": "static int configfs_dump(struct configfs_dirent *sd, int level)\n{\n\tstruct configfs_dirent *child_sd;\n\tint ret = 0;\n\n\tconfigfs_dump_one(sd, level);\n\n\tif (!(sd->s_type & (CONFIGFS_DIR|CONFIGFS_ROOT)))\n\t\treturn 0;\n\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling) {\n\t\tret = configfs_dump(child_sd, level + 2);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_dump",
          "args": [
            "child_sd",
            "level + 2"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "948-965",
          "snippet": "static int configfs_dump(struct configfs_dirent *sd, int level)\n{\n\tstruct configfs_dirent *child_sd;\n\tint ret = 0;\n\n\tconfigfs_dump_one(sd, level);\n\n\tif (!(sd->s_type & (CONFIGFS_DIR|CONFIGFS_ROOT)))\n\t\treturn 0;\n\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling) {\n\t\tret = configfs_dump(child_sd, level + 2);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child_sd",
            "&sd->s_children",
            "s_sibling"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_dump_one",
          "args": [
            "sd",
            "level"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_dump_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "933-946",
          "snippet": "static void configfs_dump_one(struct configfs_dirent *sd, int level)\n{\n\tpr_info(\"%*s\\\"%s\\\":\\n\", level, \" \", configfs_get_name(sd));\n\n#define type_print(_type) if (sd->s_type & _type) pr_info(\"%*s %s\\n\", level, \" \", #_type);\n\ttype_print(CONFIGFS_ROOT);\n\ttype_print(CONFIGFS_DIR);\n\ttype_print(CONFIGFS_ITEM_ATTR);\n\ttype_print(CONFIGFS_ITEM_LINK);\n\ttype_print(CONFIGFS_USET_DIR);\n\ttype_print(CONFIGFS_USET_DEFAULT);\n\ttype_print(CONFIGFS_USET_DROPPING);\n#undef type_print\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_dump_one(struct configfs_dirent *sd, int level)\n{\n\tpr_info(\"%*s\\\"%s\\\":\\n\", level, \" \", configfs_get_name(sd));\n\n#define type_print(_type) if (sd->s_type & _type) pr_info(\"%*s %s\\n\", level, \" \", #_type);\n\ttype_print(CONFIGFS_ROOT);\n\ttype_print(CONFIGFS_DIR);\n\ttype_print(CONFIGFS_ITEM_ATTR);\n\ttype_print(CONFIGFS_ITEM_LINK);\n\ttype_print(CONFIGFS_USET_DIR);\n\ttype_print(CONFIGFS_USET_DEFAULT);\n\ttype_print(CONFIGFS_USET_DROPPING);\n#undef type_print\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_dump(struct configfs_dirent *sd, int level)\n{\n\tstruct configfs_dirent *child_sd;\n\tint ret = 0;\n\n\tconfigfs_dump_one(sd, level);\n\n\tif (!(sd->s_type & (CONFIGFS_DIR|CONFIGFS_ROOT)))\n\t\treturn 0;\n\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling) {\n\t\tret = configfs_dump(child_sd, level + 2);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "configfs_dump_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "933-946",
    "snippet": "static void configfs_dump_one(struct configfs_dirent *sd, int level)\n{\n\tpr_info(\"%*s\\\"%s\\\":\\n\", level, \" \", configfs_get_name(sd));\n\n#define type_print(_type) if (sd->s_type & _type) pr_info(\"%*s %s\\n\", level, \" \", #_type);\n\ttype_print(CONFIGFS_ROOT);\n\ttype_print(CONFIGFS_DIR);\n\ttype_print(CONFIGFS_ITEM_ATTR);\n\ttype_print(CONFIGFS_ITEM_LINK);\n\ttype_print(CONFIGFS_USET_DIR);\n\ttype_print(CONFIGFS_USET_DEFAULT);\n\ttype_print(CONFIGFS_USET_DROPPING);\n#undef type_print\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "type_print",
          "args": [
            "CONFIGFS_USET_DROPPING"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type_print",
          "args": [
            "CONFIGFS_USET_DEFAULT"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type_print",
          "args": [
            "CONFIGFS_USET_DIR"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type_print",
          "args": [
            "CONFIGFS_ITEM_LINK"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type_print",
          "args": [
            "CONFIGFS_ITEM_ATTR"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type_print",
          "args": [
            "CONFIGFS_DIR"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type_print",
          "args": [
            "CONFIGFS_ROOT"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%*s\\\"%s\\\":\\n\"",
            "level",
            "\" \"",
            "configfs_get_name(sd)"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_get_name",
          "args": [
            "sd"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "211-226",
          "snippet": "const unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nconst unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_dump_one(struct configfs_dirent *sd, int level)\n{\n\tpr_info(\"%*s\\\"%s\\\":\\n\", level, \" \", configfs_get_name(sd));\n\n#define type_print(_type) if (sd->s_type & _type) pr_info(\"%*s %s\\n\", level, \" \", #_type);\n\ttype_print(CONFIGFS_ROOT);\n\ttype_print(CONFIGFS_DIR);\n\ttype_print(CONFIGFS_ITEM_ATTR);\n\ttype_print(CONFIGFS_ITEM_LINK);\n\ttype_print(CONFIGFS_USET_DIR);\n\ttype_print(CONFIGFS_USET_DEFAULT);\n\ttype_print(CONFIGFS_USET_DROPPING);\n#undef type_print\n}"
  },
  {
    "function_name": "client_drop_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "913-930",
    "snippet": "static void client_drop_item(struct config_item *parent_item,\n\t\t\t     struct config_item *item)\n{\n\tstruct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\t/*\n\t * If ->drop_item() exists, it is responsible for the\n\t * config_item_put().\n\t */\n\tif (type->ct_group_ops && type->ct_group_ops->drop_item)\n\t\ttype->ct_group_ops->drop_item(to_config_group(parent_item),\n\t\t\t\t\t      item);\n\telse\n\t\tconfig_item_put(item);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_item_put",
          "args": [
            "item"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "171-175",
          "snippet": "void config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->ct_group_ops->drop_item",
          "args": [
            "to_config_group(parent_item)",
            "item"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "parent_item"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!type"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void client_drop_item(struct config_item *parent_item,\n\t\t\t     struct config_item *item)\n{\n\tstruct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\t/*\n\t * If ->drop_item() exists, it is responsible for the\n\t * config_item_put().\n\t */\n\tif (type->ct_group_ops && type->ct_group_ops->drop_item)\n\t\ttype->ct_group_ops->drop_item(to_config_group(parent_item),\n\t\t\t\t\t      item);\n\telse\n\t\tconfig_item_put(item);\n}"
  },
  {
    "function_name": "client_disconnect_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "894-905",
    "snippet": "static void client_disconnect_notify(struct config_item *parent_item,\n\t\t\t\t     struct config_item *item)\n{\n\tstruct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\tif (type->ct_group_ops && type->ct_group_ops->disconnect_notify)\n\t\ttype->ct_group_ops->disconnect_notify(to_config_group(parent_item),\n\t\t\t\t\t\t      item);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "type->ct_group_ops->disconnect_notify",
          "args": [
            "to_config_group(parent_item)",
            "item"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "parent_item"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!type"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void client_disconnect_notify(struct config_item *parent_item,\n\t\t\t\t     struct config_item *item)\n{\n\tstruct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\tif (type->ct_group_ops && type->ct_group_ops->disconnect_notify)\n\t\ttype->ct_group_ops->disconnect_notify(to_config_group(parent_item),\n\t\t\t\t\t\t      item);\n}"
  },
  {
    "function_name": "configfs_detach_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "879-883",
    "snippet": "static void configfs_detach_group(struct config_item *item)\n{\n\tdetach_groups(to_config_group(item));\n\tconfigfs_detach_item(item);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_detach_item",
          "args": [
            "item"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_detach_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "834-838",
          "snippet": "static void configfs_detach_item(struct config_item *item)\n{\n\tdetach_attrs(item);\n\tconfigfs_remove_dir(item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void configfs_detach_item(struct config_item *item)\n{\n\tdetach_attrs(item);\n\tconfigfs_remove_dir(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_groups",
          "args": [
            "to_config_group(item)"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "detach_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "609-643",
          "snippet": "static void detach_groups(struct config_group *group)\n{\n\tstruct dentry * dentry = dget(group->cg_item.ci_dentry);\n\tstruct dentry *child;\n\tstruct configfs_dirent *parent_sd;\n\tstruct configfs_dirent *sd, *tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    !(sd->s_type & CONFIGFS_USET_DEFAULT))\n\t\t\tcontinue;\n\n\t\tchild = sd->s_dentry;\n\n\t\tmutex_lock(&child->d_inode->i_mutex);\n\n\t\tconfigfs_detach_group(sd->s_element);\n\t\tchild->d_inode->i_flags |= S_DEAD;\n\t\tdont_mount(child);\n\n\t\tmutex_unlock(&child->d_inode->i_mutex);\n\n\t\td_delete(child);\n\t\tdput(child);\n\t}\n\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic void detach_groups(struct config_group *group)\n{\n\tstruct dentry * dentry = dget(group->cg_item.ci_dentry);\n\tstruct dentry *child;\n\tstruct configfs_dirent *parent_sd;\n\tstruct configfs_dirent *sd, *tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    !(sd->s_type & CONFIGFS_USET_DEFAULT))\n\t\t\tcontinue;\n\n\t\tchild = sd->s_dentry;\n\n\t\tmutex_lock(&child->d_inode->i_mutex);\n\n\t\tconfigfs_detach_group(sd->s_element);\n\t\tchild->d_inode->i_flags |= S_DEAD;\n\t\tdont_mount(child);\n\n\t\tmutex_unlock(&child->d_inode->i_mutex);\n\n\t\td_delete(child);\n\t\tdput(child);\n\t}\n\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "item"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void configfs_detach_group(struct config_item *item)\n{\n\tdetach_groups(to_config_group(item));\n\tconfigfs_detach_item(item);\n}"
  },
  {
    "function_name": "configfs_attach_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "840-876",
    "snippet": "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\n\tret = configfs_attach_item(parent_item, item, dentry);\n\tif (!ret) {\n\t\tsd = dentry->d_fsdata;\n\t\tsd->s_type |= CONFIGFS_USET_DIR;\n\n\t\t/*\n\t\t * FYI, we're faking mkdir in populate_groups()\n\t\t * We must lock the group's inode to avoid races with the VFS\n\t\t * which can already hit the inode and try to add/remove entries\n\t\t * under it.\n\t\t *\n\t\t * We must also lock the inode to remove it safely in case of\n\t\t * error, as rmdir() would.\n\t\t */\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\tconfigfs_adjust_dir_dirent_depth_before_populate(sd);\n\t\tret = populate_groups(to_config_group(item));\n\t\tif (ret) {\n\t\t\tconfigfs_detach_item(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t}\n\t\tconfigfs_adjust_dir_dirent_depth_after_populate(sd);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\tif (ret)\n\t\t\td_delete(dentry);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dentry"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "afs_d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "699-717",
          "snippet": "static int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
            "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
            "static int afs_d_delete(const struct dentry *dentry);",
            "static void afs_d_release(struct dentry *dentry);",
            "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
            "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
            "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_adjust_dir_dirent_depth_after_populate",
          "args": [
            "sd"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_adjust_dir_dirent_depth_after_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "162-165",
          "snippet": "static void\nconfigfs_adjust_dir_dirent_depth_after_populate(struct configfs_dirent *sd)\n{\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void\nconfigfs_adjust_dir_dirent_depth_after_populate(struct configfs_dirent *sd)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dont_mount",
          "args": [
            "dentry"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_detach_item",
          "args": [
            "item"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_detach_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "834-838",
          "snippet": "static void configfs_detach_item(struct config_item *item)\n{\n\tdetach_attrs(item);\n\tconfigfs_remove_dir(item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void configfs_detach_item(struct config_item *item)\n{\n\tdetach_attrs(item);\n\tconfigfs_remove_dir(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_groups",
          "args": [
            "to_config_group(item)"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "populate_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "684-703",
          "snippet": "static int populate_groups(struct config_group *group)\n{\n\tstruct config_group *new_group;\n\tint ret = 0;\n\tint i;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\n\t\t\tret = create_default_group(group, new_group);\n\t\t\tif (ret) {\n\t\t\t\tdetach_groups(group);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int populate_groups(struct config_group *group)\n{\n\tstruct config_group *new_group;\n\tint ret = 0;\n\tint i;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\n\t\t\tret = create_default_group(group, new_group);\n\t\t\tif (ret) {\n\t\t\t\tdetach_groups(group);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "item"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_adjust_dir_dirent_depth_before_populate",
          "args": [
            "sd"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_adjust_dir_dirent_depth_before_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "157-160",
          "snippet": "static void\nconfigfs_adjust_dir_dirent_depth_before_populate(struct configfs_dirent *sd)\n{\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void\nconfigfs_adjust_dir_dirent_depth_before_populate(struct configfs_dirent *sd)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dentry->d_inode->i_mutex",
            "I_MUTEX_CHILD"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_attach_item",
          "args": [
            "parent_item",
            "item",
            "dentry"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_attach_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "806-831",
          "snippet": "static int configfs_attach_item(struct config_item *parent_item,\n\t\t\t\tstruct config_item *item,\n\t\t\t\tstruct dentry *dentry)\n{\n\tint ret;\n\n\tret = configfs_create_dir(item, dentry);\n\tif (!ret) {\n\t\tret = populate_attrs(item);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * We are going to remove an inode and its dentry but\n\t\t\t * the VFS may already have hit and used them. Thus,\n\t\t\t * we must lock them as rmdir() would.\n\t\t\t */\n\t\t\tmutex_lock(&dentry->d_inode->i_mutex);\n\t\t\tconfigfs_remove_dir(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\t\td_delete(dentry);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int configfs_attach_item(struct config_item *parent_item,\n\t\t\t\tstruct config_item *item,\n\t\t\t\tstruct dentry *dentry)\n{\n\tint ret;\n\n\tret = configfs_create_dir(item, dentry);\n\tif (!ret) {\n\t\tret = populate_attrs(item);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * We are going to remove an inode and its dentry but\n\t\t\t * the VFS may already have hit and used them. Thus,\n\t\t\t * we must lock them as rmdir() would.\n\t\t\t */\n\t\t\tmutex_lock(&dentry->d_inode->i_mutex);\n\t\t\tconfigfs_remove_dir(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\t\td_delete(dentry);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\n\tret = configfs_attach_item(parent_item, item, dentry);\n\tif (!ret) {\n\t\tsd = dentry->d_fsdata;\n\t\tsd->s_type |= CONFIGFS_USET_DIR;\n\n\t\t/*\n\t\t * FYI, we're faking mkdir in populate_groups()\n\t\t * We must lock the group's inode to avoid races with the VFS\n\t\t * which can already hit the inode and try to add/remove entries\n\t\t * under it.\n\t\t *\n\t\t * We must also lock the inode to remove it safely in case of\n\t\t * error, as rmdir() would.\n\t\t */\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\tconfigfs_adjust_dir_dirent_depth_before_populate(sd);\n\t\tret = populate_groups(to_config_group(item));\n\t\tif (ret) {\n\t\t\tconfigfs_detach_item(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t}\n\t\tconfigfs_adjust_dir_dirent_depth_after_populate(sd);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\tif (ret)\n\t\t\td_delete(dentry);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "configfs_detach_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "834-838",
    "snippet": "static void configfs_detach_item(struct config_item *item)\n{\n\tdetach_attrs(item);\n\tconfigfs_remove_dir(item);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_remove_dir",
          "args": [
            "item"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_remove_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "397-409",
          "snippet": "static void configfs_remove_dir(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\n\tif (!dentry)\n\t\treturn;\n\n\tremove_dir(dentry);\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void configfs_remove_dir(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\n\tif (!dentry)\n\t\treturn;\n\n\tremove_dir(dentry);\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_attrs",
          "args": [
            "item"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "detach_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "553-580",
          "snippet": "static void detach_attrs(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\tstruct configfs_dirent * parent_sd;\n\tstruct configfs_dirent * sd, * tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tpr_debug(\"configfs %s: dropping attrs for  dir\\n\",\n\t\t dentry->d_name.name);\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element || !(sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tlist_del_init(&sd->s_sibling);\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfigfs_drop_dentry(sd, dentry);\n\t\tconfigfs_put(sd);\n\t}\n\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void detach_attrs(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\tstruct configfs_dirent * parent_sd;\n\tstruct configfs_dirent * sd, * tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tpr_debug(\"configfs %s: dropping attrs for  dir\\n\",\n\t\t dentry->d_name.name);\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element || !(sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tlist_del_init(&sd->s_sibling);\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfigfs_drop_dentry(sd, dentry);\n\t\tconfigfs_put(sd);\n\t}\n\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void configfs_detach_item(struct config_item *item)\n{\n\tdetach_attrs(item);\n\tconfigfs_remove_dir(item);\n}"
  },
  {
    "function_name": "configfs_attach_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "806-831",
    "snippet": "static int configfs_attach_item(struct config_item *parent_item,\n\t\t\t\tstruct config_item *item,\n\t\t\t\tstruct dentry *dentry)\n{\n\tint ret;\n\n\tret = configfs_create_dir(item, dentry);\n\tif (!ret) {\n\t\tret = populate_attrs(item);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * We are going to remove an inode and its dentry but\n\t\t\t * the VFS may already have hit and used them. Thus,\n\t\t\t * we must lock them as rmdir() would.\n\t\t\t */\n\t\t\tmutex_lock(&dentry->d_inode->i_mutex);\n\t\t\tconfigfs_remove_dir(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\t\td_delete(dentry);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dentry"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "afs_d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "699-717",
          "snippet": "static int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
            "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
            "static int afs_d_delete(const struct dentry *dentry);",
            "static void afs_d_release(struct dentry *dentry);",
            "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
            "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
            "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dont_mount",
          "args": [
            "dentry"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_remove_dir",
          "args": [
            "item"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_remove_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "397-409",
          "snippet": "static void configfs_remove_dir(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\n\tif (!dentry)\n\t\treturn;\n\n\tremove_dir(dentry);\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void configfs_remove_dir(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\n\tif (!dentry)\n\t\treturn;\n\n\tremove_dir(dentry);\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_attrs",
          "args": [
            "item"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "populate_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "582-602",
          "snippet": "static int populate_attrs(struct config_item *item)\n{\n\tstruct config_item_type *t = item->ci_type;\n\tstruct configfs_attribute *attr;\n\tint error = 0;\n\tint i;\n\n\tif (!t)\n\t\treturn -EINVAL;\n\tif (t->ct_attrs) {\n\t\tfor (i = 0; (attr = t->ct_attrs[i]) != NULL; i++) {\n\t\t\tif ((error = configfs_create_file(item, attr)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error)\n\t\tdetach_attrs(item);\n\n\treturn error;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int populate_attrs(struct config_item *item)\n{\n\tstruct config_item_type *t = item->ci_type;\n\tstruct configfs_attribute *attr;\n\tint error = 0;\n\tint i;\n\n\tif (!t)\n\t\treturn -EINVAL;\n\tif (t->ct_attrs) {\n\t\tfor (i = 0; (attr = t->ct_attrs[i]) != NULL; i++) {\n\t\t\tif ((error = configfs_create_file(item, attr)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error)\n\t\tdetach_attrs(item);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_create_dir",
          "args": [
            "item",
            "dentry"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "272-304",
          "snippet": "static int configfs_create_dir(struct config_item *item, struct dentry *dentry)\n{\n\tint error;\n\tumode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;\n\tstruct dentry *p = dentry->d_parent;\n\n\tBUG_ON(!item);\n\n\terror = configfs_dirent_exists(p->d_fsdata, dentry->d_name.name);\n\tif (unlikely(error))\n\t\treturn error;\n\n\terror = configfs_make_dirent(p->d_fsdata, dentry, item, mode,\n\t\t\t\t     CONFIGFS_DIR | CONFIGFS_USET_CREATING);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tconfigfs_set_dir_dirent_depth(p->d_fsdata, dentry->d_fsdata);\n\terror = configfs_create(dentry, mode, init_dir);\n\tif (!error) {\n\t\tinc_nlink(p->d_inode);\n\t\titem->ci_dentry = dentry;\n\t} else {\n\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\tif (sd) {\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\tconfigfs_put(sd);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int configfs_create_dir(struct config_item *item, struct dentry *dentry)\n{\n\tint error;\n\tumode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;\n\tstruct dentry *p = dentry->d_parent;\n\n\tBUG_ON(!item);\n\n\terror = configfs_dirent_exists(p->d_fsdata, dentry->d_name.name);\n\tif (unlikely(error))\n\t\treturn error;\n\n\terror = configfs_make_dirent(p->d_fsdata, dentry, item, mode,\n\t\t\t\t     CONFIGFS_DIR | CONFIGFS_USET_CREATING);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tconfigfs_set_dir_dirent_depth(p->d_fsdata, dentry->d_fsdata);\n\terror = configfs_create(dentry, mode, init_dir);\n\tif (!error) {\n\t\tinc_nlink(p->d_inode);\n\t\titem->ci_dentry = dentry;\n\t} else {\n\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\tif (sd) {\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\tconfigfs_put(sd);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int configfs_attach_item(struct config_item *parent_item,\n\t\t\t\tstruct config_item *item,\n\t\t\t\tstruct dentry *dentry)\n{\n\tint ret;\n\n\tret = configfs_create_dir(item, dentry);\n\tif (!ret) {\n\t\tret = populate_attrs(item);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * We are going to remove an inode and its dentry but\n\t\t\t * the VFS may already have hit and used them. Thus,\n\t\t\t * we must lock them as rmdir() would.\n\t\t\t */\n\t\t\tmutex_lock(&dentry->d_inode->i_mutex);\n\t\t\tconfigfs_remove_dir(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\t\td_delete(dentry);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "link_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "767-789",
    "snippet": "static void link_group(struct config_group *parent_group, struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\tstruct configfs_subsystem *subsys = NULL; /* gcc is a turd */\n\n\tlink_obj(&parent_group->cg_item, &group->cg_item);\n\n\tif (parent_group->cg_subsys)\n\t\tsubsys = parent_group->cg_subsys;\n\telse if (configfs_is_root(&parent_group->cg_item))\n\t\tsubsys = to_configfs_subsystem(group);\n\telse\n\t\tBUG();\n\tgroup->cg_subsys = subsys;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tlink_group(group, new_group);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "link_group",
          "args": [
            "group",
            "new_group"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "link_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "767-789",
          "snippet": "static void link_group(struct config_group *parent_group, struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\tstruct configfs_subsystem *subsys = NULL; /* gcc is a turd */\n\n\tlink_obj(&parent_group->cg_item, &group->cg_item);\n\n\tif (parent_group->cg_subsys)\n\t\tsubsys = parent_group->cg_subsys;\n\telse if (configfs_is_root(&parent_group->cg_item))\n\t\tsubsys = to_configfs_subsystem(group);\n\telse\n\t\tBUG();\n\tgroup->cg_subsys = subsys;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tlink_group(group, new_group);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_configfs_subsystem",
          "args": [
            "group"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_is_root",
          "args": [
            "&parent_group->cg_item"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_is_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
          "lines": "56-59",
          "snippet": "int configfs_is_root(struct config_item *item)\n{\n\treturn item == &configfs_root_group.cg_item;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct config_group configfs_root_group = {\n\t.cg_item = {\n\t\t.ci_namebuf\t= \"root\",\n\t\t.ci_name\t= configfs_root_group.cg_item.ci_namebuf,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct config_group configfs_root_group = {\n\t.cg_item = {\n\t\t.ci_namebuf\t= \"root\",\n\t\t.ci_name\t= configfs_root_group.cg_item.ci_namebuf,\n\t},\n};\n\nint configfs_is_root(struct config_item *item)\n{\n\treturn item == &configfs_root_group.cg_item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_obj",
          "args": [
            "&parent_group->cg_item",
            "&group->cg_item"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "link_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "729-749",
          "snippet": "static void link_obj(struct config_item *parent_item, struct config_item *item)\n{\n\t/*\n\t * Parent seems redundant with group, but it makes certain\n\t * traversals much nicer.\n\t */\n\titem->ci_parent = parent_item;\n\n\t/*\n\t * We hold a reference on the parent for the child's ci_parent\n\t * link.\n\t */\n\titem->ci_group = config_group_get(to_config_group(parent_item));\n\tlist_add_tail(&item->ci_entry, &item->ci_group->cg_children);\n\n\t/*\n\t * We hold a reference on the child for ci_entry on the parent's\n\t * cg_children\n\t */\n\tconfig_item_get(item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void link_obj(struct config_item *parent_item, struct config_item *item)\n{\n\t/*\n\t * Parent seems redundant with group, but it makes certain\n\t * traversals much nicer.\n\t */\n\titem->ci_parent = parent_item;\n\n\t/*\n\t * We hold a reference on the parent for the child's ci_parent\n\t * link.\n\t */\n\titem->ci_group = config_group_get(to_config_group(parent_item));\n\tlist_add_tail(&item->ci_entry, &item->ci_group->cg_children);\n\n\t/*\n\t * We hold a reference on the child for ci_entry on the parent's\n\t * cg_children\n\t */\n\tconfig_item_get(item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void link_group(struct config_group *parent_group, struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\tstruct configfs_subsystem *subsys = NULL; /* gcc is a turd */\n\n\tlink_obj(&parent_group->cg_item, &group->cg_item);\n\n\tif (parent_group->cg_subsys)\n\t\tsubsys = parent_group->cg_subsys;\n\telse if (configfs_is_root(&parent_group->cg_item))\n\t\tsubsys = to_configfs_subsystem(group);\n\telse\n\t\tBUG();\n\tgroup->cg_subsys = subsys;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tlink_group(group, new_group);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "unlink_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "751-765",
    "snippet": "static void unlink_group(struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tunlink_group(new_group);\n\t\t}\n\t}\n\n\tgroup->cg_subsys = NULL;\n\tunlink_obj(&group->cg_item);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink_obj",
          "args": [
            "&group->cg_item"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "710-727",
          "snippet": "static void unlink_obj(struct config_item *item)\n{\n\tstruct config_group *group;\n\n\tgroup = item->ci_group;\n\tif (group) {\n\t\tlist_del_init(&item->ci_entry);\n\n\t\titem->ci_group = NULL;\n\t\titem->ci_parent = NULL;\n\n\t\t/* Drop the reference for ci_entry */\n\t\tconfig_item_put(item);\n\n\t\t/* Drop the reference for ci_parent */\n\t\tconfig_group_put(group);\n\t}\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void unlink_obj(struct config_item *item)\n{\n\tstruct config_group *group;\n\n\tgroup = item->ci_group;\n\tif (group) {\n\t\tlist_del_init(&item->ci_entry);\n\n\t\titem->ci_group = NULL;\n\t\titem->ci_parent = NULL;\n\n\t\t/* Drop the reference for ci_entry */\n\t\tconfig_item_put(item);\n\n\t\t/* Drop the reference for ci_parent */\n\t\tconfig_group_put(group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_group",
          "args": [
            "new_group"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "751-765",
          "snippet": "static void unlink_group(struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tunlink_group(new_group);\n\t\t}\n\t}\n\n\tgroup->cg_subsys = NULL;\n\tunlink_obj(&group->cg_item);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void unlink_group(struct config_group *group)\n{\n\tint i;\n\tstruct config_group *new_group;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\t\t\tunlink_group(new_group);\n\t\t}\n\t}\n\n\tgroup->cg_subsys = NULL;\n\tunlink_obj(&group->cg_item);\n}"
  },
  {
    "function_name": "link_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "729-749",
    "snippet": "static void link_obj(struct config_item *parent_item, struct config_item *item)\n{\n\t/*\n\t * Parent seems redundant with group, but it makes certain\n\t * traversals much nicer.\n\t */\n\titem->ci_parent = parent_item;\n\n\t/*\n\t * We hold a reference on the parent for the child's ci_parent\n\t * link.\n\t */\n\titem->ci_group = config_group_get(to_config_group(parent_item));\n\tlist_add_tail(&item->ci_entry, &item->ci_group->cg_children);\n\n\t/*\n\t * We hold a reference on the child for ci_entry on the parent's\n\t * cg_children\n\t */\n\tconfig_item_get(item);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_item_get",
          "args": [
            "item"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "134-139",
          "snippet": "struct config_item *config_item_get(struct config_item *item)\n{\n\tif (item)\n\t\tkref_get(&item->ci_kref);\n\treturn item;\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nstruct config_item *config_item_get(struct config_item *item)\n{\n\tif (item)\n\t\tkref_get(&item->ci_kref);\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&item->ci_entry",
            "&item->ci_group->cg_children"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_group_get",
          "args": [
            "to_config_group(parent_item)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "parent_item"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void link_obj(struct config_item *parent_item, struct config_item *item)\n{\n\t/*\n\t * Parent seems redundant with group, but it makes certain\n\t * traversals much nicer.\n\t */\n\titem->ci_parent = parent_item;\n\n\t/*\n\t * We hold a reference on the parent for the child's ci_parent\n\t * link.\n\t */\n\titem->ci_group = config_group_get(to_config_group(parent_item));\n\tlist_add_tail(&item->ci_entry, &item->ci_group->cg_children);\n\n\t/*\n\t * We hold a reference on the child for ci_entry on the parent's\n\t * cg_children\n\t */\n\tconfig_item_get(item);\n}"
  },
  {
    "function_name": "unlink_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "710-727",
    "snippet": "static void unlink_obj(struct config_item *item)\n{\n\tstruct config_group *group;\n\n\tgroup = item->ci_group;\n\tif (group) {\n\t\tlist_del_init(&item->ci_entry);\n\n\t\titem->ci_group = NULL;\n\t\titem->ci_parent = NULL;\n\n\t\t/* Drop the reference for ci_entry */\n\t\tconfig_item_put(item);\n\n\t\t/* Drop the reference for ci_parent */\n\t\tconfig_group_put(group);\n\t}\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_group_put",
          "args": [
            "group"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_item_put",
          "args": [
            "item"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "171-175",
          "snippet": "void config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&item->ci_entry"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void unlink_obj(struct config_item *item)\n{\n\tstruct config_group *group;\n\n\tgroup = item->ci_group;\n\tif (group) {\n\t\tlist_del_init(&item->ci_entry);\n\n\t\titem->ci_group = NULL;\n\t\titem->ci_parent = NULL;\n\n\t\t/* Drop the reference for ci_entry */\n\t\tconfig_item_put(item);\n\n\t\t/* Drop the reference for ci_parent */\n\t\tconfig_group_put(group);\n\t}\n}"
  },
  {
    "function_name": "populate_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "684-703",
    "snippet": "static int populate_groups(struct config_group *group)\n{\n\tstruct config_group *new_group;\n\tint ret = 0;\n\tint i;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\n\t\t\tret = create_default_group(group, new_group);\n\t\t\tif (ret) {\n\t\t\t\tdetach_groups(group);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "detach_groups",
          "args": [
            "group"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "detach_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "609-643",
          "snippet": "static void detach_groups(struct config_group *group)\n{\n\tstruct dentry * dentry = dget(group->cg_item.ci_dentry);\n\tstruct dentry *child;\n\tstruct configfs_dirent *parent_sd;\n\tstruct configfs_dirent *sd, *tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    !(sd->s_type & CONFIGFS_USET_DEFAULT))\n\t\t\tcontinue;\n\n\t\tchild = sd->s_dentry;\n\n\t\tmutex_lock(&child->d_inode->i_mutex);\n\n\t\tconfigfs_detach_group(sd->s_element);\n\t\tchild->d_inode->i_flags |= S_DEAD;\n\t\tdont_mount(child);\n\n\t\tmutex_unlock(&child->d_inode->i_mutex);\n\n\t\td_delete(child);\n\t\tdput(child);\n\t}\n\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic void detach_groups(struct config_group *group)\n{\n\tstruct dentry * dentry = dget(group->cg_item.ci_dentry);\n\tstruct dentry *child;\n\tstruct configfs_dirent *parent_sd;\n\tstruct configfs_dirent *sd, *tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    !(sd->s_type & CONFIGFS_USET_DEFAULT))\n\t\t\tcontinue;\n\n\t\tchild = sd->s_dentry;\n\n\t\tmutex_lock(&child->d_inode->i_mutex);\n\n\t\tconfigfs_detach_group(sd->s_element);\n\t\tchild->d_inode->i_flags |= S_DEAD;\n\t\tdont_mount(child);\n\n\t\tmutex_unlock(&child->d_inode->i_mutex);\n\n\t\td_delete(child);\n\t\tdput(child);\n\t}\n\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_default_group",
          "args": [
            "group",
            "new_group"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "create_default_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "653-682",
          "snippet": "static int create_default_group(struct config_group *parent_group,\n\t\t\t\tstruct config_group *group)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\t/* We trust the caller holds a reference to parent */\n\tstruct dentry *child, *parent = parent_group->cg_item.ci_dentry;\n\n\tif (!group->cg_item.ci_name)\n\t\tgroup->cg_item.ci_name = group->cg_item.ci_namebuf;\n\n\tret = -ENOMEM;\n\tchild = d_alloc_name(parent, group->cg_item.ci_name);\n\tif (child) {\n\t\td_add(child, NULL);\n\n\t\tret = configfs_attach_group(&parent_group->cg_item,\n\t\t\t\t\t    &group->cg_item, child);\n\t\tif (!ret) {\n\t\t\tsd = child->d_fsdata;\n\t\t\tsd->s_type |= CONFIGFS_USET_DEFAULT;\n\t\t} else {\n\t\t\tBUG_ON(child->d_inode);\n\t\t\td_drop(child);\n\t\t\tdput(child);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic int create_default_group(struct config_group *parent_group,\n\t\t\t\tstruct config_group *group)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\t/* We trust the caller holds a reference to parent */\n\tstruct dentry *child, *parent = parent_group->cg_item.ci_dentry;\n\n\tif (!group->cg_item.ci_name)\n\t\tgroup->cg_item.ci_name = group->cg_item.ci_namebuf;\n\n\tret = -ENOMEM;\n\tchild = d_alloc_name(parent, group->cg_item.ci_name);\n\tif (child) {\n\t\td_add(child, NULL);\n\n\t\tret = configfs_attach_group(&parent_group->cg_item,\n\t\t\t\t\t    &group->cg_item, child);\n\t\tif (!ret) {\n\t\t\tsd = child->d_fsdata;\n\t\t\tsd->s_type |= CONFIGFS_USET_DEFAULT;\n\t\t} else {\n\t\t\tBUG_ON(child->d_inode);\n\t\t\td_drop(child);\n\t\t\tdput(child);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int populate_groups(struct config_group *group)\n{\n\tstruct config_group *new_group;\n\tint ret = 0;\n\tint i;\n\n\tif (group->default_groups) {\n\t\tfor (i = 0; group->default_groups[i]; i++) {\n\t\t\tnew_group = group->default_groups[i];\n\n\t\t\tret = create_default_group(group, new_group);\n\t\t\tif (ret) {\n\t\t\t\tdetach_groups(group);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "create_default_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "653-682",
    "snippet": "static int create_default_group(struct config_group *parent_group,\n\t\t\t\tstruct config_group *group)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\t/* We trust the caller holds a reference to parent */\n\tstruct dentry *child, *parent = parent_group->cg_item.ci_dentry;\n\n\tif (!group->cg_item.ci_name)\n\t\tgroup->cg_item.ci_name = group->cg_item.ci_namebuf;\n\n\tret = -ENOMEM;\n\tchild = d_alloc_name(parent, group->cg_item.ci_name);\n\tif (child) {\n\t\td_add(child, NULL);\n\n\t\tret = configfs_attach_group(&parent_group->cg_item,\n\t\t\t\t\t    &group->cg_item, child);\n\t\tif (!ret) {\n\t\t\tsd = child->d_fsdata;\n\t\t\tsd->s_type |= CONFIGFS_USET_DEFAULT;\n\t\t} else {\n\t\t\tBUG_ON(child->d_inode);\n\t\t\td_drop(child);\n\t\t\tdput(child);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "child"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "child"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "child->d_inode"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_attach_group",
          "args": [
            "&parent_group->cg_item",
            "&group->cg_item",
            "child"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_attach_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "840-876",
          "snippet": "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\n\tret = configfs_attach_item(parent_item, item, dentry);\n\tif (!ret) {\n\t\tsd = dentry->d_fsdata;\n\t\tsd->s_type |= CONFIGFS_USET_DIR;\n\n\t\t/*\n\t\t * FYI, we're faking mkdir in populate_groups()\n\t\t * We must lock the group's inode to avoid races with the VFS\n\t\t * which can already hit the inode and try to add/remove entries\n\t\t * under it.\n\t\t *\n\t\t * We must also lock the inode to remove it safely in case of\n\t\t * error, as rmdir() would.\n\t\t */\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\tconfigfs_adjust_dir_dirent_depth_before_populate(sd);\n\t\tret = populate_groups(to_config_group(item));\n\t\tif (ret) {\n\t\t\tconfigfs_detach_item(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t}\n\t\tconfigfs_adjust_dir_dirent_depth_after_populate(sd);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\tif (ret)\n\t\t\td_delete(dentry);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\n\tret = configfs_attach_item(parent_item, item, dentry);\n\tif (!ret) {\n\t\tsd = dentry->d_fsdata;\n\t\tsd->s_type |= CONFIGFS_USET_DIR;\n\n\t\t/*\n\t\t * FYI, we're faking mkdir in populate_groups()\n\t\t * We must lock the group's inode to avoid races with the VFS\n\t\t * which can already hit the inode and try to add/remove entries\n\t\t * under it.\n\t\t *\n\t\t * We must also lock the inode to remove it safely in case of\n\t\t * error, as rmdir() would.\n\t\t */\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\tconfigfs_adjust_dir_dirent_depth_before_populate(sd);\n\t\tret = populate_groups(to_config_group(item));\n\t\tif (ret) {\n\t\t\tconfigfs_detach_item(item);\n\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t}\n\t\tconfigfs_adjust_dir_dirent_depth_after_populate(sd);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\tif (ret)\n\t\t\td_delete(dentry);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "child",
            "NULL"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "parent",
            "group->cg_item.ci_name"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic int create_default_group(struct config_group *parent_group,\n\t\t\t\tstruct config_group *group)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\t/* We trust the caller holds a reference to parent */\n\tstruct dentry *child, *parent = parent_group->cg_item.ci_dentry;\n\n\tif (!group->cg_item.ci_name)\n\t\tgroup->cg_item.ci_name = group->cg_item.ci_namebuf;\n\n\tret = -ENOMEM;\n\tchild = d_alloc_name(parent, group->cg_item.ci_name);\n\tif (child) {\n\t\td_add(child, NULL);\n\n\t\tret = configfs_attach_group(&parent_group->cg_item,\n\t\t\t\t\t    &group->cg_item, child);\n\t\tif (!ret) {\n\t\t\tsd = child->d_fsdata;\n\t\t\tsd->s_type |= CONFIGFS_USET_DEFAULT;\n\t\t} else {\n\t\t\tBUG_ON(child->d_inode);\n\t\t\td_drop(child);\n\t\t\tdput(child);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "detach_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "609-643",
    "snippet": "static void detach_groups(struct config_group *group)\n{\n\tstruct dentry * dentry = dget(group->cg_item.ci_dentry);\n\tstruct dentry *child;\n\tstruct configfs_dirent *parent_sd;\n\tstruct configfs_dirent *sd, *tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    !(sd->s_type & CONFIGFS_USET_DEFAULT))\n\t\t\tcontinue;\n\n\t\tchild = sd->s_dentry;\n\n\t\tmutex_lock(&child->d_inode->i_mutex);\n\n\t\tconfigfs_detach_group(sd->s_element);\n\t\tchild->d_inode->i_flags |= S_DEAD;\n\t\tdont_mount(child);\n\n\t\tmutex_unlock(&child->d_inode->i_mutex);\n\n\t\td_delete(child);\n\t\tdput(child);\n\t}\n\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "child"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "afs_d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "699-717",
          "snippet": "static int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
            "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
            "static int afs_d_delete(const struct dentry *dentry);",
            "static void afs_d_release(struct dentry *dentry);",
            "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
            "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
            "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&child->d_inode->i_mutex"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dont_mount",
          "args": [
            "child"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_detach_group",
          "args": [
            "sd->s_element"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_detach_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "879-883",
          "snippet": "static void configfs_detach_group(struct config_item *item)\n{\n\tdetach_groups(to_config_group(item));\n\tconfigfs_detach_item(item);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void configfs_detach_group(struct config_item *item)\n{\n\tdetach_groups(to_config_group(item));\n\tconfigfs_detach_item(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&child->d_inode->i_mutex"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "sd",
            "tmp",
            "&parent_sd->s_children",
            "s_sibling"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "group->cg_item.ci_dentry"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic void detach_groups(struct config_group *group)\n{\n\tstruct dentry * dentry = dget(group->cg_item.ci_dentry);\n\tstruct dentry *child;\n\tstruct configfs_dirent *parent_sd;\n\tstruct configfs_dirent *sd, *tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    !(sd->s_type & CONFIGFS_USET_DEFAULT))\n\t\t\tcontinue;\n\n\t\tchild = sd->s_dentry;\n\n\t\tmutex_lock(&child->d_inode->i_mutex);\n\n\t\tconfigfs_detach_group(sd->s_element);\n\t\tchild->d_inode->i_flags |= S_DEAD;\n\t\tdont_mount(child);\n\n\t\tmutex_unlock(&child->d_inode->i_mutex);\n\n\t\td_delete(child);\n\t\tdput(child);\n\t}\n\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}"
  },
  {
    "function_name": "populate_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "582-602",
    "snippet": "static int populate_attrs(struct config_item *item)\n{\n\tstruct config_item_type *t = item->ci_type;\n\tstruct configfs_attribute *attr;\n\tint error = 0;\n\tint i;\n\n\tif (!t)\n\t\treturn -EINVAL;\n\tif (t->ct_attrs) {\n\t\tfor (i = 0; (attr = t->ct_attrs[i]) != NULL; i++) {\n\t\t\tif ((error = configfs_create_file(item, attr)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error)\n\t\tdetach_attrs(item);\n\n\treturn error;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "detach_attrs",
          "args": [
            "item"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "detach_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "553-580",
          "snippet": "static void detach_attrs(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\tstruct configfs_dirent * parent_sd;\n\tstruct configfs_dirent * sd, * tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tpr_debug(\"configfs %s: dropping attrs for  dir\\n\",\n\t\t dentry->d_name.name);\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element || !(sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tlist_del_init(&sd->s_sibling);\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfigfs_drop_dentry(sd, dentry);\n\t\tconfigfs_put(sd);\n\t}\n\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void detach_attrs(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\tstruct configfs_dirent * parent_sd;\n\tstruct configfs_dirent * sd, * tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tpr_debug(\"configfs %s: dropping attrs for  dir\\n\",\n\t\t dentry->d_name.name);\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element || !(sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tlist_del_init(&sd->s_sibling);\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfigfs_drop_dentry(sd, dentry);\n\t\tconfigfs_put(sd);\n\t}\n\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_create_file",
          "args": [
            "item",
            "attr"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
          "lines": "322-335",
          "snippet": "int configfs_create_file(struct config_item * item, const struct configfs_attribute * attr)\n{\n\tstruct dentry *dir = item->ci_dentry;\n\tstruct configfs_dirent *parent_sd = dir->d_fsdata;\n\tumode_t mode = (attr->ca_mode & S_IALLUGO) | S_IFREG;\n\tint error = 0;\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_NORMAL);\n\terror = configfs_make_dirent(parent_sd, NULL, (void *) attr, mode,\n\t\t\t\t     CONFIGFS_ITEM_ATTR);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\treturn error;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint configfs_create_file(struct config_item * item, const struct configfs_attribute * attr)\n{\n\tstruct dentry *dir = item->ci_dentry;\n\tstruct configfs_dirent *parent_sd = dir->d_fsdata;\n\tumode_t mode = (attr->ca_mode & S_IALLUGO) | S_IFREG;\n\tint error = 0;\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_NORMAL);\n\terror = configfs_make_dirent(parent_sd, NULL, (void *) attr, mode,\n\t\t\t\t     CONFIGFS_ITEM_ATTR);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int populate_attrs(struct config_item *item)\n{\n\tstruct config_item_type *t = item->ci_type;\n\tstruct configfs_attribute *attr;\n\tint error = 0;\n\tint i;\n\n\tif (!t)\n\t\treturn -EINVAL;\n\tif (t->ct_attrs) {\n\t\tfor (i = 0; (attr = t->ct_attrs[i]) != NULL; i++) {\n\t\t\tif ((error = configfs_create_file(item, attr)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error)\n\t\tdetach_attrs(item);\n\n\treturn error;\n}"
  },
  {
    "function_name": "detach_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "553-580",
    "snippet": "static void detach_attrs(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\tstruct configfs_dirent * parent_sd;\n\tstruct configfs_dirent * sd, * tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tpr_debug(\"configfs %s: dropping attrs for  dir\\n\",\n\t\t dentry->d_name.name);\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element || !(sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tlist_del_init(&sd->s_sibling);\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfigfs_drop_dentry(sd, dentry);\n\t\tconfigfs_put(sd);\n\t}\n\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_put",
          "args": [
            "sd"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "157-162",
          "snippet": "static inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\n\nstatic inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_drop_dentry",
          "args": [
            "sd",
            "dentry"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_drop_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "233-247",
          "snippet": "void configfs_drop_dentry(struct configfs_dirent * sd, struct dentry * parent)\n{\n\tstruct dentry * dentry = sd->s_dentry;\n\n\tif (dentry) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!d_unhashed(dentry) && dentry->d_inode) {\n\t\t\tdget_dlock(dentry);\n\t\t\t__d_drop(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\t} else\n\t\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nvoid configfs_drop_dentry(struct configfs_dirent * sd, struct dentry * parent)\n{\n\tstruct dentry * dentry = sd->s_dentry;\n\n\tif (dentry) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!d_unhashed(dentry) && dentry->d_inode) {\n\t\t\tdget_dlock(dentry);\n\t\t\t__d_drop(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\t} else\n\t\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&sd->s_sibling"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "sd",
            "tmp",
            "&parent_sd->s_children",
            "s_sibling"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"configfs %s: dropping attrs for  dir\\n\"",
            "dentry->d_name.name"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "item->ci_dentry"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void detach_attrs(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\tstruct configfs_dirent * parent_sd;\n\tstruct configfs_dirent * sd, * tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tpr_debug(\"configfs %s: dropping attrs for  dir\\n\",\n\t\t dentry->d_name.name);\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element || !(sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tlist_del_init(&sd->s_sibling);\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfigfs_drop_dentry(sd, dentry);\n\t\tconfigfs_put(sd);\n\t}\n\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}"
  },
  {
    "function_name": "configfs_detach_rollback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "541-551",
    "snippet": "static void configfs_detach_rollback(struct dentry *dentry)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\n\tparent_sd->s_type &= ~CONFIGFS_USET_DROPPING;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling)\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT)\n\t\t\tconfigfs_detach_rollback(sd->s_dentry);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_detach_rollback",
          "args": [
            "sd->s_dentry"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_detach_rollback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "541-551",
          "snippet": "static void configfs_detach_rollback(struct dentry *dentry)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\n\tparent_sd->s_type &= ~CONFIGFS_USET_DROPPING;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling)\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT)\n\t\t\tconfigfs_detach_rollback(sd->s_dentry);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sd",
            "&parent_sd->s_children",
            "s_sibling"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic void configfs_detach_rollback(struct dentry *dentry)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\n\tparent_sd->s_type &= ~CONFIGFS_USET_DROPPING;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling)\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT)\n\t\t\tconfigfs_detach_rollback(sd->s_dentry);\n}"
  },
  {
    "function_name": "configfs_detach_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "494-535",
    "snippet": "static int configfs_detach_prep(struct dentry *dentry, struct mutex **wait_mutex)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\tint ret;\n\n\t/* Mark that we're trying to drop the group */\n\tparent_sd->s_type |= CONFIGFS_USET_DROPPING;\n\n\tret = -EBUSY;\n\tif (!list_empty(&parent_sd->s_links))\n\t\tgoto out;\n\n\tret = 0;\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    (sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT) {\n\t\t\t/* Abort if racing with mkdir() */\n\t\t\tif (sd->s_type & CONFIGFS_USET_IN_MKDIR) {\n\t\t\t\tif (wait_mutex)\n\t\t\t\t\t*wait_mutex = &sd->s_dentry->d_inode->i_mutex;\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Yup, recursive.  If there's a problem, blame\n\t\t\t * deep nesting of default_groups\n\t\t\t */\n\t\t\tret = configfs_detach_prep(sd->s_dentry, wait_mutex);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\tret = -ENOTEMPTY;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_detach_prep",
          "args": [
            "sd->s_dentry",
            "wait_mutex"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_detach_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "494-535",
          "snippet": "static int configfs_detach_prep(struct dentry *dentry, struct mutex **wait_mutex)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\tint ret;\n\n\t/* Mark that we're trying to drop the group */\n\tparent_sd->s_type |= CONFIGFS_USET_DROPPING;\n\n\tret = -EBUSY;\n\tif (!list_empty(&parent_sd->s_links))\n\t\tgoto out;\n\n\tret = 0;\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    (sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT) {\n\t\t\t/* Abort if racing with mkdir() */\n\t\t\tif (sd->s_type & CONFIGFS_USET_IN_MKDIR) {\n\t\t\t\tif (wait_mutex)\n\t\t\t\t\t*wait_mutex = &sd->s_dentry->d_inode->i_mutex;\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Yup, recursive.  If there's a problem, blame\n\t\t\t * deep nesting of default_groups\n\t\t\t */\n\t\t\tret = configfs_detach_prep(sd->s_dentry, wait_mutex);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\tret = -ENOTEMPTY;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sd",
            "&parent_sd->s_children",
            "s_sibling"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&parent_sd->s_links"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic int configfs_detach_prep(struct dentry *dentry, struct mutex **wait_mutex)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\tint ret;\n\n\t/* Mark that we're trying to drop the group */\n\tparent_sd->s_type |= CONFIGFS_USET_DROPPING;\n\n\tret = -EBUSY;\n\tif (!list_empty(&parent_sd->s_links))\n\t\tgoto out;\n\n\tret = 0;\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    (sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT) {\n\t\t\t/* Abort if racing with mkdir() */\n\t\t\tif (sd->s_type & CONFIGFS_USET_IN_MKDIR) {\n\t\t\t\tif (wait_mutex)\n\t\t\t\t\t*wait_mutex = &sd->s_dentry->d_inode->i_mutex;\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Yup, recursive.  If there's a problem, blame\n\t\t\t * deep nesting of default_groups\n\t\t\t */\n\t\t\tret = configfs_detach_prep(sd->s_dentry, wait_mutex);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\tret = -ENOTEMPTY;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "configfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "437-484",
    "snippet": "static struct dentry * configfs_lookup(struct inode *dir,\n\t\t\t\t       struct dentry *dentry,\n\t\t\t\t       unsigned int flags)\n{\n\tstruct configfs_dirent * parent_sd = dentry->d_parent->d_fsdata;\n\tstruct configfs_dirent * sd;\n\tint found = 0;\n\tint err;\n\n\t/*\n\t * Fake invisibility if dir belongs to a group/default groups hierarchy\n\t * being attached\n\t *\n\t * This forbids userspace to read/write attributes of items which may\n\t * not complete their initialization, since the dentries of the\n\t * attributes won't be instantiated.\n\t */\n\terr = -ENOENT;\n\tif (!configfs_dirent_is_ready(parent_sd))\n\t\tgoto out;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (sd->s_type & CONFIGFS_NOT_PINNED) {\n\t\t\tconst unsigned char * name = configfs_get_name(sd);\n\n\t\t\tif (strcmp(name, dentry->d_name.name))\n\t\t\t\tcontinue;\n\n\t\t\tfound = 1;\n\t\t\terr = configfs_attach_attr(sd, dentry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\t/*\n\t\t * If it doesn't exist and it isn't a NOT_PINNED item,\n\t\t * it must be negative.\n\t\t */\n\t\tif (dentry->d_name.len > NAME_MAX)\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\nout:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "NULL"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_attach_attr",
          "args": [
            "sd",
            "dentry"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_attach_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "415-435",
          "snippet": "static int configfs_attach_attr(struct configfs_dirent * sd, struct dentry * dentry)\n{\n\tstruct configfs_attribute * attr = sd->s_element;\n\tint error;\n\n\tspin_lock(&configfs_dirent_lock);\n\tdentry->d_fsdata = configfs_get(sd);\n\tsd->s_dentry = dentry;\n\tspin_unlock(&configfs_dirent_lock);\n\n\terror = configfs_create(dentry, (attr->ca_mode & S_IALLUGO) | S_IFREG,\n\t\t\t\tconfigfs_init_file);\n\tif (error) {\n\t\tconfigfs_put(sd);\n\t\treturn error;\n\t}\n\n\td_rehash(dentry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic int configfs_attach_attr(struct configfs_dirent * sd, struct dentry * dentry)\n{\n\tstruct configfs_attribute * attr = sd->s_element;\n\tint error;\n\n\tspin_lock(&configfs_dirent_lock);\n\tdentry->d_fsdata = configfs_get(sd);\n\tsd->s_dentry = dentry;\n\tspin_unlock(&configfs_dirent_lock);\n\n\terror = configfs_create(dentry, (attr->ca_mode & S_IALLUGO) | S_IFREG,\n\t\t\t\tconfigfs_init_file);\n\tif (error) {\n\t\tconfigfs_put(sd);\n\t\treturn error;\n\t}\n\n\td_rehash(dentry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "dentry->d_name.name"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_get_name",
          "args": [
            "sd"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "211-226",
          "snippet": "const unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nconst unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sd",
            "&parent_sd->s_children",
            "s_sibling"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_dirent_is_ready",
          "args": [
            "parent_sd"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_dirent_is_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "333-342",
          "snippet": "int configfs_dirent_is_ready(struct configfs_dirent *sd)\n{\n\tint ret;\n\n\tspin_lock(&configfs_dirent_lock);\n\tret = !(sd->s_type & CONFIGFS_USET_CREATING);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint configfs_dirent_is_ready(struct configfs_dirent *sd)\n{\n\tint ret;\n\n\tspin_lock(&configfs_dirent_lock);\n\tret = !(sd->s_type & CONFIGFS_USET_CREATING);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic struct dentry * configfs_lookup(struct inode *dir,\n\t\t\t\t       struct dentry *dentry,\n\t\t\t\t       unsigned int flags)\n{\n\tstruct configfs_dirent * parent_sd = dentry->d_parent->d_fsdata;\n\tstruct configfs_dirent * sd;\n\tint found = 0;\n\tint err;\n\n\t/*\n\t * Fake invisibility if dir belongs to a group/default groups hierarchy\n\t * being attached\n\t *\n\t * This forbids userspace to read/write attributes of items which may\n\t * not complete their initialization, since the dentries of the\n\t * attributes won't be instantiated.\n\t */\n\terr = -ENOENT;\n\tif (!configfs_dirent_is_ready(parent_sd))\n\t\tgoto out;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (sd->s_type & CONFIGFS_NOT_PINNED) {\n\t\t\tconst unsigned char * name = configfs_get_name(sd);\n\n\t\t\tif (strcmp(name, dentry->d_name.name))\n\t\t\t\tcontinue;\n\n\t\t\tfound = 1;\n\t\t\terr = configfs_attach_attr(sd, dentry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\t/*\n\t\t * If it doesn't exist and it isn't a NOT_PINNED item,\n\t\t * it must be negative.\n\t\t */\n\t\tif (dentry->d_name.len > NAME_MAX)\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\nout:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "configfs_attach_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "415-435",
    "snippet": "static int configfs_attach_attr(struct configfs_dirent * sd, struct dentry * dentry)\n{\n\tstruct configfs_attribute * attr = sd->s_element;\n\tint error;\n\n\tspin_lock(&configfs_dirent_lock);\n\tdentry->d_fsdata = configfs_get(sd);\n\tsd->s_dentry = dentry;\n\tspin_unlock(&configfs_dirent_lock);\n\n\terror = configfs_create(dentry, (attr->ca_mode & S_IALLUGO) | S_IFREG,\n\t\t\t\tconfigfs_init_file);\n\tif (error) {\n\t\tconfigfs_put(sd);\n\t\treturn error;\n\t}\n\n\td_rehash(dentry);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_rehash",
          "args": [
            "dentry"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2403-2408",
          "snippet": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_put",
          "args": [
            "sd"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "157-162",
          "snippet": "static inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\n\nstatic inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_create",
          "args": [
            "dentry",
            "(attr->ca_mode & S_IALLUGO) | S_IFREG",
            "configfs_init_file"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_create_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "344-366",
          "snippet": "int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t struct dentry *parent,\n\t\t\t struct dentry *dentry)\n{\n\tint err = 0;\n\tumode_t mode = S_IFLNK | S_IRWXUGO;\n\n\terr = configfs_make_dirent(parent->d_fsdata, dentry, sl, mode,\n\t\t\t\t   CONFIGFS_ITEM_LINK);\n\tif (!err) {\n\t\terr = configfs_create(dentry, mode, init_symlink);\n\t\tif (err) {\n\t\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\t\tif (sd) {\n\t\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\t\tconfigfs_put(sd);\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nint configfs_create_link(struct configfs_symlink *sl,\n\t\t\t struct dentry *parent,\n\t\t\t struct dentry *dentry)\n{\n\tint err = 0;\n\tumode_t mode = S_IFLNK | S_IRWXUGO;\n\n\terr = configfs_make_dirent(parent->d_fsdata, dentry, sl, mode,\n\t\t\t\t   CONFIGFS_ITEM_LINK);\n\tif (!err) {\n\t\terr = configfs_create(dentry, mode, init_symlink);\n\t\tif (err) {\n\t\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\t\tif (sd) {\n\t\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\t\tconfigfs_put(sd);\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_get",
          "args": [
            "sd"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "211-226",
          "snippet": "const unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nconst unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic int configfs_attach_attr(struct configfs_dirent * sd, struct dentry * dentry)\n{\n\tstruct configfs_attribute * attr = sd->s_element;\n\tint error;\n\n\tspin_lock(&configfs_dirent_lock);\n\tdentry->d_fsdata = configfs_get(sd);\n\tsd->s_dentry = dentry;\n\tspin_unlock(&configfs_dirent_lock);\n\n\terror = configfs_create(dentry, (attr->ca_mode & S_IALLUGO) | S_IFREG,\n\t\t\t\tconfigfs_init_file);\n\tif (error) {\n\t\tconfigfs_put(sd);\n\t\treturn error;\n\t}\n\n\td_rehash(dentry);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "configfs_remove_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "397-409",
    "snippet": "static void configfs_remove_dir(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\n\tif (!dentry)\n\t\treturn;\n\n\tremove_dir(dentry);\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_dir",
          "args": [
            "dentry"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_remove_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "397-409",
          "snippet": "static void configfs_remove_dir(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\n\tif (!dentry)\n\t\treturn;\n\n\tremove_dir(dentry);\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "item->ci_dentry"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void configfs_remove_dir(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\n\tif (!dentry)\n\t\treturn;\n\n\tremove_dir(dentry);\n\t/**\n\t * Drop reference from dget() on entrance.\n\t */\n\tdput(dentry);\n}"
  },
  {
    "function_name": "remove_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "368-384",
    "snippet": "static void remove_dir(struct dentry * d)\n{\n\tstruct dentry * parent = dget(d->d_parent);\n\tstruct configfs_dirent * sd;\n\n\tsd = d->d_fsdata;\n\tspin_lock(&configfs_dirent_lock);\n\tlist_del_init(&sd->s_sibling);\n\tspin_unlock(&configfs_dirent_lock);\n\tconfigfs_put(sd);\n\tif (d->d_inode)\n\t\tsimple_rmdir(parent->d_inode,d);\n\n\tpr_debug(\" o %pd removing done (%d)\\n\", d, d_count(d));\n\n\tdput(parent);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" o %pd removing done (%d)\\n\"",
            "d",
            "d_count(d)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "d"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_rmdir",
          "args": [
            "parent->d_inode",
            "d"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "simple_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "316-325",
          "snippet": "int simple_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tif (!simple_empty(dentry))\n\t\treturn -ENOTEMPTY;\n\n\tdrop_nlink(dentry->d_inode);\n\tsimple_unlink(dir, dentry);\n\tdrop_nlink(dir);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tif (!simple_empty(dentry))\n\t\treturn -ENOTEMPTY;\n\n\tdrop_nlink(dentry->d_inode);\n\tsimple_unlink(dir, dentry);\n\tdrop_nlink(dir);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_put",
          "args": [
            "sd"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "157-162",
          "snippet": "static inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\n\nstatic inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&sd->s_sibling"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "d->d_parent"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic void remove_dir(struct dentry * d)\n{\n\tstruct dentry * parent = dget(d->d_parent);\n\tstruct configfs_dirent * sd;\n\n\tsd = d->d_fsdata;\n\tspin_lock(&configfs_dirent_lock);\n\tlist_del_init(&sd->s_sibling);\n\tspin_unlock(&configfs_dirent_lock);\n\tconfigfs_put(sd);\n\tif (d->d_inode)\n\t\tsimple_rmdir(parent->d_inode,d);\n\n\tpr_debug(\" o %pd removing done (%d)\\n\", d, d_count(d));\n\n\tdput(parent);\n}"
  },
  {
    "function_name": "configfs_create_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "344-366",
    "snippet": "int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t struct dentry *parent,\n\t\t\t struct dentry *dentry)\n{\n\tint err = 0;\n\tumode_t mode = S_IFLNK | S_IRWXUGO;\n\n\terr = configfs_make_dirent(parent->d_fsdata, dentry, sl, mode,\n\t\t\t\t   CONFIGFS_ITEM_LINK);\n\tif (!err) {\n\t\terr = configfs_create(dentry, mode, init_symlink);\n\t\tif (err) {\n\t\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\t\tif (sd) {\n\t\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\t\tconfigfs_put(sd);\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_put",
          "args": [
            "sd"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "157-162",
          "snippet": "static inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\n\nstatic inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&sd->s_sibling"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_create",
          "args": [
            "dentry",
            "mode",
            "init_symlink"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_create_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "344-366",
          "snippet": "int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t struct dentry *parent,\n\t\t\t struct dentry *dentry)\n{\n\tint err = 0;\n\tumode_t mode = S_IFLNK | S_IRWXUGO;\n\n\terr = configfs_make_dirent(parent->d_fsdata, dentry, sl, mode,\n\t\t\t\t   CONFIGFS_ITEM_LINK);\n\tif (!err) {\n\t\terr = configfs_create(dentry, mode, init_symlink);\n\t\tif (err) {\n\t\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\t\tif (sd) {\n\t\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\t\tconfigfs_put(sd);\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "configfs_make_dirent",
          "args": [
            "parent->d_fsdata",
            "dentry",
            "sl",
            "mode",
            "CONFIGFS_ITEM_LINK"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_make_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "225-241",
          "snippet": "int configfs_make_dirent(struct configfs_dirent * parent_sd,\n\t\t\t struct dentry * dentry, void * element,\n\t\t\t umode_t mode, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = configfs_new_dirent(parent_sd, element, type);\n\tif (IS_ERR(sd))\n\t\treturn PTR_ERR(sd);\n\n\tsd->s_mode = mode;\n\tsd->s_dentry = dentry;\n\tif (dentry)\n\t\tdentry->d_fsdata = configfs_get(sd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nint configfs_make_dirent(struct configfs_dirent * parent_sd,\n\t\t\t struct dentry * dentry, void * element,\n\t\t\t umode_t mode, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = configfs_new_dirent(parent_sd, element, type);\n\tif (IS_ERR(sd))\n\t\treturn PTR_ERR(sd);\n\n\tsd->s_mode = mode;\n\tsd->s_dentry = dentry;\n\tif (dentry)\n\t\tdentry->d_fsdata = configfs_get(sd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nint configfs_create_link(struct configfs_symlink *sl,\n\t\t\t struct dentry *parent,\n\t\t\t struct dentry *dentry)\n{\n\tint err = 0;\n\tumode_t mode = S_IFLNK | S_IRWXUGO;\n\n\terr = configfs_make_dirent(parent->d_fsdata, dentry, sl, mode,\n\t\t\t\t   CONFIGFS_ITEM_LINK);\n\tif (!err) {\n\t\terr = configfs_create(dentry, mode, init_symlink);\n\t\tif (err) {\n\t\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\t\tif (sd) {\n\t\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\t\tconfigfs_put(sd);\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "configfs_dirent_is_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "333-342",
    "snippet": "int configfs_dirent_is_ready(struct configfs_dirent *sd)\n{\n\tint ret;\n\n\tspin_lock(&configfs_dirent_lock);\n\tret = !(sd->s_type & CONFIGFS_USET_CREATING);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint configfs_dirent_is_ready(struct configfs_dirent *sd)\n{\n\tint ret;\n\n\tspin_lock(&configfs_dirent_lock);\n\tret = !(sd->s_type & CONFIGFS_USET_CREATING);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "configfs_dir_set_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "313-321",
    "snippet": "static void configfs_dir_set_ready(struct configfs_dirent *sd)\n{\n\tstruct configfs_dirent *child_sd;\n\n\tsd->s_type &= ~CONFIGFS_USET_CREATING;\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling)\n\t\tif (child_sd->s_type & CONFIGFS_USET_CREATING)\n\t\t\tconfigfs_dir_set_ready(child_sd);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_dir_set_ready",
          "args": [
            "child_sd"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_dir_set_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "313-321",
          "snippet": "static void configfs_dir_set_ready(struct configfs_dirent *sd)\n{\n\tstruct configfs_dirent *child_sd;\n\n\tsd->s_type &= ~CONFIGFS_USET_CREATING;\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling)\n\t\tif (child_sd->s_type & CONFIGFS_USET_CREATING)\n\t\t\tconfigfs_dir_set_ready(child_sd);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child_sd",
            "&sd->s_children",
            "s_sibling"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_dir_set_ready(struct configfs_dirent *sd)\n{\n\tstruct configfs_dirent *child_sd;\n\n\tsd->s_type &= ~CONFIGFS_USET_CREATING;\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling)\n\t\tif (child_sd->s_type & CONFIGFS_USET_CREATING)\n\t\t\tconfigfs_dir_set_ready(child_sd);\n}"
  },
  {
    "function_name": "configfs_create_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "272-304",
    "snippet": "static int configfs_create_dir(struct config_item *item, struct dentry *dentry)\n{\n\tint error;\n\tumode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;\n\tstruct dentry *p = dentry->d_parent;\n\n\tBUG_ON(!item);\n\n\terror = configfs_dirent_exists(p->d_fsdata, dentry->d_name.name);\n\tif (unlikely(error))\n\t\treturn error;\n\n\terror = configfs_make_dirent(p->d_fsdata, dentry, item, mode,\n\t\t\t\t     CONFIGFS_DIR | CONFIGFS_USET_CREATING);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tconfigfs_set_dir_dirent_depth(p->d_fsdata, dentry->d_fsdata);\n\terror = configfs_create(dentry, mode, init_dir);\n\tif (!error) {\n\t\tinc_nlink(p->d_inode);\n\t\titem->ci_dentry = dentry;\n\t} else {\n\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\tif (sd) {\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\tconfigfs_put(sd);\n\t\t}\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_put",
          "args": [
            "sd"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "157-162",
          "snippet": "static inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\n\nstatic inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&sd->s_sibling"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "p->d_inode"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_create",
          "args": [
            "dentry",
            "mode",
            "init_dir"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_create_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "344-366",
          "snippet": "int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t struct dentry *parent,\n\t\t\t struct dentry *dentry)\n{\n\tint err = 0;\n\tumode_t mode = S_IFLNK | S_IRWXUGO;\n\n\terr = configfs_make_dirent(parent->d_fsdata, dentry, sl, mode,\n\t\t\t\t   CONFIGFS_ITEM_LINK);\n\tif (!err) {\n\t\terr = configfs_create(dentry, mode, init_symlink);\n\t\tif (err) {\n\t\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\t\tif (sd) {\n\t\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\t\tconfigfs_put(sd);\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nint configfs_create_link(struct configfs_symlink *sl,\n\t\t\t struct dentry *parent,\n\t\t\t struct dentry *dentry)\n{\n\tint err = 0;\n\tumode_t mode = S_IFLNK | S_IRWXUGO;\n\n\terr = configfs_make_dirent(parent->d_fsdata, dentry, sl, mode,\n\t\t\t\t   CONFIGFS_ITEM_LINK);\n\tif (!err) {\n\t\terr = configfs_create(dentry, mode, init_symlink);\n\t\tif (err) {\n\t\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\t\tif (sd) {\n\t\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\t\tconfigfs_put(sd);\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_set_dir_dirent_depth",
          "args": [
            "p->d_fsdata",
            "dentry->d_fsdata"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_set_dir_dirent_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "152-155",
          "snippet": "static void configfs_set_dir_dirent_depth(struct configfs_dirent *parent_sd,\n\t\t\t\t\t  struct configfs_dirent *sd)\n{\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_set_dir_dirent_depth(struct configfs_dirent *parent_sd,\n\t\t\t\t\t  struct configfs_dirent *sd)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_make_dirent",
          "args": [
            "p->d_fsdata",
            "dentry",
            "item",
            "mode",
            "CONFIGFS_DIR | CONFIGFS_USET_CREATING"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_make_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "225-241",
          "snippet": "int configfs_make_dirent(struct configfs_dirent * parent_sd,\n\t\t\t struct dentry * dentry, void * element,\n\t\t\t umode_t mode, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = configfs_new_dirent(parent_sd, element, type);\n\tif (IS_ERR(sd))\n\t\treturn PTR_ERR(sd);\n\n\tsd->s_mode = mode;\n\tsd->s_dentry = dentry;\n\tif (dentry)\n\t\tdentry->d_fsdata = configfs_get(sd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nint configfs_make_dirent(struct configfs_dirent * parent_sd,\n\t\t\t struct dentry * dentry, void * element,\n\t\t\t umode_t mode, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = configfs_new_dirent(parent_sd, element, type);\n\tif (IS_ERR(sd))\n\t\treturn PTR_ERR(sd);\n\n\tsd->s_mode = mode;\n\tsd->s_dentry = dentry;\n\tif (dentry)\n\t\tdentry->d_fsdata = configfs_get(sd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_dirent_exists",
          "args": [
            "p->d_fsdata",
            "dentry->d_name.name"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_dirent_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "206-222",
          "snippet": "static int configfs_dirent_exists(struct configfs_dirent *parent_sd,\n\t\t\t\t  const unsigned char *new)\n{\n\tstruct configfs_dirent * sd;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (sd->s_element) {\n\t\t\tconst unsigned char *existing = configfs_get_name(sd);\n\t\t\tif (strcmp(existing, new))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_dirent_exists(struct configfs_dirent *parent_sd,\n\t\t\t\t  const unsigned char *new)\n{\n\tstruct configfs_dirent * sd;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (sd->s_element) {\n\t\t\tconst unsigned char *existing = configfs_get_name(sd);\n\t\t\tif (strcmp(existing, new))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!item"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic int configfs_create_dir(struct config_item *item, struct dentry *dentry)\n{\n\tint error;\n\tumode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;\n\tstruct dentry *p = dentry->d_parent;\n\n\tBUG_ON(!item);\n\n\terror = configfs_dirent_exists(p->d_fsdata, dentry->d_name.name);\n\tif (unlikely(error))\n\t\treturn error;\n\n\terror = configfs_make_dirent(p->d_fsdata, dentry, item, mode,\n\t\t\t\t     CONFIGFS_DIR | CONFIGFS_USET_CREATING);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tconfigfs_set_dir_dirent_depth(p->d_fsdata, dentry->d_fsdata);\n\terror = configfs_create(dentry, mode, init_dir);\n\tif (!error) {\n\t\tinc_nlink(p->d_inode);\n\t\titem->ci_dentry = dentry;\n\t} else {\n\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\tif (sd) {\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\tconfigfs_put(sd);\n\t\t}\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "init_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "258-261",
    "snippet": "static void init_symlink(struct inode * inode)\n{\n\tinode->i_op = &configfs_symlink_inode_operations;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void init_symlink(struct inode * inode)\n{\n\tinode->i_op = &configfs_symlink_inode_operations;\n}"
  },
  {
    "function_name": "configfs_init_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "252-256",
    "snippet": "static void configfs_init_file(struct inode * inode)\n{\n\tinode->i_size = PAGE_SIZE;\n\tinode->i_fop = &configfs_file_operations;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_init_file(struct inode * inode)\n{\n\tinode->i_size = PAGE_SIZE;\n\tinode->i_fop = &configfs_file_operations;\n}"
  },
  {
    "function_name": "init_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "243-250",
    "snippet": "static void init_dir(struct inode * inode)\n{\n\tinode->i_op = &configfs_dir_inode_operations;\n\tinode->i_fop = &configfs_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations configfs_dir_inode_operations = {\n\t.mkdir\t\t= configfs_mkdir,\n\t.rmdir\t\t= configfs_rmdir,\n\t.symlink\t= configfs_symlink,\n\t.unlink\t\t= configfs_unlink,\n\t.lookup\t\t= configfs_lookup,\n\t.setattr\t= configfs_setattr,\n};",
      "const struct file_operations configfs_dir_operations = {\n\t.open\t\t= configfs_dir_open,\n\t.release\t= configfs_dir_close,\n\t.llseek\t\t= configfs_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= configfs_readdir,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nconst struct inode_operations configfs_dir_inode_operations = {\n\t.mkdir\t\t= configfs_mkdir,\n\t.rmdir\t\t= configfs_rmdir,\n\t.symlink\t= configfs_symlink,\n\t.unlink\t\t= configfs_unlink,\n\t.lookup\t\t= configfs_lookup,\n\t.setattr\t= configfs_setattr,\n};\nconst struct file_operations configfs_dir_operations = {\n\t.open\t\t= configfs_dir_open,\n\t.release\t= configfs_dir_close,\n\t.llseek\t\t= configfs_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= configfs_readdir,\n};\n\nstatic void init_dir(struct inode * inode)\n{\n\tinode->i_op = &configfs_dir_inode_operations;\n\tinode->i_fop = &configfs_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n}"
  },
  {
    "function_name": "configfs_make_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "225-241",
    "snippet": "int configfs_make_dirent(struct configfs_dirent * parent_sd,\n\t\t\t struct dentry * dentry, void * element,\n\t\t\t umode_t mode, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = configfs_new_dirent(parent_sd, element, type);\n\tif (IS_ERR(sd))\n\t\treturn PTR_ERR(sd);\n\n\tsd->s_mode = mode;\n\tsd->s_dentry = dentry;\n\tif (dentry)\n\t\tdentry->d_fsdata = configfs_get(sd);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_get",
          "args": [
            "sd"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "211-226",
          "snippet": "const unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nconst unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sd"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sd"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_new_dirent",
          "args": [
            "parent_sd",
            "element",
            "type"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_new_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "172-197",
          "snippet": "static struct configfs_dirent *configfs_new_dirent(struct configfs_dirent *parent_sd,\n\t\t\t\t\t\t   void *element, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = kmem_cache_zalloc(configfs_dir_cachep, GFP_KERNEL);\n\tif (!sd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&sd->s_count, 1);\n\tINIT_LIST_HEAD(&sd->s_links);\n\tINIT_LIST_HEAD(&sd->s_children);\n\tsd->s_element = element;\n\tsd->s_type = type;\n\tconfigfs_init_dirent_depth(sd);\n\tspin_lock(&configfs_dirent_lock);\n\tif (parent_sd->s_type & CONFIGFS_USET_DROPPING) {\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tkmem_cache_free(configfs_dir_cachep, sd);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tlist_add(&sd->s_sibling, &parent_sd->s_children);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn sd;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct configfs_dirent *configfs_new_dirent(struct configfs_dirent *parent_sd,\n\t\t\t\t\t\t   void *element, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = kmem_cache_zalloc(configfs_dir_cachep, GFP_KERNEL);\n\tif (!sd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&sd->s_count, 1);\n\tINIT_LIST_HEAD(&sd->s_links);\n\tINIT_LIST_HEAD(&sd->s_children);\n\tsd->s_element = element;\n\tsd->s_type = type;\n\tconfigfs_init_dirent_depth(sd);\n\tspin_lock(&configfs_dirent_lock);\n\tif (parent_sd->s_type & CONFIGFS_USET_DROPPING) {\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tkmem_cache_free(configfs_dir_cachep, sd);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tlist_add(&sd->s_sibling, &parent_sd->s_children);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn sd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nint configfs_make_dirent(struct configfs_dirent * parent_sd,\n\t\t\t struct dentry * dentry, void * element,\n\t\t\t umode_t mode, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = configfs_new_dirent(parent_sd, element, type);\n\tif (IS_ERR(sd))\n\t\treturn PTR_ERR(sd);\n\n\tsd->s_mode = mode;\n\tsd->s_dentry = dentry;\n\tif (dentry)\n\t\tdentry->d_fsdata = configfs_get(sd);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "configfs_dirent_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "206-222",
    "snippet": "static int configfs_dirent_exists(struct configfs_dirent *parent_sd,\n\t\t\t\t  const unsigned char *new)\n{\n\tstruct configfs_dirent * sd;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (sd->s_element) {\n\t\t\tconst unsigned char *existing = configfs_get_name(sd);\n\t\t\tif (strcmp(existing, new))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "existing",
            "new"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_get_name",
          "args": [
            "sd"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "211-226",
          "snippet": "const unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nconst unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sd",
            "&parent_sd->s_children",
            "s_sibling"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_dirent_exists(struct configfs_dirent *parent_sd,\n\t\t\t\t  const unsigned char *new)\n{\n\tstruct configfs_dirent * sd;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (sd->s_element) {\n\t\t\tconst unsigned char *existing = configfs_get_name(sd);\n\t\t\tif (strcmp(existing, new))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "configfs_new_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "172-197",
    "snippet": "static struct configfs_dirent *configfs_new_dirent(struct configfs_dirent *parent_sd,\n\t\t\t\t\t\t   void *element, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = kmem_cache_zalloc(configfs_dir_cachep, GFP_KERNEL);\n\tif (!sd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&sd->s_count, 1);\n\tINIT_LIST_HEAD(&sd->s_links);\n\tINIT_LIST_HEAD(&sd->s_children);\n\tsd->s_element = element;\n\tsd->s_type = type;\n\tconfigfs_init_dirent_depth(sd);\n\tspin_lock(&configfs_dirent_lock);\n\tif (parent_sd->s_type & CONFIGFS_USET_DROPPING) {\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tkmem_cache_free(configfs_dir_cachep, sd);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tlist_add(&sd->s_sibling, &parent_sd->s_children);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn sd;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&sd->s_sibling",
            "&parent_sd->s_children"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "configfs_dir_cachep",
            "sd"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_init_dirent_depth",
          "args": [
            "sd"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_init_dirent_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "148-150",
          "snippet": "static void configfs_init_dirent_depth(struct configfs_dirent *sd)\n{\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_init_dirent_depth(struct configfs_dirent *sd)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sd->s_children"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sd->s_links"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sd->s_count",
            "1"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "configfs_dir_cachep",
            "GFP_KERNEL"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct configfs_dirent *configfs_new_dirent(struct configfs_dirent *parent_sd,\n\t\t\t\t\t\t   void *element, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = kmem_cache_zalloc(configfs_dir_cachep, GFP_KERNEL);\n\tif (!sd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&sd->s_count, 1);\n\tINIT_LIST_HEAD(&sd->s_links);\n\tINIT_LIST_HEAD(&sd->s_children);\n\tsd->s_element = element;\n\tsd->s_type = type;\n\tconfigfs_init_dirent_depth(sd);\n\tspin_lock(&configfs_dirent_lock);\n\tif (parent_sd->s_type & CONFIGFS_USET_DROPPING) {\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tkmem_cache_free(configfs_dir_cachep, sd);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tlist_add(&sd->s_sibling, &parent_sd->s_children);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn sd;\n}"
  },
  {
    "function_name": "configfs_adjust_dir_dirent_depth_after_populate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "162-165",
    "snippet": "static void\nconfigfs_adjust_dir_dirent_depth_after_populate(struct configfs_dirent *sd)\n{\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void\nconfigfs_adjust_dir_dirent_depth_after_populate(struct configfs_dirent *sd)\n{\n}"
  },
  {
    "function_name": "configfs_adjust_dir_dirent_depth_before_populate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "157-160",
    "snippet": "static void\nconfigfs_adjust_dir_dirent_depth_before_populate(struct configfs_dirent *sd)\n{\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void\nconfigfs_adjust_dir_dirent_depth_before_populate(struct configfs_dirent *sd)\n{\n}"
  },
  {
    "function_name": "configfs_set_dir_dirent_depth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "152-155",
    "snippet": "static void configfs_set_dir_dirent_depth(struct configfs_dirent *parent_sd,\n\t\t\t\t\t  struct configfs_dirent *sd)\n{\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_set_dir_dirent_depth(struct configfs_dirent *parent_sd,\n\t\t\t\t\t  struct configfs_dirent *sd)\n{\n}"
  },
  {
    "function_name": "configfs_init_dirent_depth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "148-150",
    "snippet": "static void configfs_init_dirent_depth(struct configfs_dirent *sd)\n{\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_init_dirent_depth(struct configfs_dirent *sd)\n{\n}"
  },
  {
    "function_name": "configfs_adjust_dir_dirent_depth_after_populate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "139-144",
    "snippet": "static void\nconfigfs_adjust_dir_dirent_depth_after_populate(struct configfs_dirent *sd)\n{\n\t/* We will not create default groups anymore. */\n\tsd->s_depth = -1;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void\nconfigfs_adjust_dir_dirent_depth_after_populate(struct configfs_dirent *sd)\n{\n\t/* We will not create default groups anymore. */\n\tsd->s_depth = -1;\n}"
  },
  {
    "function_name": "configfs_adjust_dir_dirent_depth_before_populate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "118-137",
    "snippet": "static void\nconfigfs_adjust_dir_dirent_depth_before_populate(struct configfs_dirent *sd)\n{\n\t/*\n\t * item's i_mutex class is already setup, so s_depth is now only\n\t * used to set new sub-directories s_depth, which is always done\n\t * with item's i_mutex locked.\n\t */\n\t/*\n\t *  sd->s_depth == -1 iff we are a non default group.\n\t *  else (we are a default group) sd->s_depth > 0 (see\n\t *  create_dir()).\n\t */\n\tif (sd->s_depth == -1)\n\t\t/*\n\t\t * We are a non default group and we are going to create\n\t\t * default groups.\n\t\t */\n\t\tsd->s_depth = 0;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void configfs_detach_group(struct config_item *item);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void\nconfigfs_adjust_dir_dirent_depth_before_populate(struct configfs_dirent *sd)\n{\n\t/*\n\t * item's i_mutex class is already setup, so s_depth is now only\n\t * used to set new sub-directories s_depth, which is always done\n\t * with item's i_mutex locked.\n\t */\n\t/*\n\t *  sd->s_depth == -1 iff we are a non default group.\n\t *  else (we are a default group) sd->s_depth > 0 (see\n\t *  create_dir()).\n\t */\n\tif (sd->s_depth == -1)\n\t\t/*\n\t\t * We are a non default group and we are going to create\n\t\t * default groups.\n\t\t */\n\t\tsd->s_depth = 0;\n}"
  },
  {
    "function_name": "configfs_set_dir_dirent_depth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "109-116",
    "snippet": "static void configfs_set_dir_dirent_depth(struct configfs_dirent *parent_sd,\n\t\t\t\t\t  struct configfs_dirent *sd)\n{\n\tint parent_depth = parent_sd->s_depth;\n\n\tif (parent_depth >= 0)\n\t\tsd->s_depth = parent_depth + 1;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_set_dir_dirent_depth(struct configfs_dirent *parent_sd,\n\t\t\t\t\t  struct configfs_dirent *sd)\n{\n\tint parent_depth = parent_sd->s_depth;\n\n\tif (parent_depth >= 0)\n\t\tsd->s_depth = parent_depth + 1;\n}"
  },
  {
    "function_name": "configfs_init_dirent_depth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "104-107",
    "snippet": "static void configfs_init_dirent_depth(struct configfs_dirent *sd)\n{\n\tsd->s_depth = -1;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_init_dirent_depth(struct configfs_dirent *sd)\n{\n\tsd->s_depth = -1;\n}"
  },
  {
    "function_name": "configfs_d_iput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
    "lines": "53-76",
    "snippet": "static void configfs_d_iput(struct dentry * dentry,\n\t\t\t    struct inode * inode)\n{\n\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\n\tif (sd) {\n\t\t/* Coordinate with configfs_readdir */\n\t\tspin_lock(&configfs_dirent_lock);\n\t\t/* Coordinate with configfs_attach_attr where will increase\n\t\t * sd->s_count and update sd->s_dentry to new allocated one.\n\t\t * Only set sd->dentry to null when this dentry is the only\n\t\t * sd owner.\n\t\t * If not do so, configfs_d_iput may run just after\n\t\t * configfs_attach_attr and set sd->s_dentry to null\n\t\t * even it's still in use.\n\t\t */\n\t\tif (atomic_read(&sd->s_count) <= 2)\n\t\t\tsd->s_dentry = NULL;\n\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfigfs_put(sd);\n\t}\n\tiput(inode);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_put",
          "args": [
            "sd"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "157-162",
          "snippet": "static inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\n\nstatic inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sd->s_count"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nstatic void configfs_d_iput(struct dentry * dentry,\n\t\t\t    struct inode * inode)\n{\n\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\n\tif (sd) {\n\t\t/* Coordinate with configfs_readdir */\n\t\tspin_lock(&configfs_dirent_lock);\n\t\t/* Coordinate with configfs_attach_attr where will increase\n\t\t * sd->s_count and update sd->s_dentry to new allocated one.\n\t\t * Only set sd->dentry to null when this dentry is the only\n\t\t * sd owner.\n\t\t * If not do so, configfs_d_iput may run just after\n\t\t * configfs_attach_attr and set sd->s_dentry to null\n\t\t * even it's still in use.\n\t\t */\n\t\tif (atomic_read(&sd->s_count) <= 2)\n\t\t\tsd->s_dentry = NULL;\n\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfigfs_put(sd);\n\t}\n\tiput(inode);\n}"
  }
]